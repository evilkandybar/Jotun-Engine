#line 1 "d:\\my documents\\programs\\jotunengine2\\main.cpp"
#line 1 "d:\\my documents\\programs\\jotunengine2\\jotunengine2.h"
#line 1 "d:\\my documents\\programs\\jotunengine2\\stdafx.h"
#pragma once

#line 1 "d:\\programs overflow\\vc\\include\\cstdio"

#pragma once


#line 1 "d:\\programs overflow\\vc\\include\\yvals.h"

#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\xkeycheck.h"

#pragma once






 
















































































#line 91 "d:\\programs overflow\\vc\\include\\xkeycheck.h"

  


















































































#line 252 "d:\\programs overflow\\vc\\include\\xkeycheck.h"
 #line 253 "d:\\programs overflow\\vc\\include\\xkeycheck.h"

#line 255 "d:\\programs overflow\\vc\\include\\xkeycheck.h"

#line 257 "d:\\programs overflow\\vc\\include\\xkeycheck.h"
#line 258 "d:\\programs overflow\\vc\\include\\xkeycheck.h"





#line 8 "d:\\programs overflow\\vc\\include\\yvals.h"
#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"


















#line 20 "d:\\programs overflow\\vc\\include\\crtdefs.h"




#line 25 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 26 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 27 "d:\\programs overflow\\vc\\include\\crtdefs.h"

























#line 53 "d:\\programs overflow\\vc\\include\\crtdefs.h"



#line 57 "d:\\programs overflow\\vc\\include\\crtdefs.h"










#line 1 "d:\\programs overflow\\vc\\include\\sal.h"













#pragma once







































































































































#line 151 "d:\\programs overflow\\vc\\include\\sal.h"



#line 155 "d:\\programs overflow\\vc\\include\\sal.h"






































#line 194 "d:\\programs overflow\\vc\\include\\sal.h"


#line 197 "d:\\programs overflow\\vc\\include\\sal.h"

#line 199 "d:\\programs overflow\\vc\\include\\sal.h"





#line 205 "d:\\programs overflow\\vc\\include\\sal.h"



#line 209 "d:\\programs overflow\\vc\\include\\sal.h"






#line 216 "d:\\programs overflow\\vc\\include\\sal.h"











#line 228 "d:\\programs overflow\\vc\\include\\sal.h"








#line 237 "d:\\programs overflow\\vc\\include\\sal.h"
#line 238 "d:\\programs overflow\\vc\\include\\sal.h"































































































































































































































































































































































































































































































#pragma region Input Buffer SAL 1 compatibility macros




































































































































































































































































































































































































































































                                                




                                                

















































































































































































































































































































#pragma endregion Input Buffer SAL 1 compatibility macros

















































































#line 1564 "d:\\programs overflow\\vc\\include\\sal.h"






























#line 1595 "d:\\programs overflow\\vc\\include\\sal.h"
























#line 1620 "d:\\programs overflow\\vc\\include\\sal.h"












#line 1633 "d:\\programs overflow\\vc\\include\\sal.h"






































#line 1672 "d:\\programs overflow\\vc\\include\\sal.h"


























































































































#line 1795 "d:\\programs overflow\\vc\\include\\sal.h"






































































































#line 1898 "d:\\programs overflow\\vc\\include\\sal.h"








































































































































































#line 2067 "d:\\programs overflow\\vc\\include\\sal.h"





































































































#line 2169 "d:\\programs overflow\\vc\\include\\sal.h"



















































































































































































































#line 2381 "d:\\programs overflow\\vc\\include\\sal.h"
extern "C" {




#line 2387 "d:\\programs overflow\\vc\\include\\sal.h"



































































































































































































































#line 2615 "d:\\programs overflow\\vc\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2654 "d:\\programs overflow\\vc\\include\\sal.h"









































































































































































































































#line 2888 "d:\\programs overflow\\vc\\include\\sal.h"









#line 2898 "d:\\programs overflow\\vc\\include\\sal.h"


    
    
#line 2903 "d:\\programs overflow\\vc\\include\\sal.h"






#line 2910 "d:\\programs overflow\\vc\\include\\sal.h"
#line 2911 "d:\\programs overflow\\vc\\include\\sal.h"






#line 2918 "d:\\programs overflow\\vc\\include\\sal.h"
#line 2919 "d:\\programs overflow\\vc\\include\\sal.h"











#line 2931 "d:\\programs overflow\\vc\\include\\sal.h"

































#line 2965 "d:\\programs overflow\\vc\\include\\sal.h"






















}
#line 2989 "d:\\programs overflow\\vc\\include\\sal.h"

#line 1 "d:\\programs overflow\\vc\\include\\concurrencysal.h"


















#pragma once


extern "C" {
#line 24 "d:\\programs overflow\\vc\\include\\concurrencysal.h"
















































































































































































































































#line 265 "d:\\programs overflow\\vc\\include\\concurrencysal.h"



#line 269 "d:\\programs overflow\\vc\\include\\concurrencysal.h"


















































































#line 352 "d:\\programs overflow\\vc\\include\\concurrencysal.h"


}
#line 356 "d:\\programs overflow\\vc\\include\\concurrencysal.h"

#line 358 "d:\\programs overflow\\vc\\include\\concurrencysal.h"
#line 2991 "d:\\programs overflow\\vc\\include\\sal.h"


#line 68 "d:\\programs overflow\\vc\\include\\crtdefs.h"




#pragma pack(push,8)

#line 1 "d:\\programs overflow\\vc\\include\\vadefs.h"












#pragma once






#line 21 "d:\\programs overflow\\vc\\include\\vadefs.h"







#pragma pack(push,8)


extern "C" {
#line 33 "d:\\programs overflow\\vc\\include\\vadefs.h"










#line 44 "d:\\programs overflow\\vc\\include\\vadefs.h"
#line 45 "d:\\programs overflow\\vc\\include\\vadefs.h"





typedef __w64 unsigned int   uintptr_t;
#line 52 "d:\\programs overflow\\vc\\include\\vadefs.h"

#line 54 "d:\\programs overflow\\vc\\include\\vadefs.h"





typedef char *  va_list;
#line 61 "d:\\programs overflow\\vc\\include\\vadefs.h"

#line 63 "d:\\programs overflow\\vc\\include\\vadefs.h"





#line 69 "d:\\programs overflow\\vc\\include\\vadefs.h"







#line 77 "d:\\programs overflow\\vc\\include\\vadefs.h"


#line 80 "d:\\programs overflow\\vc\\include\\vadefs.h"













#line 94 "d:\\programs overflow\\vc\\include\\vadefs.h"












































#line 139 "d:\\programs overflow\\vc\\include\\vadefs.h"


}
#line 143 "d:\\programs overflow\\vc\\include\\vadefs.h"

#pragma pack(pop)

#line 147 "d:\\programs overflow\\vc\\include\\vadefs.h"
#line 75 "d:\\programs overflow\\vc\\include\\crtdefs.h"


extern "C" {
#line 79 "d:\\programs overflow\\vc\\include\\crtdefs.h"





#line 85 "d:\\programs overflow\\vc\\include\\crtdefs.h"




#line 90 "d:\\programs overflow\\vc\\include\\crtdefs.h"




#line 95 "d:\\programs overflow\\vc\\include\\crtdefs.h"







#line 103 "d:\\programs overflow\\vc\\include\\crtdefs.h"



















#line 123 "d:\\programs overflow\\vc\\include\\crtdefs.h"




#line 128 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 129 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 130 "d:\\programs overflow\\vc\\include\\crtdefs.h"




















#line 151 "d:\\programs overflow\\vc\\include\\crtdefs.h"






#line 158 "d:\\programs overflow\\vc\\include\\crtdefs.h"


#line 161 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 162 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 164 "d:\\programs overflow\\vc\\include\\crtdefs.h"










#line 175 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 177 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 178 "d:\\programs overflow\\vc\\include\\crtdefs.h"





#line 184 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 186 "d:\\programs overflow\\vc\\include\\crtdefs.h"






#line 193 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 195 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 196 "d:\\programs overflow\\vc\\include\\crtdefs.h"





#line 202 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 204 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 205 "d:\\programs overflow\\vc\\include\\crtdefs.h"




#line 210 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 212 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 213 "d:\\programs overflow\\vc\\include\\crtdefs.h"




#line 218 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 220 "d:\\programs overflow\\vc\\include\\crtdefs.h"
  
#line 222 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 223 "d:\\programs overflow\\vc\\include\\crtdefs.h"










#line 234 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 235 "d:\\programs overflow\\vc\\include\\crtdefs.h"






#line 242 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 243 "d:\\programs overflow\\vc\\include\\crtdefs.h"






#line 250 "d:\\programs overflow\\vc\\include\\crtdefs.h"

















#line 268 "d:\\programs overflow\\vc\\include\\crtdefs.h"




#line 273 "d:\\programs overflow\\vc\\include\\crtdefs.h"








#line 282 "d:\\programs overflow\\vc\\include\\crtdefs.h"






#line 289 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 290 "d:\\programs overflow\\vc\\include\\crtdefs.h"





#line 296 "d:\\programs overflow\\vc\\include\\crtdefs.h"






#line 303 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 304 "d:\\programs overflow\\vc\\include\\crtdefs.h"






#line 311 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 312 "d:\\programs overflow\\vc\\include\\crtdefs.h"




#line 317 "d:\\programs overflow\\vc\\include\\crtdefs.h"


#line 320 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 322 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 323 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 324 "d:\\programs overflow\\vc\\include\\crtdefs.h"





#line 330 "d:\\programs overflow\\vc\\include\\crtdefs.h"










#line 341 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 343 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 344 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 345 "d:\\programs overflow\\vc\\include\\crtdefs.h"








#line 354 "d:\\programs overflow\\vc\\include\\crtdefs.h"





#line 360 "d:\\programs overflow\\vc\\include\\crtdefs.h"






#line 367 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 368 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 370 "d:\\programs overflow\\vc\\include\\crtdefs.h"
















#line 387 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 388 "d:\\programs overflow\\vc\\include\\crtdefs.h"



#line 392 "d:\\programs overflow\\vc\\include\\crtdefs.h"






#line 399 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 400 "d:\\programs overflow\\vc\\include\\crtdefs.h"






#line 407 "d:\\programs overflow\\vc\\include\\crtdefs.h"






#line 414 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 416 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 417 "d:\\programs overflow\\vc\\include\\crtdefs.h"




  




#line 427 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 428 "d:\\programs overflow\\vc\\include\\crtdefs.h"



  
  




#line 438 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 439 "d:\\programs overflow\\vc\\include\\crtdefs.h"




   


#line 447 "d:\\programs overflow\\vc\\include\\crtdefs.h"




#line 452 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 453 "d:\\programs overflow\\vc\\include\\crtdefs.h"



  




#line 462 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 463 "d:\\programs overflow\\vc\\include\\crtdefs.h"



  




#line 472 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 473 "d:\\programs overflow\\vc\\include\\crtdefs.h"



#line 477 "d:\\programs overflow\\vc\\include\\crtdefs.h"





#line 483 "d:\\programs overflow\\vc\\include\\crtdefs.h"




#line 488 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 490 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 491 "d:\\programs overflow\\vc\\include\\crtdefs.h"





typedef __w64 unsigned int   size_t;
#line 498 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 500 "d:\\programs overflow\\vc\\include\\crtdefs.h"



typedef size_t rsize_t;

#line 506 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 507 "d:\\programs overflow\\vc\\include\\crtdefs.h"





typedef __w64 int            intptr_t;
#line 514 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 516 "d:\\programs overflow\\vc\\include\\crtdefs.h"














typedef __w64 int            ptrdiff_t;
#line 532 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 534 "d:\\programs overflow\\vc\\include\\crtdefs.h"







typedef unsigned short wint_t;
typedef unsigned short wctype_t;

#line 545 "d:\\programs overflow\\vc\\include\\crtdefs.h"


















typedef int errno_t;
#line 565 "d:\\programs overflow\\vc\\include\\crtdefs.h"


typedef __w64 long __time32_t;   

#line 570 "d:\\programs overflow\\vc\\include\\crtdefs.h"


typedef __int64 __time64_t;     

#line 575 "d:\\programs overflow\\vc\\include\\crtdefs.h"





typedef __time64_t time_t;      
#line 582 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 584 "d:\\programs overflow\\vc\\include\\crtdefs.h"







#line 592 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 593 "d:\\programs overflow\\vc\\include\\crtdefs.h"



#line 597 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 599 "d:\\programs overflow\\vc\\include\\crtdefs.h"




#line 604 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 606 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 607 "d:\\programs overflow\\vc\\include\\crtdefs.h"





#line 613 "d:\\programs overflow\\vc\\include\\crtdefs.h"



#line 617 "d:\\programs overflow\\vc\\include\\crtdefs.h"




#line 622 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 624 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 625 "d:\\programs overflow\\vc\\include\\crtdefs.h"










 __declspec(dllimport) void __cdecl _invalid_parameter(  const wchar_t *,   const wchar_t *,   const wchar_t *, unsigned int, uintptr_t);



#line 640 "d:\\programs overflow\\vc\\include\\crtdefs.h"

__declspec(dllimport) __declspec(noreturn)
void __cdecl _invoke_watson(  const wchar_t *,   const wchar_t *,   const wchar_t *, unsigned int, uintptr_t);



  
#line 648 "d:\\programs overflow\\vc\\include\\crtdefs.h"












#line 661 "d:\\programs overflow\\vc\\include\\crtdefs.h"


































#line 696 "d:\\programs overflow\\vc\\include\\crtdefs.h"


































































































































































#line 859 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 860 "d:\\programs overflow\\vc\\include\\crtdefs.h"









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1926 "d:\\programs overflow\\vc\\include\\crtdefs.h"















































































































































#line 2070 "d:\\programs overflow\\vc\\include\\crtdefs.h"
#line 2071 "d:\\programs overflow\\vc\\include\\crtdefs.h"

struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;
typedef struct threadmbcinfostruct * pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct
{
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
} _locale_tstruct, *_locale_t;


typedef struct localerefcount {
        char *locale;
        wchar_t *wlocale;
        int *refcount;
        int *wrefcount;
} locrefcount;

typedef struct threadlocaleinfostruct {
        int refcount;
        unsigned int lc_codepage;
        unsigned int lc_collate_cp;
        unsigned int lc_time_cp;
        locrefcount lc_category[6];
        int lc_clike;
        int mb_cur_max;
        int * lconv_intl_refcount;
        int * lconv_num_refcount;
        int * lconv_mon_refcount;
        struct lconv * lconv;
        int * ctype1_refcount;
        unsigned short * ctype1;
        const unsigned short * pctype;
        const unsigned char * pclmap;
        const unsigned char * pcumap;
        struct __lc_time_data * lc_time_curr;
        wchar_t * locale_name[6];
} threadlocinfo;

#line 2114 "d:\\programs overflow\\vc\\include\\crtdefs.h"


}
#line 2118 "d:\\programs overflow\\vc\\include\\crtdefs.h"



#line 2122 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 2124 "d:\\programs overflow\\vc\\include\\crtdefs.h"



#line 2128 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 2130 "d:\\programs overflow\\vc\\include\\crtdefs.h"



#line 2134 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 2136 "d:\\programs overflow\\vc\\include\\crtdefs.h"






#line 2143 "d:\\programs overflow\\vc\\include\\crtdefs.h"



#line 2147 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#pragma pack(pop)

#line 2151 "d:\\programs overflow\\vc\\include\\crtdefs.h"

#line 9 "d:\\programs overflow\\vc\\include\\yvals.h"

#pragma pack(push,8)




































#line 48 "d:\\programs overflow\\vc\\include\\yvals.h"

#line 50 "d:\\programs overflow\\vc\\include\\yvals.h"




























#line 79 "d:\\programs overflow\\vc\\include\\yvals.h"

#line 81 "d:\\programs overflow\\vc\\include\\yvals.h"
#line 82 "d:\\programs overflow\\vc\\include\\yvals.h"

		





#line 90 "d:\\programs overflow\\vc\\include\\yvals.h"
#line 91 "d:\\programs overflow\\vc\\include\\yvals.h"

		


		




		

 
  

 

#line 108 "d:\\programs overflow\\vc\\include\\yvals.h"

 
  
 #line 112 "d:\\programs overflow\\vc\\include\\yvals.h"



 
  
 #line 118 "d:\\programs overflow\\vc\\include\\yvals.h"










































	
	






		
			
		

#line 173 "d:\\programs overflow\\vc\\include\\yvals.h"
	#line 174 "d:\\programs overflow\\vc\\include\\yvals.h"

	
	




		
			
		

#line 186 "d:\\programs overflow\\vc\\include\\yvals.h"
	#line 187 "d:\\programs overflow\\vc\\include\\yvals.h"

	
	
		
	



#line 196 "d:\\programs overflow\\vc\\include\\yvals.h"

#line 198 "d:\\programs overflow\\vc\\include\\yvals.h"






	
		#pragma detect_mismatch("_MSC_VER", "1800")
	#line 207 "d:\\programs overflow\\vc\\include\\yvals.h"

	
		#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
	#line 211 "d:\\programs overflow\\vc\\include\\yvals.h"

	
		

#line 216 "d:\\programs overflow\\vc\\include\\yvals.h"

#line 218 "d:\\programs overflow\\vc\\include\\yvals.h"

#line 220 "d:\\programs overflow\\vc\\include\\yvals.h"
			#pragma detect_mismatch("RuntimeLibrary", "MDd_DynamicDebug")
		#line 222 "d:\\programs overflow\\vc\\include\\yvals.h"
	#line 223 "d:\\programs overflow\\vc\\include\\yvals.h"
#line 224 "d:\\programs overflow\\vc\\include\\yvals.h"
#line 225 "d:\\programs overflow\\vc\\include\\yvals.h"








	

#line 236 "d:\\programs overflow\\vc\\include\\yvals.h"
		
	#line 238 "d:\\programs overflow\\vc\\include\\yvals.h"
#line 239 "d:\\programs overflow\\vc\\include\\yvals.h"




#line 244 "d:\\programs overflow\\vc\\include\\yvals.h"




#line 249 "d:\\programs overflow\\vc\\include\\yvals.h"

#line 251 "d:\\programs overflow\\vc\\include\\yvals.h"
#line 252 "d:\\programs overflow\\vc\\include\\yvals.h"



#line 256 "d:\\programs overflow\\vc\\include\\yvals.h"











#line 268 "d:\\programs overflow\\vc\\include\\yvals.h"


 
#line 272 "d:\\programs overflow\\vc\\include\\yvals.h"

 
 

 









 









 









 

 









 









 




 





 













#line 354 "d:\\programs overflow\\vc\\include\\yvals.h"











#line 366 "d:\\programs overflow\\vc\\include\\yvals.h"

#line 1 "d:\\programs overflow\\vc\\include\\use_ansi.h"













#pragma once








#line 24 "d:\\programs overflow\\vc\\include\\use_ansi.h"











    
    



#line 41 "d:\\programs overflow\\vc\\include\\use_ansi.h"


    






#line 51 "d:\\programs overflow\\vc\\include\\use_ansi.h"



    
#line 56 "d:\\programs overflow\\vc\\include\\use_ansi.h"

#pragma comment(lib, "msvcprt" "d" "")






#line 65 "d:\\programs overflow\\vc\\include\\use_ansi.h"

#line 67 "d:\\programs overflow\\vc\\include\\use_ansi.h"

#line 69 "d:\\programs overflow\\vc\\include\\use_ansi.h"
#line 368 "d:\\programs overflow\\vc\\include\\yvals.h"



#line 372 "d:\\programs overflow\\vc\\include\\yvals.h"







#line 380 "d:\\programs overflow\\vc\\include\\yvals.h"


 















 
  

#line 402 "d:\\programs overflow\\vc\\include\\yvals.h"
   
  #line 404 "d:\\programs overflow\\vc\\include\\yvals.h"
 #line 405 "d:\\programs overflow\\vc\\include\\yvals.h"

 












 
















 
  

#line 440 "d:\\programs overflow\\vc\\include\\yvals.h"
   
  #line 442 "d:\\programs overflow\\vc\\include\\yvals.h"
 #line 443 "d:\\programs overflow\\vc\\include\\yvals.h"

 
  

#line 448 "d:\\programs overflow\\vc\\include\\yvals.h"
   
  #line 450 "d:\\programs overflow\\vc\\include\\yvals.h"
 #line 451 "d:\\programs overflow\\vc\\include\\yvals.h"


 
  





#line 461 "d:\\programs overflow\\vc\\include\\yvals.h"

   


#line 466 "d:\\programs overflow\\vc\\include\\yvals.h"
    
   #line 468 "d:\\programs overflow\\vc\\include\\yvals.h"

  #line 470 "d:\\programs overflow\\vc\\include\\yvals.h"
 #line 471 "d:\\programs overflow\\vc\\include\\yvals.h"

 
  
 #line 475 "d:\\programs overflow\\vc\\include\\yvals.h"

 
  

#line 480 "d:\\programs overflow\\vc\\include\\yvals.h"
   


     
   #line 485 "d:\\programs overflow\\vc\\include\\yvals.h"
  #line 486 "d:\\programs overflow\\vc\\include\\yvals.h"
 #line 487 "d:\\programs overflow\\vc\\include\\yvals.h"

 


























  
   
  #line 518 "d:\\programs overflow\\vc\\include\\yvals.h"
 #line 519 "d:\\programs overflow\\vc\\include\\yvals.h"

		

 
  
  
  




  
  
  

  







   
   
   
  #line 546 "d:\\programs overflow\\vc\\include\\yvals.h"

  
  
  
  

 












#line 566 "d:\\programs overflow\\vc\\include\\yvals.h"

 
namespace std {
typedef bool _Bool;
}
 #line 572 "d:\\programs overflow\\vc\\include\\yvals.h"

		





		






typedef __int64 _Longlong;
typedef unsigned __int64 _ULonglong;

		







 
#line 599 "d:\\programs overflow\\vc\\include\\yvals.h"

		
 
#line 603 "d:\\programs overflow\\vc\\include\\yvals.h"
 
  
typedef unsigned short char16_t;
typedef unsigned int char32_t;
 #line 608 "d:\\programs overflow\\vc\\include\\yvals.h"
 #line 609 "d:\\programs overflow\\vc\\include\\yvals.h"

		
		






 
namespace std {
enum _Uninitialized
	{	
	_Noinit
	};

		

#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) _Lockit
	{	
public:
 

  
















#line 652 "d:\\programs overflow\\vc\\include\\yvals.h"
	__thiscall _Lockit();	
	explicit __thiscall _Lockit(int);	
	__thiscall ~_Lockit() throw ();	
  #line 656 "d:\\programs overflow\\vc\\include\\yvals.h"

    static  void __cdecl _Lockit_ctor(int);
    static  void __cdecl _Lockit_dtor(int);

private:
    static  void __cdecl _Lockit_ctor(_Lockit *);
    static  void __cdecl _Lockit_ctor(_Lockit *, int);
    static  void __cdecl _Lockit_dtor(_Lockit *);

public:
	 _Lockit(const _Lockit&) = delete;
	_Lockit&  operator=(const _Lockit&) = delete;

private:
	int _Locktype;

  











#line 685 "d:\\programs overflow\\vc\\include\\yvals.h"
	};

 



































































  



  


  



  


  
 #line 771 "d:\\programs overflow\\vc\\include\\yvals.h"

class __declspec(dllimport) _Init_locks
	{	
public:
 
      










#line 788 "d:\\programs overflow\\vc\\include\\yvals.h"
    __thiscall _Init_locks();
	__thiscall ~_Init_locks() throw ();
  #line 791 "d:\\programs overflow\\vc\\include\\yvals.h"

private:
    static  void __cdecl _Init_locks_ctor(_Init_locks *);
    static  void __cdecl _Init_locks_dtor(_Init_locks *);

 







#line 805 "d:\\programs overflow\\vc\\include\\yvals.h"
	};

#pragma warning(pop)
}
 #line 810 "d:\\programs overflow\\vc\\include\\yvals.h"





		

__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void));

typedef int _Mbstatet;
typedef unsigned long _Uint32t;




 
 

 
 #pragma pack(pop)
#line 831 "d:\\programs overflow\\vc\\include\\yvals.h"
#line 832 "d:\\programs overflow\\vc\\include\\yvals.h"





#line 6 "d:\\programs overflow\\vc\\include\\cstdio"







 #line 1 "d:\\programs overflow\\vc\\include\\stdio.h"














#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "d:\\programs overflow\\vc\\include\\stdio.h"





#pragma pack(push,8)


extern "C" {
#line 31 "d:\\programs overflow\\vc\\include\\stdio.h"
































struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;

#line 76 "d:\\programs overflow\\vc\\include\\stdio.h"



















#line 96 "d:\\programs overflow\\vc\\include\\stdio.h"

















#line 114 "d:\\programs overflow\\vc\\include\\stdio.h"







#line 122 "d:\\programs overflow\\vc\\include\\stdio.h"
#line 123 "d:\\programs overflow\\vc\\include\\stdio.h"














__declspec(dllimport) FILE * __cdecl __iob_func(void);
#line 139 "d:\\programs overflow\\vc\\include\\stdio.h"





typedef __int64 fpos_t;

#line 147 "d:\\programs overflow\\vc\\include\\stdio.h"






#line 154 "d:\\programs overflow\\vc\\include\\stdio.h"





















  __declspec(dllimport) int __cdecl _filbuf(  FILE * _File );
 __declspec(dllimport) int __cdecl _flsbuf(  int _Ch,   FILE * _File);

  __declspec(dllimport) FILE * __cdecl _fsopen(  const char * _Filename,   const char * _Mode,   int _ShFlag);

__declspec(dllimport) void __cdecl clearerr(  FILE * _File);

 __declspec(dllimport) errno_t __cdecl clearerr_s(  FILE * _File );
#line 184 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(dllimport) int __cdecl fclose(  FILE * _File);
 __declspec(dllimport) int __cdecl _fcloseall(void);

  __declspec(dllimport) FILE * __cdecl _fdopen(  int _FileHandle,   const char * _Mode);

  __declspec(dllimport) int __cdecl feof(  FILE * _File);
  __declspec(dllimport) int __cdecl ferror(  FILE * _File);
 __declspec(dllimport) int __cdecl fflush(  FILE * _File);
 __declspec(dllimport) int __cdecl fgetc(  FILE * _File);
 __declspec(dllimport) int __cdecl _fgetchar(void);
 __declspec(dllimport) int __cdecl fgetpos(  FILE * _File ,   fpos_t * _Pos);
 __declspec(dllimport) char * __cdecl fgets(  char * _Buf,   int _MaxCount,   FILE * _File);

  __declspec(dllimport) int __cdecl _fileno(  FILE * _File);




#line 203 "d:\\programs overflow\\vc\\include\\stdio.h"

  __declspec(dllimport) char * __cdecl _tempnam(  const char * _DirName,   const char * _FilePrefix);



#line 209 "d:\\programs overflow\\vc\\include\\stdio.h"

 __declspec(dllimport) int __cdecl _flushall(void);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl fopen(  const char * _Filename,   const char * _Mode);

 __declspec(dllimport) errno_t __cdecl fopen_s(  FILE ** _File,   const char * _Filename,   const char * _Mode);
#line 215 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(dllimport) int __cdecl fprintf(  FILE * _File,     const char * _Format, ...);

 __declspec(dllimport) int __cdecl fprintf_s(  FILE * _File,     const char * _Format, ...);
#line 219 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(dllimport) int __cdecl fputc(  int _Ch,   FILE * _File);
 __declspec(dllimport) int __cdecl _fputchar(  int _Ch);
 __declspec(dllimport) int __cdecl fputs(  const char * _Str,   FILE * _File);
 __declspec(dllimport) size_t __cdecl fread(  void * _DstBuf,   size_t _ElementSize,   size_t _Count,   FILE * _File);

 __declspec(dllimport) size_t __cdecl fread_s(  void * _DstBuf,   size_t _DstSize,   size_t _ElementSize,   size_t _Count,   FILE * _File);
#line 226 "d:\\programs overflow\\vc\\include\\stdio.h"
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl freopen(  const char * _Filename,   const char * _Mode,   FILE * _File);

 __declspec(dllimport) errno_t __cdecl freopen_s(  FILE ** _File,   const char * _Filename,   const char * _Mode,   FILE * _OldFile);
#line 230 "d:\\programs overflow\\vc\\include\\stdio.h"
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl fscanf(  FILE * _File,     const char * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _fscanf_l(  FILE * _File,     const char * _Format,   _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(dllimport) int __cdecl fscanf_s(  FILE * _File,     const char * _Format, ...);
#line 237 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _fscanf_s_l(  FILE * _File,     const char * _Format,   _locale_t _Locale, ...);
#pragma warning(pop)
 __declspec(dllimport) int __cdecl fsetpos(  FILE * _File,   const fpos_t * _Pos);
 __declspec(dllimport) int __cdecl fseek(  FILE * _File,   long _Offset,   int _Origin);
  __declspec(dllimport) long __cdecl ftell(  FILE * _File);

 __declspec(dllimport) int __cdecl _fseeki64(  FILE * _File,   __int64 _Offset,   int _Origin);
  __declspec(dllimport) __int64 __cdecl _ftelli64(  FILE * _File);

 __declspec(dllimport) size_t __cdecl fwrite(  const void * _Str,   size_t _Size,   size_t _Count,   FILE * _File);
  __declspec(dllimport) int __cdecl getc(  FILE * _File);
  __declspec(dllimport) int __cdecl getchar(void);
  __declspec(dllimport) int __cdecl _getmaxstdio(void);

__declspec(dllimport) char * __cdecl gets_s(  char * _Buf,   rsize_t _Size);
#line 253 "d:\\programs overflow\\vc\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline char * __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "gets_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl gets(  char *_Buffer);
  int __cdecl _getw(  FILE * _File);


__declspec(dllimport) void __cdecl perror(  const char * _ErrMsg);
#line 260 "d:\\programs overflow\\vc\\include\\stdio.h"

 __declspec(dllimport) int __cdecl _pclose(  FILE * _File);
  __declspec(dllimport) FILE * __cdecl _popen(  const char * _Command,   const char * _Mode);
#line 264 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(dllimport) int __cdecl printf(    const char * _Format, ...);

 __declspec(dllimport) int __cdecl printf_s(    const char * _Format, ...);
#line 268 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(dllimport) int __cdecl putc(  int _Ch,   FILE * _File);
 __declspec(dllimport) int __cdecl putchar(  int _Ch);
 __declspec(dllimport) int __cdecl puts(  const char * _Str);
 __declspec(dllimport) int __cdecl _putw(  int _Word,   FILE * _File);


__declspec(dllimport) int __cdecl remove(  const char * _Filename);
  __declspec(dllimport) int __cdecl rename(  const char * _OldFilename,   const char * _NewFilename);
__declspec(dllimport) int __cdecl _unlink(  const char * _Filename);

__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_unlink" ". See online help for details.")) __declspec(dllimport) int __cdecl unlink(  const char * _Filename);
#line 280 "d:\\programs overflow\\vc\\include\\stdio.h"
#line 281 "d:\\programs overflow\\vc\\include\\stdio.h"
__declspec(dllimport) void __cdecl rewind(  FILE * _File);
 __declspec(dllimport) int __cdecl _rmtmp(void);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl scanf(    const char * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _scanf_l(    const char * _Format,   _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(dllimport) int __cdecl scanf_s(    const char * _Format, ...);
#line 290 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _scanf_s_l(    const char * _Format,   _locale_t _Locale, ...);
#pragma warning(pop)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl setbuf(  FILE * _File,     char * _Buffer);
 __declspec(dllimport) int __cdecl _setmaxstdio(  int _Max);
 __declspec(dllimport) unsigned int __cdecl _set_output_format(  unsigned int _Format);
 __declspec(dllimport) unsigned int __cdecl _get_output_format(void);
 __declspec(dllimport) int __cdecl setvbuf(  FILE * _File,   char * _Buf,   int _Mode,   size_t _Size);
 __declspec(dllimport) int __cdecl _snprintf_s(  char * _DstBuf,   size_t _SizeInBytes,   size_t _MaxCount,     const char * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snprintf_s(  char (&_Dest)[_Size],   size_t _MaxCount,     const char * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return _vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _ArgList); } __pragma(warning(pop)); }

 __declspec(dllimport) int __cdecl sprintf_s(  char * _DstBuf,   size_t _SizeInBytes,     const char * _Format, ...);
#line 302 "d:\\programs overflow\\vc\\include\\stdio.h"
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl sprintf_s(  char (&_Dest)[_Size],     const char * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return vsprintf_s(_Dest, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
  __declspec(dllimport) int __cdecl _scprintf(    const char * _Format, ...);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl sscanf(  const char * _Src,     const char * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _sscanf_l(  const char * _Src,     const char * _Format,   _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(dllimport) int __cdecl sscanf_s(  const char * _Src,     const char * _Format, ...);
#line 311 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _sscanf_s_l(  const char * _Src,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snscanf(    const char * _Src,   size_t _MaxCount,     const char * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snscanf_l(    const char * _Src,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snscanf_s(    const char * _Src,   size_t _MaxCount,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _snscanf_s_l(    const char * _Src,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
#pragma warning(pop)
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl tmpfile(void);

 __declspec(dllimport) errno_t __cdecl tmpfile_s(    FILE ** _File);
 __declspec(dllimport) errno_t __cdecl tmpnam_s(  char * _Buf,   rsize_t _Size);
#line 322 "d:\\programs overflow\\vc\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl tmpnam_s(  char (&_Buf)[_Size]) throw() { return tmpnam_s(_Buf, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl tmpnam(  char *_Buffer);
 __declspec(dllimport) int __cdecl ungetc(  int _Ch,   FILE * _File);
 __declspec(dllimport) int __cdecl vfprintf(  FILE * _File,     const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vfscanf(  FILE * _File,     const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vfprintf_s(  FILE * _File,     const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vfscanf_s(  FILE * _File,     const char * _Format, va_list _ArgList);
#line 331 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(dllimport) int __cdecl vprintf(    const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vscanf(    const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vprintf_s(    const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vscanf_s(    const char * _Format, va_list _ArgList);
#line 337 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl vsnprintf(  char * _DstBuf,   size_t _MaxCount,     const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vsnprintf_s(  char * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vsnprintf_s(  char (&_Dest)[_Size],   size_t _MaxCount,     const char * _Format, va_list _Args) throw() { return vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _Args); } }
#line 342 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _vsnprintf_s(  char * _DstBuf,   size_t _SizeInBytes,   size_t _MaxCount,     const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnprintf_s(  char (&_Dest)[_Size],   size_t _MaxCount,     const char * _Format, va_list _Args) throw() { return _vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snprintf(    char *_Dest,   size_t _Count,     const char * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnprintf(    char *_Dest,   size_t _Count,     const char * _Format, va_list _Args);
#pragma warning(pop)

__declspec(dllimport) int __cdecl vsprintf_s(  char * _DstBuf,   size_t _SizeInBytes,     const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vsprintf_s(  char (&_Dest)[_Size],     const char * _Format, va_list _Args) throw() { return vsprintf_s(_Dest, _Size, _Format, _Args); } }
 __declspec(dllimport) int __cdecl vsscanf_s(const char * _Src,     const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(  const char (&_Src)[_Size],     const char * _Format, va_list _Args) throw() { return vsscanf_s(_Src, _Size, _Format, _Args); } }
#line 354 "d:\\programs overflow\\vc\\include\\stdio.h"
#pragma warning(push)
#pragma warning(disable:4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl sprintf(  char *_Dest,  const char * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl vsprintf(  char *_Dest,  const char * _Format, va_list _Args);
 __declspec(dllimport) int __cdecl vsscanf(const char * _srcBuf,     const char * _Format, va_list _ArgList);
#pragma warning(pop)
  __declspec(dllimport) int __cdecl _vscprintf(    const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _snprintf_c(  char * _DstBuf,   size_t _MaxCount,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _vsnprintf_c(  char *_DstBuf,   size_t _MaxCount,     const char * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl _fprintf_p(  FILE * _File,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _printf_p(    const char * _Format, ...);
 __declspec(dllimport) int __cdecl _sprintf_p(  char * _Dst,   size_t _MaxCount,     const char * _Format, ...);
 __declspec(dllimport) int __cdecl _vfprintf_p(  FILE * _File,     const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vprintf_p(    const char * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsprintf_p(  char * _Dst,   size_t _MaxCount,     const char * _Format, va_list _ArgList);
  __declspec(dllimport) int __cdecl _scprintf_p(    const char * _Format, ...);
  __declspec(dllimport) int __cdecl _vscprintf_p(    const char * _Format, va_list _ArgList);
__declspec(dllimport) int __cdecl _set_printf_count_output(  int _Value);
__declspec(dllimport) int __cdecl _get_printf_count_output(void);

 __declspec(dllimport) int __cdecl _printf_l(    const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _printf_p_l(    const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _printf_s_l(    const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vprintf_l(    const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vprintf_p_l(    const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vprintf_s_l(    const char * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _fprintf_l(  FILE * _File,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fprintf_p_l(  FILE * _File,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fprintf_s_l(  FILE * _File,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vfprintf_l(  FILE * _File,   const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfprintf_p_l(  FILE * _File,   const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfprintf_s_l(  FILE * _File,   const char * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _sprintf_l(    char * _DstBuf,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _sprintf_p_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _sprintf_s_l(  char * _DstBuf,   size_t _DstSize,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsprintf_l(    char * _DstBuf,   const char * _Format,   _locale_t, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsprintf_p_l(  char * _DstBuf,   size_t _MaxCount,     const char* _Format,   _locale_t _Locale,  va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsprintf_s_l(  char * _DstBuf,   size_t _DstSize,     const char * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _scprintf_l(    const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _scprintf_p_l(    const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vscprintf_l(    const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vscprintf_p_l(    const char * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snprintf_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snprintf_c_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snprintf_s_l(  char * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnprintf_l(  char * _DstBuf,   size_t _MaxCount,     const char * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsnprintf_c_l(  char * _DstBuf,   size_t _MaxCount, const char *,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsnprintf_s_l(  char * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const char* _Format,  _locale_t _Locale, va_list _ArgList);







#line 414 "d:\\programs overflow\\vc\\include\\stdio.h"

  __declspec(dllimport) FILE * __cdecl _wfsopen(  const wchar_t * _Filename,   const wchar_t * _Mode,   int _ShFlag);

 __declspec(dllimport) wint_t __cdecl fgetwc(  FILE * _File);
 __declspec(dllimport) wint_t __cdecl _fgetwchar(void);
 __declspec(dllimport) wint_t __cdecl fputwc(  wchar_t _Ch,   FILE * _File);
 __declspec(dllimport) wint_t __cdecl _fputwchar(  wchar_t _Ch);
  __declspec(dllimport) wint_t __cdecl getwc(  FILE * _File);
  __declspec(dllimport) wint_t __cdecl getwchar(void);
 __declspec(dllimport) wint_t __cdecl putwc(  wchar_t _Ch,   FILE * _File);
 __declspec(dllimport) wint_t __cdecl putwchar(  wchar_t _Ch);
 __declspec(dllimport) wint_t __cdecl ungetwc(  wint_t _Ch,   FILE * _File);

 __declspec(dllimport) wchar_t * __cdecl fgetws(  wchar_t * _Dst,   int _SizeInWords,   FILE * _File);
 __declspec(dllimport) int __cdecl fputws(  const wchar_t * _Str,   FILE * _File);
 __declspec(dllimport) wchar_t * __cdecl _getws_s(  wchar_t * _Str,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline wchar_t * __cdecl _getws_s(  wchar_t (&_String)[_Size]) throw() { return _getws_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_getws_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _getws(  wchar_t *_String);
 __declspec(dllimport) int __cdecl _putws(  const wchar_t * _Str);

 __declspec(dllimport) int __cdecl fwprintf(  FILE * _File,     const wchar_t * _Format, ...);

 __declspec(dllimport) int __cdecl fwprintf_s(  FILE * _File,     const wchar_t * _Format, ...);
#line 438 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(dllimport) int __cdecl wprintf(    const wchar_t * _Format, ...);

 __declspec(dllimport) int __cdecl wprintf_s(    const wchar_t * _Format, ...);
#line 442 "d:\\programs overflow\\vc\\include\\stdio.h"
  __declspec(dllimport) int __cdecl _scwprintf(    const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl vfwprintf(  FILE * _File,     const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vfwscanf(  FILE * _File,     const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vfwprintf_s(  FILE * _File,     const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vfwscanf_s(  FILE * _File,     const wchar_t * _Format, va_list _ArgList);
#line 449 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(dllimport) int __cdecl vwprintf(    const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vwscanf(    const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl vwprintf_s(    const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vwscanf_s(    const wchar_t * _Format, va_list _ArgList);
#line 455 "d:\\programs overflow\\vc\\include\\stdio.h"


__declspec(dllimport) int __cdecl swprintf_s(  wchar_t * _Dst,   size_t _SizeInWords,     const wchar_t * _Format, ...);
#line 459 "d:\\programs overflow\\vc\\include\\stdio.h"
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl swprintf_s(  wchar_t (&_Dest)[_Size],     const wchar_t * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return vswprintf_s(_Dest, _Size, _Format, _ArgList); } __pragma(warning(pop)); }

__declspec(dllimport) int __cdecl vswprintf_s(  wchar_t * _Dst,   size_t _SizeInWords,     const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl vswscanf_s(const wchar_t * _Src,     const wchar_t * _Format, va_list _ArgList);
#line 464 "d:\\programs overflow\\vc\\include\\stdio.h"
extern "C++" { template <size_t _Size> inline int __cdecl vswprintf_s(  wchar_t (&_Dest)[_Size],     const wchar_t * _Format, va_list _Args) throw() { return vswprintf_s(_Dest, _Size, _Format, _Args); } }
extern "C++" { template <size_t _Size> inline int __cdecl vswscanf_s(  wchar_t (&_Dest)[_Size],     const wchar_t * _Format, va_list _Args) throw() { return vswscanf_s(_Dest, _Size, _Format, _Args); } }
 __declspec(dllimport) int __cdecl vswscanf(const wchar_t * _srcBuf,     const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl _swprintf_c(  wchar_t * _DstBuf,   size_t _SizeInWords,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _vswprintf_c(  wchar_t * _DstBuf,   size_t _SizeInWords,     const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl _snwprintf_s(  wchar_t * _DstBuf,   size_t _SizeInWords,   size_t _MaxCount,     const wchar_t * _Format, ...);
extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl _snwprintf_s(  wchar_t (&_Dest)[_Size],   size_t _Count,     const wchar_t * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _ArgList); } __pragma(warning(pop)); }
 __declspec(dllimport) int __cdecl _vsnwprintf_s(  wchar_t * _DstBuf,   size_t _SizeInWords,   size_t _MaxCount,     const wchar_t * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnwprintf_s(  wchar_t (&_Dest)[_Size],   size_t _Count,     const wchar_t * _Format, va_list _Args) throw() { return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable:4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwprintf(    wchar_t *_Dest,   size_t _Count,     const wchar_t * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnwprintf(    wchar_t *_Dest,   size_t _Count,     const wchar_t * _Format, va_list _Args);
#pragma warning(pop)

 __declspec(dllimport) int __cdecl _fwprintf_p(  FILE * _File,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _wprintf_p(    const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _vfwprintf_p(  FILE * _File,     const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vwprintf_p(    const wchar_t * _Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _swprintf_p(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _vswprintf_p(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format, va_list _ArgList);
  __declspec(dllimport) int __cdecl _scwprintf_p(    const wchar_t * _Format, ...);
  __declspec(dllimport) int __cdecl _vscwprintf_p(    const wchar_t * _Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl _wprintf_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _wprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _wprintf_s_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vwprintf_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vwprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vwprintf_s_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _fwprintf_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fwprintf_p_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _fwprintf_s_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vfwprintf_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfwprintf_p_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vfwprintf_s_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(dllimport) int __cdecl _swprintf_c_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _swprintf_p_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _swprintf_s_l(  wchar_t * _DstBuf,   size_t _DstSize,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vswprintf_c_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vswprintf_p_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vswprintf_s_l(  wchar_t * _DstBuf,   size_t _DstSize,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);

  __declspec(dllimport) int __cdecl _scwprintf_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _scwprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
  __declspec(dllimport) int __cdecl _vscwprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwprintf_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snwprintf_s_l(  wchar_t * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnwprintf_l(  wchar_t * _DstBuf,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vsnwprintf_s_l(  wchar_t * _DstBuf,   size_t _DstSize,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);










#line 529 "d:\\programs overflow\\vc\\include\\stdio.h"


#pragma warning(push)
#pragma warning(disable:4141 4996 4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _swprintf(    wchar_t *_Dest,     const wchar_t * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _vswprintf(    wchar_t *_Dest,     const wchar_t * _Format, va_list _Args);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __swprintf_l(    wchar_t *_Dest,     const wchar_t * _Format, _locale_t _Plocinfo, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __vswprintf_l(    wchar_t *_Dest,     const wchar_t * _Format, _locale_t _Plocinfo, va_list _Args);
#pragma warning(pop)


#line 1 "d:\\programs overflow\\vc\\include\\swprintf.inl"












#pragma once







#line 22 "d:\\programs overflow\\vc\\include\\swprintf.inl"










#line 33 "d:\\programs overflow\\vc\\include\\swprintf.inl"

#pragma warning( push )
#pragma warning( disable : 4793 4412 )
static __inline int swprintf(  wchar_t * _String, size_t _Count,     const wchar_t * _Format, ...)
{
    va_list _Arglist;
    int _Ret;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    _Ret = _vswprintf_c_l(_String, _Count, _Format, 0, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
static __inline int __cdecl vswprintf(  wchar_t * _String, size_t _Count,     const wchar_t * _Format, va_list _Ap)
{
    return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap);
}
#pragma warning( pop )


#line 57 "d:\\programs overflow\\vc\\include\\swprintf.inl"

#pragma warning( push )
#pragma warning( disable : 4793 4412 )
static __inline int _swprintf_l(  wchar_t * _String, size_t _Count,     const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
    va_list _Arglist;
    int _Ret;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Plocinfo) ) + ( (sizeof(_Plocinfo) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    _Ret = _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4412 )
static __inline int __cdecl _vswprintf_l(  wchar_t * _String, size_t _Count,     const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
    return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap);
}
#pragma warning( pop )


#pragma warning( push )
#pragma warning( disable : 4996 )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int swprintf(    wchar_t * _String,     const wchar_t * _Format, ...)
{
    va_list _Arglist;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    int _Ret = _vswprintf(_String, _Format, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int __cdecl vswprintf(    wchar_t * _String,     const wchar_t * _Format, va_list _Ap)
{
    return _vswprintf(_String, _Format, _Ap);
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4793 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int _swprintf_l(    wchar_t * _String,     const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
    va_list _Arglist;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Plocinfo) ) + ( (sizeof(_Plocinfo) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    int _Ret = __vswprintf_l(_String, _Format, _Plocinfo, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4141 )
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int __cdecl _vswprintf_l(    wchar_t * _String,     const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
    return __vswprintf_l(_String, _Format, _Plocinfo, _Ap);
}
#pragma warning( pop )

#pragma warning( pop )

#line 126 "d:\\programs overflow\\vc\\include\\swprintf.inl"

#line 128 "d:\\programs overflow\\vc\\include\\swprintf.inl"
#line 129 "d:\\programs overflow\\vc\\include\\swprintf.inl"

#line 539 "d:\\programs overflow\\vc\\include\\stdio.h"
#line 540 "d:\\programs overflow\\vc\\include\\stdio.h"













#line 554 "d:\\programs overflow\\vc\\include\\stdio.h"

  __declspec(dllimport) wchar_t * __cdecl _wtempnam(  const wchar_t * _Directory,   const wchar_t * _FilePrefix);



#line 560 "d:\\programs overflow\\vc\\include\\stdio.h"

  __declspec(dllimport) int __cdecl _vscwprintf(    const wchar_t * _Format, va_list _ArgList);
  __declspec(dllimport) int __cdecl _vscwprintf_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl fwscanf(  FILE * _File,     const wchar_t * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _fwscanf_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(dllimport) int __cdecl fwscanf_s(  FILE * _File,     const wchar_t * _Format, ...);
#line 570 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _fwscanf_s_l(  FILE * _File,     const wchar_t * _Format,   _locale_t _Locale, ...);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl swscanf(  const wchar_t * _Src,     const wchar_t * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _swscanf_l(  const wchar_t * _Src,     const wchar_t * _Format,   _locale_t _Locale, ...);

 __declspec(dllimport) int __cdecl swscanf_s(  const wchar_t *_Src,     const wchar_t * _Format, ...);
#line 576 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _swscanf_s_l(  const wchar_t * _Src,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwscanf(    const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwscanf_l(    const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _snwscanf_s(    const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _snwscanf_s_l(    const wchar_t * _Src,   size_t _MaxCount,     const wchar_t * _Format,   _locale_t _Locale, ...);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl wscanf(    const wchar_t * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wscanf_l(    const wchar_t * _Format,   _locale_t _Locale, ...);

 __declspec(dllimport) int __cdecl wscanf_s(    const wchar_t * _Format, ...);
#line 586 "d:\\programs overflow\\vc\\include\\stdio.h"
 __declspec(dllimport) int __cdecl _wscanf_s_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
#pragma warning(pop)

  __declspec(dllimport) FILE * __cdecl _wfdopen(  int _FileHandle ,   const wchar_t * _Mode);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl _wfopen(  const wchar_t * _Filename,   const wchar_t * _Mode);
 __declspec(dllimport) errno_t __cdecl _wfopen_s(  FILE ** _File,   const wchar_t * _Filename,   const wchar_t * _Mode);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl _wfreopen(  const wchar_t * _Filename,   const wchar_t * _Mode,   FILE * _OldFile);
 __declspec(dllimport) errno_t __cdecl _wfreopen_s(  FILE ** _File,   const wchar_t * _Filename,   const wchar_t * _Mode,   FILE * _OldFile);



__declspec(dllimport) void __cdecl _wperror(  const wchar_t * _ErrMsg);
#line 599 "d:\\programs overflow\\vc\\include\\stdio.h"

  __declspec(dllimport) FILE * __cdecl _wpopen(  const wchar_t *_Command,   const wchar_t * _Mode);
#line 602 "d:\\programs overflow\\vc\\include\\stdio.h"
__declspec(dllimport) int __cdecl _wremove(  const wchar_t * _Filename);
 __declspec(dllimport) errno_t __cdecl _wtmpnam_s(  wchar_t * _DstBuf,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wtmpnam(  wchar_t *_Buffer);

 __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(  FILE * _File);
 __declspec(dllimport) wint_t __cdecl _fputwc_nolock(  wchar_t _Ch,   FILE * _File);
 __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(  wint_t _Ch,   FILE * _File);





#line 616 "d:\\programs overflow\\vc\\include\\stdio.h"




#line 621 "d:\\programs overflow\\vc\\include\\stdio.h"
inline   wint_t __cdecl getwchar()
        {return (fgetwc((&__iob_func()[0]))); }   
inline  wint_t __cdecl putwchar(  wchar_t _C)
        {return (fputwc(_C, (&__iob_func()[1]))); }       
#line 626 "d:\\programs overflow\\vc\\include\\stdio.h"










#line 637 "d:\\programs overflow\\vc\\include\\stdio.h"


#line 640 "d:\\programs overflow\\vc\\include\\stdio.h"


#line 643 "d:\\programs overflow\\vc\\include\\stdio.h"















#line 659 "d:\\programs overflow\\vc\\include\\stdio.h"











__declspec(dllimport) void __cdecl _lock_file(  FILE * _File);
__declspec(dllimport) void __cdecl _unlock_file(  FILE * _File);

 __declspec(dllimport) int __cdecl _fclose_nolock(  FILE * _File);
 __declspec(dllimport) int __cdecl _fflush_nolock(  FILE * _File);
 __declspec(dllimport) size_t __cdecl _fread_nolock(  void * _DstBuf,   size_t _ElementSize,   size_t _Count,   FILE * _File);
 __declspec(dllimport) size_t __cdecl _fread_nolock_s(  void * _DstBuf,   size_t _DstSize,   size_t _ElementSize,   size_t _Count,   FILE * _File);
 __declspec(dllimport) int __cdecl _fseek_nolock(  FILE * _File,   long _Offset,   int _Origin);
  __declspec(dllimport) long __cdecl _ftell_nolock(  FILE * _File);
 __declspec(dllimport) int __cdecl _fseeki64_nolock(  FILE * _File,   __int64 _Offset,   int _Origin);
  __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(  FILE * _File);
 __declspec(dllimport) size_t __cdecl _fwrite_nolock(  const void * _DstBuf,   size_t _Size,   size_t _Count,   FILE * _File);
 __declspec(dllimport) int __cdecl _ungetc_nolock(  int _Ch,   FILE * _File);












#line 696 "d:\\programs overflow\\vc\\include\\stdio.h"











#line 708 "d:\\programs overflow\\vc\\include\\stdio.h"

__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_tempnam" ". See online help for details.")) __declspec(dllimport) char * __cdecl tempnam(  const char * _Directory,   const char * _FilePrefix);



#line 714 "d:\\programs overflow\\vc\\include\\stdio.h"

 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int __cdecl fcloseall(void);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fdopen" ". See online help for details.")) __declspec(dllimport) FILE * __cdecl fdopen(  int _FileHandle,   const char * _Format);
 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fgetchar" ". See online help for details.")) __declspec(dllimport) int __cdecl fgetchar(void);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fileno" ". See online help for details.")) __declspec(dllimport) int __cdecl fileno(  FILE * _File);
 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_flushall" ". See online help for details.")) __declspec(dllimport) int __cdecl flushall(void);
 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fputchar" ". See online help for details.")) __declspec(dllimport) int __cdecl fputchar(  int _Ch);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_getw" ". See online help for details.")) __declspec(dllimport) int __cdecl getw(  FILE * _File);
 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_putw" ". See online help for details.")) __declspec(dllimport) int __cdecl putw(  int _Ch,   FILE * _File);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_rmtmp" ". See online help for details.")) __declspec(dllimport) int __cdecl rmtmp(void);

#line 726 "d:\\programs overflow\\vc\\include\\stdio.h"


}
#line 730 "d:\\programs overflow\\vc\\include\\stdio.h"

#pragma pack(pop)

#line 734 "d:\\programs overflow\\vc\\include\\stdio.h"

#line 14 "d:\\programs overflow\\vc\\include\\cstdio"
#line 15 "d:\\programs overflow\\vc\\include\\cstdio"


 
 
 
 
 
 
 

 
 
 
 

  

typedef FILE _iobuf;

 
namespace std {
using :: _iobuf; using :: _Mbstatet;

using :: size_t; using :: fpos_t; using :: FILE;
using :: clearerr; using :: fclose; using :: feof;
using :: ferror; using :: fflush; using :: fgetc;
using :: fgetpos; using :: fgets; using :: fopen;
using :: fprintf; using :: fputc; using :: fputs;
using :: fread; using :: freopen; using :: fscanf;
using :: fseek; using :: fsetpos; using :: ftell;
using :: fwrite; using :: getc; using :: getchar;
using :: gets; using :: perror;
using :: putc; using :: putchar;
using :: printf; using :: puts; using :: remove;
using :: rename; using :: rewind; using :: scanf;
using :: setbuf; using :: setvbuf; using :: sprintf;
using :: sscanf; using :: tmpfile; using :: tmpnam;
using :: ungetc; using :: vfprintf; using :: vprintf;
using :: vsprintf;

 using :: vsnprintf;
using :: vfscanf; using :: vscanf; using :: vsscanf;
}
 #line 59 "d:\\programs overflow\\vc\\include\\cstdio"

#line 61 "d:\\programs overflow\\vc\\include\\cstdio"





#line 4 "d:\\my documents\\programs\\jotunengine2\\stdafx.h"
#line 1 "d:\\programs overflow\\vc\\include\\cstdlib"

#pragma once










 #line 1 "d:\\programs overflow\\vc\\include\\stdlib.h"















#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "d:\\programs overflow\\vc\\include\\stdlib.h"
#line 1 "d:\\programs overflow\\vc\\include\\limits.h"














#pragma once

#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 18 "d:\\programs overflow\\vc\\include\\limits.h"















#line 34 "d:\\programs overflow\\vc\\include\\limits.h"









































#line 76 "d:\\programs overflow\\vc\\include\\limits.h"






#line 83 "d:\\programs overflow\\vc\\include\\limits.h"
#line 84 "d:\\programs overflow\\vc\\include\\limits.h"




#line 89 "d:\\programs overflow\\vc\\include\\limits.h"
#line 90 "d:\\programs overflow\\vc\\include\\limits.h"


#line 93 "d:\\programs overflow\\vc\\include\\limits.h"
#line 23 "d:\\programs overflow\\vc\\include\\stdlib.h"





#pragma pack(push,8)


extern "C" {
#line 33 "d:\\programs overflow\\vc\\include\\stdlib.h"



















typedef int (__cdecl * _onexit_t)(void);



#line 57 "d:\\programs overflow\\vc\\include\\stdlib.h"



#line 61 "d:\\programs overflow\\vc\\include\\stdlib.h"




#line 66 "d:\\programs overflow\\vc\\include\\stdlib.h"


#line 69 "d:\\programs overflow\\vc\\include\\stdlib.h"






typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;

typedef struct _lldiv_t {
        long long quot;
        long long rem;
} lldiv_t;


#line 92 "d:\\programs overflow\\vc\\include\\stdlib.h"










#pragma pack(4)
typedef struct {
    unsigned char ld[10];
} _LDOUBLE;
#pragma pack()













#line 121 "d:\\programs overflow\\vc\\include\\stdlib.h"

typedef struct {
        double x;
} _CRT_DOUBLE;

typedef struct {
    float f;
} _CRT_FLOAT;





typedef struct {
        


        long double x;
} _LONGDOUBLE;



#pragma pack(4)
typedef struct {
    unsigned char ld12[12];
} _LDBL12;
#pragma pack()


#line 151 "d:\\programs overflow\\vc\\include\\stdlib.h"



















__declspec(dllimport) extern int __mb_cur_max;



#line 175 "d:\\programs overflow\\vc\\include\\stdlib.h"
__declspec(dllimport) int __cdecl ___mb_cur_max_func(void);
__declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t);
#line 178 "d:\\programs overflow\\vc\\include\\stdlib.h"





































typedef void (__cdecl *_purecall_handler)(void);


__declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler(  _purecall_handler _Handler);
__declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler(void);
#line 221 "d:\\programs overflow\\vc\\include\\stdlib.h"


extern "C++"
{




#line 230 "d:\\programs overflow\\vc\\include\\stdlib.h"
}
#line 232 "d:\\programs overflow\\vc\\include\\stdlib.h"



typedef void (__cdecl *_invalid_parameter_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t);


__declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(  _invalid_parameter_handler _Handler);
__declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);
#line 241 "d:\\programs overflow\\vc\\include\\stdlib.h"




__declspec(dllimport) extern int * __cdecl _errno(void);


errno_t __cdecl _set_errno(  int _Value);
errno_t __cdecl _get_errno(  int * _Value);
#line 251 "d:\\programs overflow\\vc\\include\\stdlib.h"

__declspec(dllimport) unsigned long * __cdecl __doserrno(void);


errno_t __cdecl _set_doserrno(  unsigned long _Value);
errno_t __cdecl _get_doserrno(  unsigned long * _Value);


__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char ** __cdecl __sys_errlist(void);


__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int * __cdecl __sys_nerr(void);





__declspec(dllimport) int *          __cdecl __p___argc(void);
__declspec(dllimport) char ***       __cdecl __p___argv(void);
__declspec(dllimport) wchar_t ***    __cdecl __p___wargv(void);
__declspec(dllimport) char ***       __cdecl __p__environ(void);
__declspec(dllimport) wchar_t ***    __cdecl __p__wenviron(void);
#line 274 "d:\\programs overflow\\vc\\include\\stdlib.h"

__declspec(dllimport) char **        __cdecl __p__pgmptr(void);
__declspec(dllimport) wchar_t **     __cdecl __p__wpgmptr(void);






#line 284 "d:\\programs overflow\\vc\\include\\stdlib.h"




__declspec(dllimport) extern int __argc;          
__declspec(dllimport) extern char ** __argv;      
__declspec(dllimport) extern wchar_t ** __wargv;  







#line 299 "d:\\programs overflow\\vc\\include\\stdlib.h"

#line 301 "d:\\programs overflow\\vc\\include\\stdlib.h"





__declspec(dllimport) extern char ** _environ;    
__declspec(dllimport) extern wchar_t ** _wenviron;    

#line 310 "d:\\programs overflow\\vc\\include\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern char * _pgmptr;      
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern wchar_t * _wpgmptr;  
























#line 338 "d:\\programs overflow\\vc\\include\\stdlib.h"

errno_t __cdecl _get_pgmptr(  char ** _Value);
errno_t __cdecl _get_wpgmptr(  wchar_t ** _Value);



#line 345 "d:\\programs overflow\\vc\\include\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern int _fmode;          



#line 351 "d:\\programs overflow\\vc\\include\\stdlib.h"
#line 352 "d:\\programs overflow\\vc\\include\\stdlib.h"

__declspec(dllimport) errno_t __cdecl _set_fmode(  int _Mode);
__declspec(dllimport) errno_t __cdecl _get_fmode(  int * _PMode);





#line 361 "d:\\programs overflow\\vc\\include\\stdlib.h"
extern "C++"
{
template <typename _CountofType, size_t _SizeOfArray>
char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

}
#line 368 "d:\\programs overflow\\vc\\include\\stdlib.h"
#line 369 "d:\\programs overflow\\vc\\include\\stdlib.h"







__declspec(dllimport) __declspec(noreturn) void __cdecl exit(  int _Code);

__declspec(dllimport) __declspec(noreturn) void __cdecl _exit(  int _Code);
__declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);
#line 381 "d:\\programs overflow\\vc\\include\\stdlib.h"

__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(  unsigned int _Flags,   unsigned int _Mask);

int       __cdecl abs(  int _X);
long      __cdecl labs(  long _X);
long long __cdecl llabs(  long long _X);

        __int64    __cdecl _abs64(__int64);




















#line 410 "d:\\programs overflow\\vc\\include\\stdlib.h"















#line 426 "d:\\programs overflow\\vc\\include\\stdlib.h"
        int    __cdecl atexit(void (__cdecl *)(void));
#line 428 "d:\\programs overflow\\vc\\include\\stdlib.h"
  __declspec(dllimport) double  __cdecl atof(  const char *_String);
  __declspec(dllimport) double  __cdecl _atof_l(  const char *_String,   _locale_t _Locale);
  __declspec(dllimport)  int    __cdecl atoi(  const char *_Str);
  __declspec(dllimport) int    __cdecl _atoi_l(  const char *_Str,   _locale_t _Locale);
  __declspec(dllimport) long   __cdecl atol(  const char *_Str);
  __declspec(dllimport) long   __cdecl _atol_l(  const char *_Str,   _locale_t _Locale);
  __declspec(dllimport) long long __cdecl atoll(  const char *_Str);
  __declspec(dllimport) long long __cdecl _atoll_l(  const char *_Str,   _locale_t _Locale);



  __declspec(dllimport) void * __cdecl bsearch_s(  const void * _Key,   const void * _Base,
          rsize_t _NumOfElements,   rsize_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context);
#line 443 "d:\\programs overflow\\vc\\include\\stdlib.h"
  __declspec(dllimport) void * __cdecl bsearch(  const void * _Key,   const void * _Base,
          size_t _NumOfElements,   size_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(const void *, const void *));


__declspec(dllimport) void __cdecl qsort_s(  void * _Base,
          rsize_t _NumOfElements,   rsize_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void *_Context);
#line 452 "d:\\programs overflow\\vc\\include\\stdlib.h"
__declspec(dllimport) void __cdecl qsort(  void * _Base,
          size_t _NumOfElements,   size_t _SizeOfElements,
          int (__cdecl * _PtFuncCompare)(const void *, const void *));
#line 456 "d:\\programs overflow\\vc\\include\\stdlib.h"
          unsigned short __cdecl _byteswap_ushort(  unsigned short _Short);
          unsigned long  __cdecl _byteswap_ulong (  unsigned long _Long);
          unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Int64);
  __declspec(dllimport) div_t  __cdecl div(  int _Numerator,   int _Denominator);


  __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl getenv(  const char * _VarName);

 __declspec(dllimport) errno_t __cdecl getenv_s(  size_t * _ReturnSize,   char * _DstBuf,   rsize_t _DstSize,   const char * _VarName);
#line 466 "d:\\programs overflow\\vc\\include\\stdlib.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t * _ReturnSize, char (&_Dest)[_Size],   const char * _VarName) throw() { return getenv_s(_ReturnSize, _Dest, _Size, _VarName); } }



#line 471 "d:\\programs overflow\\vc\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _dupenv_s(    char **_PBuffer,   size_t * _PBufferSizeInBytes,   const char * _VarName);



#line 477 "d:\\programs overflow\\vc\\include\\stdlib.h"
#line 478 "d:\\programs overflow\\vc\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _itoa_s(  int _Value,   char * _DstBuf,   size_t _Size,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itoa_s(  int _Value, char (&_Dest)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _itoa( int _Value,   char *_Dest,  int _Radix);
 __declspec(dllimport) errno_t __cdecl _i64toa_s(  __int64 _Val,   char * _DstBuf,   size_t _Size,   int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _i64toa(  __int64 _Val,     char * _DstBuf,   int _Radix);
 __declspec(dllimport) errno_t __cdecl _ui64toa_s(  unsigned __int64 _Val,   char * _DstBuf,   size_t _Size,   int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _ui64toa(  unsigned __int64 _Val,     char * _DstBuf,   int _Radix);
  __declspec(dllimport) __int64 __cdecl _atoi64(  const char * _String);
  __declspec(dllimport) __int64 __cdecl _atoi64_l(  const char * _String,   _locale_t _Locale);
  __declspec(dllimport) __int64 __cdecl _strtoi64(  const char * _String,     char ** _EndPtr,   int _Radix);
  __declspec(dllimport) __int64 __cdecl _strtoi64_l(  const char * _String,     char ** _EndPtr,   int _Radix,   _locale_t _Locale);
  __declspec(dllimport) unsigned __int64 __cdecl _strtoui64(  const char * _String,     char ** _EndPtr,   int _Radix);
  __declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(  const char * _String,     char ** _EndPtr,   int  _Radix,   _locale_t _Locale);
  __declspec(dllimport) ldiv_t __cdecl ldiv(  long _Numerator,   long _Denominator);
  __declspec(dllimport) lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);

extern "C++"
{
    inline long abs(long _X) throw()
    {
        return labs(_X);
    }
    inline long long abs(long long _X) throw()
    {
        return llabs(_X);
    }
    inline ldiv_t div(long _A1, long _A2) throw()
    {
        return ldiv(_A1, _A2);
    }
    inline lldiv_t div(long long _A1, long long _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#line 515 "d:\\programs overflow\\vc\\include\\stdlib.h"
 __declspec(dllimport) errno_t __cdecl _ltoa_s(  long _Val,   char * _DstBuf,   size_t _Size,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Dest)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _ltoa( long _Value,   char *_Dest,  int _Radix);
  __declspec(dllimport) int    __cdecl mblen(    const char * _Ch,   size_t _MaxCount);
  __declspec(dllimport) int    __cdecl _mblen_l(    const char * _Ch,   size_t _MaxCount,   _locale_t _Locale);
  __declspec(dllimport) size_t __cdecl _mbstrlen(  const char * _Str);
  __declspec(dllimport) size_t __cdecl _mbstrlen_l(  const char *_Str,   _locale_t _Locale);
  __declspec(dllimport) size_t __cdecl _mbstrnlen(  const char *_Str,   size_t _MaxCount);
  __declspec(dllimport) size_t __cdecl _mbstrnlen_l(  const char *_Str,   size_t _MaxCount,   _locale_t _Locale);
__declspec(dllimport) int    __cdecl mbtowc(    wchar_t * _DstCh,     const char * _SrcCh,   size_t _SrcSizeInBytes);
__declspec(dllimport) int    __cdecl _mbtowc_l(    wchar_t * _DstCh,     const char * _SrcCh,   size_t _SrcSizeInBytes,   _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl mbstowcs_s(  size_t * _PtNumOfCharConverted,   wchar_t * _DstBuf,   size_t _SizeInWords,   const char * _SrcBuf,   size_t _MaxCount );
extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t * _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   const char * _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest,  const char * _Source,  size_t _MaxCount);

 __declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(  size_t * _PtNumOfCharConverted,   wchar_t * _DstBuf,   size_t _SizeInWords,   const char * _SrcBuf,   size_t _MaxCount,   _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t * _PtNumOfCharConverted, wchar_t (&_Dest)[_Size],   const char * _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   const char * _Source,   size_t _MaxCount,   _locale_t _Locale);

  __declspec(dllimport) int    __cdecl rand(void);


#line 538 "d:\\programs overflow\\vc\\include\\stdlib.h"

 __declspec(dllimport) int    __cdecl _set_error_mode(  int _Mode);

__declspec(dllimport) void   __cdecl srand(  unsigned int _Seed);
  __declspec(dllimport) double __cdecl strtod(  const char * _Str,     char ** _EndPtr);
  __declspec(dllimport) double __cdecl _strtod_l(  const char * _Str,     char ** _EndPtr,   _locale_t _Locale);
  __declspec(dllimport) long   __cdecl strtol(  const char * _Str,     char ** _EndPtr,   int _Radix );
  __declspec(dllimport) long   __cdecl _strtol_l(  const char *_Str,     char **_EndPtr,   int _Radix,   _locale_t _Locale);
  __declspec(dllimport) long long  __cdecl strtoll(  const char * _Str,     char ** _EndPtr,   int _Radix );
  __declspec(dllimport) long long  __cdecl _strtoll_l(  const char * _Str,     char ** _EndPtr,   int _Radix,   _locale_t _Locale );
  __declspec(dllimport) unsigned long __cdecl strtoul(  const char * _Str,     char ** _EndPtr,   int _Radix);
  __declspec(dllimport) unsigned long __cdecl _strtoul_l(const char * _Str,     char **_EndPtr,   int _Radix,   _locale_t _Locale);
  __declspec(dllimport) unsigned long long __cdecl strtoull(  const char * _Str,     char ** _EndPtr,   int _Radix);
  __declspec(dllimport) unsigned long long __cdecl _strtoull_l(  const char * _Str,     char ** _EndPtr,   int _Radix,   _locale_t _Locale);
  __declspec(dllimport) long double __cdecl strtold(  const char * _Str,     char ** _EndPtr);
  __declspec(dllimport) long double __cdecl _strtold_l(  const char * _Str,     char ** _EndPtr,   _locale_t _Locale);
  __declspec(dllimport) float __cdecl strtof(  const char * _Str,     char ** _EndPtr);
  __declspec(dllimport) float __cdecl _strtof_l(  const char * _Str,     char ** _EndPtr,   _locale_t _Locale);




__declspec(dllimport) int __cdecl system(  const char * _Command);
#line 562 "d:\\programs overflow\\vc\\include\\stdlib.h"
#line 563 "d:\\programs overflow\\vc\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _ultoa_s(  unsigned long _Val,   char * _DstBuf,   size_t _Size,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Dest)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _ultoa( unsigned long _Value,   char *_Dest,  int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int    __cdecl wctomb(  char * _MbCh,   wchar_t _WCh);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int    __cdecl _wctomb_l(    char * _MbCh,   wchar_t _WCh,   _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl wctomb_s(  int * _SizeConverted,   char * _MbCh,   rsize_t _SizeInBytes,   wchar_t _WCh);
#line 572 "d:\\programs overflow\\vc\\include\\stdlib.h"
 __declspec(dllimport) errno_t __cdecl _wctomb_s_l(  int * _SizeConverted,   char * _MbCh,   size_t _SizeInBytes,   wchar_t _WCh,   _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl wcstombs_s(  size_t * _PtNumOfCharConverted,   char * _Dst,   size_t _DstSizeInBytes,   const wchar_t * _Src,   size_t _MaxCountInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t * _PtNumOfCharConverted,   char (&_Dest)[_Size],   const wchar_t * _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest,  const wchar_t * _Source,  size_t _MaxCount);
 __declspec(dllimport) errno_t __cdecl _wcstombs_s_l(  size_t * _PtNumOfCharConverted,   char * _Dst,   size_t _DstSizeInBytes,   const wchar_t * _Src,   size_t _MaxCountInBytes,   _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t * _PtNumOfCharConverted,   char (&_Dest)[_Size],   const wchar_t * _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l(  char *_Dest,   const wchar_t * _Source,   size_t _MaxCount,   _locale_t _Locale);

























#line 605 "d:\\programs overflow\\vc\\include\\stdlib.h"


































#line 640 "d:\\programs overflow\\vc\\include\\stdlib.h"
      __declspec(dllimport)  __declspec(noalias) __declspec(restrict)    void * __cdecl calloc(  __declspec(guard(overflow)) size_t _Count,   __declspec(guard(overflow)) size_t _Size);
__declspec(dllimport)                     __declspec(noalias)                                                                             void   __cdecl free(    void * _Memory);
      __declspec(dllimport)  __declspec(noalias) __declspec(restrict)                              void * __cdecl malloc(  __declspec(guard(overflow)) size_t _Size);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                           void * __cdecl realloc(    void * _Memory,   __declspec(guard(overflow)) size_t _NewSize);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                       void * __cdecl _recalloc(    void * _Memory,   __declspec(guard(overflow)) size_t _Count,   __declspec(guard(overflow)) size_t _Size);
__declspec(dllimport)                     __declspec(noalias)                                                                             void   __cdecl _aligned_free(    void * _Memory);
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_malloc(  __declspec(guard(overflow)) size_t _Size,   size_t _Alignment);
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_offset_malloc(  __declspec(guard(overflow)) size_t _Size,   size_t _Alignment,   size_t _Offset);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_realloc(    void * _Memory,   __declspec(guard(overflow)) size_t _NewSize,   size_t _Alignment);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                       void * __cdecl _aligned_recalloc(    void * _Memory,   __declspec(guard(overflow)) size_t _Count,   __declspec(guard(overflow)) size_t _Size,   size_t _Alignment);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                              void * __cdecl _aligned_offset_realloc(    void * _Memory,   __declspec(guard(overflow)) size_t _NewSize,   size_t _Alignment,   size_t _Offset);
 
      __declspec(dllimport) __declspec(noalias) __declspec(restrict)                       void * __cdecl _aligned_offset_recalloc(    void * _Memory,   __declspec(guard(overflow)) size_t _Count,   __declspec(guard(overflow)) size_t _Size,   size_t _Alignment,   size_t _Offset);
  __declspec(dllimport)                                                  size_t __cdecl _aligned_msize(  void * _Memory,   size_t _Alignment,   size_t _Offset);


















#line 678 "d:\\programs overflow\\vc\\include\\stdlib.h"

#line 680 "d:\\programs overflow\\vc\\include\\stdlib.h"





 __declspec(dllimport) errno_t __cdecl _itow_s (  int _Val,   wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Dest)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _itow( int _Value,   wchar_t *_Dest,  int _Radix);
 __declspec(dllimport) errno_t __cdecl _ltow_s (  long _Val,   wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Dest)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _ltow( long _Value,   wchar_t *_Dest,  int _Radix);
 __declspec(dllimport) errno_t __cdecl _ultow_s (  unsigned long _Val,   wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Dest)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _ultow( unsigned long _Value,   wchar_t *_Dest,  int _Radix);
  __declspec(dllimport) double __cdecl wcstod(  const wchar_t * _Str,     wchar_t ** _EndPtr);
  __declspec(dllimport) double __cdecl _wcstod_l(  const wchar_t *_Str,     wchar_t ** _EndPtr,   _locale_t _Locale);
  __declspec(dllimport) long   __cdecl wcstol(  const wchar_t *_Str,     wchar_t ** _EndPtr, int _Radix);
  __declspec(dllimport) long   __cdecl _wcstol_l(  const wchar_t *_Str,     wchar_t **_EndPtr, int _Radix,   _locale_t _Locale);
  __declspec(dllimport) long long  __cdecl wcstoll(  const wchar_t *_Str,     wchar_t **_EndPtr, int _Radix);
  __declspec(dllimport) long long  __cdecl _wcstoll_l(  const wchar_t *_Str,     wchar_t **_EndPtr, int _Radix,   _locale_t _Locale);
  __declspec(dllimport) unsigned long __cdecl wcstoul(  const wchar_t *_Str,     wchar_t ** _EndPtr, int _Radix);
  __declspec(dllimport) unsigned long __cdecl _wcstoul_l(  const wchar_t *_Str,     wchar_t **_EndPtr, int _Radix,   _locale_t _Locale);
  __declspec(dllimport) unsigned long long __cdecl wcstoull(  const wchar_t *_Str,     wchar_t ** _EndPtr, int _Radix);
  __declspec(dllimport) unsigned long long __cdecl _wcstoull_l(  const wchar_t *_Str,     wchar_t ** _EndPtr, int _Radix,   _locale_t _Locale);
  __declspec(dllimport) long double __cdecl wcstold(  const wchar_t * _Str,     wchar_t ** _EndPtr);
  __declspec(dllimport) long double __cdecl _wcstold_l(  const wchar_t * _Str,     wchar_t ** _EndPtr,   _locale_t _Locale);
  __declspec(dllimport) float __cdecl wcstof(  const wchar_t * _Str,     wchar_t ** _EndPtr);
  __declspec(dllimport) float __cdecl _wcstof_l(  const wchar_t * _Str,     wchar_t ** _EndPtr,   _locale_t _Locale);



  __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) wchar_t * __cdecl _wgetenv(  const wchar_t * _VarName);
 __declspec(dllimport) errno_t __cdecl _wgetenv_s(  size_t * _ReturnSize,   wchar_t * _DstBuf,   size_t _DstSizeInWords,   const wchar_t * _VarName);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wgetenv_s(  size_t * _ReturnSize, wchar_t (&_Dest)[_Size],   const wchar_t * _VarName) throw() { return _wgetenv_s(_ReturnSize, _Dest, _Size, _VarName); } }




#line 719 "d:\\programs overflow\\vc\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _wdupenv_s(    wchar_t **_Buffer,   size_t *_BufferSizeInWords,   const wchar_t *_VarName);



#line 725 "d:\\programs overflow\\vc\\include\\stdlib.h"



__declspec(dllimport) int __cdecl _wsystem(  const wchar_t * _Command);
#line 730 "d:\\programs overflow\\vc\\include\\stdlib.h"

#line 732 "d:\\programs overflow\\vc\\include\\stdlib.h"

  __declspec(dllimport) double __cdecl _wtof(  const wchar_t *_Str);
  __declspec(dllimport) double __cdecl _wtof_l(  const wchar_t *_Str,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _wtoi(  const wchar_t *_Str);
  __declspec(dllimport) int __cdecl _wtoi_l(  const wchar_t *_Str,   _locale_t _Locale);
  __declspec(dllimport) long __cdecl _wtol(  const wchar_t *_Str);
  __declspec(dllimport) long __cdecl _wtol_l(  const wchar_t *_Str,   _locale_t _Locale);
  __declspec(dllimport) long long __cdecl _wtoll(  const wchar_t *_Str);
  __declspec(dllimport) long long __cdecl _wtoll_l(  const wchar_t *_Str,   _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl _i64tow_s(  __int64 _Val,   wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) wchar_t * __cdecl _i64tow(  __int64 _Val,     wchar_t * _DstBuf,   int _Radix);
 __declspec(dllimport) errno_t __cdecl _ui64tow_s(  unsigned __int64 _Val,   wchar_t * _DstBuf,   size_t _SizeInWords,   int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) wchar_t * __cdecl _ui64tow(  unsigned __int64 _Val,     wchar_t * _DstBuf,   int _Radix);
  __declspec(dllimport) __int64   __cdecl _wtoi64(  const wchar_t *_Str);
  __declspec(dllimport) __int64   __cdecl _wtoi64_l(  const wchar_t *_Str,   _locale_t _Locale);
  __declspec(dllimport) __int64   __cdecl _wcstoi64(  const wchar_t * _Str,     wchar_t ** _EndPtr,   int _Radix);
  __declspec(dllimport) __int64   __cdecl _wcstoi64_l(  const wchar_t * _Str,     wchar_t ** _EndPtr,   int _Radix,   _locale_t _Locale);
  __declspec(dllimport) unsigned __int64  __cdecl _wcstoui64(  const wchar_t * _Str,     wchar_t ** _EndPtr,   int _Radix);
  __declspec(dllimport) unsigned __int64  __cdecl _wcstoui64_l(  const wchar_t *_Str ,     wchar_t ** _EndPtr,   int _Radix,   _locale_t _Locale);


#line 755 "d:\\programs overflow\\vc\\include\\stdlib.h"













#line 769 "d:\\programs overflow\\vc\\include\\stdlib.h"

  __declspec(dllimport) char * __cdecl _fullpath(  char * _FullPath,   const char * _Path,   size_t _SizeInBytes);





#line 777 "d:\\programs overflow\\vc\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _ecvt_s(  char * _DstBuf,   size_t _Size,   double _Val,   int _NumOfDights,   int * _PtDec,   int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Dest)[_Size],   double _Value,   int _NumOfDigits,   int * _PtDec,   int * _PtSign) throw() { return _ecvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
  __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _ecvt(  double _Val,   int _NumOfDigits,   int * _PtDec,   int * _PtSign);
 __declspec(dllimport) errno_t __cdecl _fcvt_s(  char * _DstBuf,   size_t _Size,   double _Val,   int _NumOfDec,   int * _PtDec,   int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _fcvt_s(char (&_Dest)[_Size],   double _Value,   int _NumOfDigits,   int * _PtDec,   int * _PtSign) throw() { return _fcvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
  __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _fcvt(  double _Val,   int _NumOfDec,   int * _PtDec,   int * _PtSign);
__declspec(dllimport) errno_t __cdecl _gcvt_s(  char * _DstBuf,   size_t _Size,   double _Val,   int _NumOfDigits);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _gcvt_s(char (&_Dest)[_Size],   double _Value,   int _NumOfDigits) throw() { return _gcvt_s(_Dest, _Size, _Value, _NumOfDigits); } }
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _gcvt(  double _Val,   int _NumOfDigits,     char * _DstBuf);

  __declspec(dllimport) int __cdecl _atodbl(  _CRT_DOUBLE * _Result,   char * _Str);
  __declspec(dllimport) int __cdecl _atoldbl(  _LDOUBLE * _Result,   char * _Str);
  __declspec(dllimport) int __cdecl _atoflt(  _CRT_FLOAT * _Result,   const char * _Str);
  __declspec(dllimport) int __cdecl _atodbl_l(  _CRT_DOUBLE * _Result,   char * _Str,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _atoldbl_l(  _LDOUBLE * _Result,   char * _Str,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _atoflt_l(  _CRT_FLOAT * _Result,   const char * _Str,   _locale_t _Locale);
          unsigned long __cdecl _lrotl(  unsigned long _Val,   int _Shift);
          unsigned long __cdecl _lrotr(  unsigned long _Val,   int _Shift);
 __declspec(dllimport) errno_t   __cdecl _makepath_s(  char * _PathResult,   size_t _SizeInWords,   const char * _Drive,   const char * _Dir,   const char * _Filename,
          const char * _Ext);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Path)[_Size],   const char * _Drive,   const char * _Dir,   const char * _Filename,   const char * _Ext) throw() { return _makepath_s(_Path, _Size, _Drive, _Dir, _Filename, _Ext); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _makepath(  char *_Path,  const char * _Drive,  const char * _Dir,  const char * _Filename,  const char * _Ext);












#line 813 "d:\\programs overflow\\vc\\include\\stdlib.h"












#line 826 "d:\\programs overflow\\vc\\include\\stdlib.h"
        _onexit_t __cdecl _onexit(  _onexit_t _Func);
#line 828 "d:\\programs overflow\\vc\\include\\stdlib.h"






#pragma warning (push)
#pragma warning (disable:6540) 


  __declspec(dllimport) int    __cdecl _putenv(  const char * _EnvString);
 __declspec(dllimport) errno_t __cdecl _putenv_s(  const char * _Name,   const char * _Value);
#line 841 "d:\\programs overflow\\vc\\include\\stdlib.h"

        unsigned int __cdecl _rotl(  unsigned int _Val,   int _Shift);
        unsigned __int64 __cdecl _rotl64(  unsigned __int64 _Val,   int _Shift);
        unsigned int __cdecl _rotr(  unsigned int _Val,   int _Shift);
        unsigned __int64 __cdecl _rotr64(  unsigned __int64 _Val,   int _Shift);
#pragma warning (pop)


__declspec(dllimport) errno_t __cdecl _searchenv_s(  const char * _Filename,   const char * _EnvVar,   char * _ResultPath,   size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(  const char * _Filename,   const char * _EnvVar, char (&_ResultPath)[_Size]) throw() { return _searchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _searchenv( const char * _Filename,  const char * _EnvVar,   char *_ResultPath);
#line 853 "d:\\programs overflow\\vc\\include\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void   __cdecl _splitpath(  const char * _FullPath,     char * _Drive,     char * _Dir,     char * _Filename,     char * _Ext);
 __declspec(dllimport) errno_t  __cdecl _splitpath_s(  const char * _FullPath,
                  char * _Drive,   size_t _DriveSize,
                  char * _Dir,   size_t _DirSize,
                  char * _Filename,   size_t _FilenameSize,
                  char * _Ext,   size_t _ExtSize);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(  const char *_Dest,   char (&_Drive)[_DriveSize],   char (&_Dir)[_DirSize],   char (&_Name)[_NameSize],   char (&_Ext)[_ExtSize]) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }

__declspec(dllimport) void   __cdecl _swab(    char * _Buf1,     char * _Buf2, int _SizeInBytes);








#line 872 "d:\\programs overflow\\vc\\include\\stdlib.h"

  __declspec(dllimport) wchar_t * __cdecl _wfullpath(  wchar_t * _FullPath,   const wchar_t * _Path,   size_t _SizeInWords);



#line 878 "d:\\programs overflow\\vc\\include\\stdlib.h"

 __declspec(dllimport) errno_t __cdecl _wmakepath_s(  wchar_t * _PathResult,   size_t _SIZE,   const wchar_t * _Drive,   const wchar_t * _Dir,   const wchar_t * _Filename,
          const wchar_t * _Ext);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_ResultPath)[_Size],   const wchar_t * _Drive,   const wchar_t * _Dir,   const wchar_t * _Filename,   const wchar_t * _Ext) throw() { return _wmakepath_s(_ResultPath, _Size, _Drive, _Dir, _Filename, _Ext); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath(  wchar_t *_ResultPath,  const wchar_t * _Drive,  const wchar_t * _Dir,  const wchar_t * _Filename,  const wchar_t * _Ext);






  __declspec(dllimport) int    __cdecl _wputenv(  const wchar_t * _EnvString);
 __declspec(dllimport) errno_t __cdecl _wputenv_s(  const wchar_t * _Name,   const wchar_t * _Value);
__declspec(dllimport) errno_t __cdecl _wsearchenv_s(  const wchar_t * _Filename,   const wchar_t * _EnvVar,   wchar_t * _ResultPath,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(  const wchar_t * _Filename,   const wchar_t * _EnvVar, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv( const wchar_t * _Filename,  const wchar_t * _EnvVar,   wchar_t *_ResultPath);
#line 895 "d:\\programs overflow\\vc\\include\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void   __cdecl _wsplitpath(  const wchar_t * _FullPath,     wchar_t * _Drive,     wchar_t * _Dir,     wchar_t * _Filename,     wchar_t * _Ext);
__declspec(dllimport) errno_t __cdecl _wsplitpath_s(  const wchar_t * _FullPath,
                  wchar_t * _Drive,   size_t _DriveSize,
                  wchar_t * _Dir,   size_t _DirSize,
                  wchar_t * _Filename,   size_t _FilenameSize,
                  wchar_t * _Ext,   size_t _ExtSize);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(  const wchar_t *_Path,   wchar_t (&_Drive)[_DriveSize],   wchar_t (&_Dir)[_DirSize],   wchar_t (&_Name)[_NameSize],   wchar_t (&_Ext)[_ExtSize]) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }


#line 906 "d:\\programs overflow\\vc\\include\\stdlib.h"



__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "SetErrorMode" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _seterrormode(  int _Mode);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Beep" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _beep(  unsigned _Frequency,   unsigned _Duration);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Sleep" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _sleep(  unsigned long _Duration);
#line 913 "d:\\programs overflow\\vc\\include\\stdlib.h"

















#line 931 "d:\\programs overflow\\vc\\include\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 4141) 
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl ecvt(  double _Val,   int _NumOfDigits,   int * _PtDec,   int * _PtSign);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl fcvt(  double _Val,   int _NumOfDec,   int * _PtDec,   int * _PtSign);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))          __declspec(dllimport) char * __cdecl gcvt(  double _Val,   int _NumOfDigits,     char * _DstBuf);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))          __declspec(dllimport) char * __cdecl itoa(  int _Val,     char * _DstBuf,   int _Radix);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))          __declspec(dllimport) char * __cdecl ltoa(  long _Val,     char * _DstBuf,   int _Radix);


  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_putenv" ". See online help for details.")) __declspec(dllimport) int    __cdecl putenv(  const char * _EnvString);
#line 943 "d:\\programs overflow\\vc\\include\\stdlib.h"

__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_swab" ". See online help for details."))                                                                           __declspec(dllimport) void   __cdecl swab(  char * _Buf1,  char * _Buf2,   int _SizeInBytes);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))        __declspec(dllimport) char * __cdecl ultoa(  unsigned long _Val,     char * _Dstbuf,   int _Radix);
#pragma warning(pop)
_onexit_t __cdecl onexit(  _onexit_t _Func);


#line 951 "d:\\programs overflow\\vc\\include\\stdlib.h"


}

#line 956 "d:\\programs overflow\\vc\\include\\stdlib.h"

#pragma pack(pop)

#line 960 "d:\\programs overflow\\vc\\include\\stdlib.h"

#line 14 "d:\\programs overflow\\vc\\include\\cstdlib"
#line 15 "d:\\programs overflow\\vc\\include\\cstdlib"

 
namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;
using :: abort; using :: abs; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;

 
using :: getenv;
using :: system;
 #line 36 "d:\\programs overflow\\vc\\include\\cstdlib"

using :: atoll; using :: llabs; using :: lldiv;
using :: strtof; using :: strtold;
using :: strtoll; using :: strtoull;
}
 #line 42 "d:\\programs overflow\\vc\\include\\cstdlib"

#line 44 "d:\\programs overflow\\vc\\include\\cstdlib"





#line 5 "d:\\my documents\\programs\\jotunengine2\\stdafx.h"
#line 1 "d:\\programs overflow\\vc\\include\\fstream"

#pragma once



#line 1 "d:\\programs overflow\\vc\\include\\istream"

#pragma once



#line 1 "d:\\programs overflow\\vc\\include\\ostream"

#pragma once



#line 1 "d:\\programs overflow\\vc\\include\\ios"

#pragma once



#line 1 "d:\\programs overflow\\vc\\include\\xlocnum"

#pragma once



#line 1 "d:\\programs overflow\\vc\\include\\climits"

#pragma once





#line 9 "d:\\programs overflow\\vc\\include\\climits"





#line 7 "d:\\programs overflow\\vc\\include\\xlocnum"
#line 1 "d:\\programs overflow\\vc\\include\\cmath"

#pragma once













 #line 1 "d:\\programs overflow\\vc\\include\\math.h"

















#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 19 "d:\\programs overflow\\vc\\include\\math.h"





#pragma pack(push,8)


extern "C" {
#line 29 "d:\\programs overflow\\vc\\include\\math.h"








struct _exception {
        int type;       
        char *name;     
        double arg1;    
        double arg2;    
        double retval;  
        } ;


#line 47 "d:\\programs overflow\\vc\\include\\math.h"







struct _complex {
        double x,y; 
        } ;




#line 62 "d:\\programs overflow\\vc\\include\\math.h"


#line 65 "d:\\programs overflow\\vc\\include\\math.h"
#line 66 "d:\\programs overflow\\vc\\include\\math.h"

typedef float float_t;
typedef double double_t;





















__declspec(dllimport) extern double _HUGE;


#line 94 "d:\\programs overflow\\vc\\include\\math.h"
#line 95 "d:\\programs overflow\\vc\\include\\math.h"





#line 101 "d:\\programs overflow\\vc\\include\\math.h"



















































































void __cdecl _fperrraise(  int _Except);

short __declspec(dllimport) __cdecl _dclass(  double _X);
short __declspec(dllimport) __cdecl _ldclass(  long double _X);
short __declspec(dllimport) __cdecl _fdclass(  float _X);

int __declspec(dllimport) __cdecl _dsign(  double _X);
int __declspec(dllimport) __cdecl _ldsign(  long double _X);
int __declspec(dllimport) __cdecl _fdsign(  float _X);

int __declspec(dllimport) __cdecl _dpcomp(  double _X,   double _Y);
int __declspec(dllimport) __cdecl _ldpcomp(  long double _X,   long double _Y);
int __declspec(dllimport) __cdecl _fdpcomp(  float _X,   float _Y);

short __declspec(dllimport) __cdecl _dtest(  double *_Px);
short __declspec(dllimport) __cdecl _ldtest(  long double *_Px);
short __declspec(dllimport) __cdecl _fdtest(  float *_Px);

short __declspec(dllimport) __cdecl _d_int(  double *_Px,   short _Xexp);
short __declspec(dllimport) __cdecl _ld_int(  long double *_Px,   short _Xexp);
short __declspec(dllimport) __cdecl _fd_int(  float *_Px,   short _Xexp);

short __declspec(dllimport) __cdecl _dscale(  double *_Px,   long _Lexp);
short __declspec(dllimport) __cdecl _ldscale(  long double *_Px,   long _Lexp);
short __declspec(dllimport) __cdecl _fdscale(  float *_Px,   long _Lexp);

short __declspec(dllimport)  __cdecl _dunscale(  short *_Pex,   double *_Px);
short __declspec(dllimport) __cdecl _ldunscale(  short *_Pex,   long double *_Px);
short __declspec(dllimport) __cdecl _fdunscale(  short *_Pex,   float *_Px);

short __declspec(dllimport) __cdecl _dexp(  double *_Px,   double _Y,   long _Eoff);
short __declspec(dllimport) __cdecl _ldexp(  long double *_Px,   long double _Y,   long _Eoff);
short __declspec(dllimport) __cdecl _fdexp(  float *_Px,   float _Y,   long _Eoff);

short __declspec(dllimport) __cdecl _dnorm(  unsigned short *_Ps);
short __declspec(dllimport) __cdecl _fdnorm(  unsigned short *_Ps);

double __cdecl _dpoly(  double _X,   const double *_Tab,   int _N);
long double __cdecl _ldpoly(  long double _X,   const long double *_Tab,   int _N);
float __cdecl _fdpoly(  float _X,   const float *_Tab,   int _N);

double __declspec(dllimport) __cdecl _dlog(  double _X,   int _Baseflag);
long double __declspec(dllimport) __cdecl _ldlog(  long double _X,   int _Baseflag);
float __declspec(dllimport) __cdecl _fdlog(  float _X,   int _Baseflag);

double __declspec(dllimport) __cdecl _dsin(  double _X,   unsigned int _Qoff);
long double __declspec(dllimport) __cdecl _ldsin(  long double _X,   unsigned int _Qoff);
float __declspec(dllimport) __cdecl _fdsin(  float _X,   unsigned int _Qoff);


typedef union
{	
    unsigned short _Sh[8];
    double _Val;
} _double_val;


typedef union
{	
    unsigned short _Sh[8];
    float _Val;
} _float_val;


typedef union
{	
    unsigned short _Sh[8];
    long double _Val;
} _ldouble_val;

typedef union
{	
    unsigned short _Word[8];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double _Zero_C, _Xbig_C;
extern const float _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;





























extern "C++" {

inline __declspec(nothrow) int fpclassify(float _X)
{
    return (_fdtest(&_X));
}

inline __declspec(nothrow) int fpclassify(double _X)
{
    return (_dtest(&_X));
}

inline __declspec(nothrow) int fpclassify(long double _X)
{
    return (_ldtest(&_X));
}

inline __declspec(nothrow) bool signbit(float _X)
{
    return (_fdsign(_X) != 0);
}

inline __declspec(nothrow) bool signbit(double _X)
{
    return (_dsign(_X) != 0);
}

inline __declspec(nothrow) bool signbit(long double _X)
{
    return (_ldsign(_X) != 0);
}

inline __declspec(nothrow) int _fpcomp(float _X, float _Y)
{
    return (_fdpcomp(_X, _Y));
}

inline __declspec(nothrow) int _fpcomp(double _X, double _Y)
{
    return (_dpcomp(_X, _Y));
}

inline __declspec(nothrow) int _fpcomp(long double _X, long double _Y)
{
    return (_ldpcomp(_X, _Y));
}

template<class _Trc, class _Tre> struct _Combined_type
{	
    typedef float _Type;	
};

template<> struct _Combined_type<float, double>
{	
    typedef double _Type;
};

template<> struct _Combined_type<float, long double>
{	
    typedef long double _Type;
};

template<class _Ty, class _T2> struct _Real_widened
{	
    typedef long double _Type;	
};

template<> struct _Real_widened<float, float>
{	
    typedef float _Type;
};

template<> struct _Real_widened<float, double>
{	
    typedef double _Type;
};

template<> struct _Real_widened<double, float>
{	
    typedef double _Type;
};

template<> struct _Real_widened<double, double>
{	
    typedef double _Type;
};

template<class _Ty> struct _Real_type
{	
    typedef double _Type;	
};

template<> struct _Real_type<float>
{	
    typedef float _Type;
};

template<> struct _Real_type<long double>
{	
    typedef long double _Type;
};

template<class _T1, class _T2> inline __declspec(nothrow) int _fpcomp(_T1 _X, _T2 _Y)
{	
    typedef typename _Combined_type<float,
        typename _Real_widened<
        typename _Real_type<_T1>::_Type,
        typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
    return (_fpcomp((_Tw)_X, (_Tw)_Y));
}

template<class _Ty> inline __declspec(nothrow) bool isfinite(_Ty _X)
{
    return (fpclassify(_X) <= 0);
}

template<class _Ty> inline __declspec(nothrow) bool isinf(_Ty _X)
{
    return (fpclassify(_X) == 1);
}

template<class _Ty> inline __declspec(nothrow) bool isnan(_Ty _X)
{
    return (fpclassify(_X) == 2);
}

template<class _Ty> inline __declspec(nothrow) bool isnormal(_Ty _X)
{
    return (fpclassify(_X) == (-1));
}

template<class _Ty1, class _Ty2> inline __declspec(nothrow) bool isgreater(_Ty1 _X, _Ty2 _Y)
{
    return ((_fpcomp(_X, _Y) & 4) != 0);
}

template<class _Ty1, class _Ty2> inline __declspec(nothrow) bool isgreaterequal(_Ty1 _X, _Ty2 _Y)
{
    return ((_fpcomp(_X, _Y) & (2 | 4)) != 0);
}

template<class _Ty1, class _Ty2> inline __declspec(nothrow) bool isless(_Ty1 _X, _Ty2 _Y)
{
    return ((_fpcomp(_X, _Y) & 1) != 0);
}

template<class _Ty1, class _Ty2> inline __declspec(nothrow) bool islessequal(_Ty1 _X, _Ty2 _Y)
{
    return ((_fpcomp(_X, _Y) & (1 | 2)) != 0);
}

template<class _Ty1, class _Ty2> inline __declspec(nothrow) bool islessgreater(_Ty1 _X, _Ty2 _Y)
{
    return ((_fpcomp(_X, _Y) & (1 | 4)) != 0);
}

template<class _Ty1, class _Ty2> inline __declspec(nothrow) bool isunordered(_Ty1 _X, _Ty2 _Y)
{
    return (_fpcomp(_X, _Y) == 0);
}

}  

#line 466 "d:\\programs overflow\\vc\\include\\math.h"




int       __cdecl abs(  int _X);
long      __cdecl labs(  long _X);
long long __cdecl llabs(  long long _X);

double  __cdecl acos(  double _X);
__declspec(dllimport) double __cdecl acosh(  double _X);
double  __cdecl asin(  double _X);
__declspec(dllimport) double __cdecl asinh(  double _X);
double  __cdecl atan(  double _X);
__declspec(dllimport) double __cdecl atanh(  double _X);
double  __cdecl atan2(  double _Y,   double _X);

__declspec(dllimport) double __cdecl cbrt(  double _X);
__declspec(dllimport) double __cdecl copysign(  double _X,   double _Y);
double  __cdecl cos(  double _X);
double  __cdecl cosh(  double _X);
__declspec(dllimport) double __cdecl erf(  double _X);
__declspec(dllimport) double __cdecl erfc(  double _X);
double  __cdecl exp(  double _X);
__declspec(dllimport) double __cdecl exp2(  double _X);
__declspec(dllimport) double __cdecl expm1(  double _X);
 double  __cdecl fabs(  double _X);
__declspec(dllimport) double __cdecl fdim(  double _X,   double _Y);
__declspec(dllimport) double __cdecl fma(  double _X,   double _Y,   double _Z);
__declspec(dllimport) double __cdecl fmax(  double _X,   double _Y);
__declspec(dllimport) double __cdecl fmin(  double _X,   double _Y);
double  __cdecl fmod(  double _X,   double _Y);
__declspec(dllimport) int __cdecl ilogb(  double _X);
__declspec(dllimport) double __cdecl lgamma(  double _X);
__declspec(dllimport) long long __cdecl llrint(  double _X);
__declspec(dllimport) long long __cdecl llround(  double _X);
double  __cdecl log(  double _X);
double  __cdecl log10(  double _X);
__declspec(dllimport) double __cdecl log1p(  double _X);
__declspec(dllimport) double __cdecl log2(  double _X);
__declspec(dllimport) double __cdecl logb(  double _X);
__declspec(dllimport) long __cdecl lrint(  double _X);
__declspec(dllimport) long __cdecl lround(  double _X);
__declspec(dllimport) double __cdecl nan(  const char *);
__declspec(dllimport) double __cdecl nearbyint(  double _X);
__declspec(dllimport) double __cdecl nextafter(  double _X,   double _Y);
__declspec(dllimport) double __cdecl nexttoward(  double _X,   long double _Y);
double  __cdecl pow(  double _X,   double _Y);
__declspec(dllimport) double __cdecl remainder(  double _X,   double _Y);
__declspec(dllimport) double __cdecl remquo(  double _X,   double _Y,   int *_Z);
__declspec(dllimport) double __cdecl rint(  double _X);
__declspec(dllimport) double __cdecl round(  double _X);
__declspec(dllimport) double __cdecl scalbln(  double _X,   long _Y);
__declspec(dllimport) double __cdecl scalbn(  double _X,   int _Y);
double  __cdecl sin(  double _X);
double  __cdecl sinh(  double _X);
  double  __cdecl sqrt(  double _X);
double  __cdecl tan(  double _X);
double  __cdecl tanh(  double _X);
__declspec(dllimport) double __cdecl tgamma(  double _X);
__declspec(dllimport) double __cdecl trunc(  double _X);

  __declspec(dllimport) double  __cdecl atof(  const char *_String);
  __declspec(dllimport) double  __cdecl _atof_l(  const char *_String,   _locale_t _Locale);

__declspec(dllimport) double  __cdecl _cabs(  struct _complex _Complex_value);
__declspec(dllimport) double  __cdecl ceil(  double _X);

  __declspec(dllimport) double __cdecl _chgsign (  double _X);
  __declspec(dllimport) double __cdecl _copysign (  double _Number,   double _Sign);

__declspec(dllimport) double  __cdecl floor(  double _X);
__declspec(dllimport) double  __cdecl frexp(  double _X,   int * _Y);
__declspec(dllimport) double  __cdecl _hypot(  double _X,   double _Y);
__declspec(dllimport) double  __cdecl _j0(  double _X );
__declspec(dllimport) double  __cdecl _j1(  double _X );
__declspec(dllimport) double  __cdecl _jn(int _X,   double _Y);
__declspec(dllimport) double  __cdecl ldexp(  double _X,   int _Y);



#line 547 "d:\\programs overflow\\vc\\include\\math.h"
int     __cdecl _matherr(  struct _exception * _Except);
#line 549 "d:\\programs overflow\\vc\\include\\math.h"

__declspec(dllimport) double  __cdecl modf(  double _X,   double * _Y);
__declspec(dllimport) double  __cdecl _y0(  double _X);
__declspec(dllimport) double  __cdecl _y1(  double _X);
__declspec(dllimport) double  __cdecl _yn(  int _X,   double _Y);

__inline double __cdecl hypot(  double _X,   double _Y)
{
    return _hypot(_X, _Y);
}


__declspec(dllimport) float __cdecl acoshf(  float _X);
__declspec(dllimport) float __cdecl asinhf(  float _X);
__declspec(dllimport) float __cdecl atanhf(  float _X);
__declspec(dllimport) float __cdecl cbrtf(  float _X);
__declspec(dllimport) float  __cdecl _chgsignf(  float _X);
__declspec(dllimport) float __cdecl copysignf(  float _X,   float _Y);
__declspec(dllimport) float  __cdecl _copysignf(  float _Number,   float _Sign);
__declspec(dllimport) float __cdecl erff(  float _X);
__declspec(dllimport) float __cdecl erfcf(  float _X);
__declspec(dllimport) float __cdecl expm1f(  float _X);
__declspec(dllimport) float __cdecl exp2f(  float _X);
__declspec(dllimport) float __cdecl fdimf(  float _X,   float _Y);
__declspec(dllimport) float __cdecl fmaf(  float _X,   float _Y,   float _Z);
__declspec(dllimport) float __cdecl fmaxf(  float _X,   float _Y);
__declspec(dllimport) float __cdecl fminf(  float _X,   float _Y);
__declspec(dllimport) float  __cdecl _hypotf(  float _X,   float _Y);
__declspec(dllimport) int __cdecl ilogbf(  float _X);
__declspec(dllimport) float __cdecl lgammaf(  float _X);
__declspec(dllimport) long long __cdecl llrintf(  float _X);
__declspec(dllimport) long long __cdecl llroundf(  float _X);
__declspec(dllimport) float __cdecl log1pf(  float _X);
__declspec(dllimport) float __cdecl log2f(  float _X);
__declspec(dllimport) float __cdecl logbf(  float _X);
__declspec(dllimport) long __cdecl lrintf(  float _X);
__declspec(dllimport) long __cdecl lroundf(  float _X);
__declspec(dllimport) float __cdecl nanf(  const char *);
__declspec(dllimport) float __cdecl nearbyintf(  float _X);
__declspec(dllimport) float __cdecl nextafterf(  float _X,   float _Y);
__declspec(dllimport) float __cdecl nexttowardf(  float _X,   long double _Y);
__declspec(dllimport) float __cdecl remainderf(  float _X,   float _Y);
__declspec(dllimport) float __cdecl remquof(  float _X,   float _Y,   int *_Z);
__declspec(dllimport) float __cdecl rintf(  float _X);
__declspec(dllimport) float __cdecl roundf(  float _X);
__declspec(dllimport) float __cdecl scalblnf(  float _X,   long _Y);
__declspec(dllimport) float __cdecl scalbnf(  float _X,   int _Y);
__declspec(dllimport) float __cdecl tgammaf(  float _X);
__declspec(dllimport) float __cdecl truncf(  float _X);



__declspec(dllimport) int  __cdecl _set_SSE2_enable(  int _Flag);

#line 604 "d:\\programs overflow\\vc\\include\\math.h"











#line 616 "d:\\programs overflow\\vc\\include\\math.h"






#line 623 "d:\\programs overflow\\vc\\include\\math.h"












#line 636 "d:\\programs overflow\\vc\\include\\math.h"

__inline float  __cdecl acosf(  float _X)
{
    return (float)acos(_X);
}

__inline float  __cdecl asinf(  float _X)
{
    return (float)asin(_X);
}

__inline float  __cdecl atan2f(  float _Y,   float _X)
{
    return (float)atan2(_Y, _X);
}

__inline float  __cdecl atanf(  float _X)
{
    return (float)atan(_X);
}

__inline float  __cdecl ceilf(  float _X)
{
    return (float)ceil(_X);
}

__inline float  __cdecl cosf(  float _X)
{
    return (float)cos(_X);
}

__inline float  __cdecl coshf(  float _X)
{
    return (float)cosh(_X);
}

__inline float  __cdecl expf(  float _X)
{
    return (float)exp(_X);
}

#line 678 "d:\\programs overflow\\vc\\include\\math.h"





#line 684 "d:\\programs overflow\\vc\\include\\math.h"

__inline float __cdecl fabsf(  float _X)
{
    return (float)fabs(_X);
}

#line 691 "d:\\programs overflow\\vc\\include\\math.h"






#line 698 "d:\\programs overflow\\vc\\include\\math.h"

__inline float __cdecl floorf(  float _X)
{
    return (float)floor(_X);
}

__inline float __cdecl fmodf(  float _X,   float _Y)
{
    return (float)fmod(_X, _Y);
}

#line 710 "d:\\programs overflow\\vc\\include\\math.h"

__inline float __cdecl frexpf(  float _X,   int *_Y)
{
    return (float)frexp(_X, _Y);
}

__inline float __cdecl hypotf(  float _X,   float _Y)
{
    return _hypotf(_X, _Y);
}

__inline float __cdecl ldexpf(  float _X,   int _Y)
{
    return (float)ldexp(_X, _Y);
}













#line 739 "d:\\programs overflow\\vc\\include\\math.h"

__inline float __cdecl log10f(  float _X)
{
    return (float)log10(_X);
}

__inline float __cdecl logf(  float _X)
{
    return (float)log(_X);
}

__inline float __cdecl modff(  float _X,   float *_Y)
{
    double _F, _I;
    _F = modf(_X, &_I);
    *_Y = (float)_I;
    return (float)_F;
}

__inline float __cdecl powf(  float _X,   float _Y)
{
    return (float)pow(_X, _Y);
}

__inline float __cdecl sinf(  float _X)
{
    return (float)sin(_X);
}

__inline float __cdecl sinhf(  float _X)
{
    return (float)sinh(_X);
}

__inline float __cdecl sqrtf(  float _X)
{
    return (float)sqrt(_X);
}

__inline float __cdecl tanf(  float _X)
{
    return (float)tan(_X);
}

__inline float __cdecl tanhf(  float _X)
{
    return (float)tanh(_X);
}

#line 789 "d:\\programs overflow\\vc\\include\\math.h"

__declspec(dllimport) long double __cdecl acoshl(  long double _X);

__inline long double __cdecl acosl(  long double _X)
{
    return acos((double)_X);
}

__declspec(dllimport) long double __cdecl asinhl(  long double _X);

__inline long double __cdecl asinl(  long double _X)
{
    return asin((double)_X);
}

__inline long double __cdecl atan2l(  long double _Y,   long double _X)
{
    return atan2((double)_Y, (double)_X);
}

__declspec(dllimport) long double __cdecl atanhl(  long double _X);

__inline long double __cdecl atanl(  long double _X)
{
    return atan((double)_X);
}

__declspec(dllimport) long double __cdecl cbrtl(  long double _X);

__inline long double __cdecl ceill(  long double _X)
{
    return ceil((double)_X);
}

__inline long double __cdecl _chgsignl(  long double _X)
{
    return _chgsign((double)_X);
}

__declspec(dllimport) long double __cdecl copysignl(  long double _X,   long double _Y);

__inline long double __cdecl _copysignl(  long double _X,   long double _Y)
{
    return _copysign((double)_X, (double)_Y);
}

__inline long double __cdecl coshl(  long double _X)
{
    return cosh((double)_X);
}

__inline long double __cdecl cosl(  long double _X)
{
    return cos((double)_X);
}

__declspec(dllimport) long double __cdecl erfl(  long double _X);
__declspec(dllimport) long double __cdecl erfcl(  long double _X);

__inline long double __cdecl expl(  long double _X)
{
    return exp((double)_X);
}

__declspec(dllimport) long double __cdecl exp2l(  long double _X);
__declspec(dllimport) long double __cdecl expm1l(  long double _X);

__inline long double __cdecl fabsl(  long double _X)
{
    return fabs((double)_X);
}

__declspec(dllimport) long double __cdecl fdiml(  long double _X,   long double _Y);

__inline long double __cdecl floorl(  long double _X)
{
    return floor((double)_X);
}

__declspec(dllimport) long double __cdecl fmal(  long double _X,   long double _Y,   long double _Z);
__declspec(dllimport) long double __cdecl fmaxl(  long double _X,   long double _Y);
__declspec(dllimport) long double __cdecl fminl(  long double _X,   long double _Y);

__inline long double __cdecl fmodl(  long double _X,   long double _Y)
{
    return fmod((double)_X, (double)_Y);
}

__inline long double __cdecl frexpl(  long double _X,   int *_Y)
{
    return frexp((double)_X, _Y);
}

__declspec(dllimport) int __cdecl ilogbl(  long double _X);

__inline long double __cdecl _hypotl(  long double _X,   long double _Y)
{
    return _hypot((double)_X, (double)_Y);
}

__inline long double __cdecl hypotl(  long double _X,   long double _Y)
{
    return _hypot((double)_X, (double)_Y);
}

__inline long double __cdecl ldexpl(  long double _X,   int _Y)
{
    return ldexp((double)_X, _Y);
}

__declspec(dllimport) long double __cdecl lgammal(  long double _X);
__declspec(dllimport) long long __cdecl llrintl(  long double _X);
__declspec(dllimport) long long __cdecl llroundl(  long double _X);

__inline long double __cdecl logl(  long double _X)
{
    return log((double)_X);
}

__inline long double __cdecl log10l(  long double _X)
{
    return log10((double)_X);
}

__declspec(dllimport) long double __cdecl log1pl(  long double _X);
__declspec(dllimport) long double __cdecl log2l(  long double _X);
__declspec(dllimport) long double __cdecl logbl(  long double _X);
__declspec(dllimport) long __cdecl lrintl(  long double _X);
__declspec(dllimport) long __cdecl lroundl(  long double _X);

__inline long double __cdecl modfl(  long double _X,   long double *_Y)
{
    double _F, _I;
    _F = modf((double)_X, &_I);
    *_Y = _I;
    return _F;
}
__declspec(dllimport) long double __cdecl nanl(  const char *);
__declspec(dllimport) long double __cdecl nearbyintl(  long double _X);
__declspec(dllimport) long double __cdecl nextafterl(  long double _X,   long double _Y);
__declspec(dllimport) long double __cdecl nexttowardl(  long double _X,   long double _Y);

__inline long double __cdecl powl(  long double _X,   long double _Y)
{
    return pow((double)_X, (double)_Y);
}

__declspec(dllimport) long double __cdecl remainderl(  long double _X,   long double _Y);
__declspec(dllimport) long double __cdecl remquol(  long double _X,   long double _Y,   int *_Z);
__declspec(dllimport) long double __cdecl rintl(  long double _X);
__declspec(dllimport) long double __cdecl roundl(  long double _X);
__declspec(dllimport) long double __cdecl scalblnl(  long double _X,   long _Y);
__declspec(dllimport) long double __cdecl scalbnl(  long double _X,   int _Y);

__inline long double __cdecl sinhl(  long double _X)
{
    return sinh((double)_X);
}

__inline long double __cdecl sinl(  long double _X)
{
    return sin((double)_X);
}

__inline long double __cdecl sqrtl(  long double _X)
{
    return sqrt((double)_X);
}

__inline long double __cdecl tanhl(  long double _X)
{
    return tanh((double)_X);
}

__inline long double __cdecl tanl(  long double _X)
{
    return tan((double)_X);
}

__declspec(dllimport) long double __cdecl tgammal(  long double _X);
__declspec(dllimport) long double __cdecl truncl(  long double _X);




#line 975 "d:\\programs overflow\\vc\\include\\math.h"

















__declspec(dllimport) extern double HUGE;


#line 996 "d:\\programs overflow\\vc\\include\\math.h"

__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_j0" ". See online help for details.")) __declspec(dllimport) double  __cdecl j0(  double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_j1" ". See online help for details.")) __declspec(dllimport) double  __cdecl j1(  double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_jn" ". See online help for details.")) __declspec(dllimport) double  __cdecl jn(  int _X,   double _Y);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_y0" ". See online help for details.")) __declspec(dllimport) double  __cdecl y0(  double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_y1" ". See online help for details.")) __declspec(dllimport) double  __cdecl y1(  double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_yn" ". See online help for details.")) __declspec(dllimport) double  __cdecl yn(  int _X,   double _Y);

#line 1005 "d:\\programs overflow\\vc\\include\\math.h"
#line 1006 "d:\\programs overflow\\vc\\include\\math.h"


}

extern "C++" {

template<class _Ty> inline
        _Ty _Pow_int(_Ty _X, int _Y) throw()
        {unsigned int _N;
        if (_Y >= 0)
                _N = (unsigned int)_Y;
        else
                _N = (unsigned int)(-_Y);
        for (_Ty _Z = _Ty(1); ; _X *= _X)
                {if ((_N & 1) != 0)
                        _Z *= _X;
                if ((_N >>= 1) == 0)
                        return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

inline double __cdecl abs(  double _X) throw()
        {return (fabs(_X)); }
inline double __cdecl pow(  double _X,   int _Y) throw()
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl abs(  float _X) throw()
        {return (fabsf(_X)); }
inline float __cdecl acos(  float _X) throw()
        {return (acosf(_X)); }
inline float __cdecl acosh(  float _X) throw()
        {return (acoshf(_X)); }
inline float __cdecl asin(  float _X) throw()
        {return (asinf(_X)); }
inline float __cdecl asinh(  float _X) throw()
        {return (asinhf(_X)); }
inline float __cdecl atan(  float _X) throw()
        {return (atanf(_X)); }
inline float __cdecl atanh(  float _X) throw()
        {return (atanhf(_X)); }
inline float __cdecl atan2(  float _Y,   float _X) throw()
        {return (atan2f(_Y, _X)); }
inline float __cdecl cbrt(  float _X) throw()
        {return (cbrtf(_X)); }
inline float __cdecl ceil(  float _X) throw()
        {return (ceilf(_X)); }
inline float __cdecl copysign(  float _X,   float _Y) throw()
        {return (copysignf(_X, _Y)); }
inline float __cdecl cos(  float _X) throw()
        {return (cosf(_X)); }
inline float __cdecl cosh(  float _X) throw()
        {return (coshf(_X)); }
inline float __cdecl erf(  float _X) throw()
        {return (erff(_X)); }
inline float __cdecl erfc(  float _X) throw()
        {return (erfcf(_X)); }
inline float __cdecl exp(  float _X) throw()
        {return (expf(_X)); }
inline float __cdecl exp2(  float _X) throw()
        {return (exp2f(_X)); }
inline float __cdecl expm1(  float _X) throw()
        {return (expm1f(_X)); }
inline float __cdecl fabs(  float _X) throw()
        {return (fabsf(_X)); }
inline float __cdecl fdim(  float _X,   float _Y) throw()
        {return (fdimf(_X, _Y)); }
inline float __cdecl floor(  float _X) throw()
        {return (floorf(_X)); }
inline float __cdecl fma(  float _X,   float _Y,   float _Z) throw()
        {return (fmaf(_X, _Y, _Z)); }
inline float __cdecl fmax(  float _X,   float _Y) throw()
        {return (fmaxf(_X, _Y)); }
inline float __cdecl fmin(  float _X,   float _Y) throw()
        {return (fminf(_X, _Y)); }
inline float __cdecl fmod(  float _X,   float _Y) throw()
        {return (fmodf(_X, _Y)); }
inline float __cdecl frexp(  float _X,   int * _Y) throw()
        {return (frexpf(_X, _Y)); }
inline float __cdecl hypot(  float _X,   float _Y) throw()
        {return (hypotf(_X, _Y)); }
inline int __cdecl ilogb(  float _X) throw()
        {return (ilogbf(_X)); }
inline float __cdecl ldexp(  float _X,   int _Y) throw()
        {return (ldexpf(_X, _Y)); }
inline float __cdecl lgamma(  float _X) throw()
        {return (lgammaf(_X)); }
inline long long __cdecl llrint(  float _X) throw()
        {return (llrintf(_X)); }
inline long long __cdecl llround(  float _X) throw()
        {return (llroundf(_X)); }
inline float __cdecl log(  float _X) throw()
        {return (logf(_X)); }
inline float __cdecl log10(  float _X) throw()
        {return (log10f(_X)); }
inline float __cdecl log1p(  float _X) throw()
        {return (log1pf(_X)); }
inline float __cdecl log2(  float _X) throw()
        {return (log2f(_X)); }
inline float __cdecl logb(  float _X) throw()
        {return (logbf(_X)); }
inline long __cdecl lrint(  float _X) throw()
        {return (lrintf(_X)); }
inline long __cdecl lround(  float _X) throw()
        {return (lroundf(_X)); }
inline float __cdecl modf(  float _X,   float * _Y) throw()
        {return (modff(_X, _Y)); }
inline float __cdecl nearbyint(  float _X) throw()
        {return (nearbyintf(_X)); }
inline float __cdecl nextafter(  float _X,   float _Y) throw()
        {return (nextafterf(_X, _Y)); }
inline float __cdecl nexttoward(  float _X,   long double _Y) throw()
        {return (nexttowardf(_X, _Y)); }
inline float __cdecl pow(  float _X,   float _Y) throw()
        {return (powf(_X, _Y)); }
inline float __cdecl pow(  float _X,   int _Y) throw()
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl remainder(  float _X,   float _Y) throw()
        {return (remainderf(_X, _Y)); }
inline float __cdecl remquo(  float _X,   float _Y,   int *_Z) throw()
        {return (remquof(_X, _Y, _Z)); }
inline float __cdecl rint(  float _X) throw()
        {return (rintf(_X)); }
inline float __cdecl round(  float _X) throw()
        {return (roundf(_X)); }
inline float __cdecl scalbln(  float _X,   long _Y) throw()
        {return (scalblnf(_X, _Y)); }
inline float __cdecl scalbn(  float _X,   int _Y) throw()
        {return (scalbnf(_X, _Y)); }
inline float __cdecl sin(  float _X) throw()
        {return (sinf(_X)); }
inline float __cdecl sinh(  float _X) throw()
        {return (sinhf(_X)); }
inline float __cdecl sqrt(  float _X) throw()
        {return (sqrtf(_X)); }
inline float __cdecl tan(  float _X) throw()
        {return (tanf(_X)); }
inline float __cdecl tanh(  float _X) throw()
        {return (tanhf(_X)); }
inline float __cdecl tgamma(  float _X) throw()
        {return (tgammaf(_X)); }
inline float __cdecl trunc(  float _X) throw()
        {return (truncf(_X)); }
inline long double __cdecl abs(  long double _X) throw()
        {return (fabsl(_X)); }
inline long double __cdecl acos(  long double _X) throw()
        {return (acosl(_X)); }
inline long double __cdecl acosh(  long double _X) throw()
        {return (acoshl(_X)); }
inline long double __cdecl asin(  long double _X) throw()
        {return (asinl(_X)); }
inline long double __cdecl asinh(  long double _X) throw()
        {return (asinhl(_X)); }
inline long double __cdecl atan(  long double _X) throw()
        {return (atanl(_X)); }
inline long double __cdecl atanh(  long double _X) throw()
        {return (atanhl(_X)); }
inline long double __cdecl atan2(  long double _Y,   long double _X) throw()
        {return (atan2l(_Y, _X)); }
inline long double __cdecl cbrt(  long double _X) throw()
        {return (cbrtl(_X)); }
inline long double __cdecl ceil(  long double _X) throw()
        {return (ceill(_X)); }
inline long double __cdecl copysign(  long double _X,   long double _Y) throw()
        {return (copysignl(_X, _Y)); }
inline long double __cdecl cos(  long double _X) throw()
        {return (cosl(_X)); }
inline long double __cdecl cosh(  long double _X) throw()
        {return (coshl(_X)); }
inline long double __cdecl erf(  long double _X) throw()
        {return (erfl(_X)); }
inline long double __cdecl erfc(  long double _X) throw()
        {return (erfcl(_X)); }
inline long double __cdecl exp(  long double _X) throw()
        {return (expl(_X)); }
inline long double __cdecl exp2(  long double _X) throw()
        {return (exp2l(_X)); }
inline long double __cdecl expm1(  long double _X) throw()
        {return (expm1l(_X)); }
inline long double __cdecl fabs(  long double _X) throw()
        {return (fabsl(_X)); }
inline long double __cdecl fdim(  long double _X,   long double _Y) throw()
        {return (fdiml(_X, _Y)); }
inline long double __cdecl floor(  long double _X) throw()
        {return (floorl(_X)); }
inline long double __cdecl fma(  long double _X,   long double _Y,   long double _Z) throw()
        {return (fmal(_X, _Y, _Z)); }
inline long double __cdecl fmax(  long double _X,   long double _Y) throw()
        {return (fmaxl(_X, _Y)); }
inline long double __cdecl fmin(  long double _X,   long double _Y) throw()
        {return (fminl(_X, _Y)); }
inline long double __cdecl fmod(  long double _X,   long double _Y) throw()
        {return (fmodl(_X, _Y)); }
inline long double __cdecl frexp(  long double _X,   int * _Y) throw()
        {return (frexpl(_X, _Y)); }
inline long double __cdecl hypot(  long double _X,   long double _Y) throw()
        {return (hypotl(_X, _Y)); }
inline int __cdecl ilogb(  long double _X) throw()
        {return (ilogbl(_X)); }
inline long double __cdecl ldexp(  long double _X,   int _Y) throw()
        {return (ldexpl(_X, _Y)); }
inline long double __cdecl lgamma(  long double _X) throw()
        {return (lgammal(_X)); }
inline long long __cdecl llrint(  long double _X) throw()
        {return (llrintl(_X)); }
inline long long __cdecl llround(  long double _X) throw()
        {return (llroundl(_X)); }
inline long double __cdecl log(  long double _X) throw()
        {return (logl(_X)); }
inline long double __cdecl log10(  long double _X) throw()
        {return (log10l(_X)); }
inline long double __cdecl log1p(  long double _X) throw()
        {return (log1pl(_X)); }
inline long double __cdecl log2(  long double _X) throw()
        {return (log2l(_X)); }
inline long double __cdecl logb(  long double _X) throw()
        {return (logbl(_X)); }
inline long  __cdecl lrint(  long double _X) throw()
        {return (lrintl(_X)); }
inline long  __cdecl lround(  long double _X) throw()
        {return (lroundl(_X)); }
inline long double __cdecl modf(  long double _X,   long double * _Y) throw()
        {return (modfl(_X, _Y)); }
inline long double __cdecl nearbyint(  long double _X) throw()
        {return (nearbyintl(_X)); }
inline long double __cdecl nextafter(  long double _X,   long double _Y) throw()
        {return (nextafterl(_X, _Y)); }
inline long double __cdecl nexttoward(  long double _X,   long double _Y) throw()
        {return (nexttowardl(_X, _Y)); }
inline long double __cdecl pow(  long double _X,   long double _Y) throw()
        {return (powl(_X, _Y)); }
inline long double __cdecl pow(  long double _X,   int _Y) throw()
        {return (_Pow_int(_X, _Y)); }
inline long double __cdecl remainder(  long double _X,   long double _Y) throw()
        {return (remainderl(_X, _Y)); }
inline long double __cdecl remquo(  long double _X,   long double _Y,   int *_Z) throw()
        {return (remquol(_X, _Y, _Z)); }
inline long double __cdecl rint(  long double _X) throw()
        {return (rintl(_X)); }
inline long double __cdecl round(  long double _X) throw()
        {return (roundl(_X)); }
inline long double __cdecl scalbln(  long double _X,   long _Y) throw()
        {return (scalblnl(_X, _Y)); }
inline long double __cdecl scalbn(  long double _X,   int _Y) throw()
        {return (scalbnl(_X, _Y)); }
inline long double __cdecl sin(  long double _X) throw()
        {return (sinl(_X)); }
inline long double __cdecl sinh(  long double _X) throw()
        {return (sinhl(_X)); }
inline long double __cdecl sqrt(  long double _X) throw()
        {return (sqrtl(_X)); }
inline long double __cdecl tan(  long double _X) throw()
        {return (tanl(_X)); }
inline long double __cdecl tanh(  long double _X) throw()
        {return (tanhl(_X)); }
inline long double __cdecl tgamma(  long double _X) throw()
        {return (tgammal(_X)); }
inline long double __cdecl trunc(  long double _X) throw()
        {return (truncl(_X)); }

}
#line 1264 "d:\\programs overflow\\vc\\include\\math.h"

#pragma pack(pop)

#line 1268 "d:\\programs overflow\\vc\\include\\math.h"







































#line 1308 "d:\\programs overflow\\vc\\include\\math.h"

#line 17 "d:\\programs overflow\\vc\\include\\cmath"

 #line 1 "d:\\programs overflow\\vc\\include\\xtgmath.h"

#pragma once




 
#line 1 "d:\\programs overflow\\vc\\include\\xtr1common"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
	
template<class _T1,
	class _Ret>
	struct unary_function;

	
template<class _T1,
	class _T2,
	class _Ret>
	struct binary_function;

	
struct _Nil
	{	
	};
static _Nil _Nil_obj;

	
template<class _Ty,
	_Ty _Val>
	struct integral_constant
	{	
	static const _Ty value = _Val;

	typedef _Ty value_type;
	typedef integral_constant<_Ty, _Val> type;

	operator value_type() const
		{	
		return (value);
		}
	};

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

	
template<bool>
	struct _Cat_base
		: false_type
	{	
	};

template<>
	struct _Cat_base<true>
		: true_type
	{	
	};

	
template<bool _Test,
	class _Ty = void>
	struct enable_if
	{	
	};

template<class _Ty>
	struct enable_if<true, _Ty>
	{	
	typedef _Ty type;
	};

	
template<bool _Test,
	class _Ty1,
	class _Ty2>
	struct conditional
	{	
	typedef _Ty2 type;
	};

template<class _Ty1,
	class _Ty2>
	struct conditional<true, _Ty1, _Ty2>
	{	
	typedef _Ty1 type;
	};

	
template<class _Ty1, class _Ty2>
	struct is_same
		: false_type
	{	
	};

template<class _Ty1>
	struct is_same<_Ty1, _Ty1>
		: true_type
	{	
	};

	
template<class _Ty>
	struct remove_const
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_const<const _Ty>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_const<const _Ty[]>
	{	
	typedef _Ty type[];
	};

template<class _Ty, unsigned int _Nx>
	struct remove_const<const _Ty[_Nx]>
	{	
	typedef _Ty type[_Nx];
	};

	
template<class _Ty>
	struct remove_volatile
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_volatile<volatile _Ty>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_volatile<volatile _Ty[]>
	{	
	typedef _Ty type[];
	};

template<class _Ty, unsigned int _Nx>
	struct remove_volatile<volatile _Ty[_Nx]>
	{	
	typedef _Ty type[_Nx];
	};

	
template<class _Ty>
	struct remove_cv
	{	
	typedef typename remove_const<typename remove_volatile<_Ty>::type>::type
		type;
	};

	
template<class _Ty>
	struct _Is_integral
		: false_type
	{	
	};

template<>
	struct _Is_integral<bool>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed char>
		: true_type
	{	
	};

 
template<>
	struct _Is_integral<wchar_t>
		: true_type
	{	
	};
 #line 201 "d:\\programs overflow\\vc\\include\\xtr1common"

template<>
	struct _Is_integral<unsigned short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed long>
		: true_type
	{	
	};

 











#line 251 "d:\\programs overflow\\vc\\include\\xtr1common"

 
template<>
	struct _Is_integral<__int64>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned __int64>
		: true_type
	{	
	};
 #line 265 "d:\\programs overflow\\vc\\include\\xtr1common"

	
template<class _Ty>
	struct is_integral
		: _Is_integral<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct _Is_floating_point
		: false_type
	{	
	};

template<>
	struct _Is_floating_point<float>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<double>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<long double>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_floating_point
		: _Is_floating_point<typename remove_cv<_Ty>::type>
	{	
	};

template<class _Ty>
	struct _Is_numeric
		: _Cat_base<is_integral<_Ty>::value
			|| is_floating_point<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct remove_reference
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&&>
	{	
	typedef _Ty type;
	};

	
template<class _Tgt,
	class _Src>
	struct _Copy_cv
	{	
	typedef typename remove_reference<_Tgt>::type _Tgtx;
	typedef _Tgtx& type;
	};

template<class _Tgt,
	class _Src>
	struct _Copy_cv<_Tgt, const _Src>
	{	
	typedef typename remove_reference<_Tgt>::type _Tgtx;
	typedef const _Tgtx& type;
	};

template<class _Tgt,
	class _Src>
	struct _Copy_cv<_Tgt, volatile _Src>
	{	
	typedef typename remove_reference<_Tgt>::type _Tgtx;
	typedef volatile _Tgtx& type;
	};

template<class _Tgt,
	class _Src>
	struct _Copy_cv<_Tgt, const volatile _Src>
	{	
	typedef typename remove_reference<_Tgt>::type _Tgtx;
	typedef const volatile _Tgtx& type;
	};

template<class _Tgt,
	class _Src>
	struct _Copy_cv<_Tgt, _Src&>
	{	
	typedef typename _Copy_cv<_Tgt, _Src>::type type;
	};

	
struct _Wrap_int
	{	
	_Wrap_int(int)
		{	
		}
	};

template<class _Ty>
	struct _Identity
	{	
	typedef _Ty type;
	};


































		
template<class _Ty>
	struct _Has_result_type
		{ template<class _Uty> static auto _Fn(int, _Identity<typename _Uty::result_type> * = 0, _Identity<typename _Uty::result_type> * = 0, _Identity<typename _Uty::result_type> * = 0) -> true_type; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 427 "d:\\programs overflow\\vc\\include\\xtr1common"
#line 428 "d:\\programs overflow\\vc\\include\\xtr1common"





#line 9 "d:\\programs overflow\\vc\\include\\xtgmath.h"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
template<class _Ty>
	struct _Promote_to_float
	{	
	typedef typename conditional<is_integral<_Ty>::value,
		double, _Ty>::type type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Common_float_type
	{	
	typedef typename _Promote_to_float<_Ty1>::type _Ty1f;
	typedef typename _Promote_to_float<_Ty2>::type _Ty2f;
	typedef typename conditional<is_same<_Ty1f, long double>::value
		|| is_same<_Ty2f, long double>::value, long double,
		typename conditional<is_same<_Ty1f, double>::value
			|| is_same<_Ty2f, double>::value, double,
			float>::type>::type type;
	};
}







































extern "C" double __cdecl pow(  double,   double);
float __cdecl  pow(  float,   float) throw ();
long double __cdecl  pow(  long double,   long double) throw ();

template<class _Ty1,
	class _Ty2> inline
	typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value
		&& ::std:: _Is_numeric<_Ty2>::value,
		typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type
	pow(const _Ty1 _Left, const _Ty2 _Right)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
	return (:: pow(type(_Left), type(_Right)));
	}


extern "C"  double __cdecl acos(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acos(_Ty _Left) { return (:: acos((double)_Left)); }
extern "C"  double __cdecl asin(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asin(_Ty _Left) { return (:: asin((double)_Left)); }
extern "C"  double __cdecl atan(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atan(_Ty _Left) { return (:: atan((double)_Left)); }
extern "C"  double __cdecl atan2(  double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type atan2(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: atan2((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl ceil(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ceil(_Ty _Left) { return (:: ceil((double)_Left)); }
extern "C"  double __cdecl cos(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cos(_Ty _Left) { return (:: cos((double)_Left)); }
extern "C"  double __cdecl cosh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cosh(_Ty _Left) { return (:: cosh((double)_Left)); }
extern "C"  double __cdecl exp(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp(_Ty _Left) { return (:: exp((double)_Left)); }

extern "C" __declspec(dllimport) double __cdecl floor(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type floor(_Ty _Left) { return (:: floor((double)_Left)); }
extern "C"  double __cdecl fmod(  double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmod(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmod((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl frexp(  double,   int *); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type frexp(_Ty _Left,   int * _Arg2) { return (:: frexp((double)_Left, _Arg2)); }
extern "C" __declspec(dllimport) double __cdecl ldexp(  double,   int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ldexp(_Ty _Left,   int _Arg2) { return (:: ldexp((double)_Left, _Arg2)); }
extern "C"  double __cdecl log(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log(_Ty _Left) { return (:: log((double)_Left)); }
extern "C"  double __cdecl log10(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log10(_Ty _Left) { return (:: log10((double)_Left)); }


extern "C"  double __cdecl sin(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sin(_Ty _Left) { return (:: sin((double)_Left)); }
extern "C"  double __cdecl sinh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sinh(_Ty _Left) { return (:: sinh((double)_Left)); }
extern "C"  double __cdecl sqrt(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sqrt(_Ty _Left) { return (:: sqrt((double)_Left)); }
extern "C"  double __cdecl tan(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tan(_Ty _Left) { return (:: tan((double)_Left)); }
extern "C"  double __cdecl tanh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tanh(_Ty _Left) { return (:: tanh((double)_Left)); }
		









		
inline float _Fma(float _Left, float _Middle, float _Right)
	{
	return (:: fmaf(_Left, _Middle, _Right));
	}

inline double _Fma(double _Left, double _Middle, double _Right)
	{
	return (:: fma(_Left, _Middle, _Right));
	}

inline long double _Fma(long double _Left, long double _Middle, long double _Right)
	{
	return (:: fmal(_Left, _Middle, _Right));
	}

template<class _Ty1,
	class _Ty2,
	class _Ty3> inline
	typename ::std:: _Common_float_type<_Ty1,
		typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type
	fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1,
		typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type type;
	return (_Fma((type)_Left, (type)_Middle, (type)_Right));
	}

		
inline float _Remquo(float _Left, float _Right, int *_Pquo)
	{
	return (:: remquof(_Left, _Right, _Pquo));
	}

inline double _Remquo(double _Left, double _Right, int *_Pquo)
	{
	return (:: remquo(_Left, _Right, _Pquo));
	}

inline long double _Remquo(long double _Left, long double _Right, int *_Pquo)
	{
	return (:: remquol(_Left, _Right, _Pquo));
	}

template<class _Ty1,
	class _Ty2> inline
	typename ::std:: _Common_float_type<_Ty1, _Ty2>::type
	remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
	return (_Remquo((type)_Left, (type)_Right, _Pquo));
	}

extern "C" __declspec(dllimport) double __cdecl acosh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acosh(_Ty _Left) { return (:: acosh((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl asinh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asinh(_Ty _Left) { return (:: asinh((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl atanh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atanh(_Ty _Left) { return (:: atanh((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl cbrt(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cbrt(_Ty _Left) { return (:: cbrt((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl copysign(  double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type copysign(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: copysign((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl erf(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erf(_Ty _Left) { return (:: erf((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl erfc(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erfc(_Ty _Left) { return (:: erfc((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl expm1(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type expm1(_Ty _Left) { return (:: expm1((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl exp2(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp2(_Ty _Left) { return (:: exp2((double)_Left)); }

extern "C" __declspec(dllimport) double __cdecl fdim(  double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fdim(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fdim((type)_Left, (type)_Right)); }

extern "C" __declspec(dllimport) double __cdecl fmax(  double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmax(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmax((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl fmin(  double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmin(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmin((type)_Left, (type)_Right)); }
extern "C"  double __cdecl hypot(  double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type hypot(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: hypot((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) int __cdecl ilogb(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, int>::type ilogb(_Ty _Left) { return (:: ilogb((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl lgamma(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type lgamma(_Ty _Left) { return (:: lgamma((double)_Left)); }
extern "C" __declspec(dllimport) long long __cdecl llrint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llrint(_Ty _Left) { return (:: llrint((double)_Left)); }
extern "C" __declspec(dllimport) long long __cdecl llround(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llround(_Ty _Left) { return (:: llround((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl log1p(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log1p(_Ty _Left) { return (:: log1p((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl log2(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log2(_Ty _Left) { return (:: log2((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl logb(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type logb(_Ty _Left) { return (:: logb((double)_Left)); }
extern "C" __declspec(dllimport) long __cdecl lrint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lrint(_Ty _Left) { return (:: lrint((double)_Left)); }
extern "C" __declspec(dllimport) long __cdecl lround(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lround(_Ty _Left) { return (:: lround((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl nearbyint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nearbyint(_Ty _Left) { return (:: nearbyint((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl nextafter(  double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type nextafter(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: nextafter((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl nexttoward(  double,   long double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nexttoward(_Ty _Left,   long double _Arg2) { return (:: nexttoward((double)_Left, _Arg2)); }
extern "C" __declspec(dllimport) double __cdecl remainder(  double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type remainder(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: remainder((type)_Left, (type)_Right)); }

extern "C" __declspec(dllimport) double __cdecl rint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type rint(_Ty _Left) { return (:: rint((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl round(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type round(_Ty _Left) { return (:: round((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl scalbln(  double,   long); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbln(_Ty _Left,   long _Arg2) { return (:: scalbln((double)_Left, _Arg2)); }
extern "C" __declspec(dllimport) double __cdecl scalbn(  double,   int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbn(_Ty _Left,   int _Arg2) { return (:: scalbn((double)_Left, _Arg2)); }
extern "C" __declspec(dllimport) double __cdecl tgamma(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tgamma(_Ty _Left) { return (:: tgamma((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl trunc(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type trunc(_Ty _Left) { return (:: trunc((double)_Left)); }

 #line 213 "d:\\programs overflow\\vc\\include\\xtgmath.h"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 218 "d:\\programs overflow\\vc\\include\\xtgmath.h"
#line 219 "d:\\programs overflow\\vc\\include\\xtgmath.h"





#line 19 "d:\\programs overflow\\vc\\include\\cmath"
#line 20 "d:\\programs overflow\\vc\\include\\cmath"

 
namespace std {
using :: abs; using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;

using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: float_t; using :: double_t;

using :: acosh; using :: asinh; using :: atanh;
using :: cbrt; using :: erf; using :: erfc;
using :: expm1; using :: exp2;
using :: hypot; using :: ilogb; using :: lgamma;
using :: log1p; using :: log2; using :: logb;
using :: llrint; using :: lrint; using :: nearbyint;
using :: rint; using :: llround; using :: lround;
using :: fdim; using :: fma; using :: fmax; using :: fmin;
using :: round; using :: trunc;
using :: remainder; using :: remquo;
using :: copysign; using :: nan; using :: nextafter;
using :: scalbn; using :: scalbln;
using :: nexttoward; using :: tgamma;

using :: acoshf; using :: asinhf; using :: atanhf;
using :: cbrtf; using :: erff; using :: erfcf;
using :: expm1f; using :: exp2f;
using :: hypotf; using :: ilogbf; using :: lgammaf;
using :: log1pf; using :: log2f; using :: logbf;
using :: llrintf; using :: lrintf; using :: nearbyintf;
using :: rintf; using :: llroundf; using :: lroundf;
using :: fdimf; using :: fmaf; using :: fmaxf; using :: fminf;
using :: roundf; using :: truncf;
using :: remainderf; using :: remquof;
using :: copysignf; using :: nanf;
using :: nextafterf; using :: scalbnf; using :: scalblnf;
using :: nexttowardf; using :: tgammaf;

using :: acoshl; using :: asinhl; using :: atanhl;
using :: cbrtl; using :: erfl; using :: erfcl;
using :: expm1l; using :: exp2l;
using :: hypotl; using :: ilogbl; using :: lgammal;
using :: log1pl; using :: log2l; using :: logbl;
using :: llrintl; using :: lrintl; using :: nearbyintl;
using :: rintl; using :: llroundl; using :: lroundl;
using :: fdiml; using :: fmal; using :: fmaxl; using :: fminl;
using :: roundl; using :: truncl;
using :: remainderl; using :: remquol;
using :: copysignl; using :: nanl;
using :: nextafterl; using :: scalbnl; using :: scalblnl;
using :: nexttowardl; using :: tgammal;

using :: fpclassify; using :: signbit;
using :: isfinite; using :: isinf;
using :: isnan; using :: isnormal;
using :: isgreater; using :: isgreaterequal;
using :: isless; using :: islessequal;
using :: islessgreater; using :: isunordered;
}
 #line 102 "d:\\programs overflow\\vc\\include\\cmath"

#line 104 "d:\\programs overflow\\vc\\include\\cmath"





#line 8 "d:\\programs overflow\\vc\\include\\xlocnum"


#line 1 "d:\\programs overflow\\vc\\include\\streambuf"

#pragma once



#line 1 "d:\\programs overflow\\vc\\include\\xiosbase"

#pragma once



#line 1 "d:\\programs overflow\\vc\\include\\xlocale"

#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\cstring"

#pragma once










 #line 1 "d:\\programs overflow\\vc\\include\\string.h"














#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "d:\\programs overflow\\vc\\include\\string.h"


extern "C" {
#line 25 "d:\\programs overflow\\vc\\include\\string.h"




#line 30 "d:\\programs overflow\\vc\\include\\string.h"

















__declspec(dllimport) void *  __cdecl _memccpy(   void * _Dst,   const void * _Src,   int _Val,   size_t _MaxCount);
  __declspec(dllimport) const void *  __cdecl memchr(   const void * _Buf ,   int _Val,   size_t _MaxCount);
  __declspec(dllimport) int     __cdecl _memicmp(  const void * _Buf1,   const void * _Buf2,   size_t _Size);
  __declspec(dllimport) int     __cdecl _memicmp_l(  const void * _Buf1,   const void * _Buf2,   size_t _Size,   _locale_t _Locale);
  int     __cdecl memcmp(  const void * _Buf1,   const void * _Buf2,   size_t _Size);

 

void *  __cdecl memcpy(  void * _Dst,   const void * _Src,   size_t _Size);

__declspec(dllimport) errno_t  __cdecl memcpy_s(  void * _Dst,   rsize_t _DstSize,   const void * _Src,   rsize_t _MaxCount);





















#line 80 "d:\\programs overflow\\vc\\include\\string.h"










#line 91 "d:\\programs overflow\\vc\\include\\string.h"
#line 92 "d:\\programs overflow\\vc\\include\\string.h"
         
        
        void *  __cdecl memset(  void * _Dst,   int _Val,   size_t _Size);



__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_memccpy" ". See online help for details.")) __declspec(dllimport) void * __cdecl memccpy(  void * _Dst,   const void * _Src,   int _Val,   size_t _Size);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_memicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl memicmp(  const void * _Buf1,   const void * _Buf2,   size_t _Size);
#line 101 "d:\\programs overflow\\vc\\include\\string.h"

#line 103 "d:\\programs overflow\\vc\\include\\string.h"
#line 104 "d:\\programs overflow\\vc\\include\\string.h"

 __declspec(dllimport) errno_t __cdecl _strset_s(  char * _Dst,   size_t _DstSize,   int _Value);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(  char (&_Dest)[_Size],   int _Value) throw() { return _strset_s(_Dest, _Size, _Value); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  char * __cdecl _strset( char *_Dest,  int _Value);

 __declspec(dllimport) errno_t __cdecl strcpy_s(  char * _Dst,   rsize_t _SizeInBytes,   const char * _Src);
#line 111 "d:\\programs overflow\\vc\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Dest)[_Size],   const char * _Source) throw() { return strcpy_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  char * __cdecl strcpy( char *_Dest,  const char * _Source);

 __declspec(dllimport) errno_t __cdecl strcat_s(  char * _Dst,   rsize_t _SizeInBytes,   const char * _Src);
#line 116 "d:\\programs overflow\\vc\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Dest)[_Size],   const char * _Source) throw() { return strcat_s(_Dest, _Size, _Source); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))  char * __cdecl strcat( char *_Dest,  const char * _Source);
#line 120 "d:\\programs overflow\\vc\\include\\string.h"
  int     __cdecl strcmp(  const char * _Str1,   const char * _Str2);
  size_t  __cdecl strlen(  const char * _Str);
  __declspec(dllimport)


size_t  __cdecl strnlen(  const char * _Str,   size_t _MaxCount);

  static __inline


size_t  __cdecl strnlen_s(  const char * _Str,   size_t _MaxCount)
{
    return (_Str==0) ? 0 : strnlen(_Str, _MaxCount);
}
#line 135 "d:\\programs overflow\\vc\\include\\string.h"

 __declspec(dllimport) errno_t __cdecl memmove_s(  void * _Dst,   rsize_t _DstSize,   const void * _Src,   rsize_t _MaxCount);
#line 138 "d:\\programs overflow\\vc\\include\\string.h"

__declspec(dllimport)  void *  __cdecl memmove(  void * _Dst,   const void * _Src,   size_t _Size);




#line 145 "d:\\programs overflow\\vc\\include\\string.h"

  __declspec(dllimport) char *  __cdecl _strdup(  const char * _Src);



#line 151 "d:\\programs overflow\\vc\\include\\string.h"

  __declspec(dllimport) const char *  __cdecl strchr(  const char * _Str,   int _Val);
  __declspec(dllimport) int     __cdecl _stricmp(   const char * _Str1,    const char * _Str2);
  __declspec(dllimport) int     __cdecl _strcmpi(   const char * _Str1,    const char * _Str2);
  __declspec(dllimport) int     __cdecl _stricmp_l(   const char * _Str1,    const char * _Str2,   _locale_t _Locale);
  __declspec(dllimport) int     __cdecl strcoll(   const char * _Str1,    const  char * _Str2);
  __declspec(dllimport) int     __cdecl _strcoll_l(   const char * _Str1,    const char * _Str2,   _locale_t _Locale);
  __declspec(dllimport) int     __cdecl _stricoll(   const char * _Str1,    const char * _Str2);
  __declspec(dllimport) int     __cdecl _stricoll_l(   const char * _Str1,    const char * _Str2,   _locale_t _Locale);
  __declspec(dllimport) int     __cdecl _strncoll  (  const char * _Str1,   const char * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int     __cdecl _strncoll_l(  const char * _Str1,   const char * _Str2,   size_t _MaxCount,   _locale_t _Locale);
  __declspec(dllimport) int     __cdecl _strnicoll (  const char * _Str1,   const char * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int     __cdecl _strnicoll_l(  const char * _Str1,   const char * _Str2,   size_t _MaxCount,   _locale_t _Locale);
  __declspec(dllimport) size_t  __cdecl strcspn(   const char * _Str,    const char * _Control);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char *  __cdecl _strerror(  const char * _ErrMsg);
 __declspec(dllimport) errno_t __cdecl _strerror_s(  char * _Buf,   size_t _SizeInBytes,   const char * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],   const char * _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char *  __cdecl strerror(  int);

 __declspec(dllimport) errno_t __cdecl strerror_s(  char * _Buf,   size_t _SizeInBytes,   int _ErrNum);
#line 172 "d:\\programs overflow\\vc\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
 __declspec(dllimport) errno_t __cdecl _strlwr_s(  char * _Str,   size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(  char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strlwr( char *_String);
 __declspec(dllimport) errno_t __cdecl _strlwr_s_l(  char * _Str,   size_t _Size,   _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strlwr_l(  char *_String,   _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl strncat_s(  char * _Dst,   rsize_t _SizeInBytes,   const char * _Src,   rsize_t _MaxCount);
#line 182 "d:\\programs overflow\\vc\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(  char (&_Dest)[_Size],   const char * _Source,   size_t _Count) throw() { return strncat_s(_Dest, _Size, _Source, _Count); } }
#pragma warning(push)
#pragma warning(disable:6059)

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl strncat(  char *_Dest,   const char * _Source,   size_t _Count);
#pragma warning(pop)
  __declspec(dllimport) int     __cdecl strncmp(  const char * _Str1,   const char * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int     __cdecl _strnicmp(  const char * _Str1,   const char * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int     __cdecl _strnicmp_l(  const char * _Str1,   const char * _Str2,   size_t _MaxCount,   _locale_t _Locale);

 __declspec(dllimport) errno_t __cdecl strncpy_s(  char * _Dst,   rsize_t _SizeInBytes,   const char * _Src,   rsize_t _MaxCount);
#line 194 "d:\\programs overflow\\vc\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Dest)[_Size],   const char * _Source,   size_t _Count) throw() { return strncpy_s(_Dest, _Size, _Source, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl strncpy(    char *_Dest,   const char * _Source,   size_t _Count);
 __declspec(dllimport) errno_t __cdecl _strnset_s(  char * _Str,   size_t _SizeInBytes,   int _Val,   size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(  char (&_Dest)[_Size],   int _Val,   size_t _Count) throw() { return _strnset_s(_Dest, _Size, _Val, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strnset(  char *_Dest,   int _Val,   size_t _Count);
  __declspec(dllimport) const char *  __cdecl strpbrk(  const char * _Str,   const char * _Control);
  __declspec(dllimport) const char *  __cdecl strrchr(  const char * _Str,   int _Ch);
__declspec(dllimport) char *  __cdecl _strrev(  char * _Str);
  __declspec(dllimport) size_t  __cdecl strspn(  const char * _Str,   const char * _Control);
    __declspec(dllimport) const char *  __cdecl strstr(  const char * _Str,   const char * _SubStr);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char *  __cdecl strtok(  char * _Str,   const char * _Delim);

  __declspec(dllimport) char *  __cdecl strtok_s(  char * _Str,   const char * _Delim,     char ** _Context);
#line 208 "d:\\programs overflow\\vc\\include\\string.h"
 __declspec(dllimport) errno_t __cdecl _strupr_s(  char * _Str,   size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(  char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strupr( char *_String);
 __declspec(dllimport) errno_t __cdecl _strupr_s_l(  char * _Str,   size_t _Size, _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(  char (&_String)[_Size], _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strupr_l(  char *_String,   _locale_t _Locale);
 __declspec(dllimport) size_t  __cdecl strxfrm (    char * _Dst,   const char * _Src,   size_t _MaxCount);
 __declspec(dllimport) size_t  __cdecl _strxfrm_l(    char * _Dst,   const char * _Src,   size_t _MaxCount,   _locale_t _Locale);


extern "C++" {


  inline char * __cdecl strchr(  char * _Str,   int _Ch)
        { return (char*)strchr((const char*)_Str, _Ch); }
  inline char * __cdecl strpbrk(  char * _Str,   const char * _Control)
        { return (char*)strpbrk((const char*)_Str, _Control); }
  inline char * __cdecl strrchr(  char * _Str,   int _Ch)
        { return (char*)strrchr((const char*)_Str, _Ch); }
    inline char * __cdecl strstr(  char * _Str,   const char * _SubStr)
        { return (char*)strstr((const char*)_Str, _SubStr); }
#line 230 "d:\\programs overflow\\vc\\include\\string.h"


  inline void * __cdecl memchr(  void * _Pv,   int _C,   size_t _N)
        { return (void*)memchr((const void*)_Pv, _C, _N); }
#line 235 "d:\\programs overflow\\vc\\include\\string.h"
}
#line 237 "d:\\programs overflow\\vc\\include\\string.h"






#line 244 "d:\\programs overflow\\vc\\include\\string.h"

  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strdup" ". See online help for details.")) __declspec(dllimport) char * __cdecl strdup(  const char * _Src);



#line 250 "d:\\programs overflow\\vc\\include\\string.h"


  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strcmpi" ". See online help for details.")) __declspec(dllimport) int __cdecl strcmpi(  const char * _Str1,   const char * _Str2);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_stricmp" ". See online help for details.")) __declspec(dllimport) int __cdecl stricmp(  const char * _Str1,   const char * _Str2);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strlwr" ". See online help for details.")) __declspec(dllimport) char * __cdecl strlwr(  char * _Str);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strnicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl strnicmp(  const char * _Str1,   const char * _Str,   size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strnset" ". See online help for details.")) __declspec(dllimport) char * __cdecl strnset(  char * _Str,   int _Val,   size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strrev" ". See online help for details.")) __declspec(dllimport) char * __cdecl strrev(  char * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strset" ". See online help for details."))         char * __cdecl strset(  char * _Str,   int _Val);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strupr" ". See online help for details.")) __declspec(dllimport) char * __cdecl strupr(  char * _Str);

#line 262 "d:\\programs overflow\\vc\\include\\string.h"









#line 272 "d:\\programs overflow\\vc\\include\\string.h"

  __declspec(dllimport) wchar_t * __cdecl _wcsdup(  const wchar_t * _Str);



#line 278 "d:\\programs overflow\\vc\\include\\string.h"


 __declspec(dllimport) errno_t __cdecl wcscat_s(  wchar_t * _Dst,   rsize_t _SizeInWords,   const wchar_t * _Src);
#line 282 "d:\\programs overflow\\vc\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Dest)[_Size],   const wchar_t * _Source) throw() { return wcscat_s(_Dest, _Size, _Source); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcscat( wchar_t *_Dest,  const wchar_t * _Source);
#line 286 "d:\\programs overflow\\vc\\include\\string.h"
 

__declspec(dllimport) const wchar_t * __cdecl wcschr(  const wchar_t * _Str, wchar_t _Ch);
  __declspec(dllimport) int __cdecl wcscmp(  const wchar_t * _Str1,   const wchar_t * _Str2);

 __declspec(dllimport) errno_t __cdecl wcscpy_s(  wchar_t * _Dst,   rsize_t _SizeInWords,   const wchar_t * _Src);
#line 293 "d:\\programs overflow\\vc\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Dest)[_Size],   const wchar_t * _Source) throw() { return wcscpy_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcscpy( wchar_t *_Dest,  const wchar_t * _Source);
  __declspec(dllimport) size_t __cdecl wcscspn(  const wchar_t * _Str,   const wchar_t * _Control);
  __declspec(dllimport) size_t __cdecl wcslen(  const wchar_t * _Str);
  __declspec(dllimport)


size_t __cdecl wcsnlen(  const wchar_t * _Src,   size_t _MaxCount);

  static __inline


size_t __cdecl wcsnlen_s(  const wchar_t * _Src,   size_t _MaxCount)
{
    return (_Src == 0) ? 0 : wcsnlen(_Src, _MaxCount);
}
#line 310 "d:\\programs overflow\\vc\\include\\string.h"

 __declspec(dllimport) errno_t __cdecl wcsncat_s(  wchar_t * _Dst,   rsize_t _SizeInWords,   const wchar_t * _Src,   rsize_t _MaxCount);
#line 313 "d:\\programs overflow\\vc\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(  wchar_t (&_Dest)[_Size],   const wchar_t * _Source,   size_t _Count) throw() { return wcsncat_s(_Dest, _Size, _Source, _Count); } }
#pragma warning(push)
#pragma warning(disable:6059)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsncat(  wchar_t *_Dest,   const wchar_t * _Source,   size_t _Count);
#pragma warning(pop)
  __declspec(dllimport) int __cdecl wcsncmp(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount);

 __declspec(dllimport) errno_t __cdecl wcsncpy_s(  wchar_t * _Dst,   rsize_t _SizeInWords,   const wchar_t * _Src,   rsize_t _MaxCount);
#line 322 "d:\\programs overflow\\vc\\include\\string.h"
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Dest)[_Size],   const wchar_t * _Source,   size_t _Count) throw() { return wcsncpy_s(_Dest, _Size, _Source, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsncpy(    wchar_t *_Dest,   const wchar_t * _Source,   size_t _Count);
  __declspec(dllimport) const wchar_t * __cdecl wcspbrk(  const wchar_t * _Str,   const wchar_t * _Control);
  __declspec(dllimport) const wchar_t * __cdecl wcsrchr(  const wchar_t * _Str,   wchar_t _Ch);
  __declspec(dllimport) size_t __cdecl wcsspn(  const wchar_t * _Str,   const wchar_t * _Control);
   

__declspec(dllimport) const wchar_t * __cdecl wcsstr(  const wchar_t * _Str,   const wchar_t * _SubStr);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcstok(  wchar_t * _Str,   const wchar_t * _Delim);

  __declspec(dllimport) wchar_t * __cdecl wcstok_s(  wchar_t * _Str,   const wchar_t * _Delim,     wchar_t ** _Context);
#line 334 "d:\\programs overflow\\vc\\include\\string.h"
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcserror(  int _ErrNum);
 __declspec(dllimport) errno_t __cdecl _wcserror_s(  wchar_t * _Buf,   size_t _SizeInWords,   int _ErrNum);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl __wcserror(  const wchar_t * _Str);
 __declspec(dllimport) errno_t __cdecl __wcserror_s(  wchar_t * _Buffer,   size_t _SizeInWords,   const wchar_t * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],   const wchar_t * _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }

  __declspec(dllimport) int __cdecl _wcsicmp(  const wchar_t * _Str1,   const wchar_t * _Str2);
  __declspec(dllimport) int __cdecl _wcsicmp_l(  const wchar_t * _Str1,   const wchar_t * _Str2,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _wcsnicmp(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int __cdecl _wcsnicmp_l(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount,   _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl _wcsnset_s(  wchar_t * _Dst,   size_t _SizeInWords,   wchar_t _Val,   size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(  wchar_t (&_Dst)[_Size], wchar_t _Val,   size_t _MaxCount) throw() { return _wcsnset_s(_Dst, _Size, _Val, _MaxCount); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsnset(  wchar_t *_Str, wchar_t _Val,   size_t _MaxCount);
__declspec(dllimport) wchar_t * __cdecl _wcsrev(  wchar_t * _Str);
 __declspec(dllimport) errno_t __cdecl _wcsset_s(  wchar_t * _Dst,   size_t _SizeInWords,   wchar_t _Value);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(  wchar_t (&_Str)[_Size], wchar_t _Val) throw() { return _wcsset_s(_Str, _Size, _Val); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsset(  wchar_t *_Str, wchar_t _Val);

 __declspec(dllimport) errno_t __cdecl _wcslwr_s(  wchar_t * _Str,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(  wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcslwr( wchar_t *_String);
 __declspec(dllimport) errno_t __cdecl _wcslwr_s_l(  wchar_t * _Str,   size_t _SizeInWords,   _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);
 __declspec(dllimport) errno_t __cdecl _wcsupr_s(  wchar_t * _Str,   size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(  wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsupr( wchar_t *_String);
 __declspec(dllimport) errno_t __cdecl _wcsupr_s_l(  wchar_t * _Str,   size_t _Size,   _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);
 __declspec(dllimport) size_t __cdecl wcsxfrm(    wchar_t * _Dst,   const wchar_t * _Src,   size_t _MaxCount);
 __declspec(dllimport) size_t __cdecl _wcsxfrm_l(    wchar_t * _Dst,   const wchar_t *_Src,   size_t _MaxCount,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl wcscoll(  const wchar_t * _Str1,   const wchar_t * _Str2);
  __declspec(dllimport) int __cdecl _wcscoll_l(  const wchar_t * _Str1,   const wchar_t * _Str2,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _wcsicoll(  const wchar_t * _Str1,   const wchar_t * _Str2);
  __declspec(dllimport) int __cdecl _wcsicoll_l(  const wchar_t * _Str1,   const wchar_t *_Str2,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _wcsncoll(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int __cdecl _wcsncoll_l(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _wcsnicoll(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount);
  __declspec(dllimport) int __cdecl _wcsnicoll_l(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount,   _locale_t _Locale);




extern "C++" {
 

        inline wchar_t * __cdecl wcschr(  wchar_t *_Str, wchar_t _Ch)
        {return ((wchar_t *)wcschr((const wchar_t *)_Str, _Ch)); }
  inline wchar_t * __cdecl wcspbrk(  wchar_t *_Str,   const wchar_t *_Control)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_Str, _Control)); }
  inline wchar_t * __cdecl wcsrchr(  wchar_t *_Str,   wchar_t _Ch)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_Str, _Ch)); }
   

        inline wchar_t * __cdecl wcsstr(  wchar_t *_Str,   const wchar_t *_SubStr)
        {return ((wchar_t *)wcsstr((const wchar_t *)_Str, _SubStr)); }
}
#line 394 "d:\\programs overflow\\vc\\include\\string.h"
#line 395 "d:\\programs overflow\\vc\\include\\string.h"






#line 402 "d:\\programs overflow\\vc\\include\\string.h"

  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsdup" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsdup(  const wchar_t * _Str);



#line 408 "d:\\programs overflow\\vc\\include\\string.h"





  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl wcsicmp(  const wchar_t * _Str1,   const wchar_t * _Str2);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsnicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl wcsnicmp(  const wchar_t * _Str1,   const wchar_t * _Str2,   size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsnset" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsnset(  wchar_t * _Str,   wchar_t _Val,   size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsrev" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsrev(  wchar_t * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsset" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsset(  wchar_t * _Str, wchar_t _Val);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcslwr" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcslwr(  wchar_t * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsupr" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsupr(  wchar_t * _Str);
  __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsicoll" ". See online help for details.")) __declspec(dllimport) int __cdecl wcsicoll(  const wchar_t * _Str1,   const wchar_t * _Str2);

#line 423 "d:\\programs overflow\\vc\\include\\string.h"


#line 426 "d:\\programs overflow\\vc\\include\\string.h"








}
#line 436 "d:\\programs overflow\\vc\\include\\string.h"

#line 438 "d:\\programs overflow\\vc\\include\\string.h"

#line 14 "d:\\programs overflow\\vc\\include\\cstring"
#line 15 "d:\\programs overflow\\vc\\include\\cstring"

 
namespace std {
using :: size_t; using :: memchr; using :: memcmp;
using :: memcpy; using :: memmove; using :: memset;
using :: strcat; using :: strchr; using :: strcmp;
using :: strcoll; using :: strcpy; using :: strcspn;
using :: strerror; using :: strlen; using :: strncat;
using :: strncmp; using :: strncpy; using :: strpbrk;
using :: strrchr; using :: strspn; using :: strstr;
using :: strtok; using :: strxfrm;
}
 #line 28 "d:\\programs overflow\\vc\\include\\cstring"

#line 30 "d:\\programs overflow\\vc\\include\\cstring"





#line 8 "d:\\programs overflow\\vc\\include\\xlocale"
#line 1 "d:\\programs overflow\\vc\\include\\stdexcept"

#pragma once



#line 1 "d:\\programs overflow\\vc\\include\\exception"

#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\xstddef"

#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\cstddef"

#pragma once










 #line 1 "d:\\programs overflow\\vc\\include\\stddef.h"














#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "d:\\programs overflow\\vc\\include\\stddef.h"


extern "C" {
#line 25 "d:\\programs overflow\\vc\\include\\stddef.h"











namespace std { typedef decltype(__nullptr) nullptr_t; }
using ::std::nullptr_t;
#line 39 "d:\\programs overflow\\vc\\include\\stddef.h"


















#line 58 "d:\\programs overflow\\vc\\include\\stddef.h"









#line 68 "d:\\programs overflow\\vc\\include\\stddef.h"

__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);


}
#line 76 "d:\\programs overflow\\vc\\include\\stddef.h"

#line 78 "d:\\programs overflow\\vc\\include\\stddef.h"
#line 14 "d:\\programs overflow\\vc\\include\\cstddef"
#line 15 "d:\\programs overflow\\vc\\include\\cstddef"

 
namespace std {
using :: ptrdiff_t; using :: size_t;
}
 #line 21 "d:\\programs overflow\\vc\\include\\cstddef"

 
namespace std {
typedef double max_align_t;	
}
 #line 27 "d:\\programs overflow\\vc\\include\\cstddef"
#line 28 "d:\\programs overflow\\vc\\include\\cstddef"





#line 8 "d:\\programs overflow\\vc\\include\\xstddef"
#line 1 "d:\\programs overflow\\vc\\include\\initializer_list"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		
template<class _Elem>
	class initializer_list
	{	
public:
	typedef _Elem value_type;
	typedef const _Elem& reference;
	typedef const _Elem& const_reference;
	typedef size_t size_type;

	typedef const _Elem* iterator;
	typedef const _Elem* const_iterator;

	initializer_list() throw ()
		: _First(0), _Last(0)
		{	
		}

	initializer_list(const _Elem *_First_arg,
		const _Elem *_Last_arg) throw ()
		: _First(_First_arg), _Last(_Last_arg)
		{	
		}

	const _Elem *begin() const throw ()
		{	
		return (_First);
		}

	const _Elem *end() const throw ()
		{	
		return (_Last);
		}

	size_t size() const throw ()
		{	
		return ((size_t)(_Last - _First));
		}

private:
	const _Elem *_First;
	const _Elem *_Last;
	};

		
template<class _Elem> inline
	const _Elem *begin(initializer_list<_Elem> _Ilist) throw ()
	{	
	return (_Ilist.begin());
	}

		
template<class _Elem> inline
	const _Elem *end(initializer_list<_Elem> _Ilist) throw ()
	{	
	return (_Ilist.end());
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 77 "d:\\programs overflow\\vc\\include\\initializer_list"
#line 78 "d:\\programs overflow\\vc\\include\\initializer_list"





#line 9 "d:\\programs overflow\\vc\\include\\xstddef"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 
  
  
  
 #line 22 "d:\\programs overflow\\vc\\include\\xstddef"

namespace std {
		
 
 
 #line 28 "d:\\programs overflow\\vc\\include\\xstddef"

 
 
 
 
 

 
 

  
  

  











#line 55 "d:\\programs overflow\\vc\\include\\xstddef"
   
   
  #line 58 "d:\\programs overflow\\vc\\include\\xstddef"

 




















#line 81 "d:\\programs overflow\\vc\\include\\xstddef"

		


		
 
 

		
template<class _Ty> inline
	_Ty *addressof(_Ty& _Val) throw ()
	{	
	return (reinterpret_cast<_Ty *>(
		(&const_cast<char&>(
		reinterpret_cast<const volatile char&>(_Val)))));
	}

		

template<bool,
	class _Ty1,
	class _Ty2>
	struct _If
	{	
	typedef _Ty2 type;
	};

template<class _Ty1,
	class _Ty2>
	struct _If<true, _Ty1, _Ty2>
	{	
	typedef _Ty1 type;
	};

template<class _Ty>
	struct _Always_false
	{	
	static const bool value = false;
	};

		
		
template<class _Arg,
	class _Result>
	struct unary_function
	{	
	typedef _Arg argument_type;
	typedef _Result result_type;
	};

		
template<class _Arg1,
	class _Arg2,
	class _Result>
	struct binary_function
	{	
	typedef _Arg1 first_argument_type;
	typedef _Arg2 second_argument_type;
	typedef _Result result_type;
	};

		
template<class _Ty = void>
	struct plus
		: public binary_function<_Ty, _Ty, _Ty>
	{	
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left + _Right);
		}
	};

		
template<class _Ty = void>
	struct minus
		: public binary_function<_Ty, _Ty, _Ty>
	{	
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left - _Right);
		}
	};

		
template<class _Ty = void>
	struct multiplies
		: public binary_function<_Ty, _Ty, _Ty>
	{	
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left * _Right);
		}
	};

		
template<class _Ty = void>
	struct equal_to
		: public binary_function<_Ty, _Ty, bool>
	{	
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left == _Right);
		}
	};

		
template<class _Ty = void>
	struct less
		: public binary_function<_Ty, _Ty, bool>
	{	
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left < _Right);
		}
	};

		
template<>
	struct plus<void>
	{	
	template<class _Ty1,
		class _Ty2>
		auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct minus<void>
	{	
	template<class _Ty1,
		class _Ty2>
		auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct multiplies<void>
	{	
	template<class _Ty1,
		class _Ty2>
		auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct equal_to<void>
	{	
	template<class _Ty1,
		class _Ty2>
		auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct less<void>
	{	
	template<class _Ty1,
		class _Ty2>
		auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right));
		}
	};


}



namespace std {
	
inline size_t _Hash_seq(const unsigned char *_First, size_t _Count)
	{	
 




#line 287 "d:\\programs overflow\\vc\\include\\xstddef"
	static_assert(sizeof(size_t) == 4, "This code is for 32-bit size_t.");
	const size_t _FNV_offset_basis = 2166136261U;
	const size_t _FNV_prime = 16777619U;
 #line 291 "d:\\programs overflow\\vc\\include\\xstddef"

	size_t _Val = _FNV_offset_basis;
	for (size_t _Next = 0; _Next < _Count; ++_Next)
		{	
		_Val ^= (size_t)_First[_Next];
		_Val *= _FNV_prime;
		}

 



#line 304 "d:\\programs overflow\\vc\\include\\xstddef"
	static_assert(sizeof(size_t) == 4, "This code is for 32-bit size_t.");
 #line 306 "d:\\programs overflow\\vc\\include\\xstddef"

	return (_Val);
	}

	
template<class _Kty>
	struct _Bitwise_hash
		: public unary_function<_Kty, size_t>
	{	
	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
		}
	};

	
template<class _Kty>
	struct hash
		: public _Bitwise_hash<_Kty>
	{	
	static const bool _Value = __is_enum(_Kty);
	static_assert(_Value,
		"The C++ Standard doesn't provide a hash for this type.");
	};
template<>
	struct hash<bool>
		: public _Bitwise_hash<bool>
	{	
	};

template<>
	struct hash<char>
		: public _Bitwise_hash<char>
	{	
	};

template<>
	struct hash<signed char>
		: public _Bitwise_hash<signed char>
	{	
	};

template<>
	struct hash<unsigned char>
		: public _Bitwise_hash<unsigned char>
	{	
	};

 











#line 367 "d:\\programs overflow\\vc\\include\\xstddef"

 
template<>
	struct hash<wchar_t>
		: public _Bitwise_hash<wchar_t>
	{	
	};
 #line 375 "d:\\programs overflow\\vc\\include\\xstddef"

template<>
	struct hash<short>
		: public _Bitwise_hash<short>
	{	
	};

template<>
	struct hash<unsigned short>
		: public _Bitwise_hash<unsigned short>
	{	
	};

template<>
	struct hash<int>
		: public _Bitwise_hash<int>
	{	
	};

template<>
	struct hash<unsigned int>
		: public _Bitwise_hash<unsigned int>
	{	
	};

template<>
	struct hash<long>
		: public _Bitwise_hash<long>
	{	
	};

template<>
	struct hash<unsigned long>
		: public _Bitwise_hash<unsigned long>
	{	
	};

template<>
	struct hash<long long>
		: public _Bitwise_hash<long long>
	{	
	};

template<>
	struct hash<unsigned long long>
		: public _Bitwise_hash<unsigned long long>
	{	
	};

template<>
	struct hash<float>
		: public _Bitwise_hash<float>
	{	
	typedef float _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval)); 
		}
	};

template<>
	struct hash<double>
		: public _Bitwise_hash<double>
	{	
	typedef double _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval)); 
		}
	};

template<>
	struct hash<long double>
		: public _Bitwise_hash<long double>
	{	
	typedef long double _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval)); 
		}
	};

template<class _Ty>
	struct hash<_Ty *>
		: public _Bitwise_hash<_Ty *>
	{	
	};
}
#line 473 "d:\\programs overflow\\vc\\include\\xstddef"

namespace std {
namespace tr1 {	
using ::std:: hash;
}	
}

  














#line 496 "d:\\programs overflow\\vc\\include\\xstddef"

 

  




















  #line 521 "d:\\programs overflow\\vc\\include\\xstddef"

 















#line 539 "d:\\programs overflow\\vc\\include\\xstddef"




























 
 #pragma warning(pop)
 #pragma pack(pop)
#line 571 "d:\\programs overflow\\vc\\include\\xstddef"
#line 572 "d:\\programs overflow\\vc\\include\\xstddef"





#line 8 "d:\\programs overflow\\vc\\include\\exception"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 










namespace std {

  


  



  



}

 

 #line 1 "d:\\programs overflow\\vc\\include\\eh.h"












#pragma once

#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 16 "d:\\programs overflow\\vc\\include\\eh.h"








#pragma pack(push,8)







typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *unexpected_handler)();





#line 42 "d:\\programs overflow\\vc\\include\\eh.h"








struct _EXCEPTION_POINTERS;

typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);
#line 54 "d:\\programs overflow\\vc\\include\\eh.h"

__declspec(dllimport) __declspec(noreturn) void __cdecl terminate(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl unexpected(void);

__declspec(dllimport) int __cdecl _is_exception_typeof(  const type_info &_Type,   struct _EXCEPTION_POINTERS * _ExceptionPtr);



__declspec(dllimport) terminate_function __cdecl set_terminate(  terminate_function _NewPtFunc);
extern "C" __declspec(dllimport) terminate_function __cdecl _get_terminate(void);
__declspec(dllimport) unexpected_function __cdecl set_unexpected(  unexpected_function _NewPtFunc);
extern "C" __declspec(dllimport) unexpected_function __cdecl _get_unexpected(void);
#line 67 "d:\\programs overflow\\vc\\include\\eh.h"



__declspec(dllimport) _se_translator_function __cdecl _set_se_translator(  _se_translator_function _NewPtFunc);
#line 72 "d:\\programs overflow\\vc\\include\\eh.h"
__declspec(dllimport) bool __cdecl __uncaught_exception();









#pragma pack(pop)
#line 84 "d:\\programs overflow\\vc\\include\\eh.h"
#line 85 "d:\\programs overflow\\vc\\include\\eh.h"
#line 41 "d:\\programs overflow\\vc\\include\\exception"
 #line 1 "d:\\programs overflow\\vc\\include\\malloc.h"














#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "d:\\programs overflow\\vc\\include\\malloc.h"





#pragma pack(push,8)


extern "C" {
#line 31 "d:\\programs overflow\\vc\\include\\malloc.h"







#line 39 "d:\\programs overflow\\vc\\include\\malloc.h"





#line 45 "d:\\programs overflow\\vc\\include\\malloc.h"













typedef struct _heapinfo {
        int * _pentry;
        size_t _size;
        int _useflag;
        } _HEAPINFO;

#line 65 "d:\\programs overflow\\vc\\include\\malloc.h"



































#line 101 "d:\\programs overflow\\vc\\include\\malloc.h"







































#line 141 "d:\\programs overflow\\vc\\include\\malloc.h"


__declspec(dllimport) int     __cdecl _resetstkoflw (void);
#line 145 "d:\\programs overflow\\vc\\include\\malloc.h"



__declspec(dllimport) unsigned long __cdecl _set_malloc_crt_max_wait(  unsigned long _NewValue);







#line 157 "d:\\programs overflow\\vc\\include\\malloc.h"

      __declspec(dllimport) void *  __cdecl _expand(  void * _Memory,   size_t _NewSize);
  __declspec(dllimport) size_t  __cdecl _msize(  void * _Memory);




#line 165 "d:\\programs overflow\\vc\\include\\malloc.h"

    void *          __cdecl _alloca(  size_t _Size);


__declspec(dllimport)  int     __cdecl _heapwalk(  _HEAPINFO * _EntryInfo);
__declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);
#line 172 "d:\\programs overflow\\vc\\include\\malloc.h"


  __declspec(dllimport) int     __cdecl _heapadd(  void * _Memory,   size_t _Size);
  __declspec(dllimport) int     __cdecl _heapchk(void);
  __declspec(dllimport) int     __cdecl _heapmin(void);
__declspec(dllimport) int     __cdecl _heapset(  unsigned int _Fill);
__declspec(dllimport) size_t  __cdecl _heapused(size_t * _Used, size_t * _Commit);
#line 180 "d:\\programs overflow\\vc\\include\\malloc.h"













#line 194 "d:\\programs overflow\\vc\\include\\malloc.h"

typedef char __static_assert_t[ (sizeof(unsigned int) <= 8) ];


#pragma warning(push)
#pragma warning(disable:6540)
__inline void *_MarkAllocaS(   void *_Ptr, unsigned int _Marker)
{
    if (_Ptr)
    {
        *((unsigned int*)_Ptr) = _Marker;
        _Ptr = (char*)_Ptr + 8;
    }
    return _Ptr;
}

__inline int _MallocaIsSizeInRange(size_t size)
{
    return size + 8 > size;
}
#pragma warning(pop)
#line 216 "d:\\programs overflow\\vc\\include\\malloc.h"









#line 226 "d:\\programs overflow\\vc\\include\\malloc.h"









#line 236 "d:\\programs overflow\\vc\\include\\malloc.h"










#line 247 "d:\\programs overflow\\vc\\include\\malloc.h"






__pragma(warning(push))
__pragma(warning(disable: 6014))
__declspec(noalias) __inline void __cdecl _freea(    void * _Memory)
{
    unsigned int _Marker;
    if (_Memory)
    {
        _Memory = (char*)_Memory - 8;
        _Marker = *(unsigned int *)_Memory;
        if (_Marker == 0xDDDD)
        {
            free(_Memory);
        }






#line 273 "d:\\programs overflow\\vc\\include\\malloc.h"
    }
}
__pragma(warning(pop))
#line 277 "d:\\programs overflow\\vc\\include\\malloc.h"
#line 278 "d:\\programs overflow\\vc\\include\\malloc.h"
#line 279 "d:\\programs overflow\\vc\\include\\malloc.h"




#line 284 "d:\\programs overflow\\vc\\include\\malloc.h"





}
#line 291 "d:\\programs overflow\\vc\\include\\malloc.h"

#pragma pack(pop)

#line 295 "d:\\programs overflow\\vc\\include\\malloc.h"
#line 42 "d:\\programs overflow\\vc\\include\\exception"
 

 

#line 47 "d:\\programs overflow\\vc\\include\\exception"

 





























#line 79 "d:\\programs overflow\\vc\\include\\exception"

 namespace std {





 
#line 88 "d:\\programs overflow\\vc\\include\\exception"

class __declspec(dllimport) exception
	{   
public:
	  exception();
	 explicit  exception(const char * const &);
	  exception(const char * const &, int);
	  exception(const exception&);
	 exception&  operator=(const exception&);
	 virtual  ~exception() throw ();
	 virtual const char *  what() const;

private:
	 void  _Copy_str(const char *);
	 void  _Tidy();

	const char * _Mywhat;
	bool _Mydofree;
	};

















































































using ::set_terminate; using ::terminate_handler; using ::terminate; using ::set_unexpected; using ::unexpected_handler; using ::unexpected;

typedef void (__cdecl *_Prhand)(const exception&);

__declspec(dllimport) bool __cdecl uncaught_exception();


inline terminate_handler __cdecl get_terminate()
	{	
	return (_get_terminate());
	}

inline unexpected_handler __cdecl get_unexpected()
	{	
	return (_get_unexpected());
	}
#line 205 "d:\\programs overflow\\vc\\include\\exception"

}

 




















































































































#line 326 "d:\\programs overflow\\vc\\include\\exception"


namespace std {


#line 332 "d:\\programs overflow\\vc\\include\\exception"

		
class bad_exception : public exception
	{	
public:
	 bad_exception(const char *_Message = "bad exception")
		throw ()
		: exception(_Message)
		{	
		}

	virtual  ~bad_exception() throw ()
		{	
		}

 





#line 354 "d:\\programs overflow\\vc\\include\\exception"

	};

		
class bad_alloc : public exception
	{	
public:
	 bad_alloc() throw ()
		: exception("bad allocation", 1)
		{	
		}

	virtual  ~bad_alloc() throw ()
		{	
		}

private:
	friend class bad_array_new_length;

	 bad_alloc(const char *_Message) throw ()
		: exception(_Message, 1)
		{	
		}

 





#line 385 "d:\\programs overflow\\vc\\include\\exception"

	};

		
class bad_array_new_length
	: public bad_alloc
	{	
public:

	bad_array_new_length() throw ()
		: bad_alloc("bad array new length")
		{	
		}
	};


}









#line 412 "d:\\programs overflow\\vc\\include\\exception"

__declspec(dllimport) void __cdecl __ExceptionPtrCreate(  void* );
__declspec(dllimport) void __cdecl __ExceptionPtrDestroy(  void* );
__declspec(dllimport) void __cdecl __ExceptionPtrCopy(  void*,   const void* );
__declspec(dllimport) void __cdecl __ExceptionPtrAssign(  void*,   const void* );
__declspec(dllimport) bool __cdecl __ExceptionPtrCompare(  const void*,   const void*);
__declspec(dllimport) bool __cdecl __ExceptionPtrToBool(  const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrSwap(  void*,   void*);

__declspec(dllimport) void __cdecl __ExceptionPtrCurrentException(  void*);
__declspec(dllimport) void __cdecl __ExceptionPtrRethrow(  const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCopyException(  void*,   const void*,   const void*);

namespace std {

class exception_ptr
	{
public:
	exception_ptr()
		{
		__ExceptionPtrCreate(this);
		}
	exception_ptr(nullptr_t)
		{
		__ExceptionPtrCreate(this);
		}
	~exception_ptr() throw ()
		{
		__ExceptionPtrDestroy(this);
		}
	exception_ptr(const exception_ptr& _Rhs)
		{
		__ExceptionPtrCopy(this, &_Rhs);
		}
	exception_ptr& operator=(const exception_ptr& _Rhs)
		{
		__ExceptionPtrAssign(this, &_Rhs);
		return *this;
		}
	exception_ptr& operator=(nullptr_t)
		{
		exception_ptr _Ptr;
		__ExceptionPtrAssign(this, &_Ptr);
		return *this;
		}

	typedef exception_ptr _Myt;

	explicit operator bool() const throw ()
		{
		return __ExceptionPtrToBool(this);
		}

	void _RethrowException() const
		{
		__ExceptionPtrRethrow(this);
		}

	static exception_ptr _Current_exception()
		{
		exception_ptr _Retval;
		__ExceptionPtrCurrentException(&_Retval);
		return _Retval;
		}
	static exception_ptr _Copy_exception(  void* _Except,   const void* _Ptr)
		{
		exception_ptr _Retval = 0;
		if (!_Ptr)
			{
			
			return _Retval;
			}
		__ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
		return _Retval;
		}
private:
	void* _Data1;
	void* _Data2;
	};

inline void swap(exception_ptr& _Lhs, exception_ptr& _Rhs)
	{
	__ExceptionPtrSwap(&_Lhs, &_Rhs);
	}

inline bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs)
	{
	return __ExceptionPtrCompare(&_Lhs, &_Rhs);
	}

inline bool operator==(nullptr_t, const exception_ptr& _Rhs)
	{
	return !_Rhs;
	}

inline bool operator==(const exception_ptr& _Lhs, nullptr_t)
	{
	return !_Lhs;
	}

inline bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs)
	{
	return !(_Lhs == _Rhs);
	}

inline bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs)
	{
	return !(_Lhs == _Rhs);
	}

inline bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs)
	{
	return !(_Lhs == _Rhs);
	}

inline exception_ptr current_exception()
	{
	return exception_ptr::_Current_exception();
	}

inline void rethrow_exception(  exception_ptr _P)
	{
	_P._RethrowException();
	}

template <class _E> void *__GetExceptionInfo(_E);

template<class _E> exception_ptr make_exception_ptr(_E _Except)
	{
	return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
	}
}







 
 #pragma warning(pop)
 #pragma pack(pop)

#line 556 "d:\\programs overflow\\vc\\include\\exception"
#line 557 "d:\\programs overflow\\vc\\include\\exception"





#line 7 "d:\\programs overflow\\vc\\include\\stdexcept"
#line 1 "d:\\programs overflow\\vc\\include\\xstring"

#pragma once



#line 1 "d:\\programs overflow\\vc\\include\\xmemory0"

#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\limits"

#pragma once



#line 1 "d:\\programs overflow\\vc\\include\\ymath.h"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 

  

 
 
extern "C" {
 #line 18 "d:\\programs overflow\\vc\\include\\ymath.h"
 #line 19 "d:\\programs overflow\\vc\\include\\ymath.h"

		





		






void __cdecl _Feraise(int);

typedef union
	{	
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		
__declspec(dllimport) double __cdecl _Cosh(double, double);
__declspec(dllimport) double __cdecl _Divide(double, double);
__declspec(dllimport) short __cdecl _Dtest(double *);
__declspec(dllimport) double __cdecl _Log(double, int);
__declspec(dllimport) double __cdecl _Recip(double);
__declspec(dllimport) double __cdecl _Sin(double, unsigned int);
__declspec(dllimport) double __cdecl _Sinx(double, unsigned int, int);
__declspec(dllimport) double __cdecl _Sinh(double, double);

__declspec(dllimport) short __cdecl _Exp(double *, double, short);
extern __declspec(dllimport)  _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		
__declspec(dllimport) float __cdecl _FCosh(float, float);
__declspec(dllimport) float __cdecl _FDivide(float, float);
__declspec(dllimport) short __cdecl _FDtest(float *);
__declspec(dllimport) float __cdecl _FLog(float, int);
__declspec(dllimport) float __cdecl _FRecip(float);
__declspec(dllimport) float __cdecl _FSin(float, unsigned int);
__declspec(dllimport) float __cdecl _FSinx(float, unsigned int, int);
__declspec(dllimport) float __cdecl _FSinh(float, float);

__declspec(dllimport) short __cdecl _FExp(float *, float, short);
extern __declspec(dllimport)  _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		
__declspec(dllimport) long double __cdecl _LCosh(long double, long double);
__declspec(dllimport) long double __cdecl _LDivide(long double, long double);
__declspec(dllimport) short __cdecl _LDtest(long double *);
__declspec(dllimport) long double __cdecl _LLog(long double, int);
__declspec(dllimport) long double __cdecl _LRecip(long double);
__declspec(dllimport) long double __cdecl _LSin(long double, unsigned int);
__declspec(dllimport) long double __cdecl _LSinx(long double, unsigned int, int);
__declspec(dllimport) long double __cdecl _LSinh(long double, long double);

__declspec(dllimport) short __cdecl _LExp(long double *, long double, short);
extern __declspec(dllimport)  _Dconst _LDenorm, _LInf, _LNan, _LSnan;

 
 
}
 #line 87 "d:\\programs overflow\\vc\\include\\ymath.h"
 #line 88 "d:\\programs overflow\\vc\\include\\ymath.h"

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 94 "d:\\programs overflow\\vc\\include\\ymath.h"
#line 95 "d:\\programs overflow\\vc\\include\\ymath.h"





#line 7 "d:\\programs overflow\\vc\\include\\limits"
#line 1 "d:\\programs overflow\\vc\\include\\cfloat"

#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\float.h"















#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "d:\\programs overflow\\vc\\include\\float.h"
#line 1 "d:\\programs overflow\\vc\\include\\crtwrn.h"











#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 18 "d:\\programs overflow\\vc\\include\\crtwrn.h"














































#line 65 "d:\\programs overflow\\vc\\include\\crtwrn.h"
#line 23 "d:\\programs overflow\\vc\\include\\float.h"








#line 32 "d:\\programs overflow\\vc\\include\\float.h"

#line 34 "d:\\programs overflow\\vc\\include\\float.h"
#line 35 "d:\\programs overflow\\vc\\include\\float.h"
#line 36 "d:\\programs overflow\\vc\\include\\float.h"


extern "C" {
#line 40 "d:\\programs overflow\\vc\\include\\float.h"





















#line 62 "d:\\programs overflow\\vc\\include\\float.h"





#line 68 "d:\\programs overflow\\vc\\include\\float.h"


#line 71 "d:\\programs overflow\\vc\\include\\float.h"
#line 72 "d:\\programs overflow\\vc\\include\\float.h"













































 __declspec(dllimport) unsigned int __cdecl _clearfp(void);
#pragma warning(push)
#pragma warning(disable: 4141)
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) unsigned int __cdecl _controlfp(  unsigned int _NewValue,  unsigned int _Mask);
#pragma warning(pop)
 __declspec(dllimport) void __cdecl _set_controlfp(  unsigned int _NewValue,   unsigned int _Mask);
 __declspec(dllimport) errno_t __cdecl _controlfp_s(  unsigned int *_CurrentState,   unsigned int _NewValue,   unsigned int _Mask);
 __declspec(dllimport) unsigned int __cdecl _statusfp(void);
 __declspec(dllimport) void __cdecl _fpreset(void);


 __declspec(dllimport) void __cdecl _statusfp2(  unsigned int *_X86_status,   unsigned int *_SSE2_status);
#line 130 "d:\\programs overflow\\vc\\include\\float.h"






































































#line 201 "d:\\programs overflow\\vc\\include\\float.h"

 __declspec(dllimport) unsigned int __cdecl _control87(  unsigned int _NewValue,  unsigned int _Mask);

 __declspec(dllimport) int __cdecl __control87_2(  unsigned int _NewValue,   unsigned int _Mask,
                                    unsigned int* _X86_cw,   unsigned int* _Sse2_cw);
#line 207 "d:\\programs overflow\\vc\\include\\float.h"



  __declspec(dllimport) extern int * __cdecl __fpecode(void);






























  __declspec(dllimport) double __cdecl _copysign(  double _Number,   double _Sign);
  __declspec(dllimport) double __cdecl _chgsign(  double _X);
  __declspec(dllimport) double __cdecl _scalb(  double _X,   long _Y);
  __declspec(dllimport) double __cdecl _logb(  double _X);
  __declspec(dllimport) double __cdecl _nextafter(  double _X,   double _Y);
  __declspec(dllimport) int    __cdecl _finite(  double _X);
  __declspec(dllimport) int    __cdecl _isnan(  double _X);
  __declspec(dllimport) int    __cdecl _fpclass(  double _X);

























 __declspec(dllimport) void __cdecl fpreset(void);





























































#line 337 "d:\\programs overflow\\vc\\include\\float.h"


}
#line 341 "d:\\programs overflow\\vc\\include\\float.h"

#line 343 "d:\\programs overflow\\vc\\include\\float.h"
#line 8 "d:\\programs overflow\\vc\\include\\cfloat"
#line 9 "d:\\programs overflow\\vc\\include\\cfloat"





#line 8 "d:\\programs overflow\\vc\\include\\limits"


#line 1 "d:\\programs overflow\\vc\\include\\cwchar"

#pragma once










 #line 1 "d:\\programs overflow\\vc\\include\\wchar.h"

















#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 24 "d:\\programs overflow\\vc\\include\\wchar.h"

#pragma pack(push,8)


extern "C" {
#line 30 "d:\\programs overflow\\vc\\include\\wchar.h"































































typedef unsigned long _fsize_t; 

#line 96 "d:\\programs overflow\\vc\\include\\wchar.h"



struct _wfinddata32_t {
        unsigned    attrib;
        __time32_t  time_create;    
        __time32_t  time_access;    
        __time32_t  time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

struct _wfinddata32i64_t {
        unsigned    attrib;
        __time32_t  time_create;    
        __time32_t  time_access;    
        __time32_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

struct _wfinddata64i32_t {
        unsigned    attrib;
        __time64_t  time_create;    
        __time64_t  time_access;    
        __time64_t  time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

struct _wfinddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    
        __time64_t  time_access;    
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};



















#line 154 "d:\\programs overflow\\vc\\include\\wchar.h"


#line 157 "d:\\programs overflow\\vc\\include\\wchar.h"





































#line 195 "d:\\programs overflow\\vc\\include\\wchar.h"

#line 197 "d:\\programs overflow\\vc\\include\\wchar.h"
#line 198 "d:\\programs overflow\\vc\\include\\wchar.h"

__declspec(dllimport) const unsigned short * __cdecl __pctype_func(void);

__declspec(dllimport) extern const unsigned short *_pctype;


#line 205 "d:\\programs overflow\\vc\\include\\wchar.h"
#line 206 "d:\\programs overflow\\vc\\include\\wchar.h"
#line 207 "d:\\programs overflow\\vc\\include\\wchar.h"





__declspec(dllimport) extern const unsigned short _wctype[];
#line 214 "d:\\programs overflow\\vc\\include\\wchar.h"








__declspec(dllimport) const wctype_t * __cdecl __pwctype_func(void);

__declspec(dllimport) extern const wctype_t *_pwctype;


#line 228 "d:\\programs overflow\\vc\\include\\wchar.h"
#line 229 "d:\\programs overflow\\vc\\include\\wchar.h"
#line 230 "d:\\programs overflow\\vc\\include\\wchar.h"







                                
















  __declspec(dllimport) int __cdecl iswalpha(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswalpha_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswupper(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswupper_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswlower(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswlower_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswdigit(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswdigit_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswxdigit(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswxdigit_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswspace(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswspace_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswpunct(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswpunct_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswblank(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswblank_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswalnum(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswalnum_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswprint(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswprint_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswgraph(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswgraph_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswcntrl(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswcntrl_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswascii(  wint_t _C);


  __declspec(dllimport) int __cdecl isleadbyte(  int _C);
  __declspec(dllimport) int __cdecl _isleadbyte_l(  int _C,   _locale_t _Locale);
#line 284 "d:\\programs overflow\\vc\\include\\wchar.h"

  __declspec(dllimport) wint_t __cdecl towupper(  wint_t _C);
  __declspec(dllimport) wint_t __cdecl _towupper_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) wint_t __cdecl towlower(  wint_t _C);
  __declspec(dllimport) wint_t __cdecl _towlower_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iswctype(  wint_t _C,   wctype_t _Type);
  __declspec(dllimport) int __cdecl _iswctype_l(  wint_t _C,   wctype_t _Type,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl __iswcsymf(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswcsymf_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl __iswcsym(  wint_t _C);
  __declspec(dllimport) int __cdecl _iswcsym_l(  wint_t _C,   _locale_t _Locale);


__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "iswctype" " instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(  wint_t _C,   wctype_t _Type);
#line 300 "d:\\programs overflow\\vc\\include\\wchar.h"



#line 304 "d:\\programs overflow\\vc\\include\\wchar.h"












#line 317 "d:\\programs overflow\\vc\\include\\wchar.h"

    __declspec(dllimport) wchar_t * __cdecl _wgetcwd(  wchar_t * _DstBuf,   int _SizeInWords);
    __declspec(dllimport) wchar_t * __cdecl _wgetdcwd(  int _Drive,   wchar_t * _DstBuf,   int _SizeInWords);





#line 326 "d:\\programs overflow\\vc\\include\\wchar.h"

  __declspec(dllimport) int __cdecl _wchdir(  const wchar_t * _Path);

#line 330 "d:\\programs overflow\\vc\\include\\wchar.h"

  __declspec(dllimport) int __cdecl _wmkdir(  const wchar_t * _Path);
  __declspec(dllimport) int __cdecl _wrmdir(  const wchar_t * _Path);


#line 336 "d:\\programs overflow\\vc\\include\\wchar.h"



  __declspec(dllimport) int __cdecl _waccess(  const wchar_t * _Filename,   int _AccessMode);
 __declspec(dllimport) errno_t __cdecl _waccess_s(  const wchar_t * _Filename,   int _AccessMode);
  __declspec(dllimport) int __cdecl _wchmod(  const wchar_t * _Filename,   int _Mode);
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wcreat(  const wchar_t * _Filename,   int _PermissionMode);
  __declspec(dllimport) intptr_t __cdecl _wfindfirst32(  const wchar_t * _Filename,   struct _wfinddata32_t * _FindData);
  __declspec(dllimport) int __cdecl _wfindnext32(  intptr_t _FindHandle,   struct _wfinddata32_t * _FindData);
__declspec(dllimport) int __cdecl _wunlink(  const wchar_t * _Filename);
  __declspec(dllimport) int __cdecl _wrename(  const wchar_t * _OldFilename,   const wchar_t * _NewFilename);
__declspec(dllimport) errno_t __cdecl _wmktemp_s(  wchar_t * _TemplateName,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wmktemp( wchar_t *_TemplateName);

  __declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(  const wchar_t * _Filename,   struct _wfinddata32i64_t * _FindData);
  __declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(  const wchar_t * _Filename,   struct _wfinddata64i32_t * _FindData);
  __declspec(dllimport) intptr_t __cdecl _wfindfirst64(  const wchar_t * _Filename,   struct _wfinddata64_t * _FindData);
  __declspec(dllimport) int __cdecl _wfindnext32i64(  intptr_t _FindHandle,   struct _wfinddata32i64_t * _FindData);
  __declspec(dllimport) int __cdecl _wfindnext64i32(  intptr_t _FindHandle,   struct _wfinddata64i32_t * _FindData);
  __declspec(dllimport) int __cdecl _wfindnext64(  intptr_t _FindHandle,   struct _wfinddata64_t * _FindData);

 __declspec(dllimport) errno_t __cdecl _wsopen_s(  int * _FileHandle,   const wchar_t * _Filename,   int _OpenFlag,   int _ShareFlag,   int _PermissionFlag);






#line 366 "d:\\programs overflow\\vc\\include\\wchar.h"


extern "C++" __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wopen(  const wchar_t * _Filename,   int _OpenFlag,   int _PermissionMode = 0);
extern "C++" __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wsopen(  const wchar_t * _Filename,   int _OpenFlag,   int _ShareFlag, int _PermissionMode = 0);

#line 372 "d:\\programs overflow\\vc\\include\\wchar.h"


#line 375 "d:\\programs overflow\\vc\\include\\wchar.h"





 __declspec(dllimport) wchar_t * __cdecl _wsetlocale(  int _Category,   const wchar_t * _Locale);
 __declspec(dllimport) _locale_t __cdecl _wcreate_locale(  int _Category,   const wchar_t * _Locale);


#line 385 "d:\\programs overflow\\vc\\include\\wchar.h"







__declspec(dllimport) intptr_t __cdecl _wexecl(  const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexecle(  const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexeclp(  const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexeclpe(  const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexecv(  const wchar_t * _Filename,   const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wexecve(  const wchar_t * _Filename,   const wchar_t * const * _ArgList,
          const wchar_t * const * _Env);
__declspec(dllimport) intptr_t __cdecl _wexecvp(  const wchar_t * _Filename,   const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wexecvpe(  const wchar_t * _Filename,   const wchar_t * const * _ArgList,
          const wchar_t * const * _Env);
__declspec(dllimport) intptr_t __cdecl _wspawnl(  int _Mode,   const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnle(  int _Mode,   const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnlp(  int _Mode,   const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnlpe(  int _Mode,   const wchar_t * _Filename,   const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnv(  int _Mode,   const wchar_t * _Filename,   const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wspawnve(  int _Mode,   const wchar_t * _Filename,   const wchar_t * const * _ArgList,
          const wchar_t * const * _Env);
__declspec(dllimport) intptr_t __cdecl _wspawnvp(  int _Mode,   const wchar_t * _Filename,   const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wspawnvpe(  int _Mode,   const wchar_t * _Filename,   const wchar_t * const * _ArgList,
          const wchar_t * const * _Env);






#line 419 "d:\\programs overflow\\vc\\include\\wchar.h"

#line 421 "d:\\programs overflow\\vc\\include\\wchar.h"







#line 429 "d:\\programs overflow\\vc\\include\\wchar.h"



































#line 465 "d:\\programs overflow\\vc\\include\\wchar.h"

#line 467 "d:\\programs overflow\\vc\\include\\wchar.h"






typedef unsigned short _ino_t;      


typedef unsigned short ino_t;
#line 478 "d:\\programs overflow\\vc\\include\\wchar.h"

#line 480 "d:\\programs overflow\\vc\\include\\wchar.h"


typedef unsigned int _dev_t;        


typedef unsigned int dev_t;
#line 487 "d:\\programs overflow\\vc\\include\\wchar.h"

#line 489 "d:\\programs overflow\\vc\\include\\wchar.h"


typedef long _off_t;                


typedef long off_t;
#line 496 "d:\\programs overflow\\vc\\include\\wchar.h"

#line 498 "d:\\programs overflow\\vc\\include\\wchar.h"



struct _stat32 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
        };



struct stat {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#line 532 "d:\\programs overflow\\vc\\include\\wchar.h"

struct _stat32i64 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        __int64    st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
        };

struct _stat64i32 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

struct _stat64 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        __int64    st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };























#line 598 "d:\\programs overflow\\vc\\include\\wchar.h"



#line 602 "d:\\programs overflow\\vc\\include\\wchar.h"





__declspec(dllimport) int __cdecl _wstat32(  const wchar_t * _Name,   struct _stat32 * _Stat);

__declspec(dllimport) int __cdecl _wstat32i64(  const wchar_t * _Name,   struct _stat32i64 * _Stat);
__declspec(dllimport) int __cdecl _wstat64i32(  const wchar_t * _Name,   struct _stat64i32 * _Stat);
__declspec(dllimport) int __cdecl _wstat64(  const wchar_t * _Name,   struct _stat64 * _Stat);


#line 615 "d:\\programs overflow\\vc\\include\\wchar.h"












 __declspec(dllimport) errno_t __cdecl _cgetws_s(  wchar_t * _Buffer, size_t _SizeInWords,   size_t * _SizeRead);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _cgetws_s(  wchar_t (&_Buffer)[_Size], size_t * _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_cgetws_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _cgetws(  wchar_t *_Buffer);
  __declspec(dllimport) wint_t __cdecl _getwch(void);
  __declspec(dllimport) wint_t __cdecl _getwche(void);
  __declspec(dllimport) wint_t __cdecl _putwch(wchar_t _WCh);
  __declspec(dllimport) wint_t __cdecl _ungetwch(wint_t _WCh);
 __declspec(dllimport) int __cdecl _cputws(  const wchar_t * _String);
 __declspec(dllimport) int __cdecl _cwprintf(    const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _cwprintf_s(    const wchar_t * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _cwscanf(    const wchar_t * _Format, ...);
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _cwscanf_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _cwscanf_s(    const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _cwscanf_s_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
 __declspec(dllimport) int __cdecl _vcwprintf(    const wchar_t *_Format, va_list _ArgList);
 __declspec(dllimport) int __cdecl _vcwprintf_s(    const wchar_t *_Format, va_list _ArgList);

 __declspec(dllimport) int __cdecl _cwprintf_p(    const wchar_t * _Format, ...);
 __declspec(dllimport) int __cdecl _vcwprintf_p(    const wchar_t*  _Format, va_list _ArgList);

__declspec(dllimport) int __cdecl _cwprintf_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _cwprintf_s_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vcwprintf_l(    const wchar_t *_Format,   _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vcwprintf_s_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _cwprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vcwprintf_p_l(    const wchar_t * _Format,   _locale_t _Locale, va_list _ArgList);

 wint_t __cdecl _putwch_nolock(wchar_t _WCh);
  wint_t __cdecl _getwch_nolock(void);
  wint_t __cdecl _getwche_nolock(void);
 wint_t __cdecl _ungetwch_nolock(wint_t _WCh);


#line 661 "d:\\programs overflow\\vc\\include\\wchar.h"

#line 663 "d:\\programs overflow\\vc\\include\\wchar.h"



























































































































































































































































































































































































































































































































struct tm {
        int tm_sec;     
        int tm_min;     
        int tm_hour;    
        int tm_mday;    
        int tm_mon;     
        int tm_year;    
        int tm_wday;    
        int tm_yday;    
        int tm_isdst;   
        };

#line 1183 "d:\\programs overflow\\vc\\include\\wchar.h"





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wasctime(  const struct tm * _Tm);
__declspec(dllimport) errno_t __cdecl _wasctime_s(    wchar_t *_Buf,   size_t _SizeInWords,   const struct tm * _Tm);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   const struct tm * _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wctime32(  const __time32_t *_Time);
__declspec(dllimport) errno_t __cdecl _wctime32_s(    wchar_t* _Buf,   size_t _SizeInWords,   const __time32_t * _Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   const __time32_t * _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }

__declspec(dllimport) size_t __cdecl wcsftime(  wchar_t * _Buf,   size_t _SizeInWords,     const wchar_t * _Format,    const struct tm * _Tm);
__declspec(dllimport) size_t __cdecl _wcsftime_l(  wchar_t * _Buf,   size_t _SizeInWords,     const wchar_t *_Format,   const struct tm *_Tm,   _locale_t _Locale);

__declspec(dllimport) errno_t __cdecl _wstrdate_s(    wchar_t * _Buf,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wstrdate( wchar_t *_Buffer);

__declspec(dllimport) errno_t __cdecl _wstrtime_s(    wchar_t * _Buf,   size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wstrtime( wchar_t *_Buffer);

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wctime64(  const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _wctime64_s(    wchar_t* _Buf,   size_t _SizeInWords,   const __time64_t *_Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   const __time64_t * _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }


#line 1 "d:\\programs overflow\\vc\\include\\wtime.inl"












#pragma once







#line 22 "d:\\programs overflow\\vc\\include\\wtime.inl"





#pragma warning(push)
#pragma warning(disable:4996)















static __inline wchar_t * __cdecl _wctime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _wctime64(_Time);
#pragma warning( pop )
}

static __inline errno_t __cdecl _wctime_s(      wchar_t *_Buffer, size_t _SizeInWords, const time_t * _Time)
{
    return _wctime64_s(_Buffer, _SizeInWords, _Time);
}
#line 57 "d:\\programs overflow\\vc\\include\\wtime.inl"

#pragma warning(pop)

#line 61 "d:\\programs overflow\\vc\\include\\wtime.inl"
#line 62 "d:\\programs overflow\\vc\\include\\wtime.inl"
#line 1213 "d:\\programs overflow\\vc\\include\\wchar.h"
#line 1214 "d:\\programs overflow\\vc\\include\\wchar.h"


#line 1217 "d:\\programs overflow\\vc\\include\\wchar.h"


typedef int mbstate_t;
typedef wchar_t _Wint_t;

__declspec(dllimport) wint_t __cdecl btowc(int);
__declspec(dllimport) size_t __cdecl mbrlen(    const char * _Ch,   size_t _SizeInBytes,
                                mbstate_t * _State);
__declspec(dllimport) size_t __cdecl mbrtowc(    wchar_t * _DstCh,     const char * _SrcCh,
                                 size_t _SizeInBytes,   mbstate_t * _State);
__declspec(dllimport) errno_t __cdecl mbsrtowcs_s(  size_t* _Retval,   wchar_t * _Dst,   size_t _Size,     const char ** _PSrc,   size_t _N,   mbstate_t * _State);
extern "C++" { template <size_t _Size> inline errno_t __cdecl mbsrtowcs_s(  size_t * _Retval,   wchar_t (&_Dest)[_Size],     const char ** _PSource,   size_t _Count,   mbstate_t * _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl mbsrtowcs(  wchar_t *_Dest,  const char ** _PSrc,  size_t _Count,  mbstate_t * _State);

__declspec(dllimport) errno_t __cdecl wcrtomb_s(  size_t * _Retval,   char * _Dst,
          size_t _SizeInBytes,   wchar_t _Ch,   mbstate_t * _State);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcrtomb_s(  size_t * _Retval,   char (&_Dest)[_Size],   wchar_t _Source,   mbstate_t * _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb(  char *_Dest,  wchar_t _Source,  mbstate_t * _State);
__declspec(dllimport) errno_t __cdecl wcsrtombs_s(  size_t * _Retval,   char * _Dst,
          size_t _SizeInBytes,     const wchar_t ** _Src,   size_t _Size,   mbstate_t * _State);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsrtombs_s(  size_t * _Retval,   char (&_Dest)[_Size],     const wchar_t ** _PSrc,   size_t _Count,   mbstate_t * _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs(  char *_Dest,  const wchar_t ** _PSource,  size_t _Count,  mbstate_t * _State);
__declspec(dllimport) int __cdecl wctob(  wint_t _WCh);




__declspec(dllimport)  void *  __cdecl memmove(  void * _Dst,   const void * _Src,   size_t _Size);

 

void *  __cdecl memcpy(  void * _Dst,   const void * _Src,   size_t _Size);

__declspec(dllimport) errno_t __cdecl memcpy_s(  void * _Dst,   rsize_t _DstSize,   const void * _Src,   rsize_t _MaxCount);
__declspec(dllimport) errno_t __cdecl memmove_s(  void * _Dst,   rsize_t _DstSize,   const void * _Src,   rsize_t _MaxCount);
#line 1253 "d:\\programs overflow\\vc\\include\\wchar.h"
__inline int __cdecl fwide(  FILE * _F, int _M)
        {(void)_F; return (_M); }
__inline int __cdecl mbsinit(  const mbstate_t *_P)
        {return (_P == 0 || *_P == 0); }
__inline const wchar_t * __cdecl wmemchr(  const wchar_t *_S,   wchar_t _C,   size_t _N)
        {for (; 0 < _N; ++_S, --_N)
                if (*_S == _C)
                        return (const wchar_t *)(_S);
        return (0); }
__inline int __cdecl wmemcmp(  const wchar_t *_S1,   const wchar_t *_S2,   size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }

 

__inline  wchar_t * __cdecl wmemcpy(  wchar_t *_S1,   const wchar_t *_S2,   size_t _N)
        {
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
            return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning( pop )
        }

__inline  wchar_t * __cdecl wmemmove(  wchar_t *_S1,   const wchar_t *_S2,   size_t _N)
        {
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
#pragma warning( disable : 6387)
                        
            return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning( pop )
        }


errno_t __cdecl wmemcpy_s(  wchar_t *_S1,   rsize_t _N1,   const wchar_t *_S2, rsize_t _N);
errno_t __cdecl wmemmove_s(  wchar_t *_S1,   rsize_t _N1,   const wchar_t *_S2,   rsize_t _N);
#line 1292 "d:\\programs overflow\\vc\\include\\wchar.h"

 

__inline wchar_t * __cdecl wmemset(  wchar_t *_S,   wchar_t _C,   size_t _N)
        {
            wchar_t *_Su = _S;
            for (; 0 < _N; ++_Su, --_N)
            {
                *_Su = _C;
            }
            return (_S);
        }


extern "C++" {
inline wchar_t * __cdecl wmemchr(  wchar_t *_S,   wchar_t _C,   size_t _N)
        { return (wchar_t *)wmemchr((const wchar_t *)_S, _C, _N); }
}
#line 1311 "d:\\programs overflow\\vc\\include\\wchar.h"
#line 1312 "d:\\programs overflow\\vc\\include\\wchar.h"


}       
#line 1316 "d:\\programs overflow\\vc\\include\\wchar.h"

#pragma pack(pop)

#line 1320 "d:\\programs overflow\\vc\\include\\wchar.h"

#line 14 "d:\\programs overflow\\vc\\include\\cwchar"
#line 15 "d:\\programs overflow\\vc\\include\\cwchar"

typedef mbstate_t _Mbstatet;

 
namespace std {
using :: _Mbstatet;

using :: mbstate_t; using :: size_t; using :: tm; using :: wint_t;

using :: btowc; using :: fgetwc; using :: fgetws; using :: fputwc;
using :: fputws; using :: fwide; using :: fwprintf;
using :: fwscanf; using :: getwc; using :: getwchar;
using :: mbrlen; using :: mbrtowc; using :: mbsrtowcs;
using :: mbsinit; using :: putwc; using :: putwchar;
using :: swprintf; using :: swscanf; using :: ungetwc;
using :: vfwprintf; using :: vswprintf; using :: vwprintf;
using :: wcrtomb; using :: wprintf; using :: wscanf;
using :: wcsrtombs; using :: wcstol; using :: wcscat;
using :: wcschr; using :: wcscmp; using :: wcscoll;
using :: wcscpy; using :: wcscspn; using :: wcslen;
using :: wcsncat; using :: wcsncmp; using :: wcsncpy;
using :: wcspbrk; using :: wcsrchr; using :: wcsspn;
using :: wcstod; using :: wcstoul; using :: wcsstr;
using :: wcstok; using :: wcsxfrm; using :: wctob;
using :: wmemchr; using :: wmemcmp; using :: wmemcpy;
using :: wmemmove; using :: wmemset; using :: wcsftime;

using :: vfwscanf; using :: vswscanf; using :: vwscanf;
using :: wcstof; using :: wcstold;
using :: wcstoll; using :: wcstoull;
}
 #line 47 "d:\\programs overflow\\vc\\include\\cwchar"

#line 49 "d:\\programs overflow\\vc\\include\\cwchar"





#line 11 "d:\\programs overflow\\vc\\include\\limits"


 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {








 

		
typedef enum
	{	
	denorm_indeterminate = -1,
	denorm_absent = 0,
	denorm_present = 1}
		float_denorm_style;

		
typedef enum
	{	
	round_indeterminate = -1,
	round_toward_zero = 0,
	round_to_nearest = 1,
	round_toward_infinity = 2,
	round_toward_neg_infinity = 3}
		float_round_style;

		
struct _Num_base
	{	
	static const float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
	static const bool has_denorm_loss = (bool)(false);
	static const bool has_infinity = (bool)(false);
	static const bool has_quiet_NaN = (bool)(false);
	static const bool has_signaling_NaN = (bool)(false);
	static const bool is_bounded = (bool)(false);
	static const bool is_exact = (bool)(false);
	static const bool is_iec559 = (bool)(false);
	static const bool is_integer = (bool)(false);
	static const bool is_modulo = (bool)(false);
	static const bool is_signed = (bool)(false);
	static const bool is_specialized = (bool)(false);
	static const bool tinyness_before = (bool)(false);
	static const bool traps = (bool)(false);
	static const float_round_style round_style = (float_round_style)(round_toward_zero);
	static const int digits = (int)(0);
	static const int digits10 = (int)(0);

	static const int max_digits10 = (int)(0);

	static const int max_exponent = (int)(0);
	static const int max_exponent10 = (int)(0);
	static const int min_exponent = (int)(0);
	static const int min_exponent10 = (int)(0);
	static const int radix = (int)(0);
	};

		
template<class _Ty>
	class numeric_limits
		: public _Num_base
	{	
public:
	static _Ty (min)() throw ()
		{	
		return (_Ty(0));
		}

	static _Ty (max)() throw ()
		{	
		return (_Ty(0));
		}

	static _Ty lowest() throw ()
		{	
		return ((min)());
		}

	static _Ty epsilon() throw ()
		{	
		return (_Ty(0));
		}

	static _Ty round_error() throw ()
		{	
		return (_Ty(0));
		}

	static _Ty denorm_min() throw ()
		{	
		return (_Ty(0));
		}

	static _Ty infinity() throw ()
		{	
		return (_Ty(0));
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (_Ty(0));
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (_Ty(0));
		}
	};

template<class _Ty>
	class numeric_limits<const _Ty>
		: public numeric_limits<_Ty>
	{	
	};

template<class _Ty>
	class numeric_limits<volatile _Ty>
		: public numeric_limits<_Ty>
	{	
	};

template<class _Ty>
	class numeric_limits<const volatile _Ty>
		: public numeric_limits<_Ty>
	{	
	};

		
struct _Num_int_base
	: public _Num_base
	{	
	static const bool is_bounded = (bool)(true);
	static const bool is_exact = (bool)(true);
	static const bool is_integer = (bool)(true);
	static const bool is_modulo = (bool)(true);
	static const bool is_specialized = (bool)(true);
	static const int radix = (int)(2);
	};

		
struct _Num_float_base
	: public _Num_base
	{	
	static const float_denorm_style has_denorm = (float_denorm_style)(denorm_present);
	static const bool has_denorm_loss = (bool)(true);
	static const bool has_infinity = (bool)(true);
	static const bool has_quiet_NaN = (bool)(true);
	static const bool has_signaling_NaN = (bool)(true);
	static const bool is_bounded = (bool)(true);
	static const bool is_exact = (bool)(false);
	static const bool is_iec559 = (bool)(true);
	static const bool is_integer = (bool)(false);
	static const bool is_modulo = (bool)(false);
	static const bool is_signed = (bool)(true);
	static const bool is_specialized = (bool)(true);
	static const bool tinyness_before = (bool)(true);
	static const bool traps = (bool)(false);
	static const float_round_style round_style = (float_round_style)(round_to_nearest);
	static const int radix = (int)(2);
	};

		
template<> class numeric_limits<char>
	: public _Num_int_base
	{	
public:
	typedef char _Ty;

	static _Ty (min)() throw ()
		{	
		return ((-128));
		}

	static _Ty (max)() throw ()
		{	
		return (127);
		}

	static _Ty lowest() throw ()
		{	
		return ((min)());
		}

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)((-128) != 0);
	static const int digits = (int)(8 - ((-128) != 0 ? 1 : 0));
	static const int digits10 = (int)((8 - ((-128) != 0 ? 1 : 0)) * 301L / 1000);
#line 237 "d:\\programs overflow\\vc\\include\\limits"
	};

		
template<> class numeric_limits<wchar_t>
	: public _Num_int_base
	{	
public:
	typedef wchar_t _Ty;

	static _Ty (min)() throw ()
		{	
		return ((_Ty)0x0000);
		}

	static _Ty (max)() throw ()
		{	
		return ((_Ty)0xffff);
		}

	static _Ty lowest() throw ()
		{	
		return ((min)());
		}

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(0x0000 != 0);
	static const int digits = (int)(8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0));
#line 294 "d:\\programs overflow\\vc\\include\\limits"
	static const int digits10 = (int)((8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0)) * 301L / 1000);
#line 296 "d:\\programs overflow\\vc\\include\\limits"
	};

		
template<> class numeric_limits<_Bool>
	: public _Num_int_base
	{	
public:
	typedef bool _Ty;

	static _Ty (min)() throw ()
		{	
		return (false);
		}

	static _Ty (max)() throw ()
		{	
		return (true);
		}

	static _Ty lowest() throw ()
		{	
		return ((min)());
		}

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_modulo = (bool)(false);
	static const bool is_signed = (bool)(false);
	static const int digits = (int)(1);
	static const int digits10 = (int)(0);
	};

		
template<> class numeric_limits<signed char>
	: public _Num_int_base
	{	
public:
	typedef signed char _Ty;

	static _Ty (min)() throw ()
		{	
		return ((-128));
		}

	static _Ty (max)() throw ()
		{	
		return (127);
		}

	static _Ty lowest() throw ()
		{	
		return ((min)());
		}

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(true);
	static const int digits = (int)(8 - 1);
	static const int digits10 = (int)((8 - 1) * 301L / 1000);
	};

		
template<> class numeric_limits<unsigned char>
	: public _Num_int_base
	{	
public:
	typedef unsigned char _Ty;

	static _Ty (min)() throw ()
		{	
		return (0);
		}

	static _Ty (max)() throw ()
		{	
		return (0xff);
		}

	static _Ty lowest() throw ()
		{	
		return ((min)());
		}

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(false);
	static const int digits = (int)(8);
	static const int digits10 = (int)(8 * 301L / 1000);
	};

		
template<> class numeric_limits<short>
	: public _Num_int_base
	{	
public:
	typedef short _Ty;

	static _Ty (min)() throw ()
		{	
		return ((-32768));
		}

	static _Ty (max)() throw ()
		{	
		return (32767);
		}

	static _Ty lowest() throw ()
		{	
		return ((min)());
		}

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(true);
	static const int digits = (int)(8 * sizeof (short) - 1);
	static const int digits10 = (int)((8 * sizeof (short) - 1) * 301L / 1000);
#line 526 "d:\\programs overflow\\vc\\include\\limits"
	};

 
		
template<> class numeric_limits<unsigned short>
	: public _Num_int_base
	{	
public:
	typedef unsigned short _Ty;

	static _Ty (min)() throw ()
		{	
		return (0);
		}

	static _Ty (max)() throw ()
		{	
		return (0xffff);
		}

	static _Ty lowest() throw ()
		{	
		return ((min)());
		}

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(false);
	static const int digits = (int)(8 * sizeof (unsigned short));
	static const int digits10 = (int)(8 * sizeof (unsigned short) * 301L / 1000);
#line 585 "d:\\programs overflow\\vc\\include\\limits"
	};
 #line 587 "d:\\programs overflow\\vc\\include\\limits"

 

























































#line 647 "d:\\programs overflow\\vc\\include\\limits"

		
template<> class numeric_limits<int>
	: public _Num_int_base
	{	
public:
	typedef int _Ty;

	static _Ty (min)() throw ()
		{	
		return ((-2147483647 - 1));
		}

	static _Ty (max)() throw ()
		{	
		return (2147483647);
		}

	static _Ty lowest() throw ()
		{	
		return ((min)());
		}

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(true);
	static const int digits = (int)(8 * sizeof (int) - 1);
	static const int digits10 = (int)((8 * sizeof (int) - 1) * 301L / 1000);
#line 704 "d:\\programs overflow\\vc\\include\\limits"
	};

		
template<> class numeric_limits<unsigned int>
	: public _Num_int_base
	{	
public:
	typedef unsigned int _Ty;

	static _Ty (min)() throw ()
		{	
		return (0);
		}

	static _Ty (max)() throw ()
		{	
		return (0xffffffff);
		}

	static _Ty lowest() throw ()
		{	
		return ((min)());
		}

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(false);
	static const int digits = (int)(8 * sizeof (unsigned int));
	static const int digits10 = (int)(8 * sizeof (unsigned int) * 301L / 1000);
#line 762 "d:\\programs overflow\\vc\\include\\limits"
	};

		
template<> class numeric_limits<long>
	: public _Num_int_base
	{	
public:
	typedef long _Ty;

	static _Ty (min)() throw ()
		{	
		return ((-2147483647L - 1));
		}

	static _Ty (max)() throw ()
		{	
		return (2147483647L);
		}

	static _Ty lowest() throw ()
		{	
		return ((min)());
		}

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(true);
	static const int digits = (int)(8 * sizeof (long) - 1);
	static const int digits10 = (int)((8 * sizeof (long) - 1) * 301L / 1000);
#line 820 "d:\\programs overflow\\vc\\include\\limits"
	};

		
template<> class numeric_limits<unsigned long>
	: public _Num_int_base
	{	
public:
	typedef unsigned long _Ty;

	static _Ty (min)() throw ()
		{	
		return (0);
		}

	static _Ty (max)() throw ()
		{	
		return (0xffffffffUL);
		}

	static _Ty lowest() throw ()
		{	
		return ((min)());
		}

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(false);
	static const int digits = (int)(8 * sizeof (unsigned long));
	static const int digits10 = (int)(8 * sizeof (unsigned long) * 301L / 1000);
#line 878 "d:\\programs overflow\\vc\\include\\limits"
	};

 

























































#line 939 "d:\\programs overflow\\vc\\include\\limits"

 
		
template<> class numeric_limits<__int64>
	: public _Num_int_base
	{	
public:
	typedef __int64 _Ty;

	static _Ty (min)() throw ()
		{	
		return (-0x7fffffffffffffff - 1);
		}

	static _Ty (max)() throw ()
		{	
		return (0x7fffffffffffffff);
		}

	static _Ty lowest() throw ()
		{	
		return ((min)());
		}

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(true);
	static const int digits = (int)(8 * sizeof (__int64) - 1);
	static const int digits10 = (int)((8 * sizeof (__int64) - 1) * 301L / 1000);
#line 997 "d:\\programs overflow\\vc\\include\\limits"
	};

		
template<> class numeric_limits<unsigned __int64>
	: public _Num_int_base
	{	
public:
	typedef unsigned __int64 _Ty;

	static _Ty (min)() throw ()
		{	
		return (0);
		}

	static _Ty (max)() throw ()
		{	
		return (0xffffffffffffffff);
		}

	static _Ty lowest() throw ()
		{	
		return ((min)());
		}

	static _Ty epsilon() throw ()
		{	
		return (0);
		}

	static _Ty round_error() throw ()
		{	
		return (0);
		}

	static _Ty denorm_min() throw ()
		{	
		return (0);
		}

	static _Ty infinity() throw ()
		{	
		return (0);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (0);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (0);
		}

	static const bool is_signed = (bool)(false);
	static const int digits = (int)(8 * sizeof (unsigned __int64));
	static const int digits10 = (int)(8 * sizeof (unsigned __int64) * 301L / 1000);
#line 1055 "d:\\programs overflow\\vc\\include\\limits"
	};
 #line 1057 "d:\\programs overflow\\vc\\include\\limits"

		
template<> class numeric_limits<float>
	: public _Num_float_base
	{	
public:
	typedef float _Ty;

	static _Ty (min)() throw ()
		{	
		return (1.175494351e-38F);
		}

	static _Ty (max)() throw ()
		{	
		return (3.402823466e+38F);
		}

	static _Ty lowest() throw ()
		{	
		return (-(max)());
		}

	static _Ty epsilon() throw ()
		{	
		return (1.192092896e-07F);
		}

	static _Ty round_error() throw ()
		{	
		return (0.5);
		}

	static _Ty denorm_min() throw ()
		{	
		return (:: _FDenorm._Float);
		}

	static _Ty infinity() throw ()
		{	
		return (:: _FInf._Float);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (:: _FNan._Float);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (:: _FSnan._Float);
		}

	static const int digits = (int)(24);
	static const int digits10 = (int)(6);

	static const int max_digits10 = (int)(2 + 24 * 301L / 1000);

	static const int max_exponent = (int)((int)128);
	static const int max_exponent10 = (int)((int)38);
	static const int min_exponent = (int)((int)(-125));
	static const int min_exponent10 = (int)((int)(-37));
	};

		
template<> class numeric_limits<double>
	: public _Num_float_base
	{	
public:
	typedef double _Ty;

	static _Ty (min)() throw ()
		{	
		return (2.2250738585072014e-308);
		}

	static _Ty (max)() throw ()
		{	
		return (1.7976931348623158e+308);
		}

	static _Ty lowest() throw ()
		{	
		return (-(max)());
		}

	static _Ty epsilon() throw ()
		{	
		return (2.2204460492503131e-016);
		}

	static _Ty round_error() throw ()
		{	
		return (0.5);
		}

	static _Ty denorm_min() throw ()
		{	
		return (:: _Denorm._Double);
		}

	static _Ty infinity() throw ()
		{	
		return (:: _Inf._Double);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (:: _Nan._Double);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (:: _Snan._Double);
		}

	static const int digits = (int)(53);
	static const int digits10 = (int)(15);

	static const int max_digits10 = (int)(2 + 53 * 301L / 1000);

	static const int max_exponent = (int)((int)1024);
	static const int max_exponent10 = (int)((int)308);
	static const int min_exponent = (int)((int)(-1021));
	static const int min_exponent10 = (int)((int)(-307));
	};

		
template<> class numeric_limits<long double>
	: public _Num_float_base
	{	
public:
	typedef long double _Ty;

	static _Ty (min)() throw ()
		{	
		return (2.2250738585072014e-308);
		}

	static _Ty (max)() throw ()
		{	
		return (1.7976931348623158e+308);
		}

	static _Ty lowest() throw ()
		{	
		return (-(max)());
		}

	static _Ty epsilon() throw ()
		{	
		return (2.2204460492503131e-016);
		}

	static _Ty round_error() throw ()
		{	
		return (0.5);
		}

	static _Ty denorm_min() throw ()
		{	
		return (:: _LDenorm._Long_double);
		}

	static _Ty infinity() throw ()
		{	
		return (:: _LInf._Long_double);
		}

	static _Ty quiet_NaN() throw ()
		{	
		return (:: _LNan._Long_double);
		}

	static _Ty signaling_NaN() throw ()
		{	
		return (:: _LSnan._Long_double);
		}

	static const int digits = (int)(53);
	static const int digits10 = (int)(15);

	static const int max_digits10 = (int)(2 + 53 * 301L / 1000);

	static const int max_exponent = (int)((int)1024);
	static const int max_exponent10 = (int)((int)308);
	static const int min_exponent = (int)((int)(-1021));
	static const int min_exponent10 = (int)((int)(-307));
	};

  













































































































































































































#line 1454 "d:\\programs overflow\\vc\\include\\limits"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1459 "d:\\programs overflow\\vc\\include\\limits"
#line 1460 "d:\\programs overflow\\vc\\include\\limits"






#line 8 "d:\\programs overflow\\vc\\include\\xmemory0"
#line 1 "d:\\programs overflow\\vc\\include\\new"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 

  








#line 22 "d:\\programs overflow\\vc\\include\\new"

namespace std {

		
 




typedef void (__cdecl * new_handler) ();
#line 33 "d:\\programs overflow\\vc\\include\\new"
 #line 34 "d:\\programs overflow\\vc\\include\\new"

 
struct nothrow_t
	{	
	};

extern const nothrow_t nothrow;	
 #line 42 "d:\\programs overflow\\vc\\include\\new"

		
__declspec(dllimport) new_handler __cdecl set_new_handler(  new_handler)
	throw ();	

__declspec(dllimport) new_handler __cdecl get_new_handler()
	throw ();	
}

		
void __cdecl operator delete(void *) throw ();
#pragma warning (suppress: 4985)
    void *__cdecl operator new(size_t _Size) throw (...);

 
  
inline void *__cdecl operator new(size_t, void *_Where) throw ()
	{	
	return (_Where);
	}

inline void __cdecl operator delete(void *, void *) throw ()
	{	
	}
 #line 67 "d:\\programs overflow\\vc\\include\\new"

 
  
inline void *__cdecl operator new[](size_t, void *_Where) throw ()
	{	
	return (_Where);
	}

inline void __cdecl operator delete[](void *, void *) throw ()
	{	
	}
 #line 79 "d:\\programs overflow\\vc\\include\\new"

void __cdecl operator delete[](void *) throw ();	

    void *__cdecl operator new[](size_t _Size)
	throw (...);	

 
  
    void *__cdecl operator new(size_t _Size, const ::std:: nothrow_t&)
	throw ();

    void *__cdecl operator new[](size_t _Size, const ::std:: nothrow_t&)
	throw ();	

void __cdecl operator delete(void *, const ::std:: nothrow_t&)
	throw ();	

void __cdecl operator delete[](void *, const ::std:: nothrow_t&)
	throw ();	
 #line 99 "d:\\programs overflow\\vc\\include\\new"


 
using ::std:: new_handler;
 #line 104 "d:\\programs overflow\\vc\\include\\new"

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 110 "d:\\programs overflow\\vc\\include\\new"
#line 111 "d:\\programs overflow\\vc\\include\\new"





#line 9 "d:\\programs overflow\\vc\\include\\xmemory0"
#line 1 "d:\\programs overflow\\vc\\include\\xutility"

#pragma once





#line 1 "d:\\programs overflow\\vc\\include\\utility"

#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\iosfwd"

#pragma once








#line 1 "d:\\programs overflow\\vc\\include\\crtdbg.h"












#pragma once

#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 16 "d:\\programs overflow\\vc\\include\\crtdbg.h"




#pragma pack(push,8)














extern "C" {
#line 37 "d:\\programs overflow\\vc\\include\\crtdbg.h"

 





typedef void *_HFILE; 























#line 69 "d:\\programs overflow\\vc\\include\\crtdbg.h"


typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);
typedef int (__cdecl * _CRT_REPORT_HOOKW)(int, wchar_t *, int *);



#line 77 "d:\\programs overflow\\vc\\include\\crtdbg.h"




#line 82 "d:\\programs overflow\\vc\\include\\crtdbg.h"




 





 










typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);


#line 107 "d:\\programs overflow\\vc\\include\\crtdbg.h"


#line 110 "d:\\programs overflow\\vc\\include\\crtdbg.h"

 





































 














typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);


#line 168 "d:\\programs overflow\\vc\\include\\crtdbg.h"


#line 171 "d:\\programs overflow\\vc\\include\\crtdbg.h"

struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        size_t lCounts[5];
        size_t lSizes[5];
        size_t lHighWaterCount;
        size_t lTotalCount;
} _CrtMemState;


 


























































































































































 
































 













__declspec(dllimport) extern long _crtAssertBusy;
#line 387 "d:\\programs overflow\\vc\\include\\crtdbg.h"


__declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(
    void
    );
#line 393 "d:\\programs overflow\\vc\\include\\crtdbg.h"






__declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
      _CRT_REPORT_HOOK _PFnNewHook
        );

__declspec(dllimport) int __cdecl _CrtSetReportHook2(
          int _Mode,
          _CRT_REPORT_HOOK _PFnNewHook
        );

__declspec(dllimport) int __cdecl _CrtSetReportHookW2(
          int _Mode,
          _CRT_REPORT_HOOKW _PFnNewHook
        );
#line 413 "d:\\programs overflow\\vc\\include\\crtdbg.h"

__declspec(dllimport) int __cdecl _CrtSetReportMode(
          int _ReportType,
          int _ReportMode
        );

__declspec(dllimport) _HFILE __cdecl _CrtSetReportFile(
          int _ReportType,
          _HFILE _ReportFile
        );

__declspec(dllimport) int __cdecl _CrtDbgReport(
          int _ReportType,
          const char * _Filename,
          int _Linenumber,
          const char * _ModuleName,
          const char * _Format,
        ...);

__declspec(dllimport) size_t __cdecl _CrtSetDebugFillThreshold(
          size_t _NewDebugFillThreshold
        );



#line 439 "d:\\programs overflow\\vc\\include\\crtdbg.h"
__declspec(dllimport) int __cdecl _CrtDbgReportW(
          int _ReportType,
          const wchar_t * _Filename,
          int _LineNumber,
          const wchar_t * _ModuleName,
          const wchar_t * _Format,
        ...);










#line 457 "d:\\programs overflow\\vc\\include\\crtdbg.h"



#line 461 "d:\\programs overflow\\vc\\include\\crtdbg.h"







#line 469 "d:\\programs overflow\\vc\\include\\crtdbg.h"



























































































#line 561 "d:\\programs overflow\\vc\\include\\crtdbg.h"

 


























































__declspec(dllimport) extern long _crtBreakAlloc;      
#line 623 "d:\\programs overflow\\vc\\include\\crtdbg.h"

__declspec(dllimport) long __cdecl _CrtSetBreakAlloc(
          long _BreakAlloc
        );





      __declspec(dllimport) void * __cdecl _malloc_dbg(
          size_t _Size,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

      __declspec(dllimport) void * __cdecl _calloc_dbg(
          size_t _Count,
          size_t _Size,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

 
      __declspec(dllimport) void * __cdecl _realloc_dbg(
            void * _Memory,
          size_t _NewSize,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

 
      __declspec(dllimport) void * __cdecl _recalloc_dbg
(
            void * _Memory,
          size_t _NumOfElements,
          size_t _SizeOfElements,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
);

      __declspec(dllimport) void * __cdecl _expand_dbg(
          void * _Memory,
          size_t _NewSize,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

__declspec(dllimport) void __cdecl _free_dbg(
            void * _Memory,
          int _BlockType
        );

__declspec(dllimport) size_t __cdecl _msize_dbg (
          void * _Memory,
          int _BlockType
        );

__declspec(dllimport) size_t __cdecl _aligned_msize_dbg (
          void * _Memory,
          size_t _Alignment,
          size_t _Offset
        );

      __declspec(dllimport) void * __cdecl _aligned_malloc_dbg(
          size_t _Size,
          size_t _Alignment,
          const char * _Filename,
          int _LineNumber
        );

 
      __declspec(dllimport) void * __cdecl _aligned_realloc_dbg(
            void * _Memory,
          size_t _NewSize,
          size_t _Alignment,
          const char * _Filename,
          int _LineNumber
        );

 
      __declspec(dllimport) void * __cdecl _aligned_recalloc_dbg
(
            void * _Memory,
          size_t _NumOfElements,
          size_t _SizeOfElements,
          size_t _Alignment,
          const char * _Filename,
          int _LineNumber
);

      __declspec(dllimport) void * __cdecl _aligned_offset_malloc_dbg(
          size_t _Size,
          size_t _Alignment,
          size_t _Offset,
          const char * _Filename,
          int _LineNumber
        );

 
      __declspec(dllimport) void * __cdecl _aligned_offset_realloc_dbg(
            void * _Memory,
          size_t _NewSize,
          size_t _Alignment,
          size_t _Offset,
          const char * _Filename,
          int _LineNumber
        );

 
      __declspec(dllimport) void * __cdecl _aligned_offset_recalloc_dbg
(
            void * _Memory,
          size_t _NumOfElements,
          size_t _SizeOfElements,
          size_t _Alignment,
          size_t _Offset,
          const char * _Filename,
          int _LineNumber
);

__declspec(dllimport) void __cdecl _aligned_free_dbg(
            void * _Memory
        );

    __declspec(dllimport) char * __cdecl _strdup_dbg(
          const char * _Str,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

    __declspec(dllimport) wchar_t * __cdecl _wcsdup_dbg(
          const wchar_t * _Str,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

    __declspec(dllimport) char * __cdecl _tempnam_dbg(
          const char * _DirName,
          const char * _FilePrefix,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

    __declspec(dllimport) wchar_t * __cdecl _wtempnam_dbg(
          const wchar_t * _DirName,
          const wchar_t * _FilePrefix,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

    __declspec(dllimport) char * __cdecl _fullpath_dbg(
          char * _FullPath,
          const char * _Path,
          size_t _SizeInBytes,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

    __declspec(dllimport) wchar_t * __cdecl _wfullpath_dbg(
          wchar_t * _FullPath,
          const wchar_t * _Path,
          size_t _SizeInWords,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

    __declspec(dllimport) char * __cdecl _getcwd_dbg(
          char * _DstBuf,
          int _SizeInBytes,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

    __declspec(dllimport) wchar_t * __cdecl _wgetcwd_dbg(
          wchar_t * _DstBuf,
          int _SizeInWords,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

    __declspec(dllimport) char * __cdecl _getdcwd_dbg(
          int _Drive,
          char * _DstBuf,
          int _SizeInBytes,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

    __declspec(dllimport) wchar_t * __cdecl _wgetdcwd_dbg(
          int _Drive,
          wchar_t * _DstBuf,
          int _SizeInWords,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

    char * __cdecl _getdcwd_lk_dbg(
          int _Drive,
          char * _DstBuf,
          int _SizeInBytes,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

    wchar_t * __cdecl _wgetdcwd_lk_dbg(
          int _Drive,
          wchar_t * _DstBuf,
          int _SizeInWords,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

 __declspec(dllimport) errno_t __cdecl _dupenv_s_dbg(
            char ** _PBuffer,
          size_t * _PBufferSizeInBytes,
          const char * _VarName,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );

 __declspec(dllimport) errno_t __cdecl _wdupenv_s_dbg(
            wchar_t ** _PBuffer,
          size_t * _PBufferSizeInWords,
          const wchar_t * _VarName,
          int _BlockType,
          const char * _Filename,
          int _LineNumber
        );









#line 879 "d:\\programs overflow\\vc\\include\\crtdbg.h"

 





__declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook
(
    void
);
#line 891 "d:\\programs overflow\\vc\\include\\crtdbg.h"






__declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook
(
      _CRT_ALLOC_HOOK _PfnNewHook
);
#line 902 "d:\\programs overflow\\vc\\include\\crtdbg.h"

 


















__declspec(dllimport) extern int _crtDbgFlag;
#line 924 "d:\\programs overflow\\vc\\include\\crtdbg.h"

__declspec(dllimport) int __cdecl _CrtCheckMemory(
        void
        );

__declspec(dllimport) int __cdecl _CrtSetDbgFlag(
          int _NewFlag
        );

__declspec(dllimport) void __cdecl _CrtDoForAllClientObjects(
          void (__cdecl *_PFn)(void *, void *),
        void * _Context
        );

  __declspec(dllimport) int __cdecl _CrtIsValidPointer(
          const void * _Ptr,
          unsigned int _Bytes,
          int _ReadWrite
        );

  __declspec(dllimport) int __cdecl _CrtIsValidHeapPointer(
          const void * _HeapPtr
        );

__declspec(dllimport) int __cdecl _CrtIsMemoryBlock(
          const void * _Memory,
          unsigned int _Bytes,
          long * _RequestNumber,
          char ** _Filename,
          int * _LineNumber
        );

  __declspec(dllimport) int __cdecl _CrtReportBlockType(
          const void * _Memory
        );


 






__declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient
(
    void
);
#line 973 "d:\\programs overflow\\vc\\include\\crtdbg.h"






__declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient
(
      _CRT_DUMP_CLIENT _PFnNewDump
);
#line 984 "d:\\programs overflow\\vc\\include\\crtdbg.h"

__declspec(dllimport)  void __cdecl _CrtMemCheckpoint(
          _CrtMemState * _State
        );

__declspec(dllimport)  int __cdecl _CrtMemDifference(
          _CrtMemState * _State,
          const _CrtMemState * _OldState,
          const _CrtMemState * _NewState
        );

__declspec(dllimport) void __cdecl _CrtMemDumpAllObjectsSince(
          const _CrtMemState * _State
        );

__declspec(dllimport) void __cdecl _CrtMemDumpStatistics(
          const _CrtMemState * _State
        );

__declspec(dllimport) int __cdecl _CrtDumpMemoryLeaks(
        void
        );

__declspec(dllimport) int __cdecl _CrtSetCheckCount(
          int _CheckCount
        );

__declspec(dllimport) int __cdecl _CrtGetCheckCount(
        void
        );

#line 1016 "d:\\programs overflow\\vc\\include\\crtdbg.h"


}



extern "C++" {






































 







#pragma warning(suppress: 4985)
    void * __cdecl operator new[](size_t _Size);

    void * __cdecl operator new(
        size_t _Size,
        int,
        const char *,
        int
        );

#pragma warning(suppress: 4985)
    void * __cdecl operator new[](
        size_t _Size,
        int,
        const char *,
        int
        );

void __cdecl operator delete[](void *);
void __cdecl operator delete(void * _P, int, const char *, int);
void __cdecl operator delete[](void * _P, int, const char *, int);



















#line 1110 "d:\\programs overflow\\vc\\include\\crtdbg.h"

#line 1112 "d:\\programs overflow\\vc\\include\\crtdbg.h"

}

#line 1116 "d:\\programs overflow\\vc\\include\\crtdbg.h"

#line 1118 "d:\\programs overflow\\vc\\include\\crtdbg.h"


#pragma pack(pop)

#line 1123 "d:\\programs overflow\\vc\\include\\crtdbg.h"

#line 12 "d:\\programs overflow\\vc\\include\\iosfwd"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		

typedef _Longlong streamoff;
typedef _Longlong streamsize;

  
  

  



extern __declspec(dllimport)  const streamoff _BADOFF;
  #line 33 "d:\\programs overflow\\vc\\include\\iosfwd"

		
template<class _Statetype>
	class fpos
	{	
	typedef fpos<_Statetype> _Myt;

public:
	 fpos(streamoff _Off = 0)
		: _Myoff(_Off), _Fpos(0), _Mystate()
		{	
		}

	 fpos(_Statetype _State, fpos_t _Fileposition)
		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
		{	
		}

	_Statetype  state() const
		{	
		return (_Mystate);
		}

	void  state(_Statetype _State)
		{	
		_Mystate = _State;
		}

	fpos_t  seekpos() const
		{	
		return (_Fpos);
		}

	 operator streamoff() const
		{	
		return ((streamoff)(_Myoff + ((long long)(_Fpos))));
		}

	streamoff  operator-(const _Myt& _Right) const
		{	
		return ((streamoff)*this - (streamoff)_Right);
		}

	_Myt&  operator+=(streamoff _Off)
		{	
		_Myoff += _Off;
		return (*this);
		}

	_Myt&  operator-=(streamoff _Off)
		{	
		_Myoff -= _Off;
		return (*this);
		}

	_Myt  operator+(streamoff _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt  operator-(streamoff _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	bool  operator==(const _Myt& _Right) const
		{	
		return ((streamoff)*this == (streamoff)_Right);
		}

	bool  operator==(streamoff _Right) const
		{	
		return ((streamoff)*this == _Right);
		}

	bool  operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

private:
	streamoff _Myoff;	
	fpos_t _Fpos;	
	_Statetype _Mystate;	
	};

 

 
 

typedef fpos<_Mbstatet> streampos;

typedef streampos wstreampos;

		
template<class _Elem,
	class _Int_type>
	struct _Char_traits
	{	
	typedef _Elem char_type;
	typedef _Int_type int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(
		  const _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		for (; 0 < _Count; --_Count, ++_First1, ++_First2)
			if (!eq(*_First1, *_First2))
				return (lt(*_First1, *_First2) ? -1 : +1);
		return (0);
		}

	static size_t __cdecl length(  const _Elem *_First)
		{	
		size_t _Count;
		for (_Count = 0; !eq(*_First, _Elem()); ++_First)
			++_Count;
		return (_Count);
		}

	static _Elem *__cdecl copy(
		  _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		_Elem *_Next = _First1;
		for (; 0 < _Count; --_Count, ++_Next, ++_First2)
			assign(*_Next, *_First2);
		return (_First1);
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Dest_size,
		  const _Elem *_First2, size_t _Count)
		{	
		{ if (!(_Count <= _Dest_size)) { (void) ((!!(("_Count <= _Dest_size" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\iosfwd", 173, 0, L"%s", L"\"_Count <= _Dest_size\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"_Count <= _Dest_size", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\iosfwd", 173, 0); return (0); } };
		return (copy(_First1, _First2, _Count));
		}

	static const _Elem *__cdecl find(
		  const _Elem *_First,
		size_t _Count, const _Elem& _Ch)
		{	
		for (; 0 < _Count; --_Count, ++_First)
			if (eq(*_First, _Ch))
				return (_First);
		return (0);
		}

	static _Elem *__cdecl move(
		  _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		_Elem *_Next = _First1;
		if (_First2 < _Next && _Next < _First2 + _Count)
			for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
				assign(*--_Next, *--_First2);
		else
			for (; 0 < _Count; --_Count, ++_Next, ++_First2)
				assign(*_Next, *_First2);
		return (_First1);
		}

	static _Elem *__cdecl assign(
		  _Elem *_First,
		size_t _Count, _Elem _Ch)
		{	
		_Elem *_Next = _First;
		for (; 0 < _Count; --_Count, ++_Next)
			assign(*_Next, _Ch);
		return (_First);
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) throw ()
		{	
		_Left = _Right;
		}

	static bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return (_Left < _Right);
		}

	static _Elem __cdecl to_char_type(
		const int_type& _Meta) throw ()
		{	
		return ((_Elem)_Meta);
		}

	static int_type __cdecl to_int_type(
		const _Elem& _Ch) throw ()
		{	
		return ((int_type)_Ch);
		}

	static bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static int_type __cdecl not_eof(
		const int_type& _Meta) throw ()
		{	
		return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());
		}

	static int_type __cdecl eof() throw ()
		{	
		return ((int_type)(-1));
		}
	};

		
template<class _Elem>
	struct char_traits
		: public _Char_traits<_Elem, long>
	{	
	};

 

















#line 284 "d:\\programs overflow\\vc\\include\\iosfwd"

		
template<>
	struct char_traits<wchar_t>
	{	
	typedef wchar_t _Elem;
	typedef _Elem char_type;	
	typedef wint_t int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: wmemcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: wcslen(_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemcpy(_First1, _First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_words,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::wmemcpy_s((_First1), (_Size_in_words), (_First2), (_Count));
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: wmemchr(_First, _Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemmove(_First1, _First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: wmemset(_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) throw ()
		{	
		_Left = _Right;
		}

	static bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return (_Left < _Right);
		}

	static _Elem __cdecl to_char_type(
		const int_type& _Meta) throw ()
		{	
		return (_Meta);
		}

	static int_type __cdecl to_int_type(
		const _Elem& _Ch) throw ()
		{	
		return (_Ch);
		}

	static bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static int_type __cdecl not_eof(
		const int_type& _Meta) throw ()
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static int_type __cdecl eof() throw ()
		{	
		return ((wint_t)(0xFFFF));
		}
	};

 
		
template<>
	struct char_traits<unsigned short>
	{	
	typedef unsigned short _Elem;
	typedef _Elem char_type;	
	typedef wint_t int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: wmemcmp((const wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: wcslen((const wchar_t *)_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemcpy((wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_words,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::wmemcpy_s(((wchar_t *)_First1), (_Size_in_words), ((const wchar_t *)_First2), (_Count));
#line 433 "d:\\programs overflow\\vc\\include\\iosfwd"
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: wmemchr((const wchar_t *)_First,
				_Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemmove((wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: wmemset((wchar_t *)_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) throw ()
		{	
		_Left = _Right;
		}

	static bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return (_Left < _Right);
		}

	static _Elem __cdecl to_char_type(const int_type& _Meta) throw ()
		{	
		return (_Meta);
		}

	static int_type __cdecl to_int_type(const _Elem& _Ch) throw ()
		{	
		return (_Ch);
		}

	static bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static int_type __cdecl not_eof(const int_type& _Meta) throw ()
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static int_type __cdecl eof() throw ()
		{	
		return ((wint_t)(0xFFFF));
		}
	};
 #line 502 "d:\\programs overflow\\vc\\include\\iosfwd"

		
template<> struct char_traits<char>
	{	
	typedef char _Elem;
	typedef _Elem char_type;
	typedef int int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: memcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: strlen(_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: memcpy(_First1, _First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_bytes,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::memcpy_s((_First1), (_Size_in_bytes), (_First2), (_Count));
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: memchr(_First, _Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: memmove(_First1, _First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: memset(_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) throw ()
		{	
		_Left = _Right;
		}

	static bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) throw ()
		{	
		return ((unsigned char)_Left < (unsigned char)_Right);
		}

	static _Elem __cdecl to_char_type(
		const int_type& _Meta) throw ()
		{	
		return ((_Elem)_Meta);
		}

	static int_type __cdecl to_int_type(
		const _Elem& _Ch) throw ()
		{	
		return ((unsigned char)_Ch);
		}

	static bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) throw ()
		{	
		return (_Left == _Right);
		}

	static int_type __cdecl not_eof(
		const int_type& _Meta) throw ()
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static int_type __cdecl eof() throw ()
		{	
		return ((-1));
		}
	};

		
template<class _Ty>
	class allocator;
class ios_base;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ios;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class istreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class ostreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_streambuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_istream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ostream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_iostream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringbuf;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_istringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_ostringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_filebuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ifstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ofstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_fstream;

 
template<class _Elem,
	class _InIt >
	class num_get;
template<class _Elem,
	class _OutIt >
	class num_put;
template<class _Elem>
	class collate;
 #line 673 "d:\\programs overflow\\vc\\include\\iosfwd"

		
typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
	allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
	allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
	allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
	allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;

		
typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
	wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;

 





















 
typedef num_get<char, istreambuf_iterator<char, char_traits<char> > >
	numget;
typedef num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >
	wnumget;
typedef num_put<char, ostreambuf_iterator<char, char_traits<char> > >
	numput;
typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >
	wnumput;
typedef collate<char> ncollate;
typedef collate<wchar_t> wcollate;
 #line 747 "d:\\programs overflow\\vc\\include\\iosfwd"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 753 "d:\\programs overflow\\vc\\include\\iosfwd"
#line 754 "d:\\programs overflow\\vc\\include\\iosfwd"





#line 8 "d:\\programs overflow\\vc\\include\\utility"
#line 1 "d:\\programs overflow\\vc\\include\\type_traits"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
 #pragma warning(disable: 4180 4296)

	

 		
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  


		



namespace std {
	
template<class _Ty>
	struct _Ptr_traits
	{	
	};

template<class _Ty>
	struct _Ptr_traits<_Ty *>
	{	
	static const bool _Is_const = false;
	static const bool _Is_volatile = false;
	};

template<class _Ty>
	struct _Ptr_traits<const _Ty *>
	{	
	static const bool _Is_const = true;
	static const bool _Is_volatile = false;
	};

template<class _Ty>
	struct _Ptr_traits<volatile _Ty *>
	{	
	static const bool _Is_const = false;
	static const bool _Is_volatile = true;
	};

template<class _Ty>
	struct _Ptr_traits<const volatile _Ty *>
	{	
	static const bool _Is_const = true;
	static const bool _Is_volatile = true;
	};

template<class _Ty>
	struct _Is_funptr
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_memfunptr
		: false_type
	{	
	};









template<class _Ret, class... _Types> struct _Is_funptr<_Ret (__cdecl *)(_Types...)> : true_type { }; template<class _Ret, class... _Types> struct _Is_funptr<_Ret (__stdcall *)(_Types...)> : true_type { }; template<class _Ret, class... _Types> struct _Is_funptr<_Ret (__fastcall *)(_Types...)> : true_type { };











template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) > : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) > : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) > : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) > : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile> : true_type { };


template<class _Ret,
	class... _Types>
	struct _Is_funptr<_Ret (*)(_Types..., ...)>
		: true_type
	{	
	};










template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> : true_type { };


	
	
template<class _Ty>
	struct add_const
	{	
	typedef const _Ty type;
	};

	
template<class _Ty>
	struct add_volatile
	{	
	typedef volatile _Ty type;
	};

	
template<class _Ty>
	struct add_cv
	{	
	typedef const volatile _Ty type;
	};

	
template<class _Ty>
	struct add_reference
	{	
	typedef _Ty& type;
	};








template<> struct add_reference< void> { typedef  void type; }; template<> struct add_reference<const void> { typedef const void type; }; template<> struct add_reference<volatile void> { typedef volatile void type; }; template<> struct add_reference<const volatile void> { typedef const volatile void type; };


	
template<class _Ty>
	struct add_lvalue_reference
	{	
	typedef typename add_reference<_Ty>::type type;
	};

	

template<class _Ty>
	struct add_rvalue_reference
	{	
	typedef _Ty&& type;
	};








template<> struct add_rvalue_reference< void> { typedef  void type; }; template<> struct add_rvalue_reference<const void> { typedef const void type; }; template<> struct add_rvalue_reference<volatile void> { typedef volatile void type; }; template<> struct add_rvalue_reference<const volatile void> { typedef const volatile void type; };


	
template<class _Ty>
	typename add_rvalue_reference<_Ty>::type
		declval() throw ();

	
template<class _Ty>
	struct remove_extent
	{	
	typedef _Ty type;
	};

template<class _Ty, unsigned int _Ix>
	struct remove_extent<_Ty[_Ix]>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_extent<_Ty[]>
	{	
	typedef _Ty type;
	};

	
template<class _Ty>
	struct remove_all_extents
	{	
	typedef _Ty type;
	};

template<class _Ty, unsigned int _Ix>
	struct remove_all_extents<_Ty[_Ix]>
	{	
	typedef typename remove_all_extents<_Ty>::type type;
	};

template<class _Ty>
	struct remove_all_extents<_Ty[]>
	{	
	typedef typename remove_all_extents<_Ty>::type type;
	};

	
template<class _Ty>
	struct remove_pointer
	{	
	typedef _Ty type;
	};








template<class _Ty> struct remove_pointer<_Ty *> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *volatile> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const volatile> { typedef _Ty type; };


	
template<class _Ty>
	struct add_pointer
	{	
	typedef typename remove_reference<_Ty>::type *type;
	};

	
	
template<class _Ty>
	struct _Is_void
		: false_type
	{	
	};

template<>
	struct _Is_void<void>
		: true_type
	{	
	};

template<class _Ty>
	struct is_void
		: _Is_void<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct is_array
		: false_type
	{	
	};

template<class _Ty, size_t _Nx>
	struct is_array<_Ty[_Nx]>
		: true_type
	{	
	};

template<class _Ty>
	struct is_array<_Ty[]>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_lvalue_reference
		: false_type
	{	
	};

template<class _Ty>
	struct is_lvalue_reference<_Ty&>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_rvalue_reference
		: false_type
	{	
	};

template<class _Ty>
	struct is_rvalue_reference<_Ty&&>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_reference
		: _Cat_base<is_lvalue_reference<_Ty>::value
		|| is_rvalue_reference<_Ty>::value>
	{	
	};


	
template<class _Ty>
	struct _Is_member_object_pointer
		: false_type
	{	
	};

template<class _Ty1, class _Ty2>
	struct _Is_member_object_pointer<_Ty1 _Ty2::*>
		: _Cat_base<!_Is_memfunptr<_Ty1 _Ty2::*>::value>
	{	
	};

template<class _Ty>
	struct is_member_object_pointer
		: _Is_member_object_pointer<typename remove_cv<_Ty>::type>
	{	
	};

	
template<class _Ty>
	struct is_member_function_pointer
		: _Cat_base<_Is_memfunptr<typename remove_cv<_Ty>::type>::value>
	{	
	};

	
template<class _Ty>
	struct _Is_pointer
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_pointer<_Ty *>
		: _Cat_base<!is_member_object_pointer<_Ty *>::value
		&& !is_member_function_pointer<_Ty *>::value>
	{	
	};

template<class _Ty>
	struct is_pointer
		: _Is_pointer<typename remove_cv<_Ty>::type>
	{	
	};

	

template<class _Ty>
	struct _Is_nullptr_t
		: _Cat_base<is_same<typename remove_cv<_Ty>::type, nullptr_t>::value>
	{	
	};

	
template<class _Ty>
	struct is_union : _Cat_base<__is_union(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_class : _Cat_base<__is_class(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_function
		: _Cat_base<_Is_funptr<typename remove_cv<_Ty>::type *>::value>
	{	
	};

template<class _Ty>
	struct is_function<_Ty&>
		: false_type
	{	
	};

template<class _Ty>
	struct is_function<_Ty&&>
		: false_type
	{	
	};

	
template<class _Ty>
	struct is_arithmetic
		: _Cat_base<is_integral<_Ty>::value
		|| is_floating_point<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_fundamental
		: _Cat_base<is_arithmetic<_Ty>::value
		|| is_void<_Ty>::value
		|| _Is_nullptr_t<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_object
		: _Cat_base<!is_function<_Ty>::value
		&& !is_reference<_Ty>::value
		&& !is_void<_Ty>::value>
	{	
	};

	

template<class _From, class _To>
	struct is_convertible
		: _Cat_base<__is_convertible_to(_From, _To)>
	{	
	};

	
template<class _Ty>
	struct is_enum
		: _Cat_base<__is_enum(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_compound
		: _Cat_base<!is_fundamental<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_member_pointer
		: _Cat_base<is_member_object_pointer<_Ty>::value
		|| is_member_function_pointer<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_scalar
		: _Cat_base<is_arithmetic<_Ty>::value
		|| is_enum<_Ty>::value
		|| is_pointer<_Ty>::value
		|| is_member_pointer<_Ty>::value
		|| _Is_nullptr_t<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_const
		: _Cat_base<_Ptr_traits<_Ty *>::_Is_const
		&& !is_function<_Ty>::value>
	{	
	};

template<class _Ty, unsigned int _Nx>
	struct is_const<_Ty[_Nx]>
		: false_type
	{	
	};

template<class _Ty, unsigned int _Nx>
	struct is_const<const _Ty[_Nx]>
		: true_type
	{	
	};

template<class _Ty>
	struct is_const<_Ty&>
		: false_type
	{	
	};

template<class _Ty>
	struct is_const<_Ty&&>
		: false_type
	{	
	};

	
template<class _Ty>
	struct is_volatile
		: _Cat_base<_Ptr_traits<_Ty *>::_Is_volatile
		&& !is_function<_Ty>::value>
	{	
	};

template<class _Ty>
	struct is_volatile<_Ty&>
		: false_type
	{	
	};

template<class _Ty>
	struct is_volatile<_Ty&&>
		: false_type
	{	
	};

	
template<class _Ty>
	struct is_pod : _Cat_base<__is_pod(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_empty : _Cat_base<__is_empty(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_polymorphic : _Cat_base<__is_polymorphic(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_abstract : _Cat_base<__is_abstract(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_standard_layout : _Cat_base<__is_standard_layout(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_literal_type : _Cat_base<__is_literal_type(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_trivial : _Cat_base<__is_trivial(_Ty)>
	{	
	};

	
template<class _Ty>
	struct has_virtual_destructor
		: _Cat_base<__has_virtual_destructor(_Ty)>
	{	
	};

		
	


template<class _Ty,
	class... _Args>
	struct is_constructible
		: _Cat_base<__is_constructible(_Ty, _Args...)>
	{	
	};


	

template<class _Ty>
	struct is_copy_constructible
		: is_constructible<
			_Ty,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct has_copy_constructor
		: is_copy_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_default_constructible
		: is_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct has_default_constructor
		: is_default_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_move_constructible
		: is_constructible<

			_Ty,

			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct has_move_constructor
		: is_move_constructible<_Ty>::type
	{	
	};

	

template<class _To,
	class _From>
	struct _Is_assignable
	{	
	template<class _Dest,
		class _Src>
		static auto _Fn(int)
			-> decltype((::std:: declval<_Dest>() = ::std:: declval<_Src>()),
				true_type());

	template<class _Dest,
		class _Src>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_To, _From>(0)) type;
	};

template<class _To,
	class _From>
	struct is_assignable
		: _Is_assignable<_To, _From>::type

	{	
	};

	

template<class _Ty>
	struct is_copy_assignable
		: is_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct has_copy_assign
		: is_copy_assignable<_Ty>::type
	{	
	};

	

template<class _Ty>
	struct is_move_assignable
		: is_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

template<class _Ty>
	struct has_move_assign
		: is_move_assignable<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_destructible
		: _Cat_base<__is_destructible(_Ty)>
	{	
	};

		
	


template<class _Ty,
	class... _Args>
	struct is_trivially_constructible
		: _Cat_base<__is_trivially_constructible(_Ty, _Args...)>
	{	
	};


	
template<class _Ty>
	struct is_trivially_copy_constructible

		: is_trivially_constructible<
			_Ty,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type

	{	
	};

	
template<class _Ty>
	struct is_trivially_copyable
		: is_trivially_copy_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct has_trivial_copy_constructor
		: is_trivially_copy_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_default_constructible
		: is_trivially_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct has_trivial_default_constructor
		: is_trivially_default_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_move_constructible

		: is_trivially_constructible<
			_Ty,
			typename add_rvalue_reference<_Ty>::type
		>::type

	{	
	};

	
template<class _Ty>
	struct has_trivial_move_constructor
		: is_trivially_move_constructible<_Ty>::type
	{	
	};

	
template<class _To,
	class _From>
	struct is_trivially_assignable

		: _Cat_base<__is_trivially_assignable(_To, _From)>

	{	
	};

	
template<class _Ty>
	struct is_trivially_copy_assignable

		: is_trivially_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type

	{	
	};

	
template<class _Ty>
	struct has_trivial_copy_assign
		: is_trivially_copy_assignable<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_move_assignable

		: is_trivially_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_rvalue_reference<_Ty>::type
		>::type

	{	
	};

	
template<class _Ty>
	struct has_trivial_move_assign
		: is_trivially_move_assignable<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_destructible
		: _Cat_base<__has_trivial_destructor(_Ty)>
	{	
	};

		
	


template<class _Ty,
	class... _Args>
	struct is_nothrow_constructible
		: _Cat_base<__is_nothrow_constructible(_Ty, _Args...)>
	{	
	};


	

template<class _Ty>
	struct is_nothrow_copy_constructible
		: is_nothrow_constructible<
			_Ty,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct has_nothrow_copy_constructor

		: is_nothrow_copy_constructible<_Ty>::type

	{	
	};

	
template<class _Ty>
	struct is_nothrow_default_constructible
		: is_nothrow_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct has_nothrow_default_constructor
		: is_nothrow_default_constructible<_Ty>::type
	{	
	};

	

template<class _Ty>
	struct is_nothrow_move_constructible
		: is_nothrow_constructible<
			_Ty,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct has_nothrow_move_constructor
		: is_nothrow_move_constructible<_Ty>::type
	{	
	};

	
template<class _To,
	class _From>
	struct is_nothrow_assignable

		: _Cat_base<__is_nothrow_assignable(_To, _From)>

	{	
	};

	
template<class _Ty>
	struct is_nothrow_copy_assignable

		: is_nothrow_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type

	{	
	};

	
template<class _Ty>
	struct has_nothrow_copy_assign
		: is_nothrow_copy_assignable<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_move_assignable

		: is_nothrow_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_rvalue_reference<_Ty>::type
		>::type

	{	
	};

	
template<class _Ty>
	struct has_nothrow_move_assign
		: is_nothrow_move_assignable<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_destructible

		: _Cat_base<__is_nothrow_destructible(_Ty)>

	{	
	};

	
template<class _Ty>
	struct has_trivial_constructor

		: is_trivially_default_constructible<_Ty>::type

	{	
	};

	
template<class _Ty>
	struct has_trivial_copy

		: is_trivially_copy_constructible<_Ty>::type

	{	
	};

	
template<class _Ty>
	struct has_trivial_assign

		: is_trivially_copy_assignable<_Ty>::type

	{	
	};

	
template<class _Ty>
	struct has_trivial_destructor

		: is_trivially_destructible<_Ty>::type

	{	
	};

	
template<class _Ty>
	struct has_nothrow_constructor

		: is_nothrow_default_constructible<_Ty>::type

	{	
	};

	
template<class _Ty>
	struct has_nothrow_copy

		: is_nothrow_copy_constructible<_Ty>::type

	{	
	};

	
template<class _Ty>
	struct has_nothrow_assign

		: is_nothrow_copy_assignable<_Ty>::type

	{	
	};

	
template<class _Ty>
	struct _Has_signed_vals
		: _Cat_base<(typename remove_cv<_Ty>::type)(-1)
		< (typename remove_cv<_Ty>::type)(0)>
	{	
	};

template<class _Ty>
	struct is_signed
		: _Cat_base<is_floating_point<_Ty>::value || (is_integral<_Ty>::value
		&& _Has_signed_vals<
			typename _If<is_integral<_Ty>::value, _Ty, int>::type>::value)>
	{	
	};

	
template<class _Ty>
	struct is_unsigned
		: _Cat_base<is_integral<_Ty>::value
		&& !_Has_signed_vals<
			typename _If<is_integral<_Ty>::value, _Ty, int>::type>::value>
	{	
	};

	
template<class _Ty>
	struct _Change_sign
	{	
	static_assert(
		((is_integral<_Ty>::value || is_enum<_Ty>::value)
			&& !is_same<_Ty, bool>::value),
		"make_signed<T>/make_unsigned<T> require that T shall be a (possibly "
		"cv-qualified) integral type or enumeration but not a bool type.");

	typedef
		typename _If<is_same<_Ty, signed char>::value
			|| is_same<_Ty, unsigned char     >::value, signed char,
		typename _If<is_same<_Ty, short       >::value
			|| is_same<_Ty, unsigned short    >::value, short,
		typename _If<is_same<_Ty, int         >::value
			|| is_same<_Ty, unsigned int      >::value, int,
		typename _If<is_same<_Ty, long        >::value
			|| is_same<_Ty, unsigned long     >::value, long,
		typename _If<is_same<_Ty, long long   >::value
			|| is_same<_Ty, unsigned long long>::value, long long,
		typename _If<sizeof (_Ty) == sizeof (signed char), signed char,
		typename _If<sizeof (_Ty) == sizeof (short      ), short,
		typename _If<sizeof (_Ty) == sizeof (int        ), int,
		typename _If<sizeof (_Ty) == sizeof (long       ), long,
			long long
		>::type>::type>::type>::type>::type>::type>::type>::type>::type
			_Signed;

	typedef
		typename _If<is_same<_Signed, signed char>::value, unsigned char,
		typename _If<is_same<_Signed, short      >::value, unsigned short,
		typename _If<is_same<_Signed, int        >::value, unsigned int,
		typename _If<is_same<_Signed, long       >::value, unsigned long,
			unsigned long long
		>::type>::type>::type>::type
			_Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const _Ty>
	{	
	typedef const typename _Change_sign<_Ty>::_Signed _Signed;
	typedef const typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

template<class _Ty>
	struct _Change_sign<volatile _Ty>
	{	
	typedef volatile typename _Change_sign<_Ty>::_Signed _Signed;
	typedef volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const volatile _Ty>
	{	
	typedef const volatile typename _Change_sign<_Ty>::_Signed _Signed;
	typedef const volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

	
template<class _Ty>
	struct make_signed
	{	
	typedef typename _Change_sign<_Ty>::_Signed type;
	};

	
template<class _Ty>
	struct make_unsigned
	{	
	typedef typename _Change_sign<_Ty>::_Unsigned type;
	};

	
 
template<class _Ty>
	struct _Get_align
	{	
	_Ty _Elt0;
	char _Elt1;
	_Ty _Elt2;

	_Get_align();	
	~_Get_align();	
	};


 #line 1182 "d:\\programs overflow\\vc\\include\\type_traits"

template<class _Ty>
	struct alignment_of
		: integral_constant<size_t, (sizeof (_Get_align<typename remove_reference<_Ty>::type>) - 2 * sizeof (typename remove_reference<_Ty>::type))>
	{	
	};

	




template<class _Ty,
	size_t _Len>
	union _Align_type
	{	
	_Ty _Val;
	char _Pad[_Len];
	};

template<size_t _Len,
	size_t _Align,
	class _Ty,
	bool _Ok>
	struct _Aligned;

template<size_t _Len,
	size_t _Align,
	class _Ty>
	struct _Aligned<_Len, _Align, _Ty, true>
	{	
	typedef _Align_type<_Ty, _Len> type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, double, false>
	{	
	typedef _Align_type<max_align_t, _Len> type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, int, false>
	{	
	typedef typename _Aligned<_Len, _Align, double, _Align <= alignment_of<double>::value>::type type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, short, false>
	{	
	typedef typename _Aligned<_Len, _Align, int, _Align <= alignment_of<int>::value>::type type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, char, false>
	{	
	typedef typename _Aligned<_Len, _Align, short, _Align <= alignment_of<short>::value>::type type;
	};

template<size_t _Len,
	size_t _Align = alignment_of<max_align_t>::value>
	struct aligned_storage
	{	
	typedef typename _Aligned<_Len, _Align, char, _Align <= alignment_of<char>::value>::type type;
	};




	
template<size_t... _Vals>
	struct _Maximum;

template<>
	struct _Maximum<>
	{	
	static const size_t value = 0;
	};

template<size_t _Val>
	struct _Maximum<_Val>
	{	
	static const size_t value = _Val;
	};

template<size_t _First,
	size_t _Second,
	size_t... _Rest>
	struct _Maximum<_First, _Second, _Rest...>
		: _Maximum<(_First < _Second ? _Second : _First), _Rest...>
	{	
	};

template<size_t _Len,
	class... _Types>
	struct aligned_union
	{	
	static const size_t _Max_len = _Maximum<
		_Len, sizeof(_Types)...>::value;	
	static const size_t alignment_value = _Maximum<
		alignment_of<_Types>::value...>::value;
	typedef typename aligned_storage<_Max_len, alignment_value>::type type;
	};

	
template<class _Ty>
	struct underlying_type
	{	
	typedef __underlying_type(_Ty) type;
	};

	
template<class _Ty>
	struct rank
		: integral_constant<size_t, 0>
	{	
	};

template<class _Ty, unsigned int _Ix>
	struct rank<_Ty[_Ix]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	
	};

template<class _Ty>
	struct rank<_Ty[]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	
	};

	
template<class _Ty, unsigned int _Nx>
	struct _Extent
		: integral_constant<size_t, 0>
	{	
	};

template<class _Ty, unsigned int _Ix>
	struct _Extent<_Ty[_Ix], 0>
		: integral_constant<size_t, _Ix>
	{	
	};

template<class _Ty, unsigned int _Nx, unsigned int _Ix>
	struct _Extent<_Ty[_Ix], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	
	};

template<class _Ty, unsigned int _Nx>
	struct _Extent<_Ty[], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	
	};

template<class _Ty, unsigned int _Nx = 0>
	struct extent
		: _Extent<_Ty, _Nx>
	{	
	};

	
template<class _Base, class _Der>
	struct is_base_of : _Cat_base<__is_base_of(_Base, _Der)>
	{	
	};

	
template<class _Ty>
	struct decay
	{	
	typedef typename remove_reference<_Ty>::type _Ty1;

	typedef typename _If<is_array<_Ty1>::value,
		typename remove_extent<_Ty1>::type *,
		typename _If<is_function<_Ty1>::value,
			typename add_pointer<_Ty1>::type,
			typename remove_cv<_Ty1>::type>::type>::type type;
	};

namespace tr1 {	
using ::std:: add_const;
using ::std:: add_cv;
using ::std:: add_pointer;
using ::std:: add_reference;	
using ::std:: add_volatile;
using ::std:: aligned_storage;
using ::std:: alignment_of;
using ::std:: conditional;
using ::std:: decay;
using ::std:: enable_if;
using ::std:: extent;
using ::std:: false_type;
using ::std:: has_nothrow_assign;	
using ::std:: has_nothrow_constructor;	
using ::std:: has_nothrow_copy;	
using ::std:: has_trivial_assign;
using ::std:: has_trivial_constructor;	
using ::std:: has_trivial_copy;	
using ::std:: has_trivial_destructor;	
using ::std:: has_virtual_destructor;
using ::std:: integral_constant;
using ::std:: is_abstract;
using ::std:: is_arithmetic;
using ::std:: is_array;
using ::std:: is_base_of;
using ::std:: is_class;
using ::std:: is_compound;
using ::std:: is_const;
using ::std:: is_convertible;
using ::std:: is_empty;
using ::std:: is_enum;
using ::std:: is_floating_point;
using ::std:: is_function;
using ::std:: is_fundamental;
using ::std:: is_integral;
using ::std:: is_member_function_pointer;
using ::std:: is_member_object_pointer;
using ::std:: is_member_pointer;
using ::std:: is_object;
using ::std:: is_pod;
using ::std:: is_pointer;
using ::std:: is_polymorphic;
using ::std:: is_reference;
using ::std:: is_same;
using ::std:: is_scalar;
using ::std:: is_signed;
using ::std:: is_union;
using ::std:: is_unsigned;
using ::std:: is_void;
using ::std:: is_volatile;
using ::std:: make_signed;
using ::std:: make_unsigned;
using ::std:: rank;
using ::std:: remove_all_extents;
using ::std:: remove_const;
using ::std:: remove_cv;
using ::std:: remove_extent;
using ::std:: remove_pointer;
using ::std:: remove_reference;
using ::std:: remove_volatile;
using ::std:: true_type;
	}	

		
template<class... _Ty>
	struct common_type;

template<class _Ty>
	struct common_type<_Ty>
	{	
	typedef typename decay<_Ty>::type type;
	};

template<class _Ty0,
	class _Ty1>
	struct common_type<_Ty0, _Ty1>
	{	
	typedef typename decay<
		decltype(_Always_false<_Ty0>::value
			? ::std:: declval<_Ty0>()
			: ::std:: declval<_Ty1>())
	>::type type;
	};

template<class _Ty0,
	class _Ty1,
	class... _Ty>
	struct common_type<_Ty0, _Ty1, _Ty...>
	{	
	typedef typename common_type<
		typename common_type<_Ty0, _Ty1>::type, _Ty...
	>::type type;
	};

	
template<size_t... _Indexes>
	struct _Arg_idx
	{	
	};

	
template<class _Ty>
	class reference_wrapper;

template<class _Ty>
	struct _Unrefwrap_helper
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct _Unrefwrap_helper<reference_wrapper<_Ty> >
	{	
	typedef _Ty& type;
	};

template<class _Ty>
	struct _Unrefwrap
	{	
	typedef typename decay<_Ty>::type _Ty1;
	typedef typename _Unrefwrap_helper<_Ty1>::type type;
	};

	
template<class _Ty>
	struct identity
	{	
	typedef _Ty type;

	const _Ty& operator()(const _Ty& _Left) const
		{	
		return (_Left);
		}
	};

	
template<class _Ty> inline
	_Ty&& forward(typename remove_reference<_Ty>::type& _Arg)
	{	
	return (static_cast<_Ty&&>(_Arg));
	}

template<class _Ty> inline
	_Ty&& forward(typename remove_reference<_Ty>::type&& _Arg) throw ()
	{	
	static_assert(!is_lvalue_reference<_Ty>::value, "bad forward call");
	return (static_cast<_Ty&&>(_Arg));
	}

		
template<class _Ty> inline
	typename remove_reference<_Ty>::type&&
		move(_Ty&& _Arg) throw ()
	{	
	return ((typename remove_reference<_Ty>::type&&)_Arg);
	}

		
template<class _Ty> inline
	typename remove_reference<_Ty>::type&&
		_Move(_Ty&& _Arg) throw ()
	{	
	return ((typename remove_reference<_Ty>::type&&)_Arg);
	}

		
template<class _Ty> inline
	typename _If<!has_nothrow_move_constructor<_Ty>::value
		&& has_copy_constructor<_Ty>::value,
			const _Ty&, _Ty&&>::type
	move_if_noexcept(_Ty& _Arg) throw ()
	{	
	return (::std:: move(_Arg));
	}

	
template<class _Ty> inline
	typename decay<_Ty>::type _Decay_copy(_Ty&& _Arg)
	{	
	return (::std:: forward<_Ty>(_Arg));
	}
}

#line 1 "d:\\programs overflow\\vc\\include\\xrefwrap"

#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4180)

namespace std {
template<class _Ty>
	class reference_wrapper;

	
template<class _Ret,
	class... _Types>
	struct _Fun_class_base
	{	
	};

template<class _Ret,
	class _Farg0>
	struct _Fun_class_base<_Ret, _Farg0>
		: public unary_function<_Farg0, _Ret>
	{	
	};

template<class _Ret,
	class _Farg0,
	class _Farg1>
	struct _Fun_class_base<_Ret, _Farg0, _Farg1>
		: public binary_function<_Farg0, _Farg1, _Ret>
	{	
	};

template<class _Ret,
	class _Farg0,
	class _Farg1,
	class... _Types>
	struct _Fun_class_base<_Ret, _Farg0, _Farg1, _Types...>
	{	
	};




template<class _Fty,
	class... _Args>
	struct _Result_of
	{	
	typedef decltype(
		::std:: declval<_Fty>()(::std:: declval<_Args>()...)) type;
	};














template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* )(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* )(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* )(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* )(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* )(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* )(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* )(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* )(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* )(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* )(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* )(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* )(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* )(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* )(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* )(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* )(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* const)(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* const)(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* const)(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* const)(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* const)(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* const)(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* const)(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* const)(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* const)(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* const)(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* const)(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* const)(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* const)(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* const)(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* const)(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* const)(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; };


template<class _Ret,
	class _Ty,
	class _Obj,
	class... _Args>
	struct _Result_of<_Ret _Ty::*, _Obj, _Args...>
	{	
		
	typedef typename _Copy_cv<_Ret,
		typename remove_pointer<
			typename remove_reference<_Obj>::type>::type>::type type;
	};

template<class _Ret,
	class _Ty,
	class _Obj,
	class... _Args>
	struct _Result_of<_Ret _Ty::*const, _Obj, _Args...>
	{	
		
	typedef typename _Copy_cv<_Ret,
		typename remove_pointer<
			typename remove_reference<_Obj>::type>::type>::type const type;
	};

template<class _Fty>
	struct result_of;	















template<class _Fty, class... _Args> struct result_of<_Fty __cdecl (_Args...)> { typedef typename _Result_of<_Fty, _Args...>::type type; }; template<class _Fty, class... _Args> struct result_of<reference_wrapper<_Fty> __cdecl (_Args...)> { typedef typename _Result_of<_Fty, _Args...>::type type; }; template<class _Fty, class... _Args> struct result_of<_Fty __stdcall (_Args...)> { typedef typename _Result_of<_Fty, _Args...>::type type; }; template<class _Fty, class... _Args> struct result_of<reference_wrapper<_Fty> __stdcall (_Args...)> { typedef typename _Result_of<_Fty, _Args...>::type type; }; template<class _Fty, class... _Args> struct result_of<_Fty __fastcall (_Args...)> { typedef typename _Result_of<_Fty, _Args...>::type type; }; template<class _Fty, class... _Args> struct result_of<reference_wrapper<_Fty> __fastcall (_Args...)> { typedef typename _Result_of<_Fty, _Args...>::type type; };





	
template<class _Ret,
	class _Arg0>
	struct _Pmd_caller
	{	
	template<class _Pmd,
		class _Farg0>
		static _Ret& _Call_pmd(_Pmd _Pm, _Farg0&& _Fx0, true_type)
		{	
		return ((_Ret&)(_Fx0.*_Pm));
		}

	template<class _Pmd,
		class _Farg0>
		static _Ret& _Call_pmd(_Pmd _Pm, _Farg0&& _Fx0, false_type)
		{	
		return ((_Ret&)((*_Fx0).*_Pm));
		}

	template<class _Pmd,
		class _Farg0>
		static _Ret& _Apply_pmd(_Pmd _Pm, _Farg0&& _Fx0)
		{	
		typedef typename remove_cv<
			typename remove_reference<_Arg0>::type>::type _Arg0_bare;
		typedef typename remove_cv<
			typename remove_reference<_Farg0>::type>::type _Farg0_bare;
		typedef _Cat_base<is_same<_Arg0_bare, _Farg0_bare>::value
			|| (is_base_of<_Arg0_bare, _Farg0_bare>::value
				&& is_same<typename add_reference<_Farg0_bare>::type,
					_Farg0>::value)> _Is_obj;

		return (_Call_pmd<_Pmd, _Farg0>(_Pm,
			::std:: forward<_Farg0>(_Fx0), _Is_obj()));
		}
	};

	
template<class _Ty,
	bool _Indirect>
	struct _Callable_base;

template<class _Ty>
	struct _Callable_base<_Ty, false>
	{	
	enum {_EEN_INDIRECT = 0};	
	typedef _Ty _MyTy;
	typedef const _Ty& _MyCnstTy;

	_Callable_base(const _Ty& _Val)
		: _Object(_Val)
		{	
		}

	const _Ty& _Get() const
		{	
		return (_Object);
		}

	_Ty& _Get()
		{	
		return (_Object);
		}

	void _Reset(_Ty& _Val)
		{	
		static_assert(_Always_false<_Ty>::value,
			"can't assign to reference_wrapper<T&>");
		}

private:
	_Callable_base& operator=(const _Callable_base&);

	_Ty _Object;
};

template<class _Ty>
	struct _Callable_base<_Ty, true>
	{	
		
	enum {_EEN_INDIRECT = 1};	
	typedef _Ty _MyTy;
	typedef _Ty& _MyCnstTy;

	_Callable_base(_Ty& _Val)
		: _Ptr(::std:: addressof(_Val))
		{	
		}

	_MyCnstTy _Get() const
		{	
		return (*_Ptr);
		}

	_Ty& _Get()
		{	
		return (*_Ptr);
		}

	void _Reset(_Ty& _Val)
		{	
		_Ptr = ::std:: addressof(_Val);
		}

private:
	_Ty *_Ptr;
};

	
template<class _Ty,
	class _Memty,
	bool _Indirect = false>
	struct _Callable_pmd
		: _Callable_base<_Ty, _Indirect>
	{	
	_Callable_pmd(const _Callable_pmd& _Right)
		: _Callable_base<_Ty, _Indirect>(_Right._Get())
		{	
		}

	_Callable_pmd(_Ty& _Val)
		: _Callable_base<_Ty, _Indirect>(_Val)
		{	
		}

	template<class _Ret,
		class _Arg0>
		_Ret& _ApplyX(_Arg0&& _A0) const
		{	
		return (_Pmd_caller<_Ret, _Memty>::
			_Apply_pmd(this->_Get(), ::std:: forward<_Arg0>(_A0)));
		}
	};

	
template<class _Ty,
	bool _Indirect = false>
	struct _Callable_obj
		: _Callable_base<_Ty, _Indirect>
	{	
	typedef _Callable_base<_Ty, _Indirect> _Mybase;

	template<class _Ty2>
		_Callable_obj(_Ty2&& _Val)
		: _Mybase(::std:: forward<_Ty2>(_Val))
		{	
		}

	template<class _Ret,
		class... _Types>
		_Ret _ApplyX(_Types&&... _Args) const
		{ 
		return (this->_Get()(::std:: forward<_Types>(_Args)...));
		}

	template<class _Ret,
		class... _Types>
		_Ret _ApplyX(_Types&&... _Args)
		{ 
		return (this->_Get()(::std:: forward<_Types>(_Args)...));
		}

	};

	

template<class _Ret,
	class _Arg0>
	struct _Pmf_caller
	{	
	template<class _Pmf,
		class _Farg0,
		class... _Ftypes>
		static _Ret _Call_pmf(_Pmf _Pm, _Farg0&& _Fx0, true_type,
			_Ftypes&&... _Fargs)
		{	
		typedef typename _Copy_cv<_Arg0, _Farg0>::type
			_Funobj_cv;
		return (((_Funobj_cv)_Fx0.*_Pm)(::std:: forward<_Ftypes>(_Fargs)...));
		}

	template<class _Pmf,
		class _Farg0,
		class... _Ftypes>
		static _Ret _Call_pmf(_Pmf _Pm, _Farg0&& _Fx0, false_type,
			_Ftypes&&... _Fargs)
		{	
		return (((*_Fx0).*_Pm)(::std:: forward<_Ftypes>(_Fargs)...));
		}

	template<class _Pmf,
		class _Farg0,
		class... _Ftypes>
		static _Ret _Apply_pmf(_Pmf _Pm, _Farg0&& _Fx0,
			_Ftypes&&... _Fargs)
		{	
		typedef typename remove_reference<_Arg0>::type _Arg0_bare0;
		typedef typename remove_cv<_Arg0_bare0>::type _Arg0_bare;
		typedef typename remove_reference<_Farg0>::type _Farg0_bare;
		typedef _Cat_base<is_same<_Arg0_bare, _Farg0_bare>::value
			|| (is_base_of<_Arg0_bare, _Farg0_bare>::value
				&& is_same<typename add_reference<_Farg0_bare>::type,
					_Farg0>::value)> _Is_obj;

		return (_Call_pmf<_Pmf, _Farg0&&, _Ftypes&&...>(_Pm,
			::std:: forward<_Farg0>(_Fx0), _Is_obj(),
				::std:: forward<_Ftypes>(_Fargs)...));
		}
	};


	
template<class _Ty,
	class _Memty,
	bool _Indirect = false>
	struct _Callable_pmf
		: _Callable_base<_Ty, _Indirect>
	{	
	_Callable_pmf(const _Callable_pmf& _Right)
		: _Callable_base<_Ty, _Indirect>(_Right._Get())
		{	
		}

	_Callable_pmf(_Ty& _Val)
		: _Callable_base<_Ty, _Indirect>(_Val)
		{	
		}

	template<class _Ret,
		class... _Types>
		_Ret _ApplyX(_Types&&... _Args) const
		{ 
		return (_Pmf_caller<_Ret, _Memty>::
			_Apply_pmf(this->_Get(), ::std:: forward<_Types>(_Args)...));
		}

	};

	
template<class _Ty,
	bool _Indirect = false>
	struct _Callable_fun
		: _Callable_base<_Ty, _Indirect>
	{	
	_Callable_fun(const _Callable_fun& _Right)
		: _Callable_base<_Ty, _Indirect>(_Right._Get())
		{	
		}

	_Callable_fun(_Ty& _Val)
		: _Callable_base<_Ty, _Indirect>(_Val)
		{	
		}

	template<class _Ret,
		class... _Types>
		_Ret _ApplyX(_Types&&... _Args) const
		{ 
		return (this->_Get()(::std:: forward<_Types>(_Args)...));
		}

	};

	
template<class _Callable>
	struct _Call_wrapper_base
	{	
	typedef typename _Callable::_MyTy _MyTy;
	typedef typename _Callable::_MyCnstTy _MyCnstTy;

	_Call_wrapper_base(_MyTy& _Val)
		: _Callee(_Val)
		{	
		}

	void _Reset(_MyTy& _Val)
		{	
		_Callee._Reset(_Val);
		}

	_MyCnstTy _Get() const
		{	
		return (_Callee._Get());
		}

	_MyCnstTy _Get()
		{	
		return (_Callee._Get());
		}

	_Callable _Callee;
	};

	
template<class _Callable,
	bool _Is_abstract = false>
	struct _Call_wrapper
	: _Call_wrapper_base<_Callable>
	{	
	typedef _Call_wrapper_base<_Callable> _Mybase;

	_Call_wrapper(typename _Call_wrapper_base<_Callable>::_MyTy& _Val)
		: _Call_wrapper_base<_Callable>(_Val)
		{	
		}

	template<class... _Types>
		typename result_of<
			typename _Callable::_MyTy(_Types...)>::type
			operator()(_Types&&... _Args) const
		{ 
		typedef typename result_of<
			typename _Callable::_MyTy(_Types...)>::type _Ret;
		return (this->_Callee.template _ApplyX<_Ret>(
			::std:: forward<_Types>(_Args)...));
		}

	};

template<class _Callable>
	struct _Call_wrapper<_Callable, true>
	: _Call_wrapper_base<_Callable>
	{	
	typedef _Call_wrapper_base<_Callable> _Mybase;

	_Call_wrapper(typename _Call_wrapper_base<_Callable>::_MyTy& _Val)
		: _Call_wrapper_base<_Callable>(_Val)
		{	
		}
	};

		
template<class _Ty>
	struct _Has_result_and_arg_type
		{ template<class _Uty> static auto _Fn(int, _Identity<typename _Uty::argument_type> * = 0, _Identity<typename _Uty::result_type> * = 0, _Identity<typename _Uty::result_type> * = 0) -> true_type; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };

		
template<class _Ty>
	struct _Has_result_and_2arg_type
		{ template<class _Uty> static auto _Fn(int, _Identity<typename _Uty::first_argument_type> * = 0, _Identity<typename _Uty::second_argument_type> * = 0, _Identity<typename _Uty::result_type> * = 0) -> true_type; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };

	
template<class _Ty,
	bool>
	struct _Refwrap_result0
	{	
	typedef typename _Ty::result_type result_type;
	};

template<class _Ty>
	struct _Refwrap_result0<_Ty, false>
	{	
	};


template<class _Ty,
	bool>
	struct _Refwrap_result1_helper
		: _Refwrap_result0<_Ty, _Has_result_type<_Ty>::type::value>
	{	
	};

template<class _Ty>
	struct _Refwrap_result1_helper<_Ty, true>
		: unary_function<typename _Ty::argument_type,
			typename _Ty::result_type>
	{	
	};

	
template<class _Ty,
	bool>
	struct _Refwrap_result1
		: _Refwrap_result0<_Ty, _Has_result_type<_Ty>::type::value>
	{	
	};

template<class _Ty>
	struct _Refwrap_result1<_Ty, true>
		: _Refwrap_result1_helper<_Ty,
			is_base_of<unary_function<
				typename _Ty::argument_type,
				typename _Ty::result_type>, _Ty>::value>
	{	
	};

	
template<class _Ty,
	bool>
	struct _Refwrap_result2_helper
		: _Refwrap_result1<_Ty, _Has_result_and_arg_type<_Ty>::type::value>
	{	
	};

template<class _Ty>
	struct _Refwrap_result2_helper<_Ty, true>
		: binary_function<typename _Ty::first_argument_type,
			typename _Ty::second_argument_type,
			typename _Ty::result_type>,
		_Refwrap_result1<_Ty, _Has_result_and_arg_type<_Ty>::type::value>
	{	
	};

	
template<class _Ty,
	bool>
	struct _Refwrap_result2
		: _Refwrap_result1<_Ty, _Has_result_and_arg_type<_Ty>::type::value>
	{	
	};

template<class _Ty>
	struct _Refwrap_result2<_Ty, true>
		: _Refwrap_result2_helper<_Ty,
			is_base_of<binary_function<
				typename _Ty::first_argument_type,
				typename _Ty::second_argument_type,
				typename _Ty::result_type>, _Ty>::value>
	{	
	};

	
template<class _Ty>
	struct _Refwrap_impl
		: _Call_wrapper<_Callable_obj<_Ty, true>,
			is_abstract<_Ty>::value>,
			_Refwrap_result2<_Ty, _Has_result_and_2arg_type<_Ty>::type::value>
	{	
	_Refwrap_impl(_Ty& _Val)
		: _Call_wrapper<_Callable_obj<_Ty, true>,
			is_abstract<_Ty>::value>(_Val)
		{	
		}
	};

template<class _Rx,
	class _Arg0>
	struct _Refwrap_impl<_Rx _Arg0::*>
		: _Call_wrapper<_Callable_pmd<_Rx _Arg0::*, _Arg0, false> >
	{	
	typedef _Rx _Arg0::* _Fty;
	typedef _Rx result_type;

	_Refwrap_impl(_Fty& _Val)
		: _Call_wrapper<_Callable_pmd<_Fty, _Arg0, false> >(_Val)
		{	
		}
	};

template<class _Rx,
	class _Arg0>
	struct _Refwrap_impl<_Rx _Arg0::*const>
		: _Call_wrapper<_Callable_pmd<_Rx _Arg0::*const, _Arg0, false> >
	{	
	typedef _Rx _Arg0::*const _Fty;
	typedef _Rx result_type;
	_Refwrap_impl(_Fty& _Val)
		: _Call_wrapper<_Callable_pmd<_Fty, _Arg0, false> >(_Val)
		{	
		}
	};

	
















template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx __cdecl (_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(_Types...), false> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__cdecl *_Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty _Val) : _Call_wrapper<_Callable_fun<_Fty, false> >(_Val) { } }; template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx __stdcall (_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__stdcall *)(_Types...), false> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__stdcall *_Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty _Val) : _Call_wrapper<_Callable_fun<_Fty, false> >(_Val) { } }; template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx __fastcall (_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__fastcall *)(_Types...), false> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__fastcall *_Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty _Val) : _Call_wrapper<_Callable_fun<_Fty, false> >(_Val) { } };


	
















template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx(__cdecl *)(_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(_Types...), true> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__cdecl * _Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx(__stdcall *)(_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__stdcall *)(_Types...), true> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__stdcall * _Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx(__fastcall *)(_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__fastcall *)(_Types...), true> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__fastcall * _Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx(__cdecl *const)(_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *const)(_Types...), true> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__cdecl *const _Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx(__stdcall *const)(_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__stdcall *const)(_Types...), true> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__stdcall *const _Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx(__fastcall *const)(_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__fastcall *const)(_Types...), true> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__fastcall *const _Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } };


	


















template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* )(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* )(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx,  _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::*  _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* )(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* )(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx,  _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::*  _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* )(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* )(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx,  _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::*  _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* )(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* )(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx,  _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::*  _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* )(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* )(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::*  _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* )(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* )(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::*  _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* )(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* )(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::*  _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* )(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* )(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::*  _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* )(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* )(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::*  _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* )(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* )(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::*  _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* )(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* )(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::*  _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* )(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* )(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::*  _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* )(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* )(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::*  _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* )(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* )(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::*  _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* )(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* )(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::*  _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* )(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* )(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::*  _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* const)(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* const)(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx,  _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::* const _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* const)(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* const)(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx,  _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::* const _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* const)(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* const)(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx,  _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::* const _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* const)(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* const)(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx,  _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::* const _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* const)(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* const)(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::* const _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* const)(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* const)(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::* const _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* const)(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* const)(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::* const _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* const)(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* const)(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::* const _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* const)(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* const)(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::* const _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* const)(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* const)(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::* const _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* const)(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* const)(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::* const _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* const)(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* const)(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::* const _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* const)(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* const)(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::* const _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* const)(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* const)(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::* const _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* const)(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* const)(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::* const _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* const)(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* const)(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::* const _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } };



	
template<class _Ty>
	class reference_wrapper
	: public _Refwrap_impl<_Ty>
	{	
public:
	typedef reference_wrapper<_Ty> _Myt;
	typedef _Refwrap_impl<_Ty> _Mybase;
	typedef _Ty type;

	reference_wrapper(_Ty& _Val) throw ()
		: _Mybase(_Val)
		{	
		}

	reference_wrapper(const _Myt& _Right) throw ()
		: _Mybase(_Right.get())
		{	
		}

	_Myt& operator=(const _Myt& _Right) throw ()
		{	
		this->_Reset(_Right.get());
		return (*this);
		}

	operator _Ty&() const throw ()
		{	
		return (this->_Get());
		}

	_Ty& get() const throw ()
		{	
		return (this->_Get());
		}

	reference_wrapper(_Ty&&) = delete;
	};

	
template<class _Ty>
	reference_wrapper<_Ty>
		ref(_Ty& _Val) throw ()
	{	
	return (reference_wrapper<_Ty>(_Val));
	}

template<class _Ty>
	void ref(const _Ty&&) = delete;

template<class _Ty>
	reference_wrapper<_Ty>
		ref(reference_wrapper<_Ty> _Val) throw ()
	{	
	return (_Val);
	}

template<class _Ty>
	reference_wrapper<const _Ty>
		cref(const _Ty& _Val) throw ()
	{	
	return (reference_wrapper<const _Ty>(_Val));
	}

template<class _Ty>
	void cref(const _Ty&&) = delete;

template<class _Ty>
	reference_wrapper<const _Ty>
		cref(reference_wrapper<_Ty> _Val) throw ()
	{	
	return (reference_wrapper<const _Ty>(_Val.get()));
	}

namespace tr1 {	
using ::std:: cref;
using ::std:: ref;
using ::std:: reference_wrapper;
using ::std:: result_of;
	}	
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 735 "d:\\programs overflow\\vc\\include\\xrefwrap"
#line 736 "d:\\programs overflow\\vc\\include\\xrefwrap"





#line 1550 "d:\\programs overflow\\vc\\include\\type_traits"

namespace std {
		
template<class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;

template<class _Ty>
	using remove_volatile_t = typename remove_volatile<_Ty>::type;

template<class _Ty>
	using remove_cv_t = typename remove_cv<_Ty>::type;

template<class _Ty>
	using add_const_t = typename add_const<_Ty>::type;

template<class _Ty>
	using add_volatile_t = typename add_volatile<_Ty>::type;

template<class _Ty>
	using add_cv_t = typename add_cv<_Ty>::type;

template<class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

template<class _Ty>
	using add_lvalue_reference_t = typename add_lvalue_reference<_Ty>::type;

template<class _Ty>
	using add_rvalue_reference_t = typename add_rvalue_reference<_Ty>::type;

template<class _Ty>
	using make_signed_t = typename make_signed<_Ty>::type;

template<class _Ty>
	using make_unsigned_t = typename make_unsigned<_Ty>::type;

template<class _Ty>
	using remove_extent_t = typename remove_extent<_Ty>::type;

template<class _Ty>
	using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

template<class _Ty>
	using remove_pointer_t = typename remove_pointer<_Ty>::type;

template<class _Ty>
	using add_pointer_t = typename add_pointer<_Ty>::type;

template<size_t _Len,
	size_t _Align = alignment_of<max_align_t>::value>
	using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

template<size_t _Len,
	class... _Types>
	using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

template<class _Ty>
	using decay_t = typename decay<_Ty>::type;

template<bool _Test,
	class _Ty = void>
	using enable_if_t = typename enable_if<_Test, _Ty>::type;

template<bool _Test,
	class _Ty1,
	class _Ty2>
	using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

template<class... _Ty>
	using common_type_t = typename common_type<_Ty...>::type;

template<class _Ty>
	using underlying_type_t = typename underlying_type<_Ty>::type;

template<class _Ty>
	using result_of_t = typename result_of<_Ty>::type;
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1632 "d:\\programs overflow\\vc\\include\\type_traits"
#line 1633 "d:\\programs overflow\\vc\\include\\type_traits"






#line 9 "d:\\programs overflow\\vc\\include\\utility"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4180 4512)

namespace std {
		
template<class _Ty> inline
	void swap(_Ty&, _Ty&)
		;
#line 23 "d:\\programs overflow\\vc\\include\\utility"

template<class _FwdIt1,
	class _FwdIt2> inline
	void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
	{	
	swap(*_Left, *_Right);
	}

		
template<class _Ty,
	size_t _Size> inline
	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
		
	{	
	if (&_Left != &_Right)
		{	
		_Ty *_First1 = _Left;
		_Ty *_Last1 = _First1 + _Size;
		_Ty *_First2 = _Right;
		for (; _First1 != _Last1; ++_First1, ++_First2)
			::std:: iter_swap(_First1, _First2);
		}
	}

template<class _Ty> inline
	void swap(_Ty& _Left, _Ty& _Right)
		
#line 51 "d:\\programs overflow\\vc\\include\\utility"
	{	
	_Ty _Tmp = _Move(_Left);
	_Left = _Move(_Right);
	_Right = _Move(_Tmp);
	}

		
template<class _Ty> inline
	void _Swap_adl(_Ty& _Left, _Ty& _Right)
	{	
	swap(_Left, _Right);
	}

		
struct piecewise_construct_t
	{	
	};

const piecewise_construct_t piecewise_construct =
	piecewise_construct_t();

		

template<class...>
	class tuple;


template<class _Ty1,
	class _Ty2>
	struct pair
	{	
	typedef pair<_Ty1, _Ty2> _Myt;
	typedef _Ty1 first_type;
	typedef _Ty2 second_type;

	pair()
		: first(), second()
		{	
		}

	pair(const _Ty1& _Val1, const _Ty2& _Val2)
		: first(_Val1), second(_Val2)
		{	
		}

	template<class _Other1,
		class _Other2,
		class = typename enable_if<is_convertible<const _Other1&, _Ty1>::value
			&& is_convertible<const _Other2&, _Ty2>::value,
			void>::type>
		pair(const pair<_Other1, _Other2>& _Right)
		: first(_Right.first), second(_Right.second)
		{	
		}

	template<class _Other1,
		class _Other2>
		_Myt& operator=(const pair<_Other1, _Other2>& _Right)
		{	
		first = _Right.first;
		second = _Right.second;
		return (*this);
		}


	template<class _Tuple1,
		class _Tuple2,
		size_t... _Indexes1,
		size_t... _Indexes2> inline
		pair(_Tuple1& _Val1,
			_Tuple2& _Val2,
			_Arg_idx<_Indexes1...>,
			_Arg_idx<_Indexes2...>);

	template<class... _Types1,
		class... _Types2> inline
		pair(piecewise_construct_t,
			tuple<_Types1...> _Val1,
			tuple<_Types2...> _Val2)
			;
#line 132 "d:\\programs overflow\\vc\\include\\utility"


	template<class _Other1,
		class _Other2,
		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
			&& is_convertible<_Other2, _Ty2>::value,
			void>::type>
		pair(_Other1&& _Val1, _Other2&& _Val2)
			
#line 142 "d:\\programs overflow\\vc\\include\\utility"
		: first(::std:: forward<_Other1>(_Val1)),
				second(::std:: forward<_Other2>(_Val2))
		{	
		}

	template<class _Other1,
		class _Other2,
		class = typename enable_if<is_convertible<_Other1, _Ty1>::value
			&& is_convertible<_Other2, _Ty2>::value,
			void>::type>
		pair(pair<_Other1, _Other2>&& _Right)
			
#line 155 "d:\\programs overflow\\vc\\include\\utility"
		: first(::std:: forward<_Other1>(_Right.first)),
			second(::std:: forward<_Other2>(_Right.second))
		{	
		}

	template<class _Other1,
		class _Other2>
		_Myt& operator=(pair<_Other1, _Other2>&& _Right)
			
#line 165 "d:\\programs overflow\\vc\\include\\utility"
		{	
		first = ::std:: forward<_Other1>(_Right.first);
		second = ::std:: forward<_Other2>(_Right.second);
		return (*this);
		}

	_Myt& operator=(_Myt&& _Right)
		
#line 174 "d:\\programs overflow\\vc\\include\\utility"
		{	
		first = ::std:: forward<_Ty1>(_Right.first);
		second = ::std:: forward<_Ty2>(_Right.second);
		return (*this);
		}

	void swap(_Myt& _Right)
		
#line 183 "d:\\programs overflow\\vc\\include\\utility"
		{	
		if (this != &_Right)
			{	
			_Swap_adl(first, _Right.first);
			_Swap_adl(second, _Right.second);
			}
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		first = _Right.first;
		second = _Right.second;
		return (*this);
		}

	_Ty1 first;	
	_Ty2 second;	
	};

		

template<class _Ty1,
	class _Ty2> inline
	void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)
		
	{	
	_Left.swap(_Right);
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator==(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Left.first == _Right.first && _Left.second == _Right.second);
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator!=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator<(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Left.first < _Right.first ||
		(!(_Right.first < _Left.first) && _Left.second < _Right.second));
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator>(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator<=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator>=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Left < _Right));
	}

	

template<class _Ty1,
	class _Ty2> inline
	pair<typename _Unrefwrap<_Ty1>::type,
		typename _Unrefwrap<_Ty2>::type>
		make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
	{	
	typedef pair<typename _Unrefwrap<_Ty1>::type,
		typename _Unrefwrap<_Ty2>::type> _Mypair;
	return (_Mypair(::std:: forward<_Ty1>(_Val1),
		::std:: forward<_Ty2>(_Val2)));
	}

		
	namespace rel_ops
		{	
template<class _Ty> inline
	bool operator!=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty> inline
	bool operator>(const _Ty& _Left, const _Ty& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty> inline
	bool operator<=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty> inline
	bool operator>=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Left < _Right));
	}
		}
}

namespace std {
	
template<class _Tuple>
	struct tuple_size
	{	
	static_assert(_Always_false<_Tuple>::value,
		"The C++ Standard doesn't define tuple_size for this type.");
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_size<pair<_Ty1, _Ty2> >
	: integral_constant<size_t, 2>
	{	
	};

template<class... _Types>
	struct tuple_size<tuple<_Types...> >
	: integral_constant<size_t, sizeof...(_Types)>
	{	
	};


template<class _Tuple>
	struct tuple_size<const _Tuple>
	: tuple_size<_Tuple>
	{	
	};

template<class _Tuple>
	struct tuple_size<volatile _Tuple>
	: tuple_size<_Tuple>
	{	
	};

template<class _Tuple>
	struct tuple_size<const volatile _Tuple>
	: tuple_size<_Tuple>
	{	
	};

	
template<size_t _Idx,
	class _Tuple>
	struct tuple_element;

template<int _Idx,
	class _Ty>
	struct _Pair_data;

template<class _Ty1,
	class _Ty2>
	struct _Pair_data<0, pair<_Ty1, _Ty2> >
	{	
	typedef typename add_lvalue_reference<const _Ty1>::type _Ctype;
	typedef typename add_lvalue_reference<_Ty1>::type _Rtype;
	typedef typename add_rvalue_reference<_Ty1>::type _RRtype;

	static _Rtype _Val(pair<_Ty1, _Ty2>& _Pr)
		{	
		return (_Pr.first);
		}

	static _Ctype _Val(const pair<_Ty1, _Ty2>& _Pr)
		{	
		return (_Pr.first);
		}

	static _RRtype _Val(pair<_Ty1, _Ty2>&& _Pr)
		{	
		return (::std:: forward<_Ty1>(_Pr.first));
		}
	};

template<class _Ty1,
	class _Ty2>
	struct _Pair_data<1, pair<_Ty1, _Ty2> >
	{	
	typedef typename add_lvalue_reference<const _Ty2>::type _Ctype;
	typedef typename add_lvalue_reference<_Ty2>::type _Rtype;
	typedef typename add_rvalue_reference<_Ty2>::type _RRtype;

	static _Rtype _Val(pair<_Ty1, _Ty2>& _Pr)
		{	
		return (_Pr.second);
		}

	static _Ctype _Val(const pair<_Ty1, _Ty2>& _Pr)
		{	
		return (_Pr.second);
		}

	static _RRtype _Val(pair<_Ty1, _Ty2>&& _Pr)
		{	
		return (::std:: forward<_Ty2>(_Pr.second));
		}
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_element<0, pair<_Ty1, _Ty2> >
	{	
	typedef _Ty1 type;
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_element<1, pair<_Ty1, _Ty2> >
	{	
	typedef _Ty2 type;
	};

template<int _Idx,
	class _Ty1,
	class _Ty2> inline
	typename _Pair_data<_Idx, pair<_Ty1, _Ty2> >::_Rtype
		get(pair<_Ty1, _Ty2>& _Pr) throw ()
	{	
	return (_Pair_data<_Idx, pair<_Ty1, _Ty2> >::_Val(_Pr));
	}

template<int _Idx,
	class _Ty1,
	class _Ty2> inline
	typename _Pair_data<_Idx, pair<_Ty1, _Ty2> >::_Ctype
		get(const pair<_Ty1, _Ty2>& _Pr) throw ()
	{	
	return (_Pair_data<_Idx, pair<_Ty1, _Ty2> >::_Val(_Pr));
	}

template<int _Idx,
	class _Ty1,
	class _Ty2> inline
	typename _Pair_data<_Idx, pair<_Ty1, _Ty2> >::_RRtype
		get(pair<_Ty1, _Ty2>&& _Pr) throw ()
	{	
	typedef typename _Pair_data<_Idx, pair<_Ty1, _Ty2> >::_RRtype
		_RRtype;
	return (::std:: forward<_RRtype>(
		_Pair_data<_Idx, pair<_Ty1, _Ty2> >::_Val(_Pr)));
	}
}

namespace std {
namespace tr1 {	
using ::std:: get;
using ::std:: tuple_element;
using ::std:: tuple_size;
}	
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 459 "d:\\programs overflow\\vc\\include\\utility"
#line 460 "d:\\programs overflow\\vc\\include\\utility"






















#line 9 "d:\\programs overflow\\vc\\include\\xutility"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		

 

  

  


typedef const wchar_t *_Dbfile_t;
typedef unsigned int _Dbline_t;

__declspec(dllimport) void __cdecl _Debug_message(const wchar_t *,
	const wchar_t *, unsigned int);

 

#line 34 "d:\\programs overflow\\vc\\include\\xutility"

		
struct _Container_proxy;
struct _Container_base12;
struct _Iterator_base12;

struct __declspec(dllimport) _Container_base0
	{	
	void _Orphan_all()
		{	
		}

	void _Swap_all(_Container_base0&)
		{	
		}
	};

struct _Iterator_base0
	{	
	void _Adopt(const void *)
		{	
		}

	const _Container_base0 *_Getcont() const
		{	
		return (0);
		}
	};

		
struct _Container_proxy
	{	
	_Container_proxy()
		: _Mycont(0), _Myfirstiter(0)
		{	
		}

	const _Container_base12 *_Mycont;
	_Iterator_base12 *_Myfirstiter;
	};

struct __declspec(dllimport) _Container_base12
	{	
public:
	_Container_base12()
		: _Myproxy(0)
		{	
		}

	_Container_base12(const _Container_base12&)
		: _Myproxy(0)
		{	
		}

	_Container_base12& operator=(const _Container_base12&)
		{	
		return (*this);
		}

	~_Container_base12() throw ()
		{	
		_Orphan_all();
		}

	_Iterator_base12 **_Getpfirst() const
		{	
		return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);
		}

	void _Orphan_all();	
	void _Swap_all(_Container_base12&);	

	_Container_proxy *_Myproxy;
	};

struct _Iterator_base12
	{	
public:
	_Iterator_base12()
		: _Myproxy(0), _Mynextiter(0)
		{	
		}

	_Iterator_base12(const _Iterator_base12& _Right)
		: _Myproxy(0), _Mynextiter(0)
		{	
		*this = _Right;
		}

	_Iterator_base12& operator=(const _Iterator_base12& _Right)
		{	
		if (_Myproxy == _Right._Myproxy)
			;
		else if (_Right._Myproxy != 0)
			_Adopt(_Right._Myproxy->_Mycont);
		else
			{	
 
			_Lockit _Lock(3);
			_Orphan_me();
 #line 135 "d:\\programs overflow\\vc\\include\\xutility"
			}
		return (*this);
		}

	~_Iterator_base12() throw ()
		{	
 
		_Lockit _Lock(3);
		_Orphan_me();
 #line 145 "d:\\programs overflow\\vc\\include\\xutility"
		}

	void _Adopt(const _Container_base12 *_Parent)
		{	
		if (_Parent == 0)
			{	
 
			_Lockit _Lock(3);
			_Orphan_me();
 #line 155 "d:\\programs overflow\\vc\\include\\xutility"
			}
		else
			{	
			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

 
			if (_Myproxy != _Parent_proxy)
				{	
				_Lockit _Lock(3);
				_Orphan_me();
				_Mynextiter = _Parent_proxy->_Myfirstiter;
				_Parent_proxy->_Myfirstiter = this;
				_Myproxy = _Parent_proxy;
				}

 

#line 173 "d:\\programs overflow\\vc\\include\\xutility"
			}
		}

	void _Clrcont()
		{	
		_Myproxy = 0;
		}

	const _Container_base12 *_Getcont() const
		{	
		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);
		}

	_Iterator_base12 **_Getpnext()
		{	
		return (&_Mynextiter);
		}

	void _Orphan_me()
		{	
 
		if (_Myproxy != 0)
			{	
			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
			while (*_Pnext != 0 && *_Pnext != this)
				_Pnext = &(*_Pnext)->_Mynextiter;

			if (*_Pnext == 0)
				_Debug_message(L"ITERATOR LIST CORRUPTED!", L"d:\\programs overflow\\vc\\include\\xutility", 201);
			*_Pnext = _Mynextiter;
			_Myproxy = 0;
			}
 #line 206 "d:\\programs overflow\\vc\\include\\xutility"
		}

	_Container_proxy *_Myproxy;
	_Iterator_base12 *_Mynextiter;
	};

		
inline void _Container_base12::_Orphan_all()
	{	
 
	if (_Myproxy != 0)
		{	
		_Lockit _Lock(3);

		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
			(*_Pnext)->_Myproxy = 0;
		_Myproxy->_Myfirstiter = 0;
		}
 #line 226 "d:\\programs overflow\\vc\\include\\xutility"
	}

inline void _Container_base12::_Swap_all(_Container_base12& _Right)
	{	
 
	_Lockit _Lock(3);
 #line 233 "d:\\programs overflow\\vc\\include\\xutility"

	_Container_proxy *_Temp = _Myproxy;
	_Myproxy = _Right._Myproxy;
	_Right._Myproxy = _Temp;

	if (_Myproxy != 0)
		_Myproxy->_Mycont = (_Container_base12 *)this;
	if (_Right._Myproxy != 0)
		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
	}

 



#line 249 "d:\\programs overflow\\vc\\include\\xutility"
typedef _Container_base12 _Container_base;
typedef _Iterator_base12 _Iterator_base;
 #line 252 "d:\\programs overflow\\vc\\include\\xutility"

		

		
 


		
template<class _Ty>
	struct _Get_unchecked_type
		{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::_Unchecked_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<_Ty>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 264 "d:\\programs overflow\\vc\\include\\xutility"

		
template<class _Ty>
	struct _Is_checked_helper
		{ template<class _Uty> static auto _Fn(int, _Identity<typename _Uty::_Unchecked_type> * = 0, _Identity<typename _Uty::_Unchecked_type> * = 0, _Identity<typename _Uty::_Unchecked_type> * = 0) -> true_type; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };

		
template<class _Iter> inline
	typename _Is_checked_helper<_Iter>::type _Is_checked(_Iter)
	{	
	return (typename _Is_checked_helper<_Iter>::type());
	}

		
template<class _Iter> inline
	_Iter _Unchecked(_Iter _Src)
	{	
	return (_Src);
	}

		
template<class _Iter,
	class _UIter> inline
	_Iter& _Rechecked(_Iter& _Dest, _UIter _Src)
	{	
	_Dest = _Src;
	return (_Dest);
	}

		
		
struct input_iterator_tag
	{	
	};

struct _Mutable_iterator_tag
	{	
	};

struct output_iterator_tag
	: _Mutable_iterator_tag
	{	
	};

struct forward_iterator_tag
	: input_iterator_tag, _Mutable_iterator_tag
	{	
	};

struct bidirectional_iterator_tag
	: forward_iterator_tag
	{	
	};

struct random_access_iterator_tag
	: bidirectional_iterator_tag
	{	
	};

		
struct _Nonscalar_ptr_iterator_tag
	{	
	};
struct _Scalar_ptr_iterator_tag
	{	
	};

		
template<class _Category,
	class _Ty,
	class _Diff = ptrdiff_t,
	class _Pointer = _Ty *,
	class _Reference = _Ty&>
	struct iterator
	{	
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;
	typedef _Diff distance_type;	
	typedef _Pointer pointer;
	typedef _Reference reference;
	};

template<class _Category,
	class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Base>
	struct _Iterator012
		: public _Base
	{	
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;
	typedef _Diff distance_type;	
	typedef _Pointer pointer;
	typedef _Reference reference;
	};


typedef iterator<output_iterator_tag, void, void, void, void> _Outit;

		
template<class _Iter>
	struct iterator_traits
	{	
	typedef typename _Iter::iterator_category iterator_category;
	typedef typename _Iter::value_type value_type;
	typedef typename _Iter::difference_type difference_type;
	typedef difference_type distance_type;	
	typedef typename _Iter::pointer pointer;
	typedef typename _Iter::reference reference;
	};

template<class _Ty>
	struct iterator_traits<_Ty *>
	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;
	typedef ptrdiff_t distance_type;	
	typedef _Ty *pointer;
	typedef _Ty& reference;
	};

template<class _Ty>
	struct iterator_traits<const _Ty *>
	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;
	typedef ptrdiff_t distance_type;	
	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	};

		
template<class _Iter> inline
	typename iterator_traits<_Iter>::iterator_category
		_Iter_cat(const _Iter&)
	{	
	typename iterator_traits<_Iter>::iterator_category _Cat;
	return (_Cat);
	}

		
template<class _Iter1,
	class _Iter2> inline
	_Nonscalar_ptr_iterator_tag _Ptr_cat(_Iter1&, _Iter2&)
	{	
	_Nonscalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

template<class _Elem1,
	class _Elem2>
	struct _Ptr_cat_helper
	{	
	typedef _Nonscalar_ptr_iterator_tag type;
	};

template<class _Elem>
	struct _Ptr_cat_helper<_Elem, _Elem>
	{	
	typedef typename _If<is_scalar<_Elem>::value,
		_Scalar_ptr_iterator_tag,
		_Nonscalar_ptr_iterator_tag>::type type;
	};

template<class _Anything>
	struct _Ptr_cat_helper<_Anything *, const _Anything *>
	{	
	typedef _Scalar_ptr_iterator_tag type;
	};

template<class _Elem1,
	class _Elem2> inline
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type
		_Ptr_cat(_Elem1 *, _Elem2 *)
	{	
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
	return (_Cat);
	}

template<class _Elem1,
	class _Elem2> inline
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type
		_Ptr_cat(const _Elem1 *, _Elem2 *)
	{	
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
	return (_Cat);
	}

		

 









#line 471 "d:\\programs overflow\\vc\\include\\xutility"

  

  
   
  #line 477 "d:\\programs overflow\\vc\\include\\xutility"

  


  
   
  #line 484 "d:\\programs overflow\\vc\\include\\xutility"

  


  
   
  #line 491 "d:\\programs overflow\\vc\\include\\xutility"

  

  


  
   
  #line 500 "d:\\programs overflow\\vc\\include\\xutility"

  

  


  
   
  #line 509 "d:\\programs overflow\\vc\\include\\xutility"

  

  


		
template<class _Pr, class _Ty1, class _Ty2> inline
	bool _Debug_lt_pred(_Pr _Pred,
		_Ty1&& _Left, _Ty2&& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	if (!_Pred(::std:: forward<_Ty1>(_Left), ::std:: forward<_Ty2>(_Right)))
		return (false);
	else if (_Pred(::std:: forward<_Ty2>(_Right), ::std:: forward<_Ty1>(_Left)))
		_Debug_message(L"invalid operator<", _File, _Line);
	return (true);
	}

		
template<class _Ty1, class _Ty2> inline
	bool _Debug_lt(_Ty1&& _Left, _Ty2&& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	return (_Debug_lt_pred(less<>(),
		::std:: forward<_Ty1>(_Left), ::std:: forward<_Ty2>(_Right), _File, _Line));
	}

		
template<class _InIt> inline
	void _Debug_pointer(_InIt&, _Dbfile_t, _Dbline_t)
	{	
	}

template<class _Ty> inline
	void _Debug_pointer(const _Ty *_First, _Dbfile_t _File, _Dbline_t _Line)
	{	
	if (_First == 0)
		_Debug_message(L"invalid null pointer", _File, _Line);
	}

template<class _Ty> inline
	void _Debug_pointer(_Ty *_First, _Dbfile_t _File, _Dbline_t _Line)
	{	
	if (_First == 0)
		_Debug_message(L"invalid null pointer", _File, _Line);
	}

		
template<class _InIt> inline
	void _Debug_range2(_InIt _First, _InIt _Last, _Dbfile_t, _Dbline_t,
		input_iterator_tag)
	{	
	bool _Ans = _First == _Last;	
	_Ans = _Ans;	
	}

template<class _RanIt> inline
	void _Debug_range2(_RanIt _First, _RanIt _Last,
		_Dbfile_t _File, _Dbline_t _Line,
		random_access_iterator_tag)
	{	
	if (_First != _Last)
		{	
		_Debug_pointer(_First, _File, _Line);
		_Debug_pointer(_Last, _File, _Line);
		if (_Last < _First)
			_Debug_message(L"invalid iterator range", _File, _Line);
		}
	}

template<class _InIt> inline
	void _Debug_range(_InIt _First, _InIt _Last,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));
	}

		
template<class _InIt> inline
	void _Debug_order2(_InIt, _InIt,
		_Dbfile_t, _Dbline_t, input_iterator_tag)
	{	
	}

template<class _FwdIt> inline
	void _Debug_order2(_FwdIt _First, _FwdIt _Last,
		_Dbfile_t _File, _Dbline_t _Line, forward_iterator_tag)
	{	
	for (_FwdIt _Next = _First; _First != _Last && ++_Next != _Last; ++_First)
		if (_Debug_lt(*_Next, *_First, L"d:\\programs overflow\\vc\\include\\xutility", 599))
			_Debug_message(L"sequence not ordered", _File, _Line);
	}

template<class _InIt> inline
	void _Debug_order(_InIt _First, _InIt _Last,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	_Debug_range(_First, _Last, _File, _Line);
	_Debug_order2(_First, _Last, _File, _Line, _Iter_cat(_First));
	}

		
template<class _InIt,
	class _Pr> inline
	void _Debug_order2(_InIt, _InIt, _Pr,
		_Dbfile_t, _Dbline_t, input_iterator_tag)
	{	
	}

template<class _FwdIt,
	class _Pr> inline
	void _Debug_order2(_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		_Dbfile_t _File, _Dbline_t _Line, forward_iterator_tag)
	{	
	for (_FwdIt _Next = _First; _First != _Last && ++_Next != _Last; ++_First)
		if (_Debug_lt_pred(_Pred, *_Next, *_First, L"d:\\programs overflow\\vc\\include\\xutility", 625))
			_Debug_message(L"sequence not ordered", _File, _Line);
	}

template<class _InIt,
	class _Pr> inline
	void _Debug_order(_InIt _First, _InIt _Last, _Pr _Pred,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	_Debug_range(_First, _Last, _File, _Line);
	_Debug_pointer(_Pred, _File, _Line);
	_Debug_order2(_First, _Last, _Pred, _File, _Line, _Iter_cat(_First));
	}
 #line 639 "d:\\programs overflow\\vc\\include\\xutility"

		
		

template<class _Iter> inline
	typename iterator_traits<_Iter>::value_type *_Val_type(_Iter)
	{	
	return (0);
	}

		
template<class _InIt,
	class _Diff> inline
	void _Advance(_InIt& _Where, _Diff _Off, input_iterator_tag)
	{	
 
	if (_Off < 0)
		_Debug_message(L"negative offset in advance", L"d:\\programs overflow\\vc\\include\\xutility", 656);
 #line 658 "d:\\programs overflow\\vc\\include\\xutility"

	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _FwdIt,
	class _Diff> inline
	void _Advance(_FwdIt& _Where, _Diff _Off, forward_iterator_tag)
	{	
 
	if (_Off < 0)
		_Debug_message(L"negative offset in advance", L"d:\\programs overflow\\vc\\include\\xutility", 669);
 #line 671 "d:\\programs overflow\\vc\\include\\xutility"

	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _BidIt,
	class _Diff> inline
	void _Advance(_BidIt& _Where, _Diff _Off, bidirectional_iterator_tag)
	{	
	for (; 0 < _Off; --_Off)
		++_Where;
	for (; _Off < 0; ++_Off)
		--_Where;
	}

template<class _RanIt,
	class _Diff> inline
	void _Advance(_RanIt& _Where, _Diff _Off, random_access_iterator_tag)
	{	
	_Where += _Off;
	}

template<class _InIt,
	class _Diff> inline
	void advance(_InIt& _Where, _Diff _Off)
	{	
	_Advance(_Where, _Off, _Iter_cat(_Where));
	}

		

template<class _Iter> inline
	typename iterator_traits<_Iter>::difference_type
		*_Dist_type(_Iter)
	{	
	return (0);
	}

		
template<class _InIt,
	class _Diff> inline
		void _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,
			input_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _FwdIt,
	class _Diff> inline
		void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,
			forward_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _BidIt,
	class _Diff> inline
		void _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,
			bidirectional_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _RanIt,
	class _Diff> inline
		void _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,
			random_access_iterator_tag)
	{	
 
	if (_First != _Last)
		{	
		_Debug_pointer(_First, L"d:\\programs overflow\\vc\\include\\xutility", 745);
		_Debug_pointer(_Last, L"d:\\programs overflow\\vc\\include\\xutility", 746);
		}
 #line 749 "d:\\programs overflow\\vc\\include\\xutility"

	_Off += _Last - _First;
	}

template<class _InIt> inline
	typename iterator_traits<_InIt>::difference_type
		distance(_InIt _First, _InIt _Last)
	{	
	typename iterator_traits<_InIt>::difference_type _Off = 0;
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	return (_Off);
	}

template<class _InIt,
	class _Diff> inline
		void _Distance(_InIt _First, _InIt _Last, _Diff& _Off)
	{	
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	}

		
template<class _FwdIt> inline
	_FwdIt next(_FwdIt _First,
		typename iterator_traits<_FwdIt>::difference_type _Off = 1)
	{	
	static_assert((is_base_of<forward_iterator_tag,
		typename iterator_traits<_FwdIt>::iterator_category>::value),
		"next requires forward iterator");

	::std:: advance(_First, _Off);
	return (_First);
	}

		
template<class _BidIt> inline
	_BidIt prev(_BidIt _First,
		typename iterator_traits<_BidIt>::difference_type _Off = 1)
	{	
	static_assert((is_base_of<bidirectional_iterator_tag,
		typename iterator_traits<_BidIt>::iterator_category>::value),
		"prev requires bidirectional iterator");

	::std:: advance(_First, -_Off);
	return (_First);
	}


		
template<class _Ty>
	struct pointer_traits;

template<class _RanIt,
	class _Base>
	class _Revranit
		: public _Base
	{	
public:
	typedef _Revranit<_RanIt, _Base> _Myt;
	typedef typename _Base::difference_type difference_type;
	typedef typename _Base::pointer pointer;
	typedef typename _Base::reference reference;
	typedef _RanIt iterator_type;

	_Revranit()
		{	
		}

	explicit _Revranit(_RanIt _Right)
		: current(_Right)
		{	
		}

	template<class _RanIt2,
		class _Base2>
		_Revranit(const _Revranit<_RanIt2, _Base2>& _Right)
		: current(_Right.base())
		{	
		}

	_RanIt base() const
		{	
		return (current);
		}

	reference operator*() const
		{	
		_RanIt _Tmp = current;
		return (*--_Tmp);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
		--current;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		++current;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	template<class _RanIt2,
		class _Base2>
		bool _Equal(const _Revranit<_RanIt2, _Base2>& _Right) const
		{	
		return (current == _Right.base());
		}



	_Myt& operator+=(difference_type _Off)
		{	
		current -= _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		return (_Myt(current - _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{	
		current += _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	
		return (_Myt(current + _Off));
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	template<class _RanIt2,
		class _Base2>
		bool _Less(const _Revranit<_RanIt2, _Base2>& _Right) const
		{	
		return (_Right.base() < current);
		}

	difference_type operator-(const _Myt& _Right) const
		{	
		return (_Right.base() - current);
		}

protected:
	_RanIt current;	
	};

		
template<class _RanIt,
	class _Base,
	class _Diff> inline
	_Revranit<_RanIt, _Base>
		operator+(_Diff _Off,
		const _Revranit<_RanIt, _Base>& _Right)
	{	
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2>
	auto inline operator-(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
			-> decltype(_Right.base() - _Left.base())
	{	
	return (_Right.base() - _Left.base());
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator==(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	
	return (_Left._Equal(_Right));
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator!=(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator<(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	
	return (_Left._Less(_Right));
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator>(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator<=(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator>=(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	
	return (!(_Left < _Right));
	}

		
template<class _RanIt>
	class reverse_iterator
		: public _Revranit<_RanIt, iterator<
			typename iterator_traits<_RanIt>::iterator_category,
			typename iterator_traits<_RanIt>::value_type,
			typename iterator_traits<_RanIt>::difference_type,
			typename iterator_traits<_RanIt>::pointer,
			typename iterator_traits<_RanIt>::reference> >
	{	
	typedef reverse_iterator<_RanIt> _Myt;
	typedef _Revranit<_RanIt, iterator<
		typename iterator_traits<_RanIt>::iterator_category,
		typename iterator_traits<_RanIt>::value_type,
		typename iterator_traits<_RanIt>::difference_type,
		typename iterator_traits<_RanIt>::pointer,
		typename iterator_traits<_RanIt>::reference> > _Mybase;

public:
	typedef typename iterator_traits<_RanIt>::difference_type difference_type;
	typedef typename iterator_traits<_RanIt>::pointer pointer;
	typedef typename iterator_traits<_RanIt>::reference reference;
	typedef _RanIt iterator_type;

	reverse_iterator()
		{	
		}

	explicit reverse_iterator(_RanIt _Right)
		: _Mybase(_Right)
		{	
		}

	template<class _Other>
		reverse_iterator(const reverse_iterator<_Other>& _Right)
		: _Mybase(_Right.base())
		{	
		}

	reverse_iterator(_Mybase _Right)
		: _Mybase(_Right)
		{	
		}

	template<class _Other>
		_Myt& operator=(const reverse_iterator<_Other>& _Right)
		{	
		this->current = _Right.base();
		return (*this);
		}

	_Myt& operator++()
		{	
		++*((_Mybase *)this);
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		--*((_Mybase *)this);
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt& operator+=(difference_type _Off)
		{	
		*((_Mybase *)this) += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt& operator-=(difference_type _Off)
		{	
		*((_Mybase *)this) -= _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}
	};

template<class _RanIt>
	struct _Is_checked_helper<reverse_iterator<_RanIt> >
		: public _Is_checked_helper<_RanIt>
	{	
	};

		
template<class _RanIt,
	class _Diff> inline
	reverse_iterator<_RanIt> operator+(_Diff _Off,
		const reverse_iterator<_RanIt>& _Right)
	{	
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	auto inline operator-(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
			-> decltype(_Right.base() - _Left.base())
	{	
	return (_Right.base() - _Left.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator==(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Equal(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator!=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Less(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left < _Right));
	}


		
template<class _Container>
	auto inline begin(_Container& _Cont) -> decltype(_Cont.begin())
	{	
	return (_Cont.begin());
	}

template<class _Container>
	auto inline begin(const _Container& _Cont) -> decltype(_Cont.begin())
	{	
	return (_Cont.begin());
	}

template<class _Container>
	auto inline end(_Container& _Cont) -> decltype(_Cont.end())
	{	
	return (_Cont.end());
	}

template<class _Container>
	auto inline end(const _Container& _Cont) -> decltype(_Cont.end())
	{	
	return (_Cont.end());
	}

template<class _Ty,
	size_t _Size> inline
	_Ty *begin(_Ty (&_Array)[_Size])
	{	
	return (_Array);
	}

template<class _Ty,
	size_t _Size> inline
	_Ty *end(_Ty (&_Array)[_Size])
	{	
	return (_Array + _Size);
	}

		
template<class _Container>
	auto inline cbegin(const _Container& _Cont) -> decltype(::std:: begin(_Cont))
	{	
	return (::std:: begin(_Cont));
	}

template<class _Container>
	auto inline cend(const _Container& _Cont) -> decltype(::std:: end(_Cont))
	{	
	return (::std:: end(_Cont));
	}

		
template<class _Container>
	auto inline rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
	{	
	return (_Cont.rbegin());
	}

template<class _Container>
	auto inline rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
	{	
	return (_Cont.rbegin());
	}

template<class _Container>
	auto inline rend(_Container& _Cont) -> decltype(_Cont.rend())
	{	
	return (_Cont.rend());
	}

template<class _Container>
	auto inline rend(const _Container& _Cont) -> decltype(_Cont.rend())
	{	
	return (_Cont.rend());
	}

template<class _Ty,
	size_t _Size> inline
	reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])
	{	
	return (reverse_iterator<_Ty *>(_Array + _Size));
	}

template<class _Ty,
	size_t _Size> inline
	reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])
	{	
	return (reverse_iterator<_Ty *>(_Array));
	}

template<class _Elem> inline
	reverse_iterator<const _Elem *> rbegin(initializer_list<_Elem> _Ilist)
	{	
	return (reverse_iterator<const _Elem *>(_Ilist.end()));
	}

template<class _Elem> inline
	reverse_iterator<const _Elem *> rend(initializer_list<_Elem> _Ilist)
	{	
	return (reverse_iterator<const _Elem *>(_Ilist.begin()));
	}

		
template<class _Container>
	auto inline crbegin(const _Container& _Cont) -> decltype(::std:: rbegin(_Cont))
	{	
	return (::std:: rbegin(_Cont));
	}

template<class _Container>
	auto inline crend(const _Container& _Cont) -> decltype(::std:: rend(_Cont))
	{	
	return (::std:: rend(_Cont));
	}


		
template<class _Ty,
	size_t _Size>
	class _Array_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			_Ty,
			ptrdiff_t,
			const _Ty *,
			const _Ty&,
			_Iterator_base>
	{	
public:
	typedef _Array_const_iterator<_Ty, _Size> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef _Ty value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	enum {_EEN_SIZE = _Size};	
	enum {_EEN_IDL =
		2};	

 




























































































































#line 1453 "d:\\programs overflow\\vc\\include\\xutility"
	_Array_const_iterator()
		{	
		_Ptr = 0;
		_Idx = 0;
		}

	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
		{	
		_Ptr = _Parg;
		_Idx = _Off;
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		_Idx = _Right - _Ptr;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Ptr + _Idx);
		}

	reference operator*() const
		{	
 
		if (_Ptr == 0
			|| _Size <= _Idx)
			{	
			_Debug_message(L"array iterator not dereferencable", L"d:\\programs overflow\\vc\\include\\xutility", 1484);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\xutility", 1485, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\xutility", 1485, 0); };
			}

 


#line 1492 "d:\\programs overflow\\vc\\include\\xutility"

		;

		return (_Ptr[_Idx]);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 
		if (_Ptr == 0
			|| _Size <= _Idx)
			{	
			_Debug_message(L"array iterator not incrementable", L"d:\\programs overflow\\vc\\include\\xutility", 1509);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\xutility", 1510, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\xutility", 1510, 0); };
			}

 


#line 1517 "d:\\programs overflow\\vc\\include\\xutility"

		++_Idx;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		if (_Ptr == 0
			|| _Idx <= 0)
			{	
			_Debug_message(L"array iterator not decrementable", L"d:\\programs overflow\\vc\\include\\xutility", 1535);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\xutility", 1536, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\xutility", 1536, 0); };
			}

 


#line 1543 "d:\\programs overflow\\vc\\include\\xutility"

		--_Idx;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
 
		if (_Size < _Idx + _Off)
			{	
			_Debug_message(L"array iterator + offset out of range", L"d:\\programs overflow\\vc\\include\\xutility", 1560);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\xutility", 1561, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\xutility", 1561, 0); };
			}

 

#line 1567 "d:\\programs overflow\\vc\\include\\xutility"

		_Idx += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Idx < _Right._Idx
			? -(difference_type)(_Right._Idx - _Idx)
			: (difference_type)_Idx - _Right._Idx);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Idx == _Right._Idx);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Idx < _Right._Idx);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Myiter& _Right) const
		{	
		if (_Ptr != _Right._Ptr)
			{	
			_Debug_message(L"array iterators incompatible", L"d:\\programs overflow\\vc\\include\\xutility", 1639);
			{ (void) ((!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\xutility", 1640, 0, L"%s", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\xutility", 1640, 0); };
			}
		}

 




#line 1650 "d:\\programs overflow\\vc\\include\\xutility"

	pointer _Ptr;	
	size_t _Idx;	
 #line 1654 "d:\\programs overflow\\vc\\include\\xutility"
	};

template<class _Ty,
	size_t _Size> inline
	typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type
		_Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Ty,
	size_t _Size> inline
	_Array_const_iterator<_Ty, _Size>&
		_Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
			typename _Array_const_iterator<_Ty, _Size>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Ty,
	size_t _Size> inline
	_Array_const_iterator<_Ty, _Size> operator+(
		typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,
		_Array_const_iterator<_Ty, _Size> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Ty,
	size_t _Size>
	class _Array_iterator
		: public _Array_const_iterator<_Ty, _Size>
	{	
public:
	typedef _Array_iterator<_Ty, _Size> _Myiter;
	typedef _Array_const_iterator<_Ty, _Size> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef _Ty value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef _Ty *pointer;
	typedef _Ty& reference;

	_Array_iterator()
		{	
		}

	explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
		: _Mybase(_Parg, _Off)
		{	
		}
	enum {_EEN_SIZE = _Size};	
	enum {_EEN_IDL =
		2};	

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		((_Mybase *)this)->_Rechecked(_Right);
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return ((pointer)((_Mybase *)this)->_Unchecked());
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Ty,
	size_t _Size> inline
	typename _Array_iterator<_Ty, _Size>::_Unchecked_type
		_Unchecked(_Array_iterator<_Ty, _Size> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Ty,
	size_t _Size> inline
	_Array_iterator<_Ty, _Size>&
		_Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
			typename _Array_iterator<_Ty, _Size>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Ty,
	size_t _Size> inline
	_Array_iterator<_Ty, _Size> operator+(
		typename _Array_iterator<_Ty, _Size>::difference_type _Off,
		_Array_iterator<_Ty, _Size> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _RanIt>
	class move_iterator
	{	
public:
	typedef move_iterator<_RanIt> _Myt;
	typedef typename iterator_traits<_RanIt>::iterator_category
		iterator_category;
	typedef typename iterator_traits<_RanIt>::value_type
		value_type;
	typedef typename iterator_traits<_RanIt>::difference_type
		difference_type;
	typedef _RanIt pointer;
	typedef value_type&& reference;
	typedef _RanIt iterator_type;

	move_iterator()
		{	
		}

	explicit move_iterator(iterator_type _Right)
		: current(_Right)
		{	
		}

	template<class _RanIt2>
		move_iterator(const move_iterator<_RanIt2>& _Right)
		: current(_Right.base())
		{	
		}

	template<class _RanIt2>
		_Myt& operator=(const move_iterator<_RanIt2>& _Right)
		{	
		current = _Right.base();
		return (*this);
		}

	_RanIt base() const
		{	
		return (current);
		}

	reference operator*() const
		{	
		return (::std:: move(*current));
		}

	pointer operator->() const
		{	
		return (current);
		}

	_Myt& operator++()
		{	
		++current;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		--current;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	template<class _RanIt2>
		bool _Equal(const move_iterator<_RanIt2>& _Right) const
		{	
		return (current == _Right.base());
		}



	_Myt& operator+=(difference_type _Off)
		{	
		current += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		return (_Myt(current + _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{	
		current -= _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	
		return (_Myt(current - _Off));
		}

	reference operator[](difference_type _Off) const
		{	
		return (::std:: move(current[_Off]));
		}

	template<class _RanIt2>
		bool _Less(const move_iterator<_RanIt2>& _Right) const
		{	
		return (current < _Right.base());
		}

	difference_type operator-(const _Myt& _Right) const
		{	
		return (current - _Right.base());
		}

protected:
	iterator_type current;	
	};

template<class _RanIt>
	struct _Is_checked_helper<move_iterator<_RanIt> >
		: public _Is_checked_helper<_RanIt>
	{	
	};

		
template<class _RanIt,
	class _Diff> inline
	move_iterator<_RanIt>
		operator+(_Diff _Off,
		const move_iterator<_RanIt>& _Right)
	{	
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	auto inline operator-(
		move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
			-> decltype(_Left.base() - _Right.base())
	{	
	return (_Left.base() - _Right.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator==(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Equal(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator!=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Less(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left < _Right));
	}

		
template<class _RanIt> inline
	move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
	{	
	return (move_iterator<_RanIt>(_Iter));
	}

		
template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_Dest, ++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	return (_Copy_impl(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 










#line 2081 "d:\\programs overflow\\vc\\include\\xutility"
template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, input_iterator_tag, _Mutable_iterator_tag)
	{	
	return (_Copy_impl(_First, _Last,
		_Dest));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	_OutIt _Ans = _Dest + (_Last - _First);	
	_Copy_impl(_First, _Last,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, true_type)
	{	
	return (_Copy_impl(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, false_type)
	{	
	return (_Copy_impl(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt copy(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	if (_First == _Last)
		return (_Dest);
	else
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xutility", 2129);
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xutility", 2130);
		return (_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
			_Dest, _Is_checked(_Dest)));
		}
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 2148 "d:\\programs overflow\\vc\\include\\xutility"
 #line 2149 "d:\\programs overflow\\vc\\include\\xutility"

		
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, input_iterator_tag)
	{	
	*_Dest = *_First;	
	while (0 < --_Count)
		*++_Dest = *++_First;
	return (++_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, forward_iterator_tag)
	{	
	for (; 0 < _Count; --_Count, ++_Dest, ++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	return (_Copy_n(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	
	return (_Copy_n(_First, _Count,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 














#line 2220 "d:\\programs overflow\\vc\\include\\xutility"
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n2(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Mutable_iterator_tag)
	{	
	return (_Copy_n(_First, _Count,
		_Dest));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n2(_InIt _First, _Diff _Count,
		_OutIt _Dest, random_access_iterator_tag)
	{	
	_OutIt _Ans = _Dest + _Count;	
	_Copy_n(_First, _Count,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n1(_InIt _First, _Diff _Count,
		_OutIt _Dest, input_iterator_tag)
	{	
	return (_Copy_n2(_First, _Count,
		_Dest, _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n1(_InIt _First, _Diff _Count,
		_OutIt _Dest, random_access_iterator_tag)
	{	
	_InIt _Last = _First + _Count;	
	_Last = _Last;	
	return (_Copy_n2(_Unchecked(_First), _Count,
		_Dest, _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, true_type)
	{	
	return (_Copy_n1(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, false_type)
	{	
	return (_Copy_n1(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	
	_Debug_pointer(_First, L"d:\\programs overflow\\vc\\include\\xutility", 2291);
	_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xutility", 2292);
	if (_Count <= 0)
		return (_Dest);
	else
		return (_Copy_n(_First, _Count,
			_Dest, _Is_checked(_Dest)));
	}

 
template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutIt _Dest)
	{	
	return (::std:: copy_n(_Array_iterator<_InTy, _InSize>(_First), _Count,
		_Dest));
	}

template<class _InIt,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *copy_n(_InIt _First, _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: copy_n(_First, _Count,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}

template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: copy_n(_Array_iterator<_InTy, _InSize>(_First), _Count,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 2337 "d:\\programs overflow\\vc\\include\\xutility"
 #line 2338 "d:\\programs overflow\\vc\\include\\xutility"

		
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	while (_First != _Last)
		*--_Dest = *--_Last;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_backward(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest - _Count, &*_First,
		_Count * sizeof (*_First));
	return (_Dest - _Count);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Copy_backward(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 










#line 2382 "d:\\programs overflow\\vc\\include\\xutility"
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, true_type)
	{	
	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, false_type)
	{	
	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xutility", 2406);
	_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xutility", 2407);
	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}
 #line 2412 "d:\\programs overflow\\vc\\include\\xutility"

		
template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_Dest, ++_First)
		*_Dest = ::std:: move(*_First);
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	return (_Move(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 










#line 2456 "d:\\programs overflow\\vc\\include\\xutility"
template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, input_iterator_tag, _Mutable_iterator_tag)
	{	
	return (_Move(_First, _Last,
		_Dest));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	_OutIt _Ans = _Dest + (_Last - _First);	
	_Move(_First, _Last,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, true_type)
	{	
	return (_Move(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, false_type)
	{	
	return (_Move(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt move(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xutility", 2500);
	_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xutility", 2501);
	return (_Move(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *move(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: move(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 2518 "d:\\programs overflow\\vc\\include\\xutility"
 #line 2519 "d:\\programs overflow\\vc\\include\\xutility"

		
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	while (_First != _Last)
		*--_Dest = ::std:: move(*--_Last);
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_backward(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest - _Count, &*_First,
		_Count * sizeof (*_First));
	return (_Dest - _Count);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Move_backward(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 










#line 2563 "d:\\programs overflow\\vc\\include\\xutility"
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, true_type)
	{	
	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, false_type)
	{	
	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xutility", 2587);
	_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xutility", 2588);
	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}
 #line 2593 "d:\\programs overflow\\vc\\include\\xutility"

		
template<class _FwdIt,
	class _Ty> inline
	void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	for (; _First != _Last; ++_First)
		*_First = _Val;
	}

inline void _Fill(char *_First, char *_Last, char _Val)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

inline void _Fill(signed char *_First, signed char *_Last, signed char _Val)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

template<class _FwdIt,
	class _Ty> inline
	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xutility", 2622);
	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
	}

		
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	
	for (; 0 < _Count; --_Count, ++_Dest)
		*_Dest = _Val;
	return (_Dest);
	}

inline char *_Fill_n(char *_Dest, size_t _Count, char _Val)
	{	
	:: memset(_Dest, _Val, _Count);
	return (_Dest + _Count);
	}

inline signed char *_Fill_n(signed char *_Dest, size_t _Count,
	signed char _Val)
	{	
	:: memset(_Dest, _Val, _Count);
	return (_Dest + _Count);
	}

inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count,
	unsigned char _Val)
	{	
	:: memset(_Dest, _Val, _Count);
	return (_Dest + _Count);
	}

 








#line 2667 "d:\\programs overflow\\vc\\include\\xutility"
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
		_Mutable_iterator_tag)
	{	
	return (_Fill_n(_Dest, _Count, _Val));
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
		random_access_iterator_tag)
	{	
	_OutIt _Ans = _Dest + _Count;	
	_Fill_n(_Unchecked(_Dest), _Count, _Val);
	return (_Ans);
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
		true_type)
	{	
	return (_Fill_n1(_Dest, _Count, _Val,
		_Iter_cat(_Dest)));
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
		false_type)
	{	
	return (_Fill_n1(_Dest, _Count, _Val,
		_Iter_cat(_Dest)));
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	
	_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xutility", 2713);
	return (_Fill_n(_Dest, _Count, _Val,
		_Is_checked(_Dest)));
	}

 
template<class _OutTy,
	size_t _OutSize,
	class _Diff,
	class _Ty> inline
	_OutTy *fill_n(_OutTy (&_Dest)[_OutSize], _Diff _Count, const _Ty& _Val)
	{	
	return (_Unchecked(::std:: fill_n(_Array_iterator<_OutTy, _OutSize>(_Dest),
		_Count, _Val)));
	}
 #line 2729 "d:\\programs overflow\\vc\\include\\xutility"
 #line 2730 "d:\\programs overflow\\vc\\include\\xutility"

		
template<class _InIt1,
	class _InIt2> inline
	bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	
	for (; _First1 != _Last1; ++_First1, ++_First2)
		if (!(*_First1 == *_First2))
			return (false);
	return (true);
	}

inline bool _Equal(const char *_First1, const char *_Last1,
	const char *_First2)
	{	
	return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool _Equal(const signed char *_First1, const signed char *_Last1,
	const signed char *_First2)
	{	
	return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,
	const unsigned char *_First2)
	{	
	return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

 









#line 2771 "d:\\programs overflow\\vc\\include\\xutility"
template<class _InIt1,
	class _InIt2> inline
	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, true_type)
	{	
	return (_Equal(_First1, _Last1,
		_First2));
	}

template<class _InIt1,
	class _InIt2> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, false_type)
	{	
	return (_Equal(_First1, _Last1,
		_First2));
	}

template<class _InIt1,
	class _InIt2> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2)
	{	
	_Debug_range(_First1, _Last1, L"d:\\programs overflow\\vc\\include\\xutility", 2795);
	_Debug_pointer(_First2, L"d:\\programs overflow\\vc\\include\\xutility", 2796);
	return (_Equal1(_Unchecked(_First1), _Unchecked(_Last1),
		_First2, _Is_checked(_First2)));
	}

 
template<class _InIt1,
	class _InTy,
	size_t _InSize> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize])
	{	
	return (::std:: equal(_First1, _Last1,
		_Array_iterator<_InTy, _InSize>(_First2)));
	}
 #line 2812 "d:\\programs overflow\\vc\\include\\xutility"
 #line 2813 "d:\\programs overflow\\vc\\include\\xutility"

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred)
	{	
	for (; _First1 != _Last1; ++_First1, ++_First2)
		if (!_Pred(*_First1, *_First2))
			return (false);
	return (true);
	}

 










#line 2839 "d:\\programs overflow\\vc\\include\\xutility"
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred, true_type)
	{	
	return (_Equal(_First1, _Last1,
		_First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred, false_type)
	{	
	return (_Equal(_First1, _Last1,
		_First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"d:\\programs overflow\\vc\\include\\xutility", 2866);
	_Debug_pointer(_First2, L"d:\\programs overflow\\vc\\include\\xutility", 2867);
	return (_Equal2(_Unchecked(_First1), _Unchecked(_Last1),
		_First2, _Pred, _Is_checked(_First2)));
	}

 
template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize], _Pr _Pred)
	{	
	return (::std:: equal(_First1, _Last1,
		_Array_iterator<_InTy, _InSize>(_First2), _Pred));
	}
 #line 2884 "d:\\programs overflow\\vc\\include\\xutility"
 #line 2885 "d:\\programs overflow\\vc\\include\\xutility"

		
template<class _InIt1,
	class _InIt2> inline
	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (_Debug_lt(*_First1, *_First2, L"d:\\programs overflow\\vc\\include\\xutility", 2893))
			return (true);
		else if (*_First2 < *_First1)
			return (false);
	return (_First1 == _Last1 && _First2 != _Last2);
	}

inline bool _Lexicographical_compare(
	const unsigned char *_First1, const unsigned char *_Last1,
	const unsigned char *_First2, const unsigned char *_Last2)
	{	
	ptrdiff_t _Num1 = _Last1 - _First1;
	ptrdiff_t _Num2 = _Last2 - _First2;
	int _Ans = :: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
	return (_Ans < 0 || (_Ans == 0 && _Num1 < _Num2));
	}

 









#line 2921 "d:\\programs overflow\\vc\\include\\xutility"

template<class _InIt1,
	class _InIt2> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	_Debug_range(_First1, _Last1, L"d:\\programs overflow\\vc\\include\\xutility", 2927);
	_Debug_range(_First2, _Last2, L"d:\\programs overflow\\vc\\include\\xutility", 2928);
	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2)));
	}

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"d:\\programs overflow\\vc\\include\\xutility", 2941))
			return (true);
		else if (_Pred(*_First2, *_First1))
			return (false);
	return (_First1 == _Last1 && _First2 != _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"d:\\programs overflow\\vc\\include\\xutility", 2954);
	_Debug_range(_First2, _Last2, L"d:\\programs overflow\\vc\\include\\xutility", 2955);
	_Debug_pointer(_Pred, L"d:\\programs overflow\\vc\\include\\xutility", 2956);
	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
	}

		
template<class _Ty,
	class _Ignored> inline
	bool _Within_limits(const _Ty& _Val, true_type, true_type, _Ignored)
	{	
	return ((-128) <= _Val && _Val <= 127);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
	{	
	return (_Val <= 127 || static_cast<_Ty>((-128)) <= _Val);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
	{	
	return (_Val <= 127);
	}

template<class _Ty,
	class _Ignored> inline
	bool _Within_limits(const _Ty& _Val, false_type, true_type, _Ignored)
	{	
	return (0 <= _Val && _Val <= 0xff);
	}

template<class _Ty,
	class _Ignored> inline
	bool _Within_limits(const _Ty& _Val, false_type, false_type, _Ignored)
	{	
	return (_Val <= 0xff);
	}

template<class _InIt,
	class _Ty> inline
	bool _Within_limits(_InIt, const _Ty& _Val)
	{	
	typedef typename remove_pointer<_InIt>::type _Elem;
	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
	}

template<class _InIt> inline
	bool _Within_limits(_InIt, const bool&)
	{	
	return (true);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
	{	
	if (!_Within_limits(_First, _Val))
		return (_Last);
	_First = static_cast<_InIt>(:: memchr(
		_First, static_cast<unsigned char>(_Val), _Last - _First));
	return (_First ? _First : _Last);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
	{	
	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			break;
	return (_First);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	
	typedef integral_constant<bool,
		(  is_same<_InIt, char *>::value
		|| is_same<_InIt, signed char *>::value
		|| is_same<_InIt, unsigned char *>::value
		|| is_same<_InIt, const char *>::value
		|| is_same<_InIt, const signed char *>::value
		|| is_same<_InIt, const unsigned char *>::value)
		&& is_integral<_Ty>::value
	> _Memchr_opt;
	return (_Find(_First, _Last, _Val, _Memchr_opt()));
	}

template<class _InIt,
	class _Ty> inline
	_InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xutility", 3052);
	return (_Rechecked(_First,
		_Find(_Unchecked(_First), _Unchecked(_Last), _Val)));
	}

		
template<class _InIt,
	class _Ty,
	class _Pr> inline
	_InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			break;
	return (_First);
	}

		
template<class _InIt,
	class _Ty> inline
	typename iterator_traits<_InIt>::difference_type
		_Count_np(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	typename iterator_traits<_InIt>::difference_type _Count = 0;

	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			++_Count;
	return (_Count);
	}

template<class _InIt,
	class _Ty> inline
	typename iterator_traits<_InIt>::difference_type
		count(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xutility", 3088);
	return (_Count_np(_Unchecked(_First), _Unchecked(_Last), _Val));
	}

		
template<class _InIt,
	class _Ty,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		_Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
	{	
	typename iterator_traits<_InIt>::difference_type _Count = 0;

	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			++_Count;
	return (_Count);
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred)
	{	
	for (; _First1 != _Last1; ++_First1, ++_First2)
		if (!_Pred(*_First1, *_First2))
			break;	
	if (_First1 != _Last1)
		{	
		_FwdIt2 _Last2 = _First2;
		advance(_Last2, distance(_First1, _Last1));
		for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
			if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
				{	
				typename iterator_traits<_FwdIt2>::difference_type _Count =
					_Count_pr(_First2, _Last2, *_Next1, _Pred);
				if (_Count == 0
					|| _Count != _Count_pr(_Next1, _Last1, *_Next1, _Pred))
					return (false);	
				}
		}
	return (true);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"d:\\programs overflow\\vc\\include\\xutility", 3140);
	_Debug_pointer(_Pred, L"d:\\programs overflow\\vc\\include\\xutility", 3141);
	return _Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Pred);
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2)
	{	
	return (::std:: is_permutation(_First1, _Last1,
		_First2, equal_to<>()));
	}

		
template<class _BidIt> inline
	void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
	{	
	for (; _First != _Last && _First != --_Last; ++_First)
		::std:: iter_swap(_First, _Last);
	}

template<class _BidIt> inline
	void reverse(_BidIt _First, _BidIt _Last)
	{	
	_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xutility", 3167);
	_Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
	}

		
template<class _FwdIt> inline
	void _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		forward_iterator_tag)
	{	
	for (_FwdIt _Next = _Mid; ; )
		{	
		::std:: iter_swap(_First, _Next);
		if (++_First == _Mid)
			if (++_Next == _Last)
				break;	
			else
				_Mid = _Next;	
		else if (++_Next == _Last)
			_Next = _Mid;	
		}
	}

template<class _BidIt> inline
	void _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		bidirectional_iterator_tag)
	{	
	::std:: reverse(_First, _Mid);
	::std:: reverse(_Mid, _Last);
	::std:: reverse(_First, _Last);
	}

template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff *, _Ty *)
	{	
	_Diff _Shift = _Mid - _First;
	_Diff _Count = _Last - _First;

	for (_Diff _Factor = _Shift; _Factor != 0; )
		{	
		_Diff _Tmp = _Count % _Factor;
		_Count = _Factor;
		_Factor = _Tmp;
		}

	if (_Count < _Last - _First)
		for (; 0 < _Count; --_Count)
			{	
			_RanIt _Hole = _First + _Count;
			_RanIt _Next = _Hole;
			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;
			for (; ; )
				{	
				iter_swap(_Next, _Next1);
				_Next = _Next1;
				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
					: _First + (_Shift - (_Last - _Next1));
				if (_Next1 == _Hole)
					break;
				}
			}
	}

template<class _RanIt> inline
	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,
		random_access_iterator_tag)
	{	
	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));
	}

template<class _FwdIt> inline
	_FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{	
	_Debug_range(_First, _Mid, L"d:\\programs overflow\\vc\\include\\xutility", 3241);
	_Debug_range(_Mid, _Last, L"d:\\programs overflow\\vc\\include\\xutility", 3242);
	if (_First != _Mid && _Mid != _Last)
		_Rotate(_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last),
			_Iter_cat(_First));
	::std:: advance(_First, ::std:: distance(_Mid, _Last));
	return (_First);
	}

	
template<class _Diff, class _Urng>
	class _Rng_from_urng
	{	
public:
	typedef typename make_unsigned<_Diff>::type _Ty0;
	typedef typename _Urng::result_type _Ty1;

	typedef typename _If<sizeof (_Ty1) < sizeof (_Ty0),
		_Ty0, _Ty1>::type _Udiff;


	explicit _Rng_from_urng(_Urng& _Func)
		: _Ref(_Func), _Bits(8 * sizeof (_Udiff)), _Bmask(_Udiff(-1))
		{	
		for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
			--_Bits;
		}

	_Diff operator()(_Diff _Index)
		{	
		for (; ; )
			{	
			_Udiff _Ret = 0;	
			_Udiff _Mask = 0;	

			while (_Mask < _Udiff(_Index - 1))
				{	
				_Ret <<= _Bits - 1;	
				_Ret <<= 1;
				_Ret |= _Get_bits();
				_Mask <<= _Bits - 1;	
				_Mask <<= 1;
				_Mask |= _Bmask;
				}

			
			if (_Ret / _Index < _Mask / _Index
				|| _Mask % _Index == _Udiff(_Index - 1))
				return (_Ret % _Index);
			}
		}

	_Udiff _Get_all_bits()
		{	
		_Udiff _Ret = 0;

		for (size_t _Num = 0; _Num < 8 * sizeof (_Udiff);
			_Num += _Bits)
			{	
			_Ret <<= _Bits - 1;	
			_Ret <<= 1;
			_Ret |= _Get_bits();
			}

		return (_Ret);
		}

private:
	_Udiff _Get_bits()
		{	
		for (; ; )
			{	
			_Udiff _Val = _Ref() - (_Urng::min)();

			if (_Val <= _Bmask)
				return (_Val);
			}
		}

	_Urng& _Ref;	
	size_t _Bits;	
	_Udiff _Bmask;	

public:
	_Rng_from_urng(const _Rng_from_urng&) = delete;
	_Rng_from_urng& operator=(const _Rng_from_urng&) = delete;
	};

		
template<class _Elem>
	class __declspec(dllimport) _Yarn
	{	
public:
	typedef _Yarn<_Elem> _Myt;

	 _Yarn()
		: _Myptr(0), _Nul(0)
		{	
		}

	 _Yarn(const _Myt& _Right)
		: _Myptr(0), _Nul(0)
		{	
		*this = _Right;
		}

	 _Yarn(const _Elem *_Right)
		: _Myptr(0), _Nul(0)
		{	
		*this = _Right;
		}

	_Myt&  operator=(const _Myt& _Right)
		{	
		return (*this = _Right._Myptr);
		}

	_Myt&  operator=(const _Elem *_Right)
		{	
		if (_Myptr != _Right)
			{	
			_Tidy();

			if (_Right != 0)
				{	
				const _Elem *_Ptr = _Right;
				while (*_Ptr != (_Elem)0)
					++_Ptr;
				size_t _Count = ((const char *)++_Ptr - (const char *)_Right);

 
				_Myptr = (_Elem *)_malloc_dbg(_Count, 2,
					"d:\\programs overflow\\vc\\include\\xutility", 3373);

 

#line 3378 "d:\\programs overflow\\vc\\include\\xutility"

				if (_Myptr != 0)
					:: memcpy(_Myptr, _Right, _Count);
				}
			}
		return (*this);
		}

	 ~_Yarn() throw ()
		{	
		_Tidy();
		}

	bool  empty() const
		{	
		return (_Myptr == 0);
		}

	const _Elem * c_str() const
		{	
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

	bool  _Empty() const
		{	
		return (_Myptr == 0);
		}

	const _Elem * _C_str() const
		{	
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

private:
	void  _Tidy()
		{	
		if (_Myptr != 0)

 
			_free_dbg(_Myptr, 2);

 

#line 3422 "d:\\programs overflow\\vc\\include\\xutility"

		_Myptr = 0;
		}

	_Elem *_Myptr;	
	_Elem _Nul;		
	};

	
template<class _Ty,
	class _Alloc>
	struct _Has_allocator_type
	{	
	template<class _Uty>
		static auto _Fn(int)
			-> is_convertible<_Alloc,
				typename _Uty::allocator_type>;
	template<class _Uty>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_Ty>(0)) type;
	};

		
struct allocator_arg_t
	{	
	};

const allocator_arg_t allocator_arg = allocator_arg_t();

__declspec(dllimport) __declspec(noreturn) void __cdecl _Xbad_alloc();
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xinvalid_argument(  const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xlength_error(  const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xout_of_range(  const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xoverflow_error(  const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xruntime_error(  const char *);
}

namespace std {
		
template<class _Ty,
	class _Alloc>
	struct uses_allocator
		: _Has_allocator_type<_Ty, _Alloc>::type
	{	
	};
}	
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3474 "d:\\programs overflow\\vc\\include\\xutility"
#line 3475 "d:\\programs overflow\\vc\\include\\xutility"























#line 10 "d:\\programs overflow\\vc\\include\\xmemory0"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4100)

namespace std {
		
template<class _Ty> inline
	_Ty *_Allocate(size_t _Count, _Ty *)
	{	
	void *_Ptr = 0;

	if (_Count == 0)
		;
	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)
		_Xbad_alloc();	

	return ((_Ty *)_Ptr);
	}

		
template<class _Ty1,
	class _Ty2> inline
	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
	{	
	void *_Vptr = _Ptr;
	::new (_Vptr) _Ty1(::std:: forward<_Ty2>(_Val));
	}

template<class _Ty1> inline
	void _Construct(_Ty1 *_Ptr)
	{	
	void *_Vptr = _Ptr;

	::new (_Vptr) _Ty1();
	}

		
template<class _Ty> inline
	void _Destroy(_Ty *_Ptr)
	{	
	_Ptr->~_Ty();
	}

template<> inline
	void _Destroy(char *)
	{	
	}

template<> inline
	void _Destroy(wchar_t *)
	{	
	}

 
template<> inline
	void _Destroy(unsigned short *)
	{	
	}
 #line 74 "d:\\programs overflow\\vc\\include\\xmemory0"

		
template<class _Alloc> inline
	void _Destroy_range(typename _Alloc::pointer _First,
		typename _Alloc::pointer _Last, _Alloc& _Al,
		_Nonscalar_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_First)
		_Al.destroy(_First);
	}

template<class _Alloc> inline
	void _Destroy_range(typename _Alloc::pointer _First,
		typename _Alloc::pointer _Last, _Alloc& _Al,
		_Scalar_ptr_iterator_tag)
	{	
	}

template<class _Alloc> inline
	void _Destroy_range(typename _Alloc::pointer _First,
		typename _Alloc::pointer _Last, _Alloc& _Al)
	{	
	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
	}

		
template<class _Alty>
	struct _Is_simple_alloc
		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
		&& is_same<typename _Alty::pointer,
			typename _Alty::value_type *>::value
		&& is_same<typename _Alty::const_pointer,
			const typename _Alty::value_type *>::value
		&& is_same<typename _Alty::reference,
			typename _Alty::value_type&>::value
		&& is_same<typename _Alty::const_reference,
			const typename _Alty::value_type&>::value>
	{	
	};

		
template<class _Value_type>
	struct _Simple_types
	{	
	typedef _Value_type value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef value_type *pointer;
	typedef const value_type *const_pointer;
	typedef value_type& reference;
	typedef const value_type& const_reference;
	};

		
template<class _Alty,
	class _Pointer>
	struct _Get_voidptr
	{	
	typedef typename _Alty::template rebind<void>::other _Alvoid;
	typedef typename _Alvoid::pointer type;
	};

template<class _Alty,
	class _Ty>
	struct _Get_voidptr<_Alty, _Ty *>
	{	
	typedef void *type;
	};

		
template<class _Iter>
	struct _Is_iterator
	: public integral_constant<bool, !is_integral<_Iter>::value>
	{	
	};

		
template<class _Ty>
	struct _Get_first_parameter;

template<template<class, class...> class _Ty,
	class _First,
	class... _Rest>
	struct _Get_first_parameter<_Ty<_First, _Rest...> >
	{	
	typedef _First type;
	};

		
template<class _Newfirst,
	class _Ty>
	struct _Replace_first_parameter;

template<class _Newfirst,
	template<class, class...> class _Ty,
	class _First,
	class... _Rest>
	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
	{	
	typedef _Ty<_Newfirst, _Rest...> type;
	};

		
template<class _Ty>
	struct _Get_element_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::element_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_first_parameter<_Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 182 "d:\\programs overflow\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_ptr_difference_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<ptrdiff_t>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 188 "d:\\programs overflow\\vc\\include\\xmemory0"

		
template<class _Ty,
	class _Other>
	struct _Get_rebind_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::template rebind<_Other>::other>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Replace_first_parameter<_Other , _Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 195 "d:\\programs overflow\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct pointer_traits
	{	
	typedef typename _Get_element_type<_Ty>::type element_type;
	typedef _Ty pointer;
	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;

	template<class _Other>
		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;

	typedef typename _If<is_void<element_type>::value,
		char&,
		typename add_reference<element_type>::type>::type _Reftype;

	static pointer pointer_to(_Reftype _Val)
		{	
		return (_Ty::pointer_to(_Val));
		}
	};

		
template<class _Ty>
	struct pointer_traits<_Ty *>
	{	
	typedef _Ty element_type;
	typedef _Ty *pointer;
	typedef ptrdiff_t difference_type;

	template<class _Other>
		using rebind = _Other *;

	typedef typename _If<is_void<_Ty>::value,
		char&,
		typename add_reference<_Ty>::type>::type _Reftype;

	static pointer pointer_to(_Reftype _Val)
		{	
		return (::std:: addressof(_Val));
		}
	};

		
template<class _Ty>
	struct _Get_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Ty::value_type *>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 243 "d:\\programs overflow\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_const_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const typename _Ty::value_type>>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 250 "d:\\programs overflow\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_void_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<void>>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 257 "d:\\programs overflow\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_const_void_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const void>>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 264 "d:\\programs overflow\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_difference_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_ptr_difference_type< typename _Get_pointer_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 271 "d:\\programs overflow\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_size_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::size_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename make_unsigned< typename _Get_difference_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 278 "d:\\programs overflow\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_copy
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_copy_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 284 "d:\\programs overflow\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_move
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_move_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 290 "d:\\programs overflow\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_swap
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_swap>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 296 "d:\\programs overflow\\vc\\include\\xmemory0"

		
struct _Alloc_allocate
	{	
		

	template<class _Alloc,
		class _Size_type,
		class _Const_void_pointer>
		static auto _Fn(int, _Alloc& _Al,
			_Size_type _Count,
			_Const_void_pointer _Hint)
			-> decltype(_Al.allocate(_Count, _Hint))
		{	
		return (_Al.allocate(_Count, _Hint));
		}

	template<class _Alloc,
		class _Size_type,
		class _Const_void_pointer>
		static auto _Fn(_Wrap_int, _Alloc& _Al,
			_Size_type _Count,
			_Const_void_pointer)
			-> decltype(_Al.allocate(_Count))
		{	
		return (_Al.allocate(_Count));
		}
	};

		
struct _Alloc_construct
	{	
		

	template<class _Ty,
		class _Objty,
		class... _Types>
		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
			_Types&&... _Args)
			-> decltype(
				_Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...))
		{	
		_Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
		}

	template<class _Ty,
		class _Objty,
		class... _Types>
		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
			_Types&&... _Args)
			-> void
		{	
		::new (static_cast<void *>(_Ptr))
			_Objty(::std:: forward<_Types>(_Args)...);
		}

	};

		
struct _Alloc_destroy
	{	
	template<class _Ty,
		class _Objty>
		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
			-> decltype(_Al.destroy(_Ptr))
		{	
		_Al.destroy(_Ptr);
		}

	template<class _Ty,
		class _Objty>
		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
			-> void
		{	
		_Ptr->~_Objty();
		}
	};

		
struct _Alloc_max_size
	{	
	template<class _Ty>
		static auto _Fn(int, const _Ty& _Al)
			-> decltype(_Al.max_size())
		{	
		return (_Al.max_size());
		}

	template<class _Ty>
		static auto _Fn(_Wrap_int, const _Ty&)
			-> typename _Get_size_type<_Ty>::type
		{	
		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
		}
	};

		
struct _Alloc_select
	{	
		

	template<class _Ty>
		static auto _Fn(int, const _Ty& _Al)
			-> decltype((_Ty)_Al.select_on_container_copy_construction())
		{	
		return (_Al.select_on_container_copy_construction());
		}

	template<class _Ty>
		static auto _Fn(_Wrap_int, const _Ty& _Al)
			-> _Ty
		{	
		return (_Al);
		}
	};

		
template<class _Alloc>
	struct allocator_traits
	{	
	typedef allocator_traits<_Alloc> other;

	typedef _Alloc allocator_type;
	typedef typename _Alloc::value_type value_type;

	typedef typename _Get_pointer_type<_Alloc>::type
		pointer;
	typedef typename _Get_const_pointer_type<_Alloc>::type
		const_pointer;
	typedef typename _Get_void_pointer_type<_Alloc>::type
		void_pointer;
	typedef typename _Get_const_void_pointer_type<_Alloc>::type
		const_void_pointer;

	typedef typename _Get_size_type<_Alloc>::type size_type;
	typedef typename _Get_difference_type<_Alloc>::type difference_type;

	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
		propagate_on_container_copy_assignment;
	typedef typename _Get_propagate_on_container_move<_Alloc>::type
		propagate_on_container_move_assignment;
	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
		propagate_on_container_swap;

	template<class _Other>
		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

	template<class _Other>
		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;

	static pointer allocate(_Alloc& _Al, size_type _Count)
		{	
		return (_Al.allocate(_Count));
		}

	static pointer allocate(_Alloc& _Al, size_type _Count,
		const_void_pointer _Hint)
		{	
		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
		}

	static void deallocate(_Alloc& _Al,
		pointer _Ptr, size_type _Count)
		{	
		_Al.deallocate(_Ptr, _Count);
		}

	template<class _Ty,
		class... _Types>
		static void construct(_Alloc& _Al, _Ty *_Ptr,
			_Types&&... _Args)
		{	
		_Alloc_construct::_Fn(0, _Al, _Ptr,
			::std:: forward<_Types>(_Args)...);
		}


	template<class _Ty>
		static void destroy(_Alloc& _Al, _Ty *_Ptr)
		{	
		_Alloc_destroy::_Fn(0, _Al, _Ptr);
		}

	static size_type max_size(const _Alloc& _Al)
		{	
		return (_Alloc_max_size::_Fn(0, _Al));
		}

	static _Alloc select_on_container_copy_construction(
		const _Alloc& _Al)
		{	
		return (_Alloc_select::_Fn(0, _Al));
		}
	};

		
template<class _Ty>
	struct _Allocator_base
	{	
	typedef _Ty value_type;
	};

		
template<class _Ty>
	struct _Allocator_base<const _Ty>
	{	
	typedef _Ty value_type;
	};

		
template<class _Ty>
	class allocator
		: public _Allocator_base<_Ty>
	{	
public:
	typedef allocator<_Ty> other;

	typedef _Allocator_base<_Ty> _Mybase;
	typedef typename _Mybase::value_type value_type;

	typedef value_type *pointer;
	typedef const value_type *const_pointer;
	typedef void *void_pointer;
	typedef const void *const_void_pointer;

	typedef value_type& reference;
	typedef const value_type& const_reference;

	typedef size_t size_type;
	typedef ptrdiff_t difference_type;

	typedef false_type propagate_on_container_copy_assignment;
	typedef false_type propagate_on_container_move_assignment;
	typedef false_type propagate_on_container_swap;

	allocator<_Ty> select_on_container_copy_construction() const
		{	
		return (*this);
		}

	template<class _Other>
		struct rebind
		{	
		typedef allocator<_Other> other;
		};

	pointer address(reference _Val) const throw ()
		{	
		return (::std:: addressof(_Val));
		}

	const_pointer address(const_reference _Val) const throw ()
		{	
		return (::std:: addressof(_Val));
		}

	allocator() throw ()
		{	
		}

	allocator(const allocator<_Ty>&) throw ()
		{	
		}

	template<class _Other>
		allocator(const allocator<_Other>&) throw ()
		{	
		}

	template<class _Other>
		allocator<_Ty>& operator=(const allocator<_Other>&)
		{	
		return (*this);
		}

	void deallocate(pointer _Ptr, size_type)
		{	
		::operator delete(_Ptr);
		}

	pointer allocate(size_type _Count)
		{	
		return (_Allocate(_Count, (pointer)0));
		}

	pointer allocate(size_type _Count, const void *)
		{	
		return (allocate(_Count));
		}

	void construct(_Ty *_Ptr)
		{	
		::new ((void *)_Ptr) _Ty();
		}

	void construct(_Ty *_Ptr, const _Ty& _Val)
		{	
		::new ((void *)_Ptr) _Ty(_Val);
		}

	template<class _Objty,
		class... _Types>
		void construct(_Objty *_Ptr, _Types&&... _Args)
		{	
		::new ((void *)_Ptr) _Objty(::std:: forward<_Types>(_Args)...);
		}


	template<class _Uty>
		void destroy(_Uty *_Ptr)
		{	
		_Ptr->~_Uty();
		}

	size_t max_size() const throw ()
		{	
		return ((size_t)(-1) / sizeof (_Ty));
		}
	};

		
template<>
	class allocator<void>
	{	
public:
	typedef allocator<void> other;

	typedef void value_type;

	typedef void *pointer;
	typedef const void *const_pointer;
	typedef void *void_pointer;
	typedef const void *const_void_pointer;

	template<class _Other>
		struct rebind
		{	
		typedef allocator<_Other> other;
		};

	allocator() throw ()
		{	
		}

	allocator(const allocator<void>&) throw ()
		{	
		}

	template<class _Other>
		allocator(const allocator<_Other>&) throw ()
		{	
		}

	template<class _Other>
		allocator<void>& operator=(const allocator<_Other>&)
		{	
		return (*this);
		}
	};

template<class _Ty,
	class _Other> inline
	bool operator==(const allocator<_Ty>&,
		const allocator<_Other>&) throw ()
	{	
	return (true);
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const allocator<_Ty>& _Left,
		const allocator<_Other>& _Right) throw ()
	{	
	return (!(_Left == _Right));
	}

		
template<class _Ty>
	struct allocator_traits<allocator<_Ty> >
	{	
	typedef allocator<_Ty> _Alloc;

	typedef allocator_traits<_Alloc> other;

	typedef _Alloc allocator_type;
	typedef typename _Alloc::value_type value_type;

	typedef value_type *pointer;
	typedef const value_type *const_pointer;
	typedef void *void_pointer;
	typedef const void *const_void_pointer;

	typedef size_t size_type;
	typedef ptrdiff_t difference_type;

	typedef false_type propagate_on_container_copy_assignment;
	typedef false_type propagate_on_container_move_assignment;
	typedef false_type propagate_on_container_swap;

	template<class _Other>
		using rebind_alloc = allocator<_Other>;

	template<class _Other>
		using rebind_traits = allocator_traits<allocator<_Other> >;

	static pointer allocate(_Alloc& _Al, size_type _Count)
		{	
		return (_Al.allocate(_Count));
		}

	static pointer allocate(_Alloc& _Al, size_type _Count,
		const_void_pointer _Hint)
		{	
		return (_Al.allocate(_Count, _Hint));
		}

	static void deallocate(_Alloc& _Al,
		pointer _Ptr, size_type _Count)
		{	
		_Al.deallocate(_Ptr, _Count);
		}

	template<class _Objty,
		class... _Types>
		static void construct(_Alloc& _Al, _Objty *_Ptr,
			_Types&&... _Args)
		{	
		_Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
		}


	template<class _Uty>
		static void destroy(_Alloc& _Al, _Uty *_Ptr)
		{	
		_Al.destroy(_Ptr);
		}

	static size_type max_size(const _Alloc& _Al)
		{	
		return (_Al.max_size());
		}

	static _Alloc select_on_container_copy_construction(
		const _Alloc& _Al)
		{	
		return (_Al.select_on_container_copy_construction());
		}
	};

		
template<class _Alloc>
	struct _Wrap_alloc
		: public _Alloc
	{	
	typedef _Wrap_alloc<_Alloc> other;

	typedef _Alloc _Mybase;
	typedef allocator_traits<_Alloc> _Mytraits;

	typedef typename _Mytraits::value_type value_type;

	typedef typename _Mytraits::pointer pointer;
	typedef typename _Mytraits::const_pointer const_pointer;
	typedef typename _Mytraits::void_pointer void_pointer;
	typedef typename _Mytraits::const_void_pointer const_void_pointer;

	typedef typename _If<is_void<value_type>::value,
		int, value_type>::type& reference;
	typedef typename _If<is_void<const value_type>::value,
		const int, const value_type>::type& const_reference;

	typedef typename _Mytraits::size_type size_type;
	typedef typename _Mytraits::difference_type difference_type;

	typedef typename _Mytraits::propagate_on_container_copy_assignment
		propagate_on_container_copy_assignment;
	typedef typename _Mytraits::propagate_on_container_move_assignment
		propagate_on_container_move_assignment;
	typedef typename _Mytraits::propagate_on_container_swap
		propagate_on_container_swap;

	_Wrap_alloc select_on_container_copy_construction() const
		{	
		return (_Mytraits::select_on_container_copy_construction(*this));
		}

	template<class _Other>
		struct rebind
		{	
		typedef typename _Mytraits::template rebind_alloc<_Other> _Other_alloc;
		typedef _Wrap_alloc<_Other_alloc> other;
		};

	pointer address(reference _Val) const
		{	
		return (::std:: addressof(_Val));
		}

	const_pointer address(const_reference _Val) const
		{	
		return (::std:: addressof(_Val));
		}

	_Wrap_alloc() throw ()
		: _Mybase()
		{	
		}

	_Wrap_alloc(const _Mybase& _Right) throw ()
		: _Mybase(_Right)
		{	
		}

	_Wrap_alloc(const _Wrap_alloc& _Right) throw ()
		: _Mybase(_Right)
		{	
		}

	template<class _Other>
		_Wrap_alloc(const _Other& _Right) throw ()
		: _Mybase(_Right)
		{	
		}

	template<class _Other>
		_Wrap_alloc(_Other& _Right) throw ()
		: _Mybase(_Right)
		{	
		}

	_Wrap_alloc& operator=(const _Mybase& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	_Wrap_alloc& operator=(const _Wrap_alloc& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	template<class _Other>
		_Wrap_alloc& operator=(const _Other& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	pointer allocate(size_type _Count)
		{	
		return (_Mybase::allocate(_Count));
		}

	pointer allocate(size_type _Count,
		const_void_pointer _Hint)
		{	
		return (_Mytraits::allocate(*this, _Count, _Hint));
		}

	void deallocate(pointer _Ptr, size_type _Count)
		{	
		_Mybase::deallocate(_Ptr, _Count);
		}

	void construct(value_type *_Ptr)
		{	
		_Mytraits::construct(*this, _Ptr);
		}

	template<class _Ty,
		class... _Types>
		void construct(_Ty *_Ptr,
			_Types&&... _Args)
		{	
		_Mytraits::construct(*this, _Ptr,
			::std:: forward<_Types>(_Args)...);
		}


	template<class _Ty>
		void destroy(_Ty *_Ptr)
		{	
		_Mytraits::destroy(*this, _Ptr);
		}

	size_type max_size() const throw ()
		{	
		return (_Mytraits::max_size(*this));
		}
	};

template<class _Ty,
	class _Other> inline
	bool operator==(const _Wrap_alloc<_Ty>& _Left,
		const _Wrap_alloc<_Other>& _Right) throw ()
	{	
	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const _Wrap_alloc<_Ty>& _Left,
		const _Wrap_alloc<_Other>& _Right) throw ()
	{	
	return (!(_Left == _Right));
	}
}

		

  
   #line 1 "d:\\programs overflow\\vc\\include\\xatomic0.h"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
 
  
 #line 17 "d:\\programs overflow\\vc\\include\\xatomic0.h"

		
typedef enum memory_order {
	memory_order_relaxed,
	memory_order_consume,
	memory_order_acquire,
	memory_order_release,
	memory_order_acq_rel,
	memory_order_seq_cst
	} memory_order;

typedef _Uint32t _Uint4_t;
typedef _Uint4_t _Atomic_integral_t;

	
	




  
  
  
  
  

  






#line 51 "d:\\programs overflow\\vc\\include\\xatomic0.h"
   

   

#line 56 "d:\\programs overflow\\vc\\include\\xatomic0.h"
	
   #line 58 "d:\\programs overflow\\vc\\include\\xatomic0.h"
  #line 59 "d:\\programs overflow\\vc\\include\\xatomic0.h"

  

#line 63 "d:\\programs overflow\\vc\\include\\xatomic0.h"

  
   
  #line 67 "d:\\programs overflow\\vc\\include\\xatomic0.h"

		

typedef long _Atomic_flag_t;

  
  
  

		
inline _Uint4_t _Atomic_load_4(volatile _Uint4_t *, memory_order);
inline int _Atomic_compare_exchange_weak_4(
	volatile _Uint4_t *, _Uint4_t *, _Uint4_t, memory_order, memory_order);
inline _Uint4_t _Atomic_fetch_add_4(
	volatile _Uint4_t *, _Uint4_t, memory_order);
inline _Uint4_t _Atomic_fetch_sub_4(
	volatile _Uint4_t *, _Uint4_t, memory_order);

typedef _Atomic_integral_t _Atomic_counter_t;

  
inline _Atomic_integral_t
	_Get_atomic_count(const _Atomic_counter_t& _Counter)
	{	
	return (_Counter);
	}

inline void _Init_atomic_counter(_Atomic_counter_t& _Counter,
	_Atomic_integral_t _Value)
	{	
	_Counter = _Value;
	}

inline _Atomic_integral_t _Inc_atomic_counter_explicit(
	_Atomic_counter_t& _Counter, memory_order _Order)
	{	
	return (_Atomic_fetch_add_4(&_Counter, 1, _Order) + 1);
	}

inline _Atomic_integral_t _Inc_atomic_counter(_Atomic_counter_t& _Counter)
	{	
	return (_Inc_atomic_counter_explicit(_Counter, memory_order_seq_cst));
	}

inline _Atomic_integral_t _Dec_atomic_counter_explicit(
	_Atomic_counter_t& _Counter, memory_order _Order)
	{	
	return (_Atomic_fetch_sub_4(&_Counter, 1, _Order) - 1);
	}

inline _Atomic_integral_t _Dec_atomic_counter(_Atomic_counter_t& _Counter)
	{	
	return (_Dec_atomic_counter_explicit(_Counter, memory_order_seq_cst));
	}

inline _Atomic_integral_t _Load_atomic_counter_explicit(
	_Atomic_counter_t& _Counter, memory_order _Order)
	{	
	return (_Atomic_load_4(&_Counter, _Order));
	}

inline _Atomic_integral_t _Load_atomic_counter(_Atomic_counter_t& _Counter)
	{	
	return (_Load_atomic_counter_explicit(_Counter, memory_order_seq_cst));
	}

inline _Atomic_integral_t _Compare_increment_atomic_counter_explicit(
	_Atomic_counter_t& _Counter,
	_Atomic_integral_t _Expected,
	memory_order _Order)
	{	
	return (_Atomic_compare_exchange_weak_4(
		&_Counter, &_Expected, _Expected + 1,
		_Order, _Order));
	}

inline _Atomic_integral_t _Compare_increment_atomic_counter(
	_Atomic_counter_t& _Counter, _Atomic_integral_t _Expected)
	{	
	return (_Compare_increment_atomic_counter_explicit(
		_Counter, _Expected, memory_order_seq_cst));
	}

  






























#line 182 "d:\\programs overflow\\vc\\include\\xatomic0.h"

		
extern "C" {
__declspec(dllimport) void __cdecl _Lock_shared_ptr_spin_lock();
__declspec(dllimport) void __cdecl _Unlock_shared_ptr_spin_lock();
}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 193 "d:\\programs overflow\\vc\\include\\xatomic0.h"
#line 194 "d:\\programs overflow\\vc\\include\\xatomic0.h"





#line 909 "d:\\programs overflow\\vc\\include\\xmemory0"
   #line 1 "d:\\programs overflow\\vc\\include\\intrin.h"












#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 19 "d:\\programs overflow\\vc\\include\\intrin.h"
#line 1 "d:\\programs overflow\\vc\\include\\setjmp.h"















#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "d:\\programs overflow\\vc\\include\\setjmp.h"









#line 32 "d:\\programs overflow\\vc\\include\\setjmp.h"





#pragma pack(push,8)


extern "C" {
#line 42 "d:\\programs overflow\\vc\\include\\setjmp.h"













#line 56 "d:\\programs overflow\\vc\\include\\setjmp.h"







typedef struct __JUMP_BUFFER {
    unsigned long Ebp;
    unsigned long Ebx;
    unsigned long Edi;
    unsigned long Esi;
    unsigned long Esp;
    unsigned long Eip;
    unsigned long Registration;
    unsigned long TryLevel;
    unsigned long Cookie;
    unsigned long UnwindFunc;
    unsigned long UnwindData[6];
} _JUMP_BUFFER;





















































































#line 162 "d:\\programs overflow\\vc\\include\\setjmp.h"





typedef int jmp_buf[16];


#line 171 "d:\\programs overflow\\vc\\include\\setjmp.h"




int __cdecl _setjmp(  jmp_buf _Buf);


}
#line 180 "d:\\programs overflow\\vc\\include\\setjmp.h"


#pragma warning(push)
#pragma warning(disable:4987)
extern "C"
{
__declspec(dllimport) __declspec(noreturn) void __cdecl longjmp(  jmp_buf _Buf,   int _Value) throw(...);
}
#pragma warning(pop)


#line 192 "d:\\programs overflow\\vc\\include\\setjmp.h"

#pragma pack(pop)

#line 196 "d:\\programs overflow\\vc\\include\\setjmp.h"
#line 20 "d:\\programs overflow\\vc\\include\\intrin.h"






#line 1 "d:\\programs overflow\\vc\\include\\immintrin.h"













#pragma once






#line 22 "d:\\programs overflow\\vc\\include\\immintrin.h"

#line 1 "d:\\programs overflow\\vc\\include\\wmmintrin.h"
















#pragma once






#line 25 "d:\\programs overflow\\vc\\include\\wmmintrin.h"

#line 1 "d:\\programs overflow\\vc\\include\\nmmintrin.h"

















#pragma once






#line 26 "d:\\programs overflow\\vc\\include\\nmmintrin.h"

#line 1 "d:\\programs overflow\\vc\\include\\smmintrin.h"

















#pragma once






#line 26 "d:\\programs overflow\\vc\\include\\smmintrin.h"

#line 1 "d:\\programs overflow\\vc\\include\\tmmintrin.h"










#pragma once






#line 19 "d:\\programs overflow\\vc\\include\\tmmintrin.h"

#line 1 "d:\\programs overflow\\vc\\include\\pmmintrin.h"


















#pragma once






#line 27 "d:\\programs overflow\\vc\\include\\pmmintrin.h"




#line 1 "d:\\programs overflow\\vc\\include\\emmintrin.h"




















#pragma once






#line 29 "d:\\programs overflow\\vc\\include\\emmintrin.h"




#line 1 "d:\\programs overflow\\vc\\include\\xmmintrin.h"



























#pragma once






#line 36 "d:\\programs overflow\\vc\\include\\xmmintrin.h"





#line 1 "d:\\programs overflow\\vc\\include\\mmintrin.h"


















#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 20 "d:\\programs overflow\\vc\\include\\mmintrin.h"



#line 24 "d:\\programs overflow\\vc\\include\\mmintrin.h"


extern "C" { 


#line 30 "d:\\programs overflow\\vc\\include\\mmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(8)) __m64
{
    unsigned __int64    m64_u64;
    float               m64_f32[2];
    __int8              m64_i8[8];
    __int16             m64_i16[4];
    __int32             m64_i32[2];
    __int64             m64_i64;
    unsigned __int8     m64_u8[8];
    unsigned __int16    m64_u16[4];
    unsigned __int32    m64_u32[2];
} __m64;


void  _m_empty(void);
__m64 _m_from_int(int _I);
int   _m_to_int(__m64 _M);
__m64 _m_packsswb(__m64 _MM1, __m64 _MM2);
__m64 _m_packssdw(__m64 _MM1, __m64 _MM2);
__m64 _m_packuswb(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhdq(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckldq(__m64 _MM1, __m64 _MM2);


__m64 _m_paddb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddd(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubd(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmaddwd(__m64 _MM1, __m64 _MM2);
__m64 _m_pmulhw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmullw(__m64 _MM1, __m64 _MM2);


__m64 _m_psllw(__m64 _M, __m64 _Count);
__m64 _m_psllwi(__m64 _M, int _Count);
__m64 _m_pslld(__m64 _M, __m64 _Count);
__m64 _m_pslldi(__m64 _M, int _Count);
__m64 _m_psllq(__m64 _M, __m64 _Count);
__m64 _m_psllqi(__m64 _M, int _Count);
__m64 _m_psraw(__m64 _M, __m64 _Count);
__m64 _m_psrawi(__m64 _M, int _Count);
__m64 _m_psrad(__m64 _M, __m64 _Count);
__m64 _m_psradi(__m64 _M, int _Count);
__m64 _m_psrlw(__m64 _M, __m64 _Count);
__m64 _m_psrlwi(__m64 _M, int _Count);
__m64 _m_psrld(__m64 _M, __m64 _Count);
__m64 _m_psrldi(__m64 _M, int _Count);
__m64 _m_psrlq(__m64 _M, __m64 _Count);
__m64 _m_psrlqi(__m64 _M, int _Count);


__m64 _m_pand(__m64 _MM1, __m64 _MM2);
__m64 _m_pandn(__m64 _MM1, __m64 _MM2);
__m64 _m_por(__m64 _MM1, __m64 _MM2);
__m64 _m_pxor(__m64 _MM1, __m64 _MM2);


__m64 _m_pcmpeqb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqd(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtd(__m64 _MM1, __m64 _MM2);


__m64 _mm_setzero_si64(void);
__m64 _mm_set_pi32(int _I1, int _I0);
__m64 _mm_set_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_set_pi8(char _B7, char _B6, char _B5, char _B4,
                  char _B3, char _B2, char _B1, char _B0);
__m64 _mm_set1_pi32(int _I);
__m64 _mm_set1_pi16(short _S);
__m64 _mm_set1_pi8(char _B);
__m64 _mm_setr_pi32(int _I1, int _I0);
__m64 _mm_setr_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_setr_pi8(char _B7, char _B6, char _B5, char _B4,
                   char _B3, char _B2, char _B1, char _B0);




























































}; 
#line 184 "d:\\programs overflow\\vc\\include\\mmintrin.h"

#line 186 "d:\\programs overflow\\vc\\include\\mmintrin.h"
#line 187 "d:\\programs overflow\\vc\\include\\mmintrin.h"
#line 188 "d:\\programs overflow\\vc\\include\\mmintrin.h"

#line 42 "d:\\programs overflow\\vc\\include\\xmmintrin.h"
#line 43 "d:\\programs overflow\\vc\\include\\xmmintrin.h"

















typedef union __declspec(intrin_type) __declspec(align(16)) __m128 {
     float               m128_f32[4];
     unsigned __int64    m128_u64[2];
     __int8              m128_i8[16];
     __int16             m128_i16[8];
     __int32             m128_i32[4];
     __int64             m128_i64[2];
     unsigned __int8     m128_u8[16];
     unsigned __int16    m128_u16[8];
     unsigned __int32    m128_u32[4];
 } __m128;





#line 77 "d:\\programs overflow\\vc\\include\\xmmintrin.h"

 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 
 
 







































































 
 
 


extern "C" { 
  
#line 181 "d:\\programs overflow\\vc\\include\\xmmintrin.h"





extern __m128 _mm_add_ss(__m128 _A, __m128 _B);
extern __m128 _mm_add_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B);
extern __m128 _mm_div_ss(__m128 _A, __m128 _B);
extern __m128 _mm_div_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sqrt_ss(__m128 _A);
extern __m128 _mm_sqrt_ps(__m128 _A);
extern __m128 _mm_rcp_ss(__m128 _A);
extern __m128 _mm_rcp_ps(__m128 _A);
extern __m128 _mm_rsqrt_ss(__m128 _A);
extern __m128 _mm_rsqrt_ps(__m128 _A);
extern __m128 _mm_min_ss(__m128 _A, __m128 _B);
extern __m128 _mm_min_ps(__m128 _A, __m128 _B);
extern __m128 _mm_max_ss(__m128 _A, __m128 _B);
extern __m128 _mm_max_ps(__m128 _A, __m128 _B);





extern __m128 _mm_and_ps(__m128 _A, __m128 _B);
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B);
extern __m128 _mm_or_ps(__m128 _A, __m128 _B);
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B);





extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B);
extern int _mm_comieq_ss(__m128 _A, __m128 _B);
extern int _mm_comilt_ss(__m128 _A, __m128 _B);
extern int _mm_comile_ss(__m128 _A, __m128 _B);
extern int _mm_comigt_ss(__m128 _A, __m128 _B);
extern int _mm_comige_ss(__m128 _A, __m128 _B);
extern int _mm_comineq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomile_ss(__m128 _A, __m128 _B);
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomige_ss(__m128 _A, __m128 _B);
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B);





extern int _mm_cvt_ss2si(__m128 _A);
extern __m64 _mm_cvt_ps2pi(__m128 _A);
extern int _mm_cvtt_ss2si(__m128 _A);
extern __m64 _mm_cvtt_ps2pi(__m128 _A);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern __m128 _mm_cvt_pi2ps(__m128, __m64);
extern float _mm_cvtss_f32(__m128 _A);








#line 275 "d:\\programs overflow\\vc\\include\\xmmintrin.h"





extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned int _Imm8);
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B);
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 _A);





extern int _m_pextrw(__m64, int);
extern __m64 _m_pinsrw(__m64, int, int);
extern __m64 _m_pmaxsw(__m64, __m64);
extern __m64 _m_pmaxub(__m64, __m64);
extern __m64 _m_pminsw(__m64, __m64);
extern __m64 _m_pminub(__m64, __m64);
extern int _m_pmovmskb(__m64);
extern __m64 _m_pmulhuw(__m64, __m64);
extern __m64 _m_pshufw(__m64, int);
extern void _m_maskmovq(__m64, __m64, char *);
extern __m64 _m_pavgb(__m64, __m64);
extern __m64 _m_pavgw(__m64, __m64);
extern __m64 _m_psadbw(__m64, __m64);





extern __m128 _mm_set_ss(float _A);
extern __m128 _mm_set_ps1(float _A);
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*_A);
extern __m128 _mm_load_ps1(float const*_A);
extern __m128 _mm_load_ps(float const*_A);
extern __m128 _mm_loadr_ps(float const*_A);
extern __m128 _mm_loadu_ps(float const*_A);
extern void _mm_store_ss(float *_V, __m128 _A);
extern void _mm_store_ps1(float *_V, __m128 _A);
extern void _mm_store_ps(float *_V, __m128 _A);
extern void _mm_storer_ps(float *_V, __m128 _A);
extern void _mm_storeu_ps(float *_V, __m128 _A);
extern void _mm_prefetch(char const*_A, int _Sel);
extern void _mm_stream_pi(__m64 *, __m64);
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 _A, __m128 _B);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);






























 
 
 

 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi16_ps(__m64 a)
{
  __m128 tmp;
  __m64  ext_val = _m_pcmpgtw(_mm_setzero_si64(), a);

  tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(a, ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(tmp, tmp),
                        _m_punpcklwd(a, ext_val)));
}


 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpu16_ps(__m64 a)
{
  __m128 tmp;
  __m64  ext_val = _mm_setzero_si64();

  tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(a, ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(tmp, tmp),
                        _m_punpcklwd(a, ext_val)));
}


 
 
 
 
 
 
 
 
__inline __m64 _mm_cvtps_pi16(__m128 a)
{
  return _m_packssdw(_mm_cvt_ps2pi(a),
                        _mm_cvt_ps2pi(_mm_movehl_ps(a, a)));
}


 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi8_ps(__m64 a)
{
  __m64  ext_val = _m_pcmpgtb(_mm_setzero_si64(), a);

  return _mm_cvtpi16_ps(_m_punpcklbw(a, ext_val));
}


 
 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpu8_ps(__m64 a)
{
  return _mm_cvtpu16_ps(_m_punpcklbw(a, _mm_setzero_si64()));
}


 
 
 
 
 
 
 
 
__inline __m64 _mm_cvtps_pi8(__m128 a)
{
  return _m_packsswb(_mm_cvtps_pi16(a), _mm_setzero_si64());
}


 
 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi32x2_ps(__m64 a, __m64 b)
{
  return _mm_movelh_ps(_mm_cvt_pi2ps(_mm_setzero_ps(), a),
                       _mm_cvt_pi2ps(_mm_setzero_ps(), b));
}



}; 
#line 487 "d:\\programs overflow\\vc\\include\\xmmintrin.h"

#line 489 "d:\\programs overflow\\vc\\include\\xmmintrin.h"

#line 491 "d:\\programs overflow\\vc\\include\\xmmintrin.h"
#line 492 "d:\\programs overflow\\vc\\include\\xmmintrin.h"
#line 34 "d:\\programs overflow\\vc\\include\\emmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8              m128i_i8[16];
    __int16             m128i_i16[8];
    __int32             m128i_i32[4];
    __int64             m128i_i64[2];
    unsigned __int8     m128i_u8[16];
    unsigned __int16    m128i_u16[8];
    unsigned __int32    m128i_u32[4];
    unsigned __int64    m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double              m128d_f64[2];
} __m128d;






 
 
 


extern "C" { 
  
#line 63 "d:\\programs overflow\\vc\\include\\emmintrin.h"





extern __m128d _mm_add_sd(__m128d _A, __m128d _B);
extern __m128d _mm_add_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_pd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_sd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_pd(__m128d _A);
extern __m128d _mm_div_sd(__m128d _A, __m128d _B);
extern __m128d _mm_div_pd(__m128d _A, __m128d _B);
extern __m128d _mm_min_sd(__m128d _A, __m128d _B);
extern __m128d _mm_min_pd(__m128d _A, __m128d _B);
extern __m128d _mm_max_sd(__m128d _A, __m128d _B);
extern __m128d _mm_max_pd(__m128d _A, __m128d _B);





extern __m128d _mm_and_pd(__m128d _A, __m128d _B);
extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B);
extern __m128d _mm_or_pd(__m128d _A, __m128d _B);
extern __m128d _mm_xor_pd(__m128d _A, __m128d _B);





extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B);
extern int _mm_comieq_sd(__m128d _A, __m128d _B);
extern int _mm_comilt_sd(__m128d _A, __m128d _B);
extern int _mm_comile_sd(__m128d _A, __m128d _B);
extern int _mm_comigt_sd(__m128d _A, __m128d _B);
extern int _mm_comige_sd(__m128d _A, __m128d _B);
extern int _mm_comineq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomieq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomilt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomile_sd(__m128d _A, __m128d _B);
extern int _mm_ucomigt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomige_sd(__m128d _A, __m128d _B);
extern int _mm_ucomineq_sd(__m128d _A, __m128d _B);





extern __m128d _mm_cvtepi32_pd(__m128i _A);
extern __m128i _mm_cvtpd_epi32(__m128d _A);
extern __m128i _mm_cvttpd_epi32(__m128d _A);
extern __m128 _mm_cvtepi32_ps(__m128i _A);
extern __m128i _mm_cvtps_epi32(__m128 _A);
extern __m128i _mm_cvttps_epi32(__m128 _A);
extern __m128 _mm_cvtpd_ps(__m128d _A);
extern __m128d _mm_cvtps_pd(__m128 _A);
extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B);
extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B);

extern int _mm_cvtsd_si32(__m128d _A);
extern int _mm_cvttsd_si32(__m128d _A);
extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B);

extern __m64 _mm_cvtpd_pi32(__m128d _A);
extern __m64 _mm_cvttpd_pi32(__m128d _A);
extern __m128d _mm_cvtpi32_pd(__m64 _A);





extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B);
extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B);
extern int _mm_movemask_pd(__m128d _A);
extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I);





extern __m128d _mm_load_pd(double const*_Dp);
extern __m128d _mm_load1_pd(double const*_Dp);
extern __m128d _mm_loadr_pd(double const*_Dp);
extern __m128d _mm_loadu_pd(double const*_Dp);
extern __m128d _mm_load_sd(double const*_Dp);
extern __m128d _mm_loadh_pd(__m128d _A, double const*_Dp);
extern __m128d _mm_loadl_pd(__m128d _A, double const*_Dp);





extern __m128d _mm_set_sd(double _W);
extern __m128d _mm_set1_pd(double _A);
extern __m128d _mm_set_pd(double _Z, double _Y);
extern __m128d _mm_setr_pd(double _Y, double _Z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d _A, __m128d _B);





extern void _mm_store_sd(double *_Dp, __m128d _A);
extern void _mm_store1_pd(double *_Dp, __m128d _A);
extern void _mm_store_pd(double *_Dp, __m128d _A);
extern void _mm_storeu_pd(double *_Dp, __m128d _A);
extern void _mm_storer_pd(double *_Dp, __m128d _A);
extern void _mm_storeh_pd(double *_Dp, __m128d _A);
extern void _mm_storel_pd(double *_Dp, __m128d _A);





extern __m128i _mm_add_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi32(__m128i _A, __m128i _B);
extern __m64 _mm_add_si64(__m64 _A, __m64 _B);
extern __m128i _mm_add_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_min_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_min_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B);
extern __m64 _mm_mul_su32(__m64 _A, __m64 _B);
extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B);
extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B);
extern __m64 _mm_sub_si64(__m64 _A, __m64 _B);
extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B);





extern __m128i _mm_and_si128(__m128i _A, __m128i _B);
extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B);
extern __m128i _mm_or_si128(__m128i _A, __m128i _B);
extern __m128i _mm_xor_si128(__m128i _A, __m128i _B);





extern __m128i _mm_slli_si128(__m128i _A, int _Imm);
extern __m128i _mm_slli_epi16(__m128i _A, int _Count);
extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi32(__m128i _A, int _Count);
extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi64(__m128i _A, int _Count);
extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi16(__m128i _A, int _Count);
extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi32(__m128i _A, int _Count);
extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_si128(__m128i _A, int _Imm);
extern __m128i _mm_srli_epi16(__m128i _A, int _Count);
extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi32(__m128i _A, int _Count);
extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi64(__m128i _A, int _Count);
extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count);





extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B);





extern __m128i _mm_cvtsi32_si128(int _A);
extern int _mm_cvtsi128_si32(__m128i _A);





extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B);
extern int _mm_extract_epi16(__m128i _A, int _Imm);
extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm);
extern int _mm_movemask_epi8(__m128i _A);
extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm);
extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm);
extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm);
extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B);





extern __m128i _mm_load_si128(__m128i const*_P);
extern __m128i _mm_loadu_si128(__m128i const*_P);
extern __m128i _mm_loadl_epi64(__m128i const*_P);





extern __m128i _mm_set_epi64(__m64 _Q1, __m64 _Q0);
extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0);
extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4,
                             short _W3, short _W2, short _W1, short _W0);
extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12,
                            char _B11, char _B10, char _B9, char _B8,
                            char _B7, char _B6, char _B5, char _B4,
                            char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_set1_epi64(__m64 _Q);
extern __m128i _mm_set1_epi32(int _I);
extern __m128i _mm_set1_epi16(short _W);
extern __m128i _mm_set1_epi8(char _B);
extern __m128i _mm_setl_epi64(__m128i _Q);
extern __m128i _mm_setr_epi64(__m64 _Q0, __m64 _Q1);
extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3);
extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3,
                              short _W4, short _W5, short _W6, short _W7);
extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12,
                             char _B11, char _B10, char _B9, char _B8,
                             char _B7, char _B6, char _B5, char _B4,
                             char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_setzero_si128(void);





extern void _mm_store_si128(__m128i *_P, __m128i _B);
extern void _mm_storeu_si128(__m128i *_P, __m128i _B);
extern void _mm_storel_epi64(__m128i *_P, __m128i _Q);
extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char *_P);





extern __m128i _mm_move_epi64(__m128i _Q);
extern __m128i _mm_movpi64_epi64(__m64 _Q);
extern __m64 _mm_movepi64_pi64(__m128i _Q);





extern void _mm_stream_pd(double *_Dp, __m128d _A);
extern void _mm_stream_si128(__m128i *_P, __m128i _A);
extern void _mm_clflush(void const*_P);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *_P, int _I);
extern void _mm_pause(void);





extern double _mm_cvtsd_f64(__m128d _A);







extern __m128  _mm_castpd_ps(__m128d);
extern __m128i _mm_castpd_si128(__m128d);
extern __m128d _mm_castps_pd(__m128);
extern __m128i _mm_castps_si128(__m128);
extern __m128  _mm_castsi128_ps(__m128i);
extern __m128d _mm_castsi128_pd(__m128i);













#line 407 "d:\\programs overflow\\vc\\include\\emmintrin.h"


}; 
#line 411 "d:\\programs overflow\\vc\\include\\emmintrin.h"

#line 413 "d:\\programs overflow\\vc\\include\\emmintrin.h"

#line 415 "d:\\programs overflow\\vc\\include\\emmintrin.h"
#line 416 "d:\\programs overflow\\vc\\include\\emmintrin.h"
#line 32 "d:\\programs overflow\\vc\\include\\pmmintrin.h"

 
 
 














 
 
 


extern "C" { 
  
#line 58 "d:\\programs overflow\\vc\\include\\pmmintrin.h"





extern __m128 _mm_addsub_ps(__m128 a, __m128 b);
extern __m128 _mm_hadd_ps(__m128 a, __m128 b);
extern __m128 _mm_hsub_ps(__m128 a, __m128 b);
extern __m128 _mm_movehdup_ps(__m128 a);
extern __m128 _mm_moveldup_ps(__m128 a);





extern __m128d _mm_addsub_pd(__m128d a, __m128d b);
extern __m128d _mm_hadd_pd(__m128d a, __m128d b);
extern __m128d _mm_hsub_pd(__m128d a, __m128d b);
extern __m128d _mm_loaddup_pd(double const * dp);
extern __m128d _mm_movedup_pd(__m128d a);




extern __m128i _mm_lddqu_si128(__m128i const *p);







extern void _mm_monitor(void const *p, unsigned extensions, unsigned hints);




extern void _mm_mwait(unsigned extensions, unsigned hints);


}; 
#line 100 "d:\\programs overflow\\vc\\include\\pmmintrin.h"

#line 102 "d:\\programs overflow\\vc\\include\\pmmintrin.h"

#line 104 "d:\\programs overflow\\vc\\include\\pmmintrin.h"
#line 105 "d:\\programs overflow\\vc\\include\\pmmintrin.h"
#line 21 "d:\\programs overflow\\vc\\include\\tmmintrin.h"









extern "C" {
#line 32 "d:\\programs overflow\\vc\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_hadd_epi16 (__m128i a, __m128i b);
    extern __m128i _mm_hadd_epi32 (__m128i a, __m128i b);
    extern __m128i _mm_hadds_epi16 (__m128i a, __m128i b);

    extern __m64 _mm_hadd_pi16 (__m64 a, __m64 b);
    extern __m64 _mm_hadd_pi32 (__m64 a, __m64 b);
    extern __m64 _mm_hadds_pi16 (__m64 a, __m64 b);

    
    

    extern __m128i _mm_hsub_epi16 (__m128i a, __m128i b);
    extern __m128i _mm_hsub_epi32 (__m128i a, __m128i b);
    extern __m128i _mm_hsubs_epi16 (__m128i a, __m128i b);

    extern __m64 _mm_hsub_pi16 (__m64 a, __m64 b);
    extern __m64 _mm_hsub_pi32 (__m64 a, __m64 b);
    extern __m64 _mm_hsubs_pi16 (__m64 a, __m64 b);

    
    

    extern __m128i _mm_maddubs_epi16 (__m128i a, __m128i b);

    extern __m64 _mm_maddubs_pi16 (__m64 a, __m64 b);

    
    

    extern __m128i _mm_mulhrs_epi16 (__m128i a, __m128i b);

    extern __m64 _mm_mulhrs_pi16 (__m64 a, __m64 b);

    
    

    extern __m128i _mm_shuffle_epi8 (__m128i a, __m128i b);

    extern __m64 _mm_shuffle_pi8 (__m64 a, __m64 b);

    
    

    extern __m128i _mm_sign_epi8 (__m128i a, __m128i b);
    extern __m128i _mm_sign_epi16 (__m128i a, __m128i b);
    extern __m128i _mm_sign_epi32 (__m128i a, __m128i b);

    extern __m64 _mm_sign_pi8 (__m64 a, __m64 b);
    extern __m64 _mm_sign_pi16 (__m64 a, __m64 b);
    extern __m64 _mm_sign_pi32 (__m64 a, __m64 b);

    
    

    extern __m128i _mm_alignr_epi8 (__m128i a, __m128i b, int n);

    extern __m64 _mm_alignr_pi8 (__m64 a, __m64 b, int n);

    
    

    extern __m128i _mm_abs_epi8 (__m128i a);
    extern __m128i _mm_abs_epi16 (__m128i a);
    extern __m128i _mm_abs_epi32 (__m128i a);

    extern __m64 _mm_abs_pi8 (__m64 a);
    extern __m64 _mm_abs_pi16 (__m64 a);
    extern __m64 _mm_abs_pi32 (__m64 a);


};
#line 108 "d:\\programs overflow\\vc\\include\\tmmintrin.h"

#line 110 "d:\\programs overflow\\vc\\include\\tmmintrin.h"

#line 112 "d:\\programs overflow\\vc\\include\\tmmintrin.h"

#line 114 "d:\\programs overflow\\vc\\include\\tmmintrin.h"
#line 28 "d:\\programs overflow\\vc\\include\\smmintrin.h"


















































extern "C" {
#line 80 "d:\\programs overflow\\vc\\include\\smmintrin.h"

        
        

        extern __m128i _mm_blend_epi16 (__m128i v1, __m128i v2,
                                        const int mask);
        extern __m128i _mm_blendv_epi8 (__m128i v1, __m128i v2, __m128i mask);

        
        

        extern __m128  _mm_blend_ps (__m128  v1, __m128  v2, const int mask);
        extern __m128  _mm_blendv_ps(__m128  v1, __m128  v2, __m128 v3);

        
        

        extern __m128d _mm_blend_pd (__m128d v1, __m128d v2, const int mask);
        extern __m128d _mm_blendv_pd(__m128d v1, __m128d v2, __m128d v3);

        
        

        extern __m128  _mm_dp_ps(__m128  val1, __m128  val2, const int mask);
        extern __m128d _mm_dp_pd(__m128d val1, __m128d val2, const int mask);

        
        

        extern __m128i _mm_cmpeq_epi64(__m128i val1, __m128i val2);

        

        extern __m128i _mm_min_epi8 (__m128i val1, __m128i val2);
        extern __m128i _mm_max_epi8 (__m128i val1, __m128i val2);

        extern __m128i _mm_min_epu16(__m128i val1, __m128i val2);
        extern __m128i _mm_max_epu16(__m128i val1, __m128i val2);

        extern __m128i _mm_min_epi32(__m128i val1, __m128i val2);
        extern __m128i _mm_max_epi32(__m128i val1, __m128i val2);
        extern __m128i _mm_min_epu32(__m128i val1, __m128i val2);
        extern __m128i _mm_max_epu32(__m128i val1, __m128i val2);

        
        

        extern __m128i _mm_mullo_epi32(__m128i a, __m128i b);

        
        

        extern __m128i _mm_mul_epi32(__m128i a, __m128i b);

        
        

        extern int _mm_testz_si128(__m128i mask, __m128i val);

        
        

        extern int _mm_testc_si128(__m128i mask, __m128i val);

        
        
        

        extern int _mm_testnzc_si128(__m128i mask, __m128i s2);

        
        
        
        
        

        extern __m128 _mm_insert_ps(__m128 dst, __m128 src, const int ndx);

        




        
        

        extern int _mm_extract_ps(__m128 src, const int ndx);

        
        




        
        





        
        

        extern __m128i _mm_insert_epi8 (__m128i dst, int s, const int ndx);
        extern __m128i _mm_insert_epi32(__m128i dst, int s, const int ndx);



#line 190 "d:\\programs overflow\\vc\\include\\smmintrin.h"
        
        

        extern int   _mm_extract_epi8 (__m128i src, const int ndx);
        extern int   _mm_extract_epi32(__m128i src, const int ndx);



#line 199 "d:\\programs overflow\\vc\\include\\smmintrin.h"

        
        

        extern __m128i _mm_minpos_epu16(__m128i shortValues);

        

        extern __m128d _mm_round_pd(__m128d val, int iRoundMode);
        extern __m128d _mm_round_sd(__m128d dst, __m128d val, int iRoundMode);

        

        extern __m128  _mm_round_ps(__m128  val, int iRoundMode);
        extern __m128  _mm_round_ss(__m128 dst, __m128  val, int iRoundMode);

        

        extern __m128i _mm_cvtepi8_epi32 (__m128i byteValues);
        extern __m128i _mm_cvtepi16_epi32(__m128i shortValues);
        extern __m128i _mm_cvtepi8_epi64 (__m128i byteValues);
        extern __m128i _mm_cvtepi32_epi64(__m128i intValues);
        extern __m128i _mm_cvtepi16_epi64(__m128i shortValues);
        extern __m128i _mm_cvtepi8_epi16 (__m128i byteValues);

        

        extern __m128i _mm_cvtepu8_epi32 (__m128i byteValues);
        extern __m128i _mm_cvtepu16_epi32(__m128i shortValues);
        extern __m128i _mm_cvtepu8_epi64 (__m128i shortValues);
        extern __m128i _mm_cvtepu32_epi64(__m128i intValues);
        extern __m128i _mm_cvtepu16_epi64(__m128i shortValues);
        extern __m128i _mm_cvtepu8_epi16 (__m128i byteValues);


        
        

        extern __m128i _mm_packus_epi32(__m128i val1, __m128i val2);

        
        
        

        extern __m128i _mm_mpsadbw_epu8(__m128i s1, __m128i s2, const int msk);

        



        extern __m128i _mm_stream_load_si128(__m128i* v1);


}; 
#line 254 "d:\\programs overflow\\vc\\include\\smmintrin.h"

#line 256 "d:\\programs overflow\\vc\\include\\smmintrin.h"

#line 258 "d:\\programs overflow\\vc\\include\\smmintrin.h"
#line 259 "d:\\programs overflow\\vc\\include\\smmintrin.h"
#line 28 "d:\\programs overflow\\vc\\include\\nmmintrin.h"



extern "C" {
#line 33 "d:\\programs overflow\\vc\\include\\nmmintrin.h"













































    extern __m128i _mm_cmpistrm (__m128i a, __m128i b, const int mode);
    extern int     _mm_cmpistri (__m128i a, __m128i b, const int mode);

    extern __m128i _mm_cmpestrm (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int     _mm_cmpestri (__m128i a, int la, __m128i b, int lb, const int mode);





    extern int     _mm_cmpistrz (__m128i a, __m128i b, const int mode);
    extern int     _mm_cmpistrc (__m128i a, __m128i b, const int mode);
    extern int     _mm_cmpistrs (__m128i a, __m128i b, const int mode);
    extern int     _mm_cmpistro (__m128i a, __m128i b, const int mode);
    extern int     _mm_cmpistra (__m128i a, __m128i b, const int mode);

    extern int     _mm_cmpestrz (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int     _mm_cmpestrc (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int     _mm_cmpestrs (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int     _mm_cmpestro (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int     _mm_cmpestra (__m128i a, int la, __m128i b, int lb, const int mode);






    extern __m128i _mm_cmpgt_epi64(__m128i val1, __m128i val2);





    extern int _mm_popcnt_u32(unsigned int v);



#line 116 "d:\\programs overflow\\vc\\include\\nmmintrin.h"





    extern unsigned int _mm_crc32_u8 (unsigned int crc, unsigned char v);
    extern unsigned int _mm_crc32_u16(unsigned int crc, unsigned short v);
    extern unsigned int _mm_crc32_u32(unsigned int crc, unsigned int v);



#line 128 "d:\\programs overflow\\vc\\include\\nmmintrin.h"


}; 
#line 132 "d:\\programs overflow\\vc\\include\\nmmintrin.h"

#line 134 "d:\\programs overflow\\vc\\include\\nmmintrin.h"

#line 136 "d:\\programs overflow\\vc\\include\\nmmintrin.h"
#line 137 "d:\\programs overflow\\vc\\include\\nmmintrin.h"
#line 27 "d:\\programs overflow\\vc\\include\\wmmintrin.h"



extern "C" {
#line 32 "d:\\programs overflow\\vc\\include\\wmmintrin.h"





extern __m128i _mm_aesdec_si128(__m128i v, __m128i rkey);





extern __m128i _mm_aesdeclast_si128(__m128i v, __m128i rkey);





extern __m128i _mm_aesenc_si128(__m128i v, __m128i rkey);





extern __m128i _mm_aesenclast_si128(__m128i v, __m128i rkey);





extern __m128i _mm_aesimc_si128(__m128i v);






extern __m128i _mm_aeskeygenassist_si128(__m128i ckey, const int rcon);







extern __m128i _mm_clmulepi64_si128(__m128i v1, __m128i v2,
                                            const int imm8);





}; 
#line 85 "d:\\programs overflow\\vc\\include\\wmmintrin.h"

#line 87 "d:\\programs overflow\\vc\\include\\wmmintrin.h"

#line 89 "d:\\programs overflow\\vc\\include\\wmmintrin.h"
#line 90 "d:\\programs overflow\\vc\\include\\wmmintrin.h"
#line 24 "d:\\programs overflow\\vc\\include\\immintrin.h"


extern "C" {
#line 28 "d:\\programs overflow\\vc\\include\\immintrin.h"




typedef union __declspec(intrin_type) __declspec(align(32)) __m256 {
    float m256_f32[8];
} __m256;

typedef struct __declspec(intrin_type) __declspec(align(32)) __m256d {
    double m256d_f64[4];
} __m256d;

typedef union  __declspec(intrin_type) __declspec(align(32)) __m256i {
    __int8              m256i_i8[32];
    __int16             m256i_i16[16];
    __int32             m256i_i32[8];
    __int64             m256i_i64[4];
    unsigned __int8     m256i_u8[32];
    unsigned __int16    m256i_u16[16];
    unsigned __int32    m256i_u32[8];
    unsigned __int64    m256i_u64[4];
} __m256i;



















































extern __m256d __cdecl _mm256_add_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_add_ps(__m256, __m256);












extern __m256d __cdecl _mm256_addsub_pd(__m256d, __m256d);












extern __m256 __cdecl _mm256_addsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_and_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_and_ps(__m256, __m256);








extern __m256d __cdecl _mm256_andnot_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_andnot_ps(__m256, __m256);













extern __m256d __cdecl _mm256_blend_pd(__m256d, __m256d, const int);













extern __m256 __cdecl _mm256_blend_ps(__m256, __m256, const int);









extern __m256d __cdecl _mm256_blendv_pd(__m256d, __m256d, __m256d);









extern __m256 __cdecl _mm256_blendv_ps(__m256, __m256, __m256);








extern __m256d __cdecl _mm256_div_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_div_ps(__m256, __m256);














extern __m256 __cdecl _mm256_dp_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_hadd_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hadd_ps(__m256, __m256);








extern __m256d __cdecl _mm256_hsub_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_max_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_max_ps(__m256, __m256);








extern __m256d __cdecl _mm256_min_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_min_ps(__m256, __m256);









extern __m256d __cdecl _mm256_mul_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_mul_ps(__m256, __m256);








extern __m256d __cdecl _mm256_or_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_or_ps(__m256, __m256);











extern __m256d __cdecl _mm256_shuffle_pd(__m256d, __m256d, const int);












extern __m256 __cdecl _mm256_shuffle_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_sub_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_sub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_xor_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_xor_ps(__m256, __m256);















extern __m128d __cdecl _mm_cmp_pd(__m128d, __m128d, const int);
extern __m256d __cdecl _mm256_cmp_pd(__m256d, __m256d, const int);















extern __m128 __cdecl _mm_cmp_ps(__m128, __m128, const int);
extern __m256 __cdecl _mm256_cmp_ps(__m256, __m256, const int);












extern __m128d __cdecl _mm_cmp_sd(__m128d, __m128d, const int);












extern __m128 __cdecl _mm_cmp_ss(__m128, __m128, const int);








extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i);








extern __m256  __cdecl _mm256_cvtepi32_ps(__m256i);









extern __m128  __cdecl _mm256_cvtpd_ps(__m256d);








extern __m256i __cdecl _mm256_cvtps_epi32(__m256);









extern __m256d __cdecl _mm256_cvtps_pd(__m128);












extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d);








extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d);












extern __m256i __cdecl _mm256_cvttps_epi32(__m256);







extern __m128  __cdecl _mm256_extractf128_ps(__m256, const int);
extern __m128d __cdecl _mm256_extractf128_pd(__m256d, const int);
extern __m128i __cdecl _mm256_extractf128_si256(__m256i, const int);






extern void __cdecl _mm256_zeroall(void);







extern void __cdecl _mm256_zeroupper(void);









extern __m256  __cdecl _mm256_permutevar_ps(__m256, __m256i);
extern __m128  __cdecl _mm_permutevar_ps(__m128, __m128i);









extern __m256  __cdecl _mm256_permute_ps(__m256, int);
extern __m128  __cdecl _mm_permute_ps(__m128, int);









extern __m256d __cdecl _mm256_permutevar_pd(__m256d, __m256i);
extern __m128d __cdecl _mm_permutevar_pd(__m128d, __m128i);









extern __m256d __cdecl _mm256_permute_pd(__m256d, int);
extern __m128d __cdecl _mm_permute_pd(__m128d, int);








extern __m256  __cdecl _mm256_permute2f128_ps(__m256, __m256, int);
extern __m256d __cdecl _mm256_permute2f128_pd(__m256d, __m256d, int);
extern __m256i __cdecl _mm256_permute2f128_si256(__m256i, __m256i, int);








extern __m256  __cdecl _mm256_broadcast_ss(float const *);
extern __m128  __cdecl _mm_broadcast_ss(float const *);







extern __m256d __cdecl _mm256_broadcast_sd(double const *);







extern __m256  __cdecl _mm256_broadcast_ps(__m128 const *);
extern __m256d __cdecl _mm256_broadcast_pd(__m128d const *);









extern __m256  __cdecl _mm256_insertf128_ps(__m256, __m128, int);
extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d, int);
extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i, int);








extern __m256d __cdecl _mm256_load_pd(double const *);
extern void    __cdecl _mm256_store_pd(double *, __m256d);








extern __m256  __cdecl _mm256_load_ps(float const *);
extern void    __cdecl _mm256_store_ps(float *, __m256);








extern __m256d __cdecl _mm256_loadu_pd(double const *);
extern void    __cdecl _mm256_storeu_pd(double *, __m256d);








extern __m256  __cdecl _mm256_loadu_ps(float const *);
extern void    __cdecl _mm256_storeu_ps(float *, __m256);








extern __m256i __cdecl _mm256_load_si256(__m256i const *);
extern void    __cdecl _mm256_store_si256(__m256i *, __m256i);








extern __m256i __cdecl _mm256_loadu_si256(__m256i const *);
extern void    __cdecl _mm256_storeu_si256(__m256i *, __m256i);







































































extern __m256d __cdecl _mm256_maskload_pd(double const *, __m256i);
extern void    __cdecl _mm256_maskstore_pd(double *, __m256i, __m256d);
extern __m128d __cdecl _mm_maskload_pd(double const *, __m128i);
extern void    __cdecl _mm_maskstore_pd(double *, __m128i, __m128d);



















extern __m256  __cdecl _mm256_maskload_ps(float const *, __m256i);
extern void    __cdecl _mm256_maskstore_ps(float *, __m256i, __m256);
extern __m128  __cdecl _mm_maskload_ps(float const *, __m128i);
extern void    __cdecl _mm_maskstore_ps(float *, __m128i, __m128);







extern __m256  __cdecl _mm256_movehdup_ps(__m256);







extern __m256  __cdecl _mm256_moveldup_ps(__m256);







extern __m256d __cdecl _mm256_movedup_pd(__m256d);









extern __m256i __cdecl _mm256_lddqu_si256(__m256i const *);







extern void    __cdecl _mm256_stream_si256(__m256i *, __m256i);








extern void    __cdecl _mm256_stream_pd(double *, __m256d);








extern void    __cdecl _mm256_stream_ps(float *, __m256);









extern __m256  __cdecl _mm256_rcp_ps(__m256);










extern __m256  __cdecl _mm256_rsqrt_ps(__m256);








extern __m256d __cdecl _mm256_sqrt_pd(__m256d);








extern __m256  __cdecl _mm256_sqrt_ps(__m256);












extern __m256d __cdecl _mm256_round_pd(__m256d, int);














extern __m256  __cdecl _mm256_round_ps(__m256, int);









extern __m256d __cdecl _mm256_unpackhi_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpackhi_ps(__m256, __m256);







extern __m256d __cdecl _mm256_unpacklo_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpacklo_ps(__m256, __m256);









extern int     __cdecl _mm256_testz_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testc_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testnzc_si256(__m256i, __m256i);














extern int     __cdecl _mm256_testz_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testc_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testnzc_pd(__m256d, __m256d);
extern int     __cdecl _mm_testz_pd(__m128d, __m128d);
extern int     __cdecl _mm_testc_pd(__m128d, __m128d);
extern int     __cdecl _mm_testnzc_pd(__m128d, __m128d);












extern int     __cdecl _mm256_testz_ps(__m256, __m256);
extern int     __cdecl _mm256_testc_ps(__m256, __m256);
extern int     __cdecl _mm256_testnzc_ps(__m256, __m256);
extern int     __cdecl _mm_testz_ps(__m128, __m128);
extern int     __cdecl _mm_testc_ps(__m128, __m128);
extern int     __cdecl _mm_testnzc_ps(__m128, __m128);








extern int     __cdecl _mm256_movemask_pd(__m256d);








extern int     __cdecl _mm256_movemask_ps(__m256);




extern __m256d __cdecl _mm256_setzero_pd(void);
extern __m256  __cdecl _mm256_setzero_ps(void);
extern __m256i __cdecl _mm256_setzero_si256(void);




extern __m256d __cdecl _mm256_set_pd(double, double, double, double);
extern __m256  __cdecl _mm256_set_ps(float, float, float, float,
                                            float, float, float, float);
extern __m256i __cdecl _mm256_set_epi8(char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char);
extern __m256i __cdecl _mm256_set_epi16(short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short);
extern __m256i __cdecl _mm256_set_epi32(int, int, int, int,
                                               int, int, int, int);
extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64,
                                                __int64, __int64);










extern __m256d __cdecl _mm256_setr_pd(double, double, double, double);
extern __m256  __cdecl _mm256_setr_ps(float, float, float, float,
                                             float, float, float, float);
extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char);
extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short);
extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int,
                                                int, int, int, int);
extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64,
                                                 __int64, __int64);







extern __m256d __cdecl _mm256_set1_pd(double);
extern __m256  __cdecl _mm256_set1_ps(float);
extern __m256i __cdecl _mm256_set1_epi8(char);
extern __m256i __cdecl _mm256_set1_epi16(short);
extern __m256i __cdecl _mm256_set1_epi32(int);
extern __m256i __cdecl _mm256_set1_epi64x(long long);







extern __m256  __cdecl _mm256_castpd_ps(__m256d);
extern __m256d __cdecl _mm256_castps_pd(__m256);
extern __m256i __cdecl _mm256_castps_si256(__m256);
extern __m256i __cdecl _mm256_castpd_si256(__m256d);
extern __m256  __cdecl _mm256_castsi256_ps(__m256i);
extern __m256d __cdecl _mm256_castsi256_pd(__m256i);
extern __m128  __cdecl _mm256_castps256_ps128(__m256);
extern __m128d __cdecl _mm256_castpd256_pd128(__m256d);
extern __m128i __cdecl _mm256_castsi256_si128(__m256i);
extern __m256  __cdecl _mm256_castps128_ps256(__m128);
extern __m256d __cdecl _mm256_castpd128_pd256(__m128d);
extern __m256i __cdecl _mm256_castsi128_si256(__m128i);






extern __m128  __cdecl _mm_cvtph_ps(__m128i);
extern __m256  __cdecl _mm256_cvtph_ps(__m128i);
extern __m128i __cdecl _mm_cvtps_ph(__m128 m1, const int imm);
extern __m128i __cdecl _mm256_cvtps_ph(__m256, int);




















extern unsigned __int64 __cdecl _xgetbv(unsigned int);


extern void __cdecl _xsetbv(unsigned int, unsigned __int64);






extern void __cdecl _xsave(void *, unsigned __int64);


#line 1216 "d:\\programs overflow\\vc\\include\\immintrin.h"






extern void __cdecl _xsaveopt(void *, unsigned __int64);


#line 1226 "d:\\programs overflow\\vc\\include\\immintrin.h"






extern void __cdecl _xrstor(void const *, unsigned __int64);


#line 1236 "d:\\programs overflow\\vc\\include\\immintrin.h"





extern void __cdecl _fxsave(void *);


#line 1245 "d:\\programs overflow\\vc\\include\\immintrin.h"





extern void __cdecl _fxrstor(void const *);


#line 1254 "d:\\programs overflow\\vc\\include\\immintrin.h"







extern int __cdecl _rdrand16_step(unsigned short *);
extern int __cdecl _rdrand32_step(unsigned int *);


#line 1266 "d:\\programs overflow\\vc\\include\\immintrin.h"

















#line 1284 "d:\\programs overflow\\vc\\include\\immintrin.h"




extern __m128  __cdecl _mm_fmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_sd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmsub_pd(__m256d, __m256d, __m256d);





extern __m128  __cdecl _mm_fmaddsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmaddsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsubadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsubadd_pd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmaddsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmaddsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsubadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsubadd_pd(__m256d, __m256d, __m256d);





extern __m256i __cdecl _mm256_cmpeq_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_cmpgt_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi64(__m256i, __m256i);





extern __m256i __cdecl _mm256_max_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu32(__m256i, __m256i);

extern __m256i __cdecl _mm256_min_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu32(__m256i, __m256i);





extern __m256i __cdecl _mm256_and_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_andnot_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_or_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_xor_si256(__m256i, __m256i);





extern __m256i __cdecl _mm256_abs_epi8(__m256i);
extern __m256i __cdecl _mm256_abs_epi16(__m256i);
extern __m256i __cdecl _mm256_abs_epi32(__m256i);

extern __m256i __cdecl _mm256_add_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_adds_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sub_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_subs_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_avg_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_avg_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hadd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadd_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadds_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hsub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_madd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_maddubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mulhi_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mullo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mullo_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mul_epu32(__m256i, __m256i);
extern __m256i __cdecl _mm256_mul_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_sign_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhrs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sad_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mpsadbw_epu8(__m256i, __m256i, const int);





extern __m256i __cdecl _mm256_slli_si256(__m256i, const int);
extern __m256i __cdecl _mm256_srli_si256(__m256i, const int);

extern __m256i __cdecl _mm256_sll_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_slli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_sllv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sllv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_sllv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_sllv_epi64(__m128i, __m128i);

extern __m256i __cdecl _mm256_sra_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sra_epi32(__m256i, __m128i);

extern __m256i __cdecl _mm256_srai_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srai_epi32(__m256i, int);

extern __m256i __cdecl _mm256_srav_epi32(__m256i, __m256i);

extern __m128i __cdecl _mm_srav_epi32(__m128i, __m128i);

extern __m256i __cdecl _mm256_srl_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_srli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_srlv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_srlv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_srlv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_srlv_epi64(__m128i, __m128i);





extern __m128i __cdecl _mm_blend_epi32(__m128i, __m128i, const int);

extern __m256i __cdecl _mm256_blend_epi32(__m256i,__m256i, const int);

extern __m256i __cdecl _mm256_alignr_epi8(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_blendv_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_blend_epi16(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_packs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packs_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpackhi_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpacklo_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_shuffle_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_shuffle_epi32(__m256i, const int);

extern __m256i __cdecl _mm256_shufflehi_epi16(__m256i, const int);
extern __m256i __cdecl _mm256_shufflelo_epi16(__m256i, const int);

extern __m128i __cdecl _mm256_extracti128_si256(__m256i, const int);
extern __m256i __cdecl _mm256_inserti128_si256(__m256i, __m128i, const int);





extern __m128  __cdecl _mm_broadcastss_ps(__m128);
extern __m128d __cdecl _mm_broadcastsd_pd(__m128d);

extern __m128i __cdecl _mm_broadcastb_epi8(__m128i);
extern __m128i __cdecl _mm_broadcastw_epi16(__m128i);
extern __m128i __cdecl _mm_broadcastd_epi32(__m128i);
extern __m128i __cdecl _mm_broadcastq_epi64(__m128i);

extern __m256  __cdecl _mm256_broadcastss_ps(__m128);
extern __m256d __cdecl _mm256_broadcastsd_pd(__m128d);

extern __m256i __cdecl _mm256_broadcastb_epi8(__m128i);
extern __m256i __cdecl _mm256_broadcastw_epi16(__m128i);
extern __m256i __cdecl _mm256_broadcastd_epi32(__m128i);
extern __m256i __cdecl _mm256_broadcastq_epi64(__m128i);

extern __m256i __cdecl _mm256_broadcastsi128_si256(__m128i);






extern __m256i __cdecl _mm256_cvtepi8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi32_epi64(__m128i);

extern __m256i __cdecl _mm256_cvtepu8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu32_epi64(__m128i);






extern int __cdecl _mm256_movemask_epi8(__m256i);





extern __m128i __cdecl _mm_maskload_epi32(int const * ,
                                          __m128i     );
extern __m128i __cdecl _mm_maskload_epi64(__int64 const * ,
                                          __m128i         );

extern void __cdecl _mm_maskstore_epi32(int *   ,
                                        __m128i ,
                                        __m128i );
extern void __cdecl _mm_maskstore_epi64(__int64 * ,
                                        __m128i   ,
                                        __m128i   );

extern __m256i __cdecl _mm256_maskload_epi32(int const * ,
                                             __m256i     );
extern __m256i __cdecl _mm256_maskload_epi64(__int64 const * ,
                                             __m256i         );

extern void __cdecl _mm256_maskstore_epi32(int *   ,
                                           __m256i ,
                                           __m256i );
extern void __cdecl _mm256_maskstore_epi64(__int64 * ,
                                           __m256i   ,
                                           __m256i   );





extern __m256i __cdecl _mm256_permutevar8x32_epi32(__m256i, __m256i);
extern __m256  __cdecl _mm256_permutevar8x32_ps(__m256, __m256i);

extern __m256i __cdecl _mm256_permute4x64_epi64(__m256i, const int);
extern __m256d __cdecl _mm256_permute4x64_pd(__m256d, const int);

extern __m256i __cdecl _mm256_permute2x128_si256(__m256i, __m256i, const int);





extern __m256i  __cdecl _mm256_stream_load_si256(__m256i const *);






extern __m256d __cdecl _mm256_mask_i32gather_pd(__m256d        ,
                                                double const * ,
                                                __m128i        ,
                                                __m256d        ,
                                                const int      );
extern __m256  __cdecl _mm256_mask_i32gather_ps(__m256         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m256         ,
                                                const int      );
extern __m256d __cdecl _mm256_mask_i64gather_pd(__m256d        ,
                                                double const * ,
                                                __m256i        ,
                                                __m256d        ,
                                                const int      );
extern __m128  __cdecl _mm256_mask_i64gather_ps(__m128         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m128         ,
                                                const int      );

extern __m128d __cdecl _mm_mask_i32gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i32gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );
extern __m128d __cdecl _mm_mask_i64gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i64gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );


extern __m256i __cdecl _mm256_mask_i32gather_epi32(__m256i     ,
                                                   int const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i32gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m128i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m128i __cdecl _mm256_mask_i64gather_epi32(__m128i     ,
                                                   int     const * ,
                                                   __m256i     ,
                                                   __m128i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i64gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );

extern __m128i __cdecl _mm_mask_i32gather_epi32(__m128i         ,
                                                int const *     ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i32gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi32(__m128i         ,
                                                int     const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );





extern __m256d __cdecl _mm256_i32gather_pd(double const * ,
                                           __m128i        ,
                                           const int      );
extern __m256  __cdecl _mm256_i32gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );
extern __m256d __cdecl _mm256_i64gather_pd(double const * ,
                                           __m256i        ,
                                           const int      );
extern __m128  __cdecl _mm256_i64gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );

extern __m128d __cdecl _mm_i32gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i32gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );
extern __m128d __cdecl _mm_i64gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i64gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );

extern __m256i __cdecl _mm256_i32gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i32gather_epi64(__int64 const * ,
                                              __m128i         ,
                                              const int       );
extern __m128i __cdecl _mm256_i64gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i64gather_epi64(__int64 const * ,
                                              __m256i         ,
                                              const int       );

extern __m128i __cdecl _mm_i32gather_epi32(int const *     ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i32gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi32(int     const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );





extern unsigned int     _bextr_u32(unsigned int ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned int     _blsi_u32(unsigned int);
extern unsigned int     _blsmsk_u32(unsigned int);
extern unsigned int     _blsr_u32(unsigned int);
extern unsigned int     _bzhi_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _mulx_u32(unsigned int ,
                                  unsigned int ,
                                  unsigned int * );
extern unsigned int     _pdep_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _pext_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _rorx_u32(unsigned int ,
                                  const unsigned int );
extern int              _sarx_i32(int ,
                                  unsigned int );
extern unsigned int     _shlx_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _shrx_u32(unsigned int ,
                                          unsigned int );

























#line 1804 "d:\\programs overflow\\vc\\include\\immintrin.h"








extern unsigned int     _lzcnt_u32(unsigned int);


#line 1816 "d:\\programs overflow\\vc\\include\\immintrin.h"








extern unsigned int     _tzcnt_u32(unsigned int);


#line 1828 "d:\\programs overflow\\vc\\include\\immintrin.h"






extern void __cdecl _invpcid(unsigned int , void * );


extern void _Store_HLERelease(long volatile *,long);
extern void _StorePointer_HLERelease(void * volatile *,void *);

extern long _InterlockedExchange_HLEAcquire(long volatile *,long);
extern long _InterlockedExchange_HLERelease(long volatile *,long);
extern void * _InterlockedExchangePointer_HLEAcquire(void *volatile *,void *);
extern void * _InterlockedExchangePointer_HLERelease(void *volatile *,void *);

extern long _InterlockedCompareExchange_HLEAcquire(long volatile *,long,long);
extern long _InterlockedCompareExchange_HLERelease(long volatile *,long,long);
extern __int64 _InterlockedCompareExchange64_HLEAcquire(__int64 volatile *,__int64,__int64);
extern __int64 _InterlockedCompareExchange64_HLERelease(__int64 volatile *,__int64,__int64);
extern void * _InterlockedCompareExchangePointer_HLEAcquire(void *volatile *,void *,void *);
extern void * _InterlockedCompareExchangePointer_HLERelease(void *volatile *,void *,void *);

extern long _InterlockedExchangeAdd_HLEAcquire(long volatile *,long);
extern long _InterlockedExchangeAdd_HLERelease(long volatile *,long);

extern long _InterlockedAnd_HLEAcquire(long volatile *,long);
extern long _InterlockedAnd_HLERelease(long volatile *,long);
extern long _InterlockedOr_HLEAcquire(long volatile *,long);
extern long _InterlockedOr_HLERelease(long volatile *,long);
extern long _InterlockedXor_HLEAcquire(long volatile *,long);
extern long _InterlockedXor_HLERelease(long volatile *,long);

extern unsigned char _interlockedbittestandset_HLEAcquire(long *a,long b);
extern unsigned char _interlockedbittestandset_HLERelease(long *a,long b);
extern unsigned char _interlockedbittestandreset_HLEAcquire(long *a,long b);
extern unsigned char _interlockedbittestandreset_HLERelease(long *a,long b);




















#line 1887 "d:\\programs overflow\\vc\\include\\immintrin.h"











extern unsigned int     __cdecl _xbegin(void);
extern void             __cdecl _xend(void);
extern void             __cdecl _xabort(const unsigned int);
extern unsigned char    __cdecl _xtest(void);








extern int __cdecl _rdseed16_step(unsigned short *);
extern int __cdecl _rdseed32_step(unsigned int *);
extern int __cdecl _rdseed64_step(unsigned __int64 *);










extern unsigned char __cdecl _addcarryx_u32(unsigned char ,
                                                   unsigned int ,
                                                   unsigned int ,
                                                   unsigned int * );





#line 1933 "d:\\programs overflow\\vc\\include\\immintrin.h"


}; 
#line 1937 "d:\\programs overflow\\vc\\include\\immintrin.h"

#line 1939 "d:\\programs overflow\\vc\\include\\immintrin.h"

#line 1941 "d:\\programs overflow\\vc\\include\\immintrin.h"
#line 1942 "d:\\programs overflow\\vc\\include\\immintrin.h"

#line 27 "d:\\programs overflow\\vc\\include\\intrin.h"
#line 1 "d:\\programs overflow\\vc\\include\\ammintrin.h"












#pragma once






#line 21 "d:\\programs overflow\\vc\\include\\ammintrin.h"


extern "C" { 
#line 25 "d:\\programs overflow\\vc\\include\\ammintrin.h"





























































































__m128 _mm_macc_ps(__m128, __m128, __m128);
__m128d _mm_macc_pd(__m128d, __m128d, __m128d);
__m128 _mm_macc_ss(__m128, __m128, __m128);
__m128d _mm_macc_sd(__m128d, __m128d, __m128d);
__m128 _mm_maddsub_ps(__m128, __m128, __m128);
__m128d _mm_maddsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msubadd_ps(__m128, __m128, __m128);
__m128d _mm_msubadd_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ps(__m128, __m128, __m128);
__m128d _mm_msub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ss(__m128, __m128, __m128);
__m128d _mm_msub_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ps(__m128, __m128, __m128);
__m128d _mm_nmacc_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ss(__m128, __m128, __m128);
__m128d _mm_nmacc_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ps(__m128, __m128, __m128);
__m128d _mm_nmsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ss(__m128, __m128, __m128);
__m128d _mm_nmsub_sd(__m128d, __m128d, __m128d);


__m128i _mm_maccs_epi16(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccs_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macclo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macchi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maddd_epi16(__m128i, __m128i, __m128i);


__m128i _mm_haddw_epi8(__m128i);
__m128i _mm_haddd_epi8(__m128i);
__m128i _mm_haddq_epi8(__m128i);
__m128i _mm_haddd_epi16(__m128i);
__m128i _mm_haddq_epi16(__m128i);
__m128i _mm_haddq_epi32(__m128i);
__m128i _mm_haddw_epu8(__m128i);
__m128i _mm_haddd_epu8(__m128i);
__m128i _mm_haddq_epu8(__m128i);
__m128i _mm_haddd_epu16(__m128i);
__m128i _mm_haddq_epu16(__m128i);
__m128i _mm_haddq_epu32(__m128i);
__m128i _mm_hsubw_epi8(__m128i);
__m128i _mm_hsubd_epi16(__m128i);
__m128i _mm_hsubq_epi32(__m128i);


__m128i _mm_cmov_si128(__m128i, __m128i, __m128i);
__m128i _mm_perm_epi8(__m128i, __m128i, __m128i);


__m128i _mm_rot_epi8(__m128i, __m128i);
__m128i _mm_rot_epi16(__m128i, __m128i);
__m128i _mm_rot_epi32(__m128i, __m128i);
__m128i _mm_rot_epi64(__m128i, __m128i);
__m128i _mm_roti_epi8(__m128i, int);
__m128i _mm_roti_epi16(__m128i, int);
__m128i _mm_roti_epi32(__m128i, int);
__m128i _mm_roti_epi64(__m128i, int);
__m128i _mm_shl_epi8(__m128i, __m128i);
__m128i _mm_shl_epi16(__m128i, __m128i);
__m128i _mm_shl_epi32(__m128i, __m128i);
__m128i _mm_shl_epi64(__m128i, __m128i);
__m128i _mm_sha_epi8(__m128i, __m128i);
__m128i _mm_sha_epi16(__m128i, __m128i);
__m128i _mm_sha_epi32(__m128i, __m128i);
__m128i _mm_sha_epi64(__m128i, __m128i);



__m128i _mm_com_epu8(__m128i, __m128i, int);
__m128i _mm_com_epu16(__m128i, __m128i, int);
__m128i _mm_com_epu32(__m128i, __m128i, int);
__m128i _mm_com_epu64(__m128i, __m128i, int);
__m128i _mm_com_epi8(__m128i, __m128i, int);
__m128i _mm_com_epi16(__m128i, __m128i, int);
__m128i _mm_com_epi32(__m128i, __m128i, int);
__m128i _mm_com_epi64(__m128i, __m128i, int);



__m128 _mm_frcz_ps(__m128);
__m128d _mm_frcz_pd(__m128d);
__m128 _mm_frcz_ss(__m128, __m128);
__m128d _mm_frcz_sd(__m128d, __m128d);








__m128 _mm_permute2_ps(__m128, __m128, __m128i, int);
__m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int);



__m256 _mm256_macc_ps(__m256, __m256, __m256);
__m256d _mm256_macc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_maddsub_ps(__m256, __m256, __m256);
__m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msubadd_ps(__m256, __m256, __m256);
__m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msub_ps(__m256, __m256, __m256);
__m256d _mm256_msub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmacc_ps(__m256, __m256, __m256);
__m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmsub_ps(__m256, __m256, __m256);
__m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d);
__m256i _mm256_cmov_si256(__m256i, __m256i, __m256i);
__m256 _mm256_frcz_ps(__m256);
__m256d _mm256_frcz_pd(__m256d);
__m256 _mm256_permute2_ps(__m256, __m256, __m256i, int);
__m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int);


void __llwpcb(void *);
void *__slwpcb();
void __lwpval32(unsigned int, unsigned int, unsigned int);
unsigned char __lwpins32(unsigned int, unsigned int, unsigned int);



#line 249 "d:\\programs overflow\\vc\\include\\ammintrin.h"


unsigned int _bextr_u32(unsigned int, unsigned int, unsigned int);
unsigned int _andn_u32(unsigned int, unsigned int);
unsigned int _tzcnt_u32(unsigned int);
unsigned int _lzcnt_u32(unsigned int);
unsigned int _blsr_u32(unsigned int);
unsigned int _blsmsk_u32(unsigned int);
unsigned int _blsi_u32(unsigned int);








#line 267 "d:\\programs overflow\\vc\\include\\ammintrin.h"


unsigned int _bextri_u32(unsigned int, unsigned int);
unsigned int _blcfill_u32(unsigned int);
unsigned int _blsfill_u32(unsigned int);
unsigned int _blcs_u32(unsigned int);
unsigned int _tzmsk_u32(unsigned int);
unsigned int _blcic_u32(unsigned int);
unsigned int _blsic_u32(unsigned int);
unsigned int _t1mskc_u32(unsigned int);
unsigned int _blcmsk_u32(unsigned int);
unsigned int _blci_u32(unsigned int);











#line 291 "d:\\programs overflow\\vc\\include\\ammintrin.h"


}; 
#line 295 "d:\\programs overflow\\vc\\include\\ammintrin.h"

#line 297 "d:\\programs overflow\\vc\\include\\ammintrin.h"
#line 298 "d:\\programs overflow\\vc\\include\\ammintrin.h"
#line 299 "d:\\programs overflow\\vc\\include\\ammintrin.h"
#line 28 "d:\\programs overflow\\vc\\include\\intrin.h"
#line 29 "d:\\programs overflow\\vc\\include\\intrin.h"


#line 1 "d:\\programs overflow\\vc\\include\\mm3dnow.h"















#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "d:\\programs overflow\\vc\\include\\mm3dnow.h"




extern "C" { 
#line 28 "d:\\programs overflow\\vc\\include\\mm3dnow.h"



void _m_femms(void);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pf2id(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pmulhrw(__m64, __m64);
void _m_prefetch(void*);
void _m_prefetchw(volatile const void*_Source);

__m64 _m_from_float(float);
float _m_to_float(__m64);



__m64 _m_pf2iw(__m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pswapd(__m64);


}; 
#line 68 "d:\\programs overflow\\vc\\include\\mm3dnow.h"

#line 70 "d:\\programs overflow\\vc\\include\\mm3dnow.h"
#line 71 "d:\\programs overflow\\vc\\include\\mm3dnow.h"
#line 32 "d:\\programs overflow\\vc\\include\\intrin.h"
#line 33 "d:\\programs overflow\\vc\\include\\intrin.h"



#line 37 "d:\\programs overflow\\vc\\include\\intrin.h"

#line 39 "d:\\programs overflow\\vc\\include\\intrin.h"

#line 41 "d:\\programs overflow\\vc\\include\\intrin.h"


extern "C" {
#line 45 "d:\\programs overflow\\vc\\include\\intrin.h"






















#line 68 "d:\\programs overflow\\vc\\include\\intrin.h"


#line 71 "d:\\programs overflow\\vc\\include\\intrin.h"






#line 78 "d:\\programs overflow\\vc\\include\\intrin.h"




#line 83 "d:\\programs overflow\\vc\\include\\intrin.h"




#line 88 "d:\\programs overflow\\vc\\include\\intrin.h"




#line 93 "d:\\programs overflow\\vc\\include\\intrin.h"




#line 98 "d:\\programs overflow\\vc\\include\\intrin.h"




#line 103 "d:\\programs overflow\\vc\\include\\intrin.h"

#line 105 "d:\\programs overflow\\vc\\include\\intrin.h"


void * _AddressOfReturnAddress(void);
unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);

unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);




















long _InterlockedAddLargeStatistic(__int64 volatile * _Addend, long _Value);



long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);









char _InterlockedAnd8(char volatile * _Value, char _Mask);








long __cdecl _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);



short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);




__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);




char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);



void * _InterlockedCompareExchangePointer(void * volatile * _Destination, void * _Exchange, void * _Comparand);








long __cdecl _InterlockedDecrement(long volatile * _Addend);

short _InterlockedDecrement16(short volatile * _Addend);










long __cdecl _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);







char _InterlockedExchange8(char volatile * _Target, char _Value);



long __cdecl _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);







char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);






 


__forceinline static void * _Intrin_h_InterlockedExchangePointer(void * volatile * _Target, void * _Value)
{
    return (void *)_InterlockedExchange((long volatile *) _Target, (long) _Value);
}



#line 236 "d:\\programs overflow\\vc\\include\\intrin.h"






long __cdecl _InterlockedIncrement(long volatile * _Addend);

short _InterlockedIncrement16(short volatile * _Addend);










long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);









char _InterlockedOr8(char volatile * _Value, char _Mask);








long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);









char _InterlockedXor8(char volatile * _Value, char _Mask);
















void _ReadBarrier(void);

void _ReadWriteBarrier(void);
void * _ReturnAddress(void);

void _WriteBarrier(void);

void __addfsbyte(unsigned long, unsigned char);
void __addfsdword(unsigned long, unsigned long);
void __addfsword(unsigned long, unsigned short);




void __code_seg(const char *);
void __cpuid(int[4], int);
void __cpuidex(int[4], int, int);
void __cdecl __debugbreak(void);

__int64 __emul(int, int);
unsigned __int64 __emulu(unsigned int, unsigned int);
__declspec(noreturn) void __fastfail(unsigned int);

unsigned int __getcallerseflags(void);
void __halt(void);

unsigned char __inbyte(unsigned short);
void __inbytestring(unsigned short, unsigned char *, unsigned long);
void __incfsbyte(unsigned long);
void __incfsdword(unsigned long);
void __incfsword(unsigned long);




unsigned long __indword(unsigned short);
void __indwordstring(unsigned short, unsigned long *, unsigned long);
void __int2c(void);
void __invlpg(void *);
unsigned short __inword(unsigned short);
void __inwordstring(unsigned short, unsigned short *, unsigned long);









void __lidt(void *);
unsigned __int64 __ll_lshift(unsigned __int64, int);
__int64 __ll_rshift(__int64, int);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);

void __movsb(unsigned char *, unsigned char const *, size_t);
void __movsd(unsigned long *, unsigned long const *, size_t);

void __movsw(unsigned short *, unsigned short const *, size_t);

void __nop(void);
void __nvreg_restore_fence(void);
void __nvreg_save_fence(void);
void __outbyte(unsigned short, unsigned char);
void __outbytestring(unsigned short, unsigned char *, unsigned long);
void __outdword(unsigned short, unsigned long);
void __outdwordstring(unsigned short, unsigned long *, unsigned long);
void __outword(unsigned short, unsigned short);
void __outwordstring(unsigned short, unsigned short *, unsigned long);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);




unsigned __int64 __rdtsc(void);
unsigned __int64 __rdtscp(unsigned int *);

unsigned long __readcr0(void);

unsigned long __readcr2(void);

unsigned long __readcr3(void);

unsigned long __readcr4(void);

unsigned long __readcr8(void);

unsigned int __readdr(unsigned int);

unsigned int __readeflags(void);
unsigned char __readfsbyte(unsigned long);
unsigned long __readfsdword(unsigned long);
unsigned __int64 __readfsqword(unsigned long);
unsigned short __readfsword(unsigned long);




unsigned __int64 __readmsr(unsigned long);
unsigned __int64 __readpmc(unsigned long);
unsigned long __segmentlimit(unsigned long);



void __sidt(void *);

void __stosb(unsigned char *, unsigned char, size_t);
void __stosd(unsigned long *, unsigned long, size_t);

void __stosw(unsigned short *, unsigned short, size_t);
void __svm_clgi(void);
void __svm_invlpga(void *, int);
void __svm_skinit(int);
void __svm_stgi(void);
void __svm_vmload(size_t);
void __svm_vmrun(size_t);
void __svm_vmsave(size_t);



void __ud2(void);
unsigned __int64 __ull_rshift(unsigned __int64, int);

void __vmx_off(void);




void __vmx_vmptrst(unsigned __int64 *);



void __wbinvd(void);



void __writecr0(unsigned int);

void __writecr3(unsigned int);

void __writecr4(unsigned int);

void __writecr8(unsigned int);

void __writedr(unsigned int, unsigned int);

void __writeeflags(unsigned int);
void __writefsbyte(unsigned long, unsigned char);
void __writefsdword(unsigned long, unsigned long);
void __writefsqword(unsigned long, unsigned __int64);
void __writefsword(unsigned long, unsigned short);




void __writemsr(unsigned long, unsigned __int64);

unsigned char _bittest(long const *, long);

unsigned char _bittestandcomplement(long *, long);

unsigned char _bittestandreset(long *, long);

unsigned char _bittestandset(long *, long);

  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64);
  unsigned long __cdecl _byteswap_ulong(  unsigned long);
  unsigned short __cdecl _byteswap_ushort(  unsigned short);
void __cdecl _disable(void);
void __cdecl _enable(void);
unsigned char _interlockedbittestandreset(long volatile *, long);




unsigned char _interlockedbittestandset(long volatile *, long);






  unsigned long __cdecl _lrotl(  unsigned long,   int);
  unsigned long __cdecl _lrotr(  unsigned long,   int);
void _m_empty(void);
void _m_femms(void);
__m64 _m_from_float(float);
__m64 _m_from_int(int);
void _m_maskmovq(__m64, __m64, char *);
__m64 _m_packssdw(__m64, __m64);
__m64 _m_packsswb(__m64, __m64);
__m64 _m_packuswb(__m64, __m64);
__m64 _m_paddb(__m64, __m64);
__m64 _m_paddd(__m64, __m64);
__m64 _m_paddsb(__m64, __m64);
__m64 _m_paddsw(__m64, __m64);
__m64 _m_paddusb(__m64, __m64);
__m64 _m_paddusw(__m64, __m64);
__m64 _m_paddw(__m64, __m64);
__m64 _m_pand(__m64, __m64);
__m64 _m_pandn(__m64, __m64);
__m64 _m_pavgb(__m64, __m64);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pavgw(__m64, __m64);
__m64 _m_pcmpeqb(__m64, __m64);
__m64 _m_pcmpeqd(__m64, __m64);
__m64 _m_pcmpeqw(__m64, __m64);
__m64 _m_pcmpgtb(__m64, __m64);
__m64 _m_pcmpgtd(__m64, __m64);
__m64 _m_pcmpgtw(__m64, __m64);
int _m_pextrw(__m64, int);
__m64 _m_pf2id(__m64);
__m64 _m_pf2iw(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pinsrw(__m64, int, int);
__m64 _m_pmaddwd(__m64, __m64);
__m64 _m_pmaxsw(__m64, __m64);
__m64 _m_pmaxub(__m64, __m64);
__m64 _m_pminsw(__m64, __m64);
__m64 _m_pminub(__m64, __m64);
int _m_pmovmskb(__m64);
__m64 _m_pmulhrw(__m64, __m64);
__m64 _m_pmulhuw(__m64, __m64);
__m64 _m_pmulhw(__m64, __m64);
__m64 _m_pmullw(__m64, __m64);
__m64 _m_por(__m64, __m64);
void _m_prefetch(void *);
void _m_prefetchw(volatile const void *);
__m64 _m_psadbw(__m64, __m64);
__m64 _m_pshufw(__m64, int);
__m64 _m_pslld(__m64, __m64);
__m64 _m_pslldi(__m64, int);
__m64 _m_psllq(__m64, __m64);
__m64 _m_psllqi(__m64, int);
__m64 _m_psllw(__m64, __m64);
__m64 _m_psllwi(__m64, int);
__m64 _m_psrad(__m64, __m64);
__m64 _m_psradi(__m64, int);
__m64 _m_psraw(__m64, __m64);
__m64 _m_psrawi(__m64, int);
__m64 _m_psrld(__m64, __m64);
__m64 _m_psrldi(__m64, int);
__m64 _m_psrlq(__m64, __m64);
__m64 _m_psrlqi(__m64, int);
__m64 _m_psrlw(__m64, __m64);
__m64 _m_psrlwi(__m64, int);
__m64 _m_psubb(__m64, __m64);
__m64 _m_psubd(__m64, __m64);
__m64 _m_psubsb(__m64, __m64);
__m64 _m_psubsw(__m64, __m64);
__m64 _m_psubusb(__m64, __m64);
__m64 _m_psubusw(__m64, __m64);
__m64 _m_psubw(__m64, __m64);
__m64 _m_pswapd(__m64);
__m64 _m_punpckhbw(__m64, __m64);
__m64 _m_punpckhdq(__m64, __m64);
__m64 _m_punpckhwd(__m64, __m64);
__m64 _m_punpcklbw(__m64, __m64);
__m64 _m_punpckldq(__m64, __m64);
__m64 _m_punpcklwd(__m64, __m64);
__m64 _m_pxor(__m64, __m64);
float _m_to_float(__m64);
int _m_to_int(__m64);
__m128i _mm_abs_epi16(__m128i);
__m128i _mm_abs_epi32(__m128i);
__m128i _mm_abs_epi8(__m128i);
__m64 _mm_abs_pi16(__m64);
__m64 _mm_abs_pi32(__m64);
__m64 _mm_abs_pi8(__m64);
__m128i _mm_add_epi16(__m128i, __m128i);
__m128i _mm_add_epi32(__m128i, __m128i);
__m128i _mm_add_epi64(__m128i, __m128i);
__m128i _mm_add_epi8(__m128i, __m128i);
__m128d _mm_add_pd(__m128d, __m128d);
__m128 _mm_add_ps(__m128, __m128);
__m128d _mm_add_sd(__m128d, __m128d);
__m64 _mm_add_si64(__m64, __m64);
__m128 _mm_add_ss(__m128, __m128);
__m128i _mm_adds_epi16(__m128i, __m128i);
__m128i _mm_adds_epi8(__m128i, __m128i);
__m128i _mm_adds_epu16(__m128i, __m128i);
__m128i _mm_adds_epu8(__m128i, __m128i);
__m128d _mm_addsub_pd(__m128d, __m128d);
__m128 _mm_addsub_ps(__m128, __m128);
__m128i _mm_alignr_epi8(__m128i, __m128i, int);
__m64 _mm_alignr_pi8(__m64, __m64, int);
__m128d _mm_and_pd(__m128d, __m128d);
__m128 _mm_and_ps(__m128, __m128);
__m128i _mm_and_si128(__m128i, __m128i);
__m128d _mm_andnot_pd(__m128d, __m128d);
__m128 _mm_andnot_ps(__m128, __m128);
__m128i _mm_andnot_si128(__m128i, __m128i);
__m128i _mm_avg_epu16(__m128i, __m128i);
__m128i _mm_avg_epu8(__m128i, __m128i);
__m128i _mm_blend_epi16(__m128i, __m128i, int);
__m128d _mm_blend_pd(__m128d, __m128d, int);
__m128 _mm_blend_ps(__m128, __m128, int);
__m128i _mm_blendv_epi8(__m128i, __m128i, __m128i);
__m128d _mm_blendv_pd(__m128d, __m128d, __m128d);
__m128 _mm_blendv_ps(__m128, __m128, __m128);
void _mm_clflush(void const *);
__m128i _mm_cmpeq_epi16(__m128i, __m128i);
__m128i _mm_cmpeq_epi32(__m128i, __m128i);
__m128i _mm_cmpeq_epi64(__m128i, __m128i);
__m128i _mm_cmpeq_epi8(__m128i, __m128i);
__m128d _mm_cmpeq_pd(__m128d, __m128d);
__m128 _mm_cmpeq_ps(__m128, __m128);
__m128d _mm_cmpeq_sd(__m128d, __m128d);
__m128 _mm_cmpeq_ss(__m128, __m128);
int _mm_cmpestra(__m128i, int, __m128i, int, int);
int _mm_cmpestrc(__m128i, int, __m128i, int, int);
int _mm_cmpestri(__m128i, int, __m128i, int, int);
__m128i _mm_cmpestrm(__m128i, int, __m128i, int, int);
int _mm_cmpestro(__m128i, int, __m128i, int, int);
int _mm_cmpestrs(__m128i, int, __m128i, int, int);
int _mm_cmpestrz(__m128i, int, __m128i, int, int);
__m128d _mm_cmpge_pd(__m128d, __m128d);
__m128 _mm_cmpge_ps(__m128, __m128);
__m128d _mm_cmpge_sd(__m128d, __m128d);
__m128 _mm_cmpge_ss(__m128, __m128);
__m128i _mm_cmpgt_epi16(__m128i, __m128i);
__m128i _mm_cmpgt_epi32(__m128i, __m128i);
__m128i _mm_cmpgt_epi64(__m128i, __m128i);
__m128i _mm_cmpgt_epi8(__m128i, __m128i);
__m128d _mm_cmpgt_pd(__m128d, __m128d);
__m128 _mm_cmpgt_ps(__m128, __m128);
__m128d _mm_cmpgt_sd(__m128d, __m128d);
__m128 _mm_cmpgt_ss(__m128, __m128);
int _mm_cmpistra(__m128i, __m128i, int);
int _mm_cmpistrc(__m128i, __m128i, int);
int _mm_cmpistri(__m128i, __m128i, int);
__m128i _mm_cmpistrm(__m128i, __m128i, int);
int _mm_cmpistro(__m128i, __m128i, int);
int _mm_cmpistrs(__m128i, __m128i, int);
int _mm_cmpistrz(__m128i, __m128i, int);
__m128d _mm_cmple_pd(__m128d, __m128d);
__m128 _mm_cmple_ps(__m128, __m128);
__m128d _mm_cmple_sd(__m128d, __m128d);
__m128 _mm_cmple_ss(__m128, __m128);
__m128i _mm_cmplt_epi16(__m128i, __m128i);
__m128i _mm_cmplt_epi32(__m128i, __m128i);
__m128i _mm_cmplt_epi8(__m128i, __m128i);
__m128d _mm_cmplt_pd(__m128d, __m128d);
__m128 _mm_cmplt_ps(__m128, __m128);
__m128d _mm_cmplt_sd(__m128d, __m128d);
__m128 _mm_cmplt_ss(__m128, __m128);
__m128d _mm_cmpneq_pd(__m128d, __m128d);
__m128 _mm_cmpneq_ps(__m128, __m128);
__m128d _mm_cmpneq_sd(__m128d, __m128d);
__m128 _mm_cmpneq_ss(__m128, __m128);
__m128d _mm_cmpnge_pd(__m128d, __m128d);
__m128 _mm_cmpnge_ps(__m128, __m128);
__m128d _mm_cmpnge_sd(__m128d, __m128d);
__m128 _mm_cmpnge_ss(__m128, __m128);
__m128d _mm_cmpngt_pd(__m128d, __m128d);
__m128 _mm_cmpngt_ps(__m128, __m128);
__m128d _mm_cmpngt_sd(__m128d, __m128d);
__m128 _mm_cmpngt_ss(__m128, __m128);
__m128d _mm_cmpnle_pd(__m128d, __m128d);
__m128 _mm_cmpnle_ps(__m128, __m128);
__m128d _mm_cmpnle_sd(__m128d, __m128d);
__m128 _mm_cmpnle_ss(__m128, __m128);
__m128d _mm_cmpnlt_pd(__m128d, __m128d);
__m128 _mm_cmpnlt_ps(__m128, __m128);
__m128d _mm_cmpnlt_sd(__m128d, __m128d);
__m128 _mm_cmpnlt_ss(__m128, __m128);
__m128d _mm_cmpord_pd(__m128d, __m128d);
__m128 _mm_cmpord_ps(__m128, __m128);
__m128d _mm_cmpord_sd(__m128d, __m128d);
__m128 _mm_cmpord_ss(__m128, __m128);
__m128d _mm_cmpunord_pd(__m128d, __m128d);
__m128 _mm_cmpunord_ps(__m128, __m128);
__m128d _mm_cmpunord_sd(__m128d, __m128d);
__m128 _mm_cmpunord_ss(__m128, __m128);
int _mm_comieq_sd(__m128d, __m128d);
int _mm_comieq_ss(__m128, __m128);
int _mm_comige_sd(__m128d, __m128d);
int _mm_comige_ss(__m128, __m128);
int _mm_comigt_sd(__m128d, __m128d);
int _mm_comigt_ss(__m128, __m128);
int _mm_comile_sd(__m128d, __m128d);
int _mm_comile_ss(__m128, __m128);
int _mm_comilt_sd(__m128d, __m128d);
int _mm_comilt_ss(__m128, __m128);
int _mm_comineq_sd(__m128d, __m128d);
int _mm_comineq_ss(__m128, __m128);
unsigned int _mm_crc32_u16(unsigned int, unsigned short);
unsigned int _mm_crc32_u32(unsigned int, unsigned int);

unsigned int _mm_crc32_u8(unsigned int, unsigned char);
__m128 _mm_cvt_pi2ps(__m128, __m64);
__m64 _mm_cvt_ps2pi(__m128);
__m128 _mm_cvt_si2ss(__m128, int);
int _mm_cvt_ss2si(__m128);
__m128i _mm_cvtepi16_epi32(__m128i);
__m128i _mm_cvtepi16_epi64(__m128i);
__m128i _mm_cvtepi32_epi64(__m128i);
__m128d _mm_cvtepi32_pd(__m128i);
__m128 _mm_cvtepi32_ps(__m128i);
__m128i _mm_cvtepi8_epi16(__m128i);
__m128i _mm_cvtepi8_epi32(__m128i);
__m128i _mm_cvtepi8_epi64(__m128i);
__m128i _mm_cvtepu16_epi32(__m128i);
__m128i _mm_cvtepu16_epi64(__m128i);
__m128i _mm_cvtepu32_epi64(__m128i);
__m128i _mm_cvtepu8_epi16(__m128i);
__m128i _mm_cvtepu8_epi32(__m128i);
__m128i _mm_cvtepu8_epi64(__m128i);
__m128i _mm_cvtpd_epi32(__m128d);
__m64 _mm_cvtpd_pi32(__m128d);
__m128 _mm_cvtpd_ps(__m128d);
__m128d _mm_cvtpi32_pd(__m64);
__m128i _mm_cvtps_epi32(__m128);
__m128d _mm_cvtps_pd(__m128);
int _mm_cvtsd_si32(__m128d);


__m128 _mm_cvtsd_ss(__m128, __m128d);
int _mm_cvtsi128_si32(__m128i);


__m128d _mm_cvtsi32_sd(__m128d, int);
__m128i _mm_cvtsi32_si128(int);






__m128d _mm_cvtss_sd(__m128d, __m128);


__m64 _mm_cvtt_ps2pi(__m128);
int _mm_cvtt_ss2si(__m128);
__m128i _mm_cvttpd_epi32(__m128d);
__m64 _mm_cvttpd_pi32(__m128d);
__m128i _mm_cvttps_epi32(__m128);
int _mm_cvttsd_si32(__m128d);




__m128d _mm_div_pd(__m128d, __m128d);
__m128 _mm_div_ps(__m128, __m128);
__m128d _mm_div_sd(__m128d, __m128d);
__m128 _mm_div_ss(__m128, __m128);
__m128d _mm_dp_pd(__m128d, __m128d, int);
__m128 _mm_dp_ps(__m128, __m128, int);
int _mm_extract_epi16(__m128i, int);
int _mm_extract_epi32(__m128i, int);

int _mm_extract_epi8(__m128i, int);
int _mm_extract_ps(__m128, int);
__m128i _mm_extract_si64(__m128i, __m128i);
__m128i _mm_extracti_si64(__m128i, int, int);
unsigned int _mm_getcsr(void);
__m128i _mm_hadd_epi16(__m128i, __m128i);
__m128i _mm_hadd_epi32(__m128i, __m128i);
__m128d _mm_hadd_pd(__m128d, __m128d);
__m64 _mm_hadd_pi16(__m64, __m64);
__m64 _mm_hadd_pi32(__m64, __m64);
__m128 _mm_hadd_ps(__m128, __m128);
__m128i _mm_hadds_epi16(__m128i, __m128i);
__m64 _mm_hadds_pi16(__m64, __m64);
__m128i _mm_hsub_epi16(__m128i, __m128i);
__m128i _mm_hsub_epi32(__m128i, __m128i);
__m128d _mm_hsub_pd(__m128d, __m128d);
__m64 _mm_hsub_pi16(__m64, __m64);
__m64 _mm_hsub_pi32(__m64, __m64);
__m128 _mm_hsub_ps(__m128, __m128);
__m128i _mm_hsubs_epi16(__m128i, __m128i);
__m64 _mm_hsubs_pi16(__m64, __m64);
__m128i _mm_insert_epi16(__m128i, int, int);
__m128i _mm_insert_epi32(__m128i, int, int);

__m128i _mm_insert_epi8(__m128i, int, int);
__m128 _mm_insert_ps(__m128, __m128, int);
__m128i _mm_insert_si64(__m128i, __m128i);
__m128i _mm_inserti_si64(__m128i, __m128i, int, int);
__m128i _mm_lddqu_si128(__m128i const *);
void _mm_lfence(void);
__m128d _mm_load1_pd(double const *);
__m128d _mm_load_pd(double const *);
__m128 _mm_load_ps(float const *);
__m128 _mm_load_ps1(float const *);
__m128d _mm_load_sd(double const *);
__m128i _mm_load_si128(__m128i const *);
__m128 _mm_load_ss(float const *);
__m128d _mm_loaddup_pd(double const *);
__m128d _mm_loadh_pd(__m128d, double const *);
__m128 _mm_loadh_pi(__m128, __m64 const *);
__m128i _mm_loadl_epi64(__m128i const *);
__m128d _mm_loadl_pd(__m128d, double const *);
__m128 _mm_loadl_pi(__m128, __m64 const *);
__m128d _mm_loadr_pd(double const *);
__m128 _mm_loadr_ps(float const *);
__m128d _mm_loadu_pd(double const *);
__m128 _mm_loadu_ps(float const *);
__m128i _mm_loadu_si128(__m128i const *);
__m128i _mm_madd_epi16(__m128i, __m128i);
__m128i _mm_maddubs_epi16(__m128i, __m128i);
__m64 _mm_maddubs_pi16(__m64, __m64);
void _mm_maskmoveu_si128(__m128i, __m128i, char *);
__m128i _mm_max_epi16(__m128i, __m128i);
__m128i _mm_max_epi32(__m128i, __m128i);
__m128i _mm_max_epi8(__m128i, __m128i);
__m128i _mm_max_epu16(__m128i, __m128i);
__m128i _mm_max_epu32(__m128i, __m128i);
__m128i _mm_max_epu8(__m128i, __m128i);
__m128d _mm_max_pd(__m128d, __m128d);
__m128 _mm_max_ps(__m128, __m128);
__m128d _mm_max_sd(__m128d, __m128d);
__m128 _mm_max_ss(__m128, __m128);
void _mm_mfence(void);
__m128i _mm_min_epi16(__m128i, __m128i);
__m128i _mm_min_epi32(__m128i, __m128i);
__m128i _mm_min_epi8(__m128i, __m128i);
__m128i _mm_min_epu16(__m128i, __m128i);
__m128i _mm_min_epu32(__m128i, __m128i);
__m128i _mm_min_epu8(__m128i, __m128i);
__m128d _mm_min_pd(__m128d, __m128d);
__m128 _mm_min_ps(__m128, __m128);
__m128d _mm_min_sd(__m128d, __m128d);
__m128 _mm_min_ss(__m128, __m128);
__m128i _mm_minpos_epu16(__m128i);
void _mm_monitor(void const *, unsigned int, unsigned int);
__m128i _mm_move_epi64(__m128i);
__m128d _mm_move_sd(__m128d, __m128d);
__m128 _mm_move_ss(__m128, __m128);
__m128d _mm_movedup_pd(__m128d);
__m128 _mm_movehdup_ps(__m128);
__m128 _mm_movehl_ps(__m128, __m128);
__m128 _mm_moveldup_ps(__m128);
__m128 _mm_movelh_ps(__m128, __m128);
int _mm_movemask_epi8(__m128i);
int _mm_movemask_pd(__m128d);
int _mm_movemask_ps(__m128);
__m64 _mm_movepi64_pi64(__m128i);
__m128i _mm_movpi64_epi64(__m64);
__m128i _mm_mpsadbw_epu8(__m128i, __m128i, int);
__m128i _mm_mul_epi32(__m128i, __m128i);
__m128i _mm_mul_epu32(__m128i, __m128i);
__m128d _mm_mul_pd(__m128d, __m128d);
__m128 _mm_mul_ps(__m128, __m128);
__m128d _mm_mul_sd(__m128d, __m128d);
__m128 _mm_mul_ss(__m128, __m128);
__m64 _mm_mul_su32(__m64, __m64);
__m128i _mm_mulhi_epi16(__m128i, __m128i);
__m128i _mm_mulhi_epu16(__m128i, __m128i);
__m128i _mm_mulhrs_epi16(__m128i, __m128i);
__m64 _mm_mulhrs_pi16(__m64, __m64);
__m128i _mm_mullo_epi16(__m128i, __m128i);
__m128i _mm_mullo_epi32(__m128i, __m128i);
void _mm_mwait(unsigned int, unsigned int);
__m128d _mm_or_pd(__m128d, __m128d);
__m128 _mm_or_ps(__m128, __m128);
__m128i _mm_or_si128(__m128i, __m128i);
__m128i _mm_packs_epi16(__m128i, __m128i);
__m128i _mm_packs_epi32(__m128i, __m128i);
__m128i _mm_packus_epi16(__m128i, __m128i);
__m128i _mm_packus_epi32(__m128i, __m128i);
void _mm_pause(void);
int _mm_popcnt_u32(unsigned int);

void _mm_prefetch(char const *, int);
__m128 _mm_rcp_ps(__m128);
__m128 _mm_rcp_ss(__m128);
__m128d _mm_round_pd(__m128d, int);
__m128 _mm_round_ps(__m128, int);
__m128d _mm_round_sd(__m128d, __m128d, int);
__m128 _mm_round_ss(__m128, __m128, int);
__m128 _mm_rsqrt_ps(__m128);
__m128 _mm_rsqrt_ss(__m128);
__m128i _mm_sad_epu8(__m128i, __m128i);
__m128i _mm_set1_epi16(short);
__m128i _mm_set1_epi32(int);
__m128i _mm_set1_epi64(__m64);

__m128i _mm_set1_epi8(char);
__m128d _mm_set1_pd(double);
__m64 _mm_set1_pi16(short);
__m64 _mm_set1_pi32(int);
__m64 _mm_set1_pi8(char);
__m128i _mm_set_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_set_epi32(int, int, int, int);
__m128i _mm_set_epi64(__m64, __m64);

__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_set_pd(double, double);
__m64 _mm_set_pi16(short, short, short, short);
__m64 _mm_set_pi32(int, int);
__m64 _mm_set_pi8(char, char, char, char, char, char, char, char);
__m128 _mm_set_ps(float, float, float, float);
__m128 _mm_set_ps1(float);
__m128d _mm_set_sd(double);
__m128 _mm_set_ss(float);
void _mm_setcsr(unsigned int);
__m128i _mm_setl_epi64(__m128i);
__m128i _mm_setr_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_setr_epi32(int, int, int, int);
__m128i _mm_setr_epi64(__m64, __m64);
__m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_setr_pd(double, double);
__m64 _mm_setr_pi16(short, short, short, short);
__m64 _mm_setr_pi32(int, int);
__m64 _mm_setr_pi8(char, char, char, char, char, char, char, char);
__m128 _mm_setr_ps(float, float, float, float);
__m128d _mm_setzero_pd(void);
__m128 _mm_setzero_ps(void);
__m128i _mm_setzero_si128(void);
__m64 _mm_setzero_si64(void);
void _mm_sfence(void);
__m128i _mm_shuffle_epi32(__m128i, int);
__m128i _mm_shuffle_epi8(__m128i, __m128i);
__m128d _mm_shuffle_pd(__m128d, __m128d, int);
__m64 _mm_shuffle_pi8(__m64, __m64);
__m128 _mm_shuffle_ps(__m128, __m128, unsigned int);
__m128i _mm_shufflehi_epi16(__m128i, int);
__m128i _mm_shufflelo_epi16(__m128i, int);
__m128i _mm_sign_epi16(__m128i, __m128i);
__m128i _mm_sign_epi32(__m128i, __m128i);
__m128i _mm_sign_epi8(__m128i, __m128i);
__m64 _mm_sign_pi16(__m64, __m64);
__m64 _mm_sign_pi32(__m64, __m64);
__m64 _mm_sign_pi8(__m64, __m64);
__m128i _mm_sll_epi16(__m128i, __m128i);
__m128i _mm_sll_epi32(__m128i, __m128i);
__m128i _mm_sll_epi64(__m128i, __m128i);
__m128i _mm_slli_epi16(__m128i, int);
__m128i _mm_slli_epi32(__m128i, int);
__m128i _mm_slli_epi64(__m128i, int);
__m128i _mm_slli_si128(__m128i, int);
__m128d _mm_sqrt_pd(__m128d);
__m128 _mm_sqrt_ps(__m128);
__m128d _mm_sqrt_sd(__m128d, __m128d);
__m128 _mm_sqrt_ss(__m128);
__m128i _mm_sra_epi16(__m128i, __m128i);
__m128i _mm_sra_epi32(__m128i, __m128i);
__m128i _mm_srai_epi16(__m128i, int);
__m128i _mm_srai_epi32(__m128i, int);
__m128i _mm_srl_epi16(__m128i, __m128i);
__m128i _mm_srl_epi32(__m128i, __m128i);
__m128i _mm_srl_epi64(__m128i, __m128i);
__m128i _mm_srli_epi16(__m128i, int);
__m128i _mm_srli_epi32(__m128i, int);
__m128i _mm_srli_epi64(__m128i, int);
__m128i _mm_srli_si128(__m128i, int);
void _mm_store1_pd(double *, __m128d);
void _mm_store_pd(double *, __m128d);
void _mm_store_ps(float *, __m128);
void _mm_store_ps1(float *, __m128);
void _mm_store_sd(double *, __m128d);
void _mm_store_si128(__m128i *, __m128i);
void _mm_store_ss(float *, __m128);
void _mm_storeh_pd(double *, __m128d);
void _mm_storeh_pi(__m64 *, __m128);
void _mm_storel_epi64(__m128i *, __m128i);
void _mm_storel_pd(double *, __m128d);
void _mm_storel_pi(__m64 *, __m128);
void _mm_storer_pd(double *, __m128d);
void _mm_storer_ps(float *, __m128);
void _mm_storeu_pd(double *, __m128d);
void _mm_storeu_ps(float *, __m128);
void _mm_storeu_si128(__m128i *, __m128i);
__m128i _mm_stream_load_si128(__m128i *);
void _mm_stream_pd(double *, __m128d);
void _mm_stream_pi(__m64 *, __m64);
void _mm_stream_ps(float *, __m128);
void _mm_stream_sd(double *, __m128d);
void _mm_stream_si128(__m128i *, __m128i);
void _mm_stream_si32(int *, int);

void _mm_stream_ss(float *, __m128);
__m128i _mm_sub_epi16(__m128i, __m128i);
__m128i _mm_sub_epi32(__m128i, __m128i);
__m128i _mm_sub_epi64(__m128i, __m128i);
__m128i _mm_sub_epi8(__m128i, __m128i);
__m128d _mm_sub_pd(__m128d, __m128d);
__m128 _mm_sub_ps(__m128, __m128);
__m128d _mm_sub_sd(__m128d, __m128d);
__m64 _mm_sub_si64(__m64, __m64);
__m128 _mm_sub_ss(__m128, __m128);
__m128i _mm_subs_epi16(__m128i, __m128i);
__m128i _mm_subs_epi8(__m128i, __m128i);
__m128i _mm_subs_epu16(__m128i, __m128i);
__m128i _mm_subs_epu8(__m128i, __m128i);
int _mm_testc_si128(__m128i, __m128i);
int _mm_testnzc_si128(__m128i, __m128i);
int _mm_testz_si128(__m128i, __m128i);
int _mm_ucomieq_sd(__m128d, __m128d);
int _mm_ucomieq_ss(__m128, __m128);
int _mm_ucomige_sd(__m128d, __m128d);
int _mm_ucomige_ss(__m128, __m128);
int _mm_ucomigt_sd(__m128d, __m128d);
int _mm_ucomigt_ss(__m128, __m128);
int _mm_ucomile_sd(__m128d, __m128d);
int _mm_ucomile_ss(__m128, __m128);
int _mm_ucomilt_sd(__m128d, __m128d);
int _mm_ucomilt_ss(__m128, __m128);
int _mm_ucomineq_sd(__m128d, __m128d);
int _mm_ucomineq_ss(__m128, __m128);
__m128i _mm_unpackhi_epi16(__m128i, __m128i);
__m128i _mm_unpackhi_epi32(__m128i, __m128i);
__m128i _mm_unpackhi_epi64(__m128i, __m128i);
__m128i _mm_unpackhi_epi8(__m128i, __m128i);
__m128d _mm_unpackhi_pd(__m128d, __m128d);
__m128 _mm_unpackhi_ps(__m128, __m128);
__m128i _mm_unpacklo_epi16(__m128i, __m128i);
__m128i _mm_unpacklo_epi32(__m128i, __m128i);
__m128i _mm_unpacklo_epi64(__m128i, __m128i);
__m128i _mm_unpacklo_epi8(__m128i, __m128i);
__m128d _mm_unpacklo_pd(__m128d, __m128d);
__m128 _mm_unpacklo_ps(__m128, __m128);
__m128d _mm_xor_pd(__m128d, __m128d);
__m128 _mm_xor_ps(__m128, __m128);
__m128i _mm_xor_si128(__m128i, __m128i);

unsigned int __cdecl _rotl(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotl64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift);
unsigned int __cdecl _rotr(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotr64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift);
int __cdecl _setjmp(jmp_buf);


void _rsm(void);
void _lgdt(void *);
void _sgdt(void *);
void _clac(void);
void _stac(void);
unsigned char __cdecl _addcarry_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _subborrow_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _addcarry_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _subborrow_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _addcarry_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
unsigned char __cdecl _subborrow_u32(unsigned char, unsigned int, unsigned int, unsigned int *);




}
#line 1068 "d:\\programs overflow\\vc\\include\\intrin.h"
#line 1069 "d:\\programs overflow\\vc\\include\\intrin.h"
#line 1070 "d:\\programs overflow\\vc\\include\\intrin.h"

#line 910 "d:\\programs overflow\\vc\\include\\xmemory0"

   

   


  






#line 924 "d:\\programs overflow\\vc\\include\\xmemory0"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 929 "d:\\programs overflow\\vc\\include\\xmemory0"
#line 930 "d:\\programs overflow\\vc\\include\\xmemory0"






















#line 7 "d:\\programs overflow\\vc\\include\\xstring"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
 #pragma warning(disable: 4127)

  #pragma warning(disable: 4251)

template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Ax = allocator<_Elem> >
	class basic_string;

  
  
  

		
template<class _Mystr>
	class _String_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			typename _Mystr::value_type,
			typename _Mystr::difference_type,
			typename _Mystr::const_pointer,
			typename _Mystr::const_reference,
			_Iterator_base>
	{	
public:
	typedef _String_const_iterator<_Mystr> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Mystr::value_type value_type;
	typedef typename _Mystr::difference_type difference_type;
	typedef typename _Mystr::const_pointer pointer;
	typedef typename _Mystr::const_reference reference;

	_String_const_iterator()
		{	
		this->_Ptr = 0;
		}

	_String_const_iterator(pointer _Parg, const _Container_base *_Pstring)
		{	
		this->_Adopt(_Pstring);
		this->_Ptr = _Parg;
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr));
		}

	reference operator*() const
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
			|| ((_Mystr *)this->_Getcont())->_Myptr()
				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
			{	
			_Debug_message(L"string iterator not dereferencable", L"d:\\programs overflow\\vc\\include\\xstring", 79);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\xstring", 80, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\xstring", 80, 0); };
			}

 





#line 90 "d:\\programs overflow\\vc\\include\\xstring"

		;

		return (*this->_Ptr);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| ((_Mystr *)this->_Getcont())->_Myptr()
				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)
			{	
			_Debug_message(L"string iterator not incrementable", L"d:\\programs overflow\\vc\\include\\xstring", 109);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\xstring", 110, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\xstring", 110, 0); };
			}

 




#line 119 "d:\\programs overflow\\vc\\include\\xstring"

		++this->_Ptr;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| this->_Ptr <= ((_Mystr *)this->_Getcont())->_Myptr())
			{	
			_Debug_message(L"string iterator not decrementable", L"d:\\programs overflow\\vc\\include\\xstring", 138);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\xstring", 139, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\xstring", 139, 0); };
			}

 



#line 147 "d:\\programs overflow\\vc\\include\\xstring"

		--this->_Ptr;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| this->_Ptr + _Off < ((_Mystr *)this->_Getcont())->_Myptr()
			|| ((_Mystr *)this->_Getcont())->_Myptr()
				+ ((_Mystr *)this->_Getcont())->_Mysize < this->_Ptr + _Off)
			{	
			_Debug_message(L"string iterator + offset out of range", L"d:\\programs overflow\\vc\\include\\xstring", 168);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\xstring", 169, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\xstring", 169, 0); };
			}

 





#line 179 "d:\\programs overflow\\vc\\include\\xstring"

		_Ptr += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr - _Right._Ptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr < _Right._Ptr);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Myiter& _Right) const
		{	
		if (this->_Getcont() == 0
			|| this->_Getcont() != _Right._Getcont())
			{	
			_Debug_message(L"string iterators incompatible", L"d:\\programs overflow\\vc\\include\\xstring", 250);
			{ (void) ((!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\xstring", 251, 0, L"%s", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\xstring", 251, 0); };
			}
		}

 










#line 267 "d:\\programs overflow\\vc\\include\\xstring"

	pointer _Ptr;	
	};

template<class _Mystr> inline
	typename _String_const_iterator<_Mystr>::_Unchecked_type
		_Unchecked(_String_const_iterator<_Mystr> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mystr> inline
	_String_const_iterator<_Mystr>
		_Rechecked(_String_const_iterator<_Mystr>& _Iter,
			typename _String_const_iterator<_Mystr>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Mystr> inline
	_String_const_iterator<_Mystr> operator+(
		typename _String_const_iterator<_Mystr>
			::difference_type _Off,
		_String_const_iterator<_Mystr> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Mystr>
	class _String_iterator
		: public _String_const_iterator<_Mystr>
	{	
public:
	typedef _String_iterator<_Mystr> _Myiter;
	typedef _String_const_iterator<_Mystr> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Mystr::value_type value_type;
	typedef typename _Mystr::difference_type difference_type;
	typedef typename _Mystr::pointer pointer;
	typedef typename _Mystr::reference reference;

	_String_iterator()
		{	
		}

	_String_iterator(pointer _Parg, const _Container_base *_Pstring)
		: _Mybase(_Parg, _Pstring)
		{	
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr));
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return ((_Mybase)*this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Mystr> inline
	typename _String_iterator<_Mystr>::_Unchecked_type
		_Unchecked(_String_iterator<_Mystr> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mystr> inline
	_String_iterator<_Mystr>
		_Rechecked(_String_iterator<_Mystr>& _Iter,
			typename _String_iterator<_Mystr>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Mystr> inline
	_String_iterator<_Mystr> operator+(
		typename _String_iterator<_Mystr>
			::difference_type _Off,
		_String_iterator<_Mystr> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference>
	struct _String_iter_types
	{	
	typedef _Value_type value_type;
	typedef _Size_type size_type;
	typedef _Difference_type difference_type;
	typedef _Pointer pointer;
	typedef _Const_pointer const_pointer;
	typedef _Reference reference;
	typedef _Const_reference const_reference;
	};

template<class _Ty,
	class _Alloc0>
	struct _String_base_types
	{	
	typedef _Alloc0 _Alloc;
	typedef _String_base_types<_Ty, _Alloc> _Myt;

	typedef _Wrap_alloc<_Alloc> _Alty0;
	typedef typename _Alty0::template rebind<_Ty>::other _Alty;


	typedef typename _Alty::pointer _Tptr;
	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;

	typedef typename _If<_Is_simple_alloc<_Alty>::value,
		_Simple_types<typename _Alty::value_type>,
		_String_iter_types<typename _Alty::value_type,
			typename _Alty::size_type,
			typename _Alty::difference_type,
			typename _Alty::pointer,
			typename _Alty::const_pointer,
			typename _Alty::reference,
			typename _Alty::const_reference> >::type
		_Val_types;
	};

		
template<class _Val_types>
	class _String_val
		: public _Container_base
	{	
public:
	typedef _String_val<_Val_types> _Myt;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _String_iterator<_Myt> iterator;
	typedef _String_const_iterator<_Myt> const_iterator;

	_String_val()
		{	
		_Mysize = 0;
		_Myres = 0;
		}

	enum
		{	
		_BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
			: 16 / sizeof (value_type)};
	enum
		{	
		_ALLOC_MASK = sizeof (value_type) <= 1 ? 15
			: sizeof (value_type) <= 2 ? 7
			: sizeof (value_type) <= 4 ? 3
			: sizeof (value_type) <= 8 ? 1 : 0};

	value_type *_Myptr()
		{	
		return (this->_BUF_SIZE <= this->_Myres
			? ::std:: addressof(*this->_Bx._Ptr)
			: this->_Bx._Buf);
		}

	const value_type *_Myptr() const
		{	
		return (this->_BUF_SIZE <= this->_Myres
			? ::std:: addressof(*this->_Bx._Ptr)
			: this->_Bx._Buf);
		}

	union _Bxty
		{	
		value_type _Buf[_BUF_SIZE];
		pointer _Ptr;
		char _Alias[_BUF_SIZE];	
		} _Bx;

	size_type _Mysize;	
	size_type _Myres;	
	};

		
template<bool _Al_has_storage,
	class _Alloc_types>
	class _String_alloc
		: public _String_val<typename _Alloc_types::_Val_types>
	{	
public:
	typename _Alloc_types::_Alty _Alval;	

	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;
	typedef typename _Alloc_types::_Alty _Alty;

 















#line 564 "d:\\programs overflow\\vc\\include\\xstring"
	_String_alloc(const _Alloc& _Al = _Alloc())
		: _Alval(_Al)
		{	
		_Alloc_proxy();
		}

	~_String_alloc() throw ()
		{	
		_Free_proxy();
		}

	void _Change_alloc(const _Alty& _Al)
		{	
		_Free_proxy();
		this->_Alval = _Al;
		_Alloc_proxy();
		}

	void _Swap_alloc(_Myt& _Right)
		{	
		_Swap_adl(this->_Alval, _Right._Alval);
		_Swap_adl(this->_Myproxy, _Right._Myproxy);
		}

	void _Alloc_proxy()
		{	
		typename _Alloc::template rebind<_Container_proxy>::other
			_Alproxy(this->_Alval);
		this->_Myproxy = _Alproxy.allocate(1);
		_Alproxy.construct(this->_Myproxy, _Container_proxy());
		this->_Myproxy->_Mycont = this;
		}

	void _Free_proxy()
		{	
		typename _Alloc::template rebind<_Container_proxy>::other
			_Alproxy(this->_Alval);
		this->_Orphan_all();
		_Alproxy.destroy(this->_Myproxy);
		_Alproxy.deallocate(this->_Myproxy, 1);
		this->_Myproxy = 0;
		}
 #line 607 "d:\\programs overflow\\vc\\include\\xstring"

	_Alty& _Getal()
		{	
		return (this->_Alval);
		}

	const _Alty& _Getal() const
		{	
		return (this->_Alval);
		}
	};

template<class _Alloc_types>
	class _String_alloc<false, _Alloc_types>
		: public _String_val<typename _Alloc_types::_Val_types>
	{	
public:
	typedef _String_alloc<false, _Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;

	typedef typename _Alloc_types::_Alty _Alty;

 












#line 643 "d:\\programs overflow\\vc\\include\\xstring"
	_String_alloc(const _Alloc& = _Alloc())
		{	
		_Alloc_proxy();
		}

	~_String_alloc() throw ()
		{	
		_Free_proxy();
		}

	void _Change_alloc(const _Alty&)
		{	
		}

	void _Swap_alloc(_Myt& _Right)
		{	
		_Swap_adl(this->_Myproxy, _Right._Myproxy);
		}

	void _Alloc_proxy()
		{	
		typename _Alloc::template rebind<_Container_proxy>::other
			_Alproxy;
		this->_Myproxy = _Alproxy.allocate(1);
		_Alproxy.construct(this->_Myproxy, _Container_proxy());
		this->_Myproxy->_Mycont = this;
		}

	void _Free_proxy()
		{	
		typename _Alloc::template rebind<_Container_proxy>::other
			_Alproxy;
		this->_Orphan_all();
		_Alproxy.destroy(this->_Myproxy);
		_Alproxy.deallocate(this->_Myproxy, 1);
		this->_Myproxy = 0;
		}
 #line 681 "d:\\programs overflow\\vc\\include\\xstring"

	_Alty _Getal() const
		{	
		return (_Alty());
		}
	};

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_string
		: public _String_alloc<!is_empty<_Alloc>::value,
			_String_base_types<_Elem, _Alloc> >
	{	
public:
	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
	typedef _String_alloc<!is_empty<_Alloc>::value,
		_String_base_types<_Elem, _Alloc> > _Mybase;
	typedef _Traits traits_type;
	typedef _Alloc allocator_type;

	typedef typename _Mybase::_Alty _Alty;

	typedef typename _Mybase::value_type value_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;

	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	basic_string(const _Myt& _Right)

		: _Mybase(_Right._Getal().select_on_container_copy_construction())


		{	
		_Tidy();
		assign(_Right, 0, npos);
		}

	basic_string(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Right, 0, npos);
		}

	basic_string()
		: _Mybase()
		{	
		_Tidy();
		}

	explicit basic_string(const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		}

	basic_string(const _Myt& _Right, size_type _Roff,
		size_type _Count = npos)
		: _Mybase(_Right._Getal())
		{	
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
		const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count)
		: _Mybase()
		{	
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr)
		: _Mybase()
		{	
		_Tidy();
		assign(_Ptr);
		}

	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ptr);
		}

	basic_string(size_type _Count, _Elem _Ch)
		: _Mybase()
		{	
		_Tidy();
		assign(_Count, _Ch);
		}

	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Count, _Ch);
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		basic_string(_Iter _First, _Iter _Last)
		: _Mybase()
		{	
		_Tidy();
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, input_iterator_tag)
		{	
		try {
		for (; _First != _Last; ++_First)
			append((size_type)1, (_Elem)*_First);
		} catch (...) {
		_Tidy(true);
		throw;
		}
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, forward_iterator_tag)
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xstring", 843);
		size_type _Count = 0;
		_Distance(_First, _Last, _Count);
		reserve(_Count);

		try {
		for (; _First != _Last; ++_First)
			append((size_type)1, (_Elem)*_First);
		} catch (...) {
		_Tidy(true);
		throw;
		}
		}

	basic_string(const_pointer _First, const_pointer _Last)
		: _Mybase()
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xstring", 860);
		_Tidy();
		if (_First != _Last)
			assign(&*_First, _Last - _First);
		}

	basic_string(const_pointer _First, const_pointer _Last,
		const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xstring", 870);
		_Tidy();
		if (_First != _Last)
			assign(&*_First, _Last - _First);
		}

	basic_string(const_iterator _First, const_iterator _Last)
		: _Mybase()
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xstring", 879);
		_Tidy();
		if (_First != _Last)
			assign(&*_First, _Last - _First);
		}

	basic_string(_Myt&& _Right) throw ()
		: _Mybase(_Right._Getal())
		{	
		_Tidy();
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	basic_string(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		if (this->_Getal() != _Right._Getal())
			assign(_Right.begin(), _Right.end());
		else
			_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right) throw ()
		{	
		if (this != &_Right)
			{	
			_Tidy(true);

			if (_Alty::propagate_on_container_move_assignment::value
				&& this->_Getal() != _Right._Getal())
				this->_Change_alloc(_Right._Getal());

			if (this->_Getal() != _Right._Getal())
				assign(_Right.begin(), _Right.end());
			else
				_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	_Myt& assign(_Myt&& _Right) throw ()
		{	
		if (this == &_Right)
			;
		else if (get_allocator() != _Right.get_allocator()
			&& this->_BUF_SIZE <= _Right._Myres)
			*this = _Right;
		else
			{	
			_Tidy(true);
			_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (_Right._Myres < this->_BUF_SIZE)
			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
				_Right._Mysize + 1);
		else
			{	
			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
			_Right._Bx._Ptr = pointer();
			}
		this->_Mysize = _Right._Mysize;
		this->_Myres = _Right._Myres;
		_Right._Tidy();
		}

	basic_string(::std:: initializer_list<_Elem> _Ilist,
		const _Alloc& _Al = allocator_type())
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (assign(_Ilist.begin(), _Ilist.end()));
		}

	_Myt& operator+=(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (append(_Ilist.begin(), _Ilist.end()));
		}

	_Myt& assign(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (assign(_Ilist.begin(), _Ilist.end()));
		}

	_Myt& append(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (append(_Ilist.begin(), _Ilist.end()));
		}

	iterator insert(const_iterator _Where,
		::std:: initializer_list<_Elem> _Ilist)
		{	
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		::std:: initializer_list<_Elem> _Ilist)
		{	
		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
		}

	~basic_string() throw ()
		{	
		_Tidy(true);
		}

	 static const size_type npos;	

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_copy_assignment::value)
				{	
				_Tidy(true);
				this->_Change_alloc(_Right._Getal());
				}

			assign(_Right);
			}
		return (*this);
		}

	_Myt& operator=(const _Elem *_Ptr)
		{	
		return (assign(_Ptr));
		}

	_Myt& operator=(_Elem _Ch)
		{	
		return (assign(1, _Ch));
		}

	_Myt& operator+=(const _Myt& _Right)
		{	
		return (append(_Right));
		}

	_Myt& operator+=(const _Elem *_Ptr)
		{	
		return (append(_Ptr));
		}

	_Myt& operator+=(_Elem _Ch)
		{	
		return (append((size_type)1, _Ch));
		}

	_Myt& append(const _Myt& _Right)
		{	
		return (append(_Right, 0, npos));
		}

	_Myt& append(const _Myt& _Right,
		size_type _Roff, size_type _Count)
		{	
		if (_Right.size() < _Roff)
			_Xran();	
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	
		if (npos - this->_Mysize <= _Count)
			_Xlen();	

		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
			{	
			_Traits::copy(this->_Myptr() + this->_Mysize,
				_Right._Myptr() + _Roff, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr, size_type _Count)
		{	
 
		if (_Count != 0)
			_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 1066);
 #line 1068 "d:\\programs overflow\\vc\\include\\xstring"

		if (_Inside(_Ptr))
			return (append(*this,
				_Ptr - this->_Myptr(), _Count));	
		if (npos - this->_Mysize <= _Count)
			_Xlen();	

		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
			{	
			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 1086);
		return (append(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& append(size_type _Count, _Elem _Ch)
		{	
		if (npos - this->_Mysize <= _Count)
			_Xlen();	

		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
			{	
			_Chassign(this->_Mysize, _Count, _Ch);
			_Eos(_Num);
			}
		return (*this);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		append(_Iter _First, _Iter _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& append(const_pointer _First, const_pointer _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& append(const_iterator _First, const_iterator _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& assign(const _Myt& _Right)
		{	
		return (assign(_Right, 0, npos));
		}

	_Myt& assign(const _Myt& _Right,
		size_type _Roff, size_type _Count)
		{	
		if (_Right.size() < _Roff)
			_Xran();	
		size_type _Num = _Right.size() - _Roff;
		if (_Count < _Num)
			_Num = _Count;	

		if (this == &_Right)
			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	
		else if (_Grow(_Num))
			{	
			_Traits::copy(this->_Myptr(),
				_Right._Myptr() + _Roff, _Num);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr, size_type _Count)
		{	
 
		if (_Count != 0)
			_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 1151);
 #line 1153 "d:\\programs overflow\\vc\\include\\xstring"

		if (_Inside(_Ptr))
			return (assign(*this,
				_Ptr - this->_Myptr(), _Count));	

		if (_Grow(_Count))
			{	
			_Traits::copy(this->_Myptr(), _Ptr, _Count);
			_Eos(_Count);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 1168);
		return (assign(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& assign(size_type _Count, _Elem _Ch)
		{	
		if (_Count == npos)
			_Xlen();	

		if (_Grow(_Count))
			{	
			_Chassign(0, _Count, _Ch);
			_Eos(_Count);
			}
		return (*this);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		assign(_Iter _First, _Iter _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& assign(const_pointer _First, const_pointer _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& assign(const_iterator _First, const_iterator _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& insert(size_type _Off, const _Myt& _Right)
		{	
		return (insert(_Off, _Right, 0, npos));
		}

	_Myt& insert(size_type _Off,
		const _Myt& _Right, size_type _Roff, size_type _Count)
		{	
		if (this->_Mysize < _Off || _Right.size() < _Roff)
			_Xran();	
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	
		if (npos - this->_Mysize <= _Count)
			_Xlen();	

		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize - _Off);	
			if (this == &_Right)
				_Traits::move(this->_Myptr() + _Off,
					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
						_Count);	
			else
				_Traits::copy(this->_Myptr() + _Off,
					_Right._Myptr() + _Roff, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off,
		const _Elem *_Ptr, size_type _Count)
		{	
 
		if (_Count != 0)
			_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 1241);
 #line 1243 "d:\\programs overflow\\vc\\include\\xstring"

		if (_Inside(_Ptr))
			return (insert(_Off, *this,
				_Ptr - this->_Myptr(), _Count));	
		if (this->_Mysize < _Off)
			_Xran();	
		if (npos - this->_Mysize <= _Count)
			_Xlen();	
		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize - _Off);	
			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off, const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 1265);
		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& insert(size_type _Off,
		size_type _Count, _Elem _Ch)
		{	
		if (this->_Mysize < _Off)
			_Xran();	
		if (npos - this->_Mysize <= _Count)
			_Xlen();	
		size_type _Num;
		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize - _Off);	
			_Chassign(_Off, _Count, _Ch);	
			_Eos(_Num);
			}
		return (*this);
		}

	iterator insert(const_iterator _Where)
		{	
		return (insert(_Where, _Elem()));
		}

	iterator insert(const_iterator _Where, _Elem _Ch)
		{	
		size_type _Off = _Pdif(_Where, begin());
		insert(_Off, 1, _Ch);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
		{	
		size_type _Off = _Pdif(_Where, begin());
		insert(_Off, _Count, _Ch);
		return (begin() + _Off);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = _Pdif(_Where, begin());
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where,
		const_pointer _First, const_pointer _Last)
		{	
		size_type _Off = _Pdif(_Where, begin());
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where,
		const_iterator _First, const_iterator _Last)
		{	
		size_type _Off = _Pdif(_Where, begin());
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	_Myt& erase(size_type _Off = 0)
		{	
		if (this->_Mysize < _Off)
			_Xran();	
		_Eos(_Off);
		return (*this);
		}

	_Myt& erase(size_type _Off, size_type _Count)
		{	
		if (this->_Mysize < _Off)
			_Xran();	
		if (this->_Mysize - _Off <= _Count)
			_Eos(_Off);	
		else if (0 < _Count)
			{	
			value_type *_Ptr = this->_Myptr() + _Off;
			size_type _Newsize = this->_Mysize - _Count;
			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
			_Eos(_Newsize);
			}
		return (*this);
		}

	iterator erase(const_iterator _Where)
		{	
		size_type _Count = _Pdif(_Where, begin());
		erase(_Count, 1);
		return (iterator(this->_Myptr() + _Count, this));
		}

	iterator erase(const_iterator _First, const_iterator _Last)
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xstring", 1366);
		size_type _Count = _Pdif(_First, begin());
		erase(_Count, _Pdif(_Last, _First));
		return (iterator(this->_Myptr() + _Count, this));
		}

	void clear() throw ()
		{	
		_Eos(0);
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
		{	
		return (replace(_Off, _N0, _Right, 0, npos));
		}

	_Myt& replace(size_type _Off,
		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
		{	
		if (this->_Mysize < _Off || _Right.size() < _Roff)
			_Xran();	
		if (this->_Mysize - _Off < _N0)
			_N0 = this->_Mysize - _Off;	
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	
		if (npos - _Count <= this->_Mysize - _N0)
			_Xlen();	

		size_type _Nm = this->_Mysize - _N0 - _Off;	
		size_type _Newsize = this->_Mysize + _Count - _N0;
		if (this->_Mysize < _Newsize)
			_Grow(_Newsize);

		if (this != &_Right)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::copy(this->_Myptr() + _Off,
				_Right._Myptr() + _Roff, _Count);	
			}
		else if (_Count <= _N0)
			{	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _Count);	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			}
		else if (_Roff <= _Off)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _Count);	
			}
		else if (_Off + _N0 <= _Roff)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + (_Roff + _Count - _N0),
				_Count);	
			}
		else
			{	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _N0);	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off + _N0,
				this->_Myptr() + _Roff + _Count,
				_Count - _N0);	
			}

		_Eos(_Newsize);
		return (*this);
		}

	_Myt& replace(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count)
		{	
 
		if (_Count != 0)
			_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 1449);
 #line 1451 "d:\\programs overflow\\vc\\include\\xstring"

		if (_Inside(_Ptr))
			return (replace(_Off, _N0, *this,
				_Ptr - this->_Myptr(),
				_Count));	
		if (this->_Mysize < _Off)
			_Xran();	
		if (this->_Mysize - _Off < _N0)
			_N0 = this->_Mysize - _Off;	
		if (npos - _Count <= this->_Mysize - _N0)
			_Xlen();	
		size_type _Nm = this->_Mysize - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0,
				_Nm);	
		size_type _Num;
		if ((0 < _Count || 0 < _N0)
			&& _Grow(_Num = this->_Mysize + _Count - _N0))
			{	
			if (_N0 < _Count)
				_Traits::move(this->_Myptr() + _Off + _Count,
					this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 1483);
		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& replace(size_type _Off,
		size_type _N0, size_type _Count, _Elem _Ch)
		{	
		if (this->_Mysize < _Off)
			_Xran();	
		if (this->_Mysize - _Off < _N0)
			_N0 = this->_Mysize - _Off;	
		if (npos - _Count <= this->_Mysize - _N0)
			_Xlen();	
		size_type _Nm = this->_Mysize - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0,
				_Nm);	
		size_type _Num;
		if ((0 < _Count || 0 < _N0)
			&& _Grow(_Num = this->_Mysize + _Count - _N0))
			{	
			if (_N0 < _Count)
				_Traits::move(this->_Myptr() + _Off + _Count,
					this->_Myptr() + _Off + _N0, _Nm);	
			_Chassign(_Off, _Count, _Ch);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Myt& _Right)
		{	
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Elem *_Ptr, size_type _Count)
		{	
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Elem *_Ptr)
		{	
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		size_type _Count, _Elem _Ch)
		{	
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		replace(const_iterator _First, const_iterator _Last,
			_Iter _First2, _Iter _Last2)
		{	
		_Myt _Right(_First2, _Last2);
		replace(_First, _Last, _Right);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const_pointer _First2, const_pointer _Last2)
		{	
		if (_First2 == _Last2)
			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
		else
			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		pointer _First2, pointer _Last2)
		{	
		if (_First2 == _Last2)
			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
		else
			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const_iterator _First2, const_iterator _Last2)
		{	
		if (_First2 == _Last2)
			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
		else
			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		iterator _First2, iterator _Last2)
		{	
		if (_First2 == _Last2)
			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
		else
			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	iterator begin() throw ()
		{	
		return (iterator(this->_Myptr(), this));
		}

	const_iterator begin() const throw ()
		{	
		return (const_iterator(this->_Myptr(), this));
		}

	iterator end() throw ()
		{	
		return (iterator(this->_Myptr() + this->_Mysize, this));
		}

	const_iterator end() const throw ()
		{	
		return (const_iterator(this->_Myptr() + this->_Mysize, this));
		}

	reverse_iterator rbegin() throw ()
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const throw ()
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() throw ()
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const throw ()
		{	
		return (const_reverse_iterator(begin()));
		}

	const_iterator cbegin() const throw ()
		{	
		return (((const _Myt *)this)->begin());
		}

	const_iterator cend() const throw ()
		{	
		return (((const _Myt *)this)->end());
		}

	const_reverse_iterator crbegin() const throw ()
		{	
		return (((const _Myt *)this)->rbegin());
		}

	const_reverse_iterator crend() const throw ()
		{	
		return (((const _Myt *)this)->rend());
		}

	void shrink_to_fit()
		{	
		if ((size() | this->_ALLOC_MASK) < capacity())
			{	
			_Myt _Tmp(*this);
			swap(_Tmp);
			}
		}

	reference at(size_type _Off)
		{	
		if (this->_Mysize <= _Off)
			_Xran();	
		return (this->_Myptr()[_Off]);
		}

	const_reference at(size_type _Off) const
		{	
		if (this->_Mysize <= _Off)
			_Xran();	
		return (this->_Myptr()[_Off]);
		}

	reference operator[](size_type _Off)
		{	
 
		if (this->_Mysize < _Off)	
			_Debug_message(L"string subscript out of range", L"d:\\programs overflow\\vc\\include\\xstring", 1685);

 

#line 1690 "d:\\programs overflow\\vc\\include\\xstring"

		return (this->_Myptr()[_Off]);
		}

	const_reference operator[](size_type _Off) const
		{	
 
		if (this->_Mysize < _Off)	
			_Debug_message(L"string subscript out of range", L"d:\\programs overflow\\vc\\include\\xstring", 1698);

 

#line 1703 "d:\\programs overflow\\vc\\include\\xstring"

		return (this->_Myptr()[_Off]);
		}

	void push_back(_Elem _Ch)
		{	
		insert(end(), _Ch);
		}

	void pop_back()
		{	
		erase(this->_Mysize - 1);	
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	const _Elem *c_str() const throw ()
		{	
		return (this->_Myptr());
		}

	const _Elem *data() const throw ()
		{	
		return (c_str());
		}

	size_type length() const throw ()
		{	
		return (this->_Mysize);
		}

	size_type size() const throw ()
		{	
		return (this->_Mysize);
		}

	size_type max_size() const throw ()
		{	
		size_type _Num = this->_Getal().max_size();
		return (_Num <= 1 ? 1 : _Num - 1);
		}

	void resize(size_type _Newsize)
		{	
		resize(_Newsize, _Elem());
		}

	void resize(size_type _Newsize, _Elem _Ch)
		{	
		if (_Newsize <= this->_Mysize)
			_Eos(_Newsize);
		else
			append(_Newsize - this->_Mysize, _Ch);
		}

	size_type capacity() const throw ()
		{	
		return (this->_Myres);
		}

	void reserve(size_type _Newcap = 0)
		{	
		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
			{	
			size_type _Size = this->_Mysize;
			if (_Grow(_Newcap, true))
				_Eos(_Size);
			}
		}

	bool empty() const throw ()
		{	
		return (this->_Mysize == 0);
		}

	__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))

	size_type copy(_Elem *_Ptr,
		size_type _Count, size_type _Off = 0) const
		{	
 
		if (_Count != 0)
			_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 1803);
 #line 1805 "d:\\programs overflow\\vc\\include\\xstring"

		if (this->_Mysize < _Off)
			_Xran();	
		if (this->_Mysize - _Off < _Count)
			_Count = this->_Mysize - _Off;
		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
		return (_Count);
		}

	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
		size_type _Count, size_type _Off = 0) const
		{	
 
		if (_Count != 0)
			_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xstring", 1819);
 #line 1821 "d:\\programs overflow\\vc\\include\\xstring"

		if (this->_Mysize < _Off)
			_Xran();	
		if (this->_Mysize - _Off < _Count)
			_Count = this->_Mysize - _Off;
		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
		return (_Count);
		}

	void _Swap_bx(_Myt& _Right)
		{	
		if (this->_BUF_SIZE <= this->_Myres)
			if (this->_BUF_SIZE <= _Right._Myres)
				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
			else
				{	
				pointer _Ptr = this->_Bx._Ptr;
				this->_Getal().destroy(&this->_Bx._Ptr);
				_Traits::copy(this->_Bx._Buf,
					_Right._Bx._Buf, _Right._Mysize + 1);
				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
				}
		else
			if (_Right._Myres < this->_BUF_SIZE)
				::std:: swap(this->_Bx._Buf, _Right._Bx._Buf);
			else
				{	
				pointer _Ptr = _Right._Bx._Ptr;
				this->_Getal().destroy(&_Right._Bx._Ptr);
				_Traits::copy(_Right._Bx._Buf,
					this->_Bx._Buf, this->_Mysize + 1);
				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
				}
		}

	void swap(_Myt& _Right)
		{	
		if (this == &_Right)
			;	
		else if (this->_Getal() == _Right._Getal())
			{	
			this->_Swap_all(_Right);
			_Swap_bx(_Right);
			::std:: swap(this->_Mysize, _Right._Mysize);
			::std:: swap(this->_Myres, _Right._Myres);
			}

		else if (_Alty::propagate_on_container_swap::value)
			{	
			this->_Swap_alloc(_Right);
			_Swap_bx(_Right);
			::std:: swap(this->_Bx, _Right._Bx);	
			::std:: swap(this->_Mysize, _Right._Mysize);
			::std:: swap(this->_Myres, _Right._Myres);
			}

		else
			{	
			_Myt _Tmp = *this;

			*this = _Right;
			_Right = _Tmp;
			}
		}

	size_type find(const _Myt& _Right, size_type _Off = 0) const throw ()
		{	
		return (find(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
 
		if (_Count != 0)
			_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 1896);
 #line 1898 "d:\\programs overflow\\vc\\include\\xstring"

		if (_Count == 0 && _Off <= this->_Mysize)
			return (_Off);	

		size_type _Nm;
		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
			{	
			const _Elem *_Uptr, *_Vptr;
			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - this->_Myptr());	
			}

		return (npos);	
		}

	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
		{	
		_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 1918);
		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find(_Elem _Ch, size_type _Off = 0) const
		{	
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type rfind(const _Myt& _Right, size_type _Off = npos) const throw ()
		{	
		return (rfind(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type rfind(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
 
		if (_Count != 0)
			_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 1937);
 #line 1939 "d:\\programs overflow\\vc\\include\\xstring"

		if (_Count == 0)
			return (_Off < this->_Mysize ? _Off
				: this->_Mysize);	
		if (_Count <= this->_Mysize)
			{	
			const _Elem *_Uptr = this->_Myptr() +
				(_Off < this->_Mysize - _Count ? _Off
					: this->_Mysize - _Count);
			for (; ; --_Uptr)
				if (_Traits::eq(*_Uptr, *_Ptr)
					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - this->_Myptr());	
				else if (_Uptr == this->_Myptr())
					break;	
			}

		return (npos);	
		}

	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
		{	
		_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 1961);
		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type rfind(_Elem _Ch, size_type _Off = npos) const
		{	
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_of(const _Myt& _Right,
		size_type _Off = 0) const throw ()
		{	
		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_first_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
 
		if (_Count != 0)
			_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 1981);
 #line 1983 "d:\\programs overflow\\vc\\include\\xstring"

		if (0 < _Count && _Off < this->_Mysize)
			{	
			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
			for (const _Elem *_Uptr = this->_Myptr() + _Off;
				_Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - this->_Myptr());	
			}

		return (npos);	
		}

	size_type find_first_of(const _Elem *_Ptr,
		size_type _Off = 0) const
		{	
		_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 1999);
		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_of(_Elem _Ch,
		size_type _Off = 0) const
		{	
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_of(const _Myt& _Right,
		size_type _Off = npos) const throw ()
		{	
		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
 
		if (_Count != 0)
			_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 2020);
 #line 2022 "d:\\programs overflow\\vc\\include\\xstring"

		if (0 < _Count && 0 < this->_Mysize)
			{	
			const _Elem *_Uptr = this->_Myptr()
				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
			for (; ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - this->_Myptr());	
				else if (_Uptr == this->_Myptr())
					break;	
			}

		return (npos);	
		}

	size_type find_last_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	
		_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 2040);
		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_of(_Elem _Ch,
		size_type _Off = npos) const
		{	
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_not_of(const _Myt& _Right,
		size_type _Off = 0) const throw ()
		{	
		return (find_first_not_of(_Right._Myptr(), _Off,
			_Right.size()));
		}

	size_type find_first_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
 
		if (_Count != 0)
			_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 2062);
 #line 2064 "d:\\programs overflow\\vc\\include\\xstring"

		if (_Off < this->_Mysize)
			{	
			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
			for (const _Elem *_Uptr = this->_Myptr() + _Off;
				_Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - this->_Myptr());
			}
		return (npos);
		}

	size_type find_first_not_of(const _Elem *_Ptr,
		size_type _Off = 0) const
		{	
		_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 2079);
		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_not_of(_Elem _Ch,
		size_type _Off = 0) const
		{	
		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_not_of(const _Myt& _Right,
		size_type _Off = npos) const throw ()
		{	
		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
 
		if (_Count != 0)
			_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 2100);
 #line 2102 "d:\\programs overflow\\vc\\include\\xstring"

		if (0 < this->_Mysize)
			{	
			const _Elem *_Uptr = this->_Myptr()
				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
			for (; ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - this->_Myptr());
				else if (_Uptr == this->_Myptr())
					break;
			}
		return (npos);
		}

	size_type find_last_not_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	
		_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 2119);
		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_not_of(_Elem _Ch,
		size_type _Off = npos) const
		{	
		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
		{	
		return (_Myt(*this, _Off, _Count, get_allocator()));
		}

	int compare(const _Myt& _Right) const throw ()
		{	
		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
		}

	int compare(size_type _Off, size_type _N0,
		const _Myt& _Right) const
		{	
		return (compare(_Off, _N0, _Right, 0, npos));
		}

	int compare(size_type _Off,
		size_type _N0, const _Myt& _Right,
		size_type _Roff, size_type _Count) const
		{	
		if (_Right.size() < _Roff)
			_Xran();	
		if (_Right._Mysize - _Roff < _Count)
			_Count = _Right._Mysize - _Roff;	
		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
		}

	int compare(const _Elem *_Ptr) const
		{	
		_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 2158);
		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
		{	
		_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 2164);
		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count) const
		{	
 
		if (_Count != 0)
			_Debug_pointer(_Ptr, L"d:\\programs overflow\\vc\\include\\xstring", 2173);
 #line 2175 "d:\\programs overflow\\vc\\include\\xstring"

		if (this->_Mysize < _Off)
			_Xran();	
		if (this->_Mysize - _Off < _N0)
			_N0 = this->_Mysize - _Off;	

		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
			_N0 < _Count ? _N0 : _Count);
		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
			: _N0 == _Count ? 0 : +1);
		}

	allocator_type get_allocator() const throw ()
		{	
		return (this->_Getal());
		}

	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
		{	
		if (_Count == 1)
			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
		else
			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
		}

	void _Copy(size_type _Newsize, size_type _Oldlen)
		{	
		size_type _Newres = _Newsize | this->_ALLOC_MASK;
		if (max_size() < _Newres)
			_Newres = _Newsize;	
		else if (this->_Myres / 2 <= _Newres / 3)
			;
		else if (this->_Myres <= max_size() - this->_Myres / 2)
			_Newres = this->_Myres
				+ this->_Myres / 2;	
		else
			_Newres = max_size();	

		_Elem *_Ptr;
		try {
			_Ptr = this->_Getal().allocate(_Newres + 1);
		} catch (...) {
			_Newres = _Newsize;	
			try {
				_Ptr = this->_Getal().allocate(_Newres + 1);
			} catch (...) {
			_Tidy(true);	
			throw;
			}
		}

		if (0 < _Oldlen)
			_Traits::copy(_Ptr, this->_Myptr(),
				_Oldlen);	
		_Tidy(true);
		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
		this->_Myres = _Newres;
		_Eos(_Oldlen);
		}

	void _Eos(size_type _Newsize)
		{	
		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
		}

	bool _Grow(size_type _Newsize,
		bool _Trim = false)
		{	
		if (max_size() < _Newsize)
			_Xlen();	
		if (this->_Myres < _Newsize)
			_Copy(_Newsize, this->_Mysize);	
		else if (_Trim && _Newsize < this->_BUF_SIZE)
			_Tidy(true,	
				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
		else if (_Newsize == 0)
			_Eos(0);	
		return (0 < _Newsize);	
		}

	bool _Inside(const _Elem *_Ptr)
		{	
		if (_Ptr == 0 || _Ptr < this->_Myptr()
			|| this->_Myptr() + this->_Mysize <= _Ptr)
			return (false);	
		else
			return (true);
		}

	static size_type _Pdif(const_iterator _P2,
		const_iterator _P1)
		{	
		return ((_P2)._Ptr == 0 ? 0 : _P2 - _P1);
		}

	void _Tidy(bool _Built = false,
		size_type _Newsize = 0)
		{	
		if (!_Built)
			;
		else if (this->_BUF_SIZE <= this->_Myres)
			{	
			pointer _Ptr = this->_Bx._Ptr;
			this->_Getal().destroy(&this->_Bx._Ptr);
			if (0 < _Newsize)
				_Traits::copy(this->_Bx._Buf,
					::std:: addressof(*_Ptr), _Newsize);
			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
			}
		this->_Myres = this->_BUF_SIZE - 1;
		_Eos(_Newsize);
		}

	__declspec(noreturn) void _Xlen() const
		{	
		_Xlength_error("string too long");
		}

	__declspec(noreturn) void _Xran() const
		{	
		_Xout_of_range("invalid string position");
		}
	};

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	 const typename basic_string<_Elem, _Traits, _Alloc>::size_type
		basic_string<_Elem, _Traits, _Alloc>::npos =
			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);

		

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Traits::length(_Left) + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(1 + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + _Traits::length(_Right));
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + 1);
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (::std:: move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	if (_Right.size() <= _Left.capacity() - _Left.size()
		|| _Right.capacity() - _Right.size() < _Left.size())
		return (::std:: move(_Left.append(_Right)));
	else
		return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem *_Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	return (::std:: move(_Right.insert(0, 1, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const _Elem *_Right)
	{	
	return (::std:: move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const _Elem _Right)
	{	
	return (::std:: move(_Left.append(1, _Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right.compare(_Left) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right.compare(_Left) > 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Left < _Right));
	}

typedef basic_string<char, char_traits<char>, allocator<char> >
	string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
	wstring;

	
template<class _Elem,
	class _Traits,
	class _Alloc>
	struct hash<basic_string<_Elem, _Traits, _Alloc> >
		: public unary_function<basic_string<_Elem, _Traits, _Alloc>, size_t>
	{	
	typedef basic_string<_Elem, _Traits, _Alloc> _Kty;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Hash_seq((const unsigned char *)_Keyval.c_str(),
			_Keyval.size() * sizeof (_Elem)));
		}
	};

typedef basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >
	u16string;
typedef basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >
	u32string;
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 2673 "d:\\programs overflow\\vc\\include\\xstring"
#line 2674 "d:\\programs overflow\\vc\\include\\xstring"






#line 8 "d:\\programs overflow\\vc\\include\\stdexcept"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {










		
class logic_error
	: public ::std:: exception
	{	
public:
	typedef ::std:: exception _Mybase;

	explicit logic_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit logic_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 50 "d:\\programs overflow\\vc\\include\\stdexcept"
	};

		
class domain_error
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit domain_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit domain_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 78 "d:\\programs overflow\\vc\\include\\stdexcept"
	};

		
class invalid_argument
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit invalid_argument(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit invalid_argument(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 106 "d:\\programs overflow\\vc\\include\\stdexcept"
	};

		
class length_error
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit length_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit length_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 134 "d:\\programs overflow\\vc\\include\\stdexcept"
	};

		
class out_of_range
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit out_of_range(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit out_of_range(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 162 "d:\\programs overflow\\vc\\include\\stdexcept"
	};

		
class runtime_error
	: public ::std:: exception
	{	
public:
	typedef ::std:: exception _Mybase;

	explicit runtime_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit runtime_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 190 "d:\\programs overflow\\vc\\include\\stdexcept"
	};

		
class overflow_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit overflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit overflow_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 218 "d:\\programs overflow\\vc\\include\\stdexcept"
	};

		
class underflow_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit underflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit underflow_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 246 "d:\\programs overflow\\vc\\include\\stdexcept"
	};

		
class range_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit range_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit range_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 274 "d:\\programs overflow\\vc\\include\\stdexcept"
	};
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 280 "d:\\programs overflow\\vc\\include\\stdexcept"
#line 281 "d:\\programs overflow\\vc\\include\\stdexcept"





#line 9 "d:\\programs overflow\\vc\\include\\xlocale"
#line 1 "d:\\programs overflow\\vc\\include\\typeinfo"














#pragma once







#pragma pack(push,8)
#pragma warning(push,3)


#pragma warning(disable: 4275)

 



 

#line 36 "d:\\programs overflow\\vc\\include\\typeinfo"

struct __type_info_node {
    void *_MemPtr;
    __type_info_node* _Next;
};

extern __type_info_node __type_info_root_node;

class type_info {
public:
	size_t hash_code() const throw ()
		{	
		return (::std:: _Hash_seq((const unsigned char *) name(),
			:: strlen(name())));
		}



#line 55 "d:\\programs overflow\\vc\\include\\typeinfo"
    


    virtual ~type_info() throw ();



#line 63 "d:\\programs overflow\\vc\\include\\typeinfo"
    __declspec(dllimport) bool  operator==(const type_info& _Rhs) const;
    __declspec(dllimport) bool  operator!=(const type_info& _Rhs) const;
#line 66 "d:\\programs overflow\\vc\\include\\typeinfo"
    __declspec(dllimport) bool  before(const type_info& _Rhs) const;
    __declspec(dllimport) const char*  name(__type_info_node* __ptype_info_node = &__type_info_root_node) const;
    __declspec(dllimport) const char*  raw_name() const;
private:
    void *_M_data;
    char _M_d_name[1];



#line 76 "d:\\programs overflow\\vc\\include\\typeinfo"
public:
     type_info(const type_info&) = delete;
    type_info&  operator=(const type_info&) = delete;
private:
#line 81 "d:\\programs overflow\\vc\\include\\typeinfo"
    __declspec(dllimport) static const char *__cdecl _Name_base(const type_info *,__type_info_node* __ptype_info_node);
    __declspec(dllimport) static void __cdecl _Type_info_dtor(type_info *);











#line 95 "d:\\programs overflow\\vc\\include\\typeinfo"
};

 

 namespace std {

using ::type_info;

 }






 namespace std {

class __declspec(dllimport) bad_cast : public exception {
public:


















     bad_cast(const char * _Message = "bad cast");
     bad_cast(const bad_cast &);
    virtual  ~bad_cast() throw ();





#line 141 "d:\\programs overflow\\vc\\include\\typeinfo"
#line 142 "d:\\programs overflow\\vc\\include\\typeinfo"
};

class __declspec(dllimport) bad_typeid : public exception {
public:










     bad_typeid(const char * _Message = "bad typeid");
     bad_typeid(const bad_typeid &);
    virtual  ~bad_typeid() throw ();
#line 160 "d:\\programs overflow\\vc\\include\\typeinfo"

};

class __declspec(dllimport) __non_rtti_object : public bad_typeid {
public:










     __non_rtti_object(const char * _Message);
     __non_rtti_object(const __non_rtti_object &);
    virtual  ~__non_rtti_object() throw ();
#line 179 "d:\\programs overflow\\vc\\include\\typeinfo"
};

 }
#line 183 "d:\\programs overflow\\vc\\include\\typeinfo"

 























































#line 241 "d:\\programs overflow\\vc\\include\\typeinfo"

#line 243 "d:\\programs overflow\\vc\\include\\typeinfo"


#pragma pack(pop)
#pragma warning(pop)

#line 249 "d:\\programs overflow\\vc\\include\\typeinfo"







#line 10 "d:\\programs overflow\\vc\\include\\xlocale"
#line 1 "d:\\programs overflow\\vc\\include\\xlocinfo"

#pragma once



#line 1 "d:\\programs overflow\\vc\\include\\xlocinfo.h"

#pragma once



#line 1 "d:\\programs overflow\\vc\\include\\ctype.h"













#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 20 "d:\\programs overflow\\vc\\include\\ctype.h"


extern "C" {
#line 24 "d:\\programs overflow\\vc\\include\\ctype.h"

















































































                                













  __declspec(dllimport) int __cdecl _isctype(  int _C,   int _Type);
  __declspec(dllimport) int __cdecl _isctype_l(  int _C,   int _Type,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalpha(  int _C);
  __declspec(dllimport) int __cdecl _isalpha_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isupper(  int _C);
  __declspec(dllimport) int __cdecl _isupper_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl islower(  int _C);
  __declspec(dllimport) int __cdecl _islower_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isdigit(  int _C);
  __declspec(dllimport) int __cdecl _isdigit_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isxdigit(  int _C);
  __declspec(dllimport) int __cdecl _isxdigit_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isspace(  int _C);
  __declspec(dllimport) int __cdecl _isspace_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl ispunct(  int _C);
  __declspec(dllimport) int __cdecl _ispunct_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isblank(  int _C);
  __declspec(dllimport) int __cdecl _isblank_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalnum(  int _C);
  __declspec(dllimport) int __cdecl _isalnum_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isprint(  int _C);
  __declspec(dllimport) int __cdecl _isprint_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isgraph(  int _C);
  __declspec(dllimport) int __cdecl _isgraph_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iscntrl(  int _C);
  __declspec(dllimport) int __cdecl _iscntrl_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl toupper(  int _C);
   __declspec(dllimport) int __cdecl tolower(  int _C);
   __declspec(dllimport) int __cdecl _tolower(  int _C);
  __declspec(dllimport) int __cdecl _tolower_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl _toupper(  int _C);
  __declspec(dllimport) int __cdecl _toupper_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl __isascii(  int _C);
  __declspec(dllimport) int __cdecl __toascii(  int _C);
  __declspec(dllimport) int __cdecl __iscsymf(  int _C);
  __declspec(dllimport) int __cdecl __iscsym(  int _C);

#line 157 "d:\\programs overflow\\vc\\include\\ctype.h"


























































































__declspec(dllimport) int __cdecl _chvalidator(  int _Ch,   int _Mask);



#line 252 "d:\\programs overflow\\vc\\include\\ctype.h"




























#line 281 "d:\\programs overflow\\vc\\include\\ctype.h"


__declspec(dllimport) int __cdecl _chvalidator_l(  _locale_t,   int _Ch,   int _Mask);



#line 288 "d:\\programs overflow\\vc\\include\\ctype.h"













































































#line 366 "d:\\programs overflow\\vc\\include\\ctype.h"
















#line 383 "d:\\programs overflow\\vc\\include\\ctype.h"

#line 385 "d:\\programs overflow\\vc\\include\\ctype.h"


}
#line 389 "d:\\programs overflow\\vc\\include\\ctype.h"

#line 391 "d:\\programs overflow\\vc\\include\\ctype.h"
#line 7 "d:\\programs overflow\\vc\\include\\xlocinfo.h"
#line 1 "d:\\programs overflow\\vc\\include\\locale.h"













#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 20 "d:\\programs overflow\\vc\\include\\locale.h"





#pragma pack(push,8)


extern "C" {
#line 30 "d:\\programs overflow\\vc\\include\\locale.h"

























struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        wchar_t *_W_decimal_point;
        wchar_t *_W_thousands_sep;
        wchar_t *_W_int_curr_symbol;
        wchar_t *_W_currency_symbol;
        wchar_t *_W_mon_decimal_point;
        wchar_t *_W_mon_thousands_sep;
        wchar_t *_W_positive_sign;
        wchar_t *_W_negative_sign;
        };

#line 85 "d:\\programs overflow\\vc\\include\\locale.h"




















#line 106 "d:\\programs overflow\\vc\\include\\locale.h"

 __declspec(dllimport) int __cdecl _configthreadlocale(  int _Flag);
 __declspec(dllimport) char * __cdecl setlocale(  int _Category,   const char * _Locale);
 __declspec(dllimport) struct lconv * __cdecl localeconv(void);
 __declspec(dllimport) _locale_t __cdecl _get_current_locale(void);
 __declspec(dllimport) _locale_t __cdecl _create_locale(  int _Category,   const char * _Locale);
__declspec(dllimport) void __cdecl _free_locale(  _locale_t _Locale);



  __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "_get_current_locale" " instead. See online help for details.")) __declspec(dllimport) _locale_t __cdecl __get_current_locale(void);
  __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "_create_locale" " instead. See online help for details.")) __declspec(dllimport) _locale_t __cdecl __create_locale(  int _Category,   const char * _Locale);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "_free_locale" " instead. See online help for details.")) __declspec(dllimport) void __cdecl __free_locale(  _locale_t _Locale);
#line 120 "d:\\programs overflow\\vc\\include\\locale.h"












}
#line 134 "d:\\programs overflow\\vc\\include\\locale.h"

#pragma pack(pop)

#line 138 "d:\\programs overflow\\vc\\include\\locale.h"
#line 8 "d:\\programs overflow\\vc\\include\\xlocinfo.h"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 


 
  
extern "C" {
  #line 21 "d:\\programs overflow\\vc\\include\\xlocinfo.h"
 #line 22 "d:\\programs overflow\\vc\\include\\xlocinfo.h"

		












		










 
 
 
 
 
 
 
 

typedef struct _Collvec
	{	
	unsigned int _Page;		
	wchar_t *_LocaleName;
	} _Collvec;

typedef struct _Ctypevec
	{	
	unsigned int _Page;		
	const short *_Table;
	int _Delfl;
	wchar_t *_LocaleName;
	} _Ctypevec;

typedef struct _Cvtvec
	{	
	unsigned int _Page;		
	unsigned int _Mbcurmax;
	int _Isclocale;	
	unsigned char _Isleadbyte[32];	
	} _Cvtvec;

		
__declspec(dllimport) _Collvec __cdecl _Getcoll();
__declspec(dllimport) _Ctypevec __cdecl _Getctype();
__declspec(dllimport) _Cvtvec __cdecl _Getcvt();
__declspec(dllimport) int __cdecl _Getdateorder();

 








__declspec(dllimport) int __cdecl _Mbrtowc(  wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
 #line 96 "d:\\programs overflow\\vc\\include\\xlocinfo.h"

__declspec(dllimport) float __cdecl _Stof(const char *,
	    char **, long);
__declspec(dllimport) double __cdecl _Stod(const char *,
	    char **, long);
__declspec(dllimport) long double __cdecl _Stold(const char *,
	    char **, long);

__declspec(dllimport) int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Strxfrm(
	    char *_String1,
	  char *_End1, const char *, const char *, const _Collvec *);
__declspec(dllimport) int __cdecl _Tolower(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Toupper(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Wcrtomb(  char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
__declspec(dllimport) int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Wcsxfrm(
	    wchar_t *_String1,
	  wchar_t *_End1, const wchar_t *, const wchar_t *, const _Collvec *);

__declspec(dllimport) short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
__declspec(dllimport) const wchar_t *__cdecl _Getwctypes(const wchar_t *,
	const wchar_t *, short *, const _Ctypevec *);
__declspec(dllimport) wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
__declspec(dllimport) wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);

 
  
}
  #line 129 "d:\\programs overflow\\vc\\include\\xlocinfo.h"
 #line 130 "d:\\programs overflow\\vc\\include\\xlocinfo.h"


extern "C" {
__declspec(dllimport) char *__cdecl _Getdays();
__declspec(dllimport) char *__cdecl _Getmonths();
__declspec(dllimport) void *__cdecl _Gettnames();
__declspec(dllimport) size_t __cdecl _Strftime(  char *,
	  size_t _Maxsize,     const char *,
	  const struct tm *, void *);

__declspec(dllimport) wchar_t *__cdecl _W_Getdays();
__declspec(dllimport) wchar_t *__cdecl _W_Getmonths();
__declspec(dllimport) void *__cdecl _W_Gettnames();
__declspec(dllimport) size_t __cdecl _Wcsftime(  wchar_t *,
	  size_t _Maxsize,     const wchar_t *,
	  const struct tm *, void *);
}

 







__declspec(dllimport) _locale_t __cdecl _GetLocaleForCP(unsigned int);
 #line 158 "d:\\programs overflow\\vc\\include\\xlocinfo.h"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 163 "d:\\programs overflow\\vc\\include\\xlocinfo.h"
#line 164 "d:\\programs overflow\\vc\\include\\xlocinfo.h"





#line 7 "d:\\programs overflow\\vc\\include\\xlocinfo"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412)

namespace std {
		
class __declspec(dllimport) _Timevec
	{	
public:
	 _Timevec(void *_Ptr = 0)
		: _Timeptr(_Ptr)
		{	
		}

	 _Timevec(const _Timevec& _Right)
		{	
		*this = _Right;
		}

	 ~_Timevec() throw ()
		{	
		free(_Timeptr);
		}

	_Timevec&  operator=(const _Timevec& _Right)
		{	
		_Timeptr = _Right._Timeptr;
		((_Timevec *)&_Right)->_Timeptr = 0;
		return (*this);
		}

	void * _Getptr() const
		{	
		return (_Timeptr);
		}

private:
	void *_Timeptr;	
	};

		
class __declspec(dllimport) _Locinfo
	{	
public:
	typedef ::_Collvec _Collvec;
	typedef ::_Ctypevec _Ctypevec;
	typedef ::_Cvtvec _Cvtvec;
	typedef ::std:: _Timevec _Timevec;

	static  void __cdecl _Locinfo_ctor(
		_Locinfo *, const char *);
	static  void __cdecl _Locinfo_ctor(
		_Locinfo *, int, const char *);
	static  void __cdecl _Locinfo_dtor(
		_Locinfo *);
	static  _Locinfo& __cdecl _Locinfo_Addcats(
		_Locinfo *, int, const char *);

	 _Locinfo(const char *_Pch = "C")
 
		: _Lock(0)
 #line 75 "d:\\programs overflow\\vc\\include\\xlocinfo"

		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		_Locinfo_ctor(this, _Pch);
		}

	 _Locinfo(int _Cat, const char *_Pch)
 
		: _Lock(0)
 #line 86 "d:\\programs overflow\\vc\\include\\xlocinfo"

		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		_Locinfo_ctor(this, _Cat, _Pch);
		}

	 ~_Locinfo() throw ()
		{	
		_Locinfo_dtor(this);
		}

	_Locinfo&  _Addcats(int _Cat, const char *_Pch)
		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		return (_Locinfo_Addcats(this, _Cat, _Pch));
		}

	const char * _Getname() const
		{	
		return (_Newlocname._C_str());
		}

	_Collvec  _Getcoll() const
		{	
		return (::_Getcoll());
		}

	_Ctypevec  _Getctype() const
		{	
		return (::_Getctype());
		}

	_Cvtvec  _Getcvt() const
		{	
		return (::_Getcvt());
		}

	const lconv * _Getlconv() const
		{	
		return (localeconv());
		}

	_Timevec  _Gettnames() const
		{	
		return (_Timevec(::_Gettnames()));
		}

	const char * _Getdays() const
		{	
		const char *_Ptr = ::_Getdays();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_Days = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Days._Empty() ? _Days._C_str()
			: ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				":Thu:Thursday:Fri:Friday:Sat:Saturday");
		}

	const char * _Getmonths() const
		{	
		const char *_Ptr = ::_Getmonths();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_Months = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Months._Empty() ? _Months._C_str()
			: ":Jan:January:Feb:February:Mar:March"
				":Apr:April:May:May:Jun:June"
				":Jul:July:Aug:August:Sep:September"
				":Oct:October:Nov:November:Dec:December");
		}

	const char * _Getfalse() const
		{	
		return ("false");
		}

	const char * _Gettrue() const
		{	
		return ("true");
		}

	int  _Getdateorder() const
		{	
		return (::_Getdateorder());
		}

	_Timevec  _W_Gettnames() const
		{	
		return (_Timevec(::_W_Gettnames()));
		}

	const unsigned short * _W_Getdays() const
		{	
		const wchar_t *_Ptr = ::_W_Getdays();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_W_Days = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Days._Empty()
			? _W_Days._C_str()
			: L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				L":Thu:Thursday:Fri:Friday:Sat:Saturday"));
		}

	const unsigned short * _W_Getmonths() const
		{	
		const wchar_t *_Ptr = ::_W_Getmonths();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_W_Months = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Months._Empty()
			? _W_Months._C_str()
			: L":Jan:January:Feb:February:Mar:March"
				L":Apr:April:May:May:Jun:June"
				L":Jul:July:Aug:August:Sep:September"
				L":Oct:October:Nov:November:Dec:December"));
		}

	_Locinfo(const _Locinfo&) = delete;
	_Locinfo& operator=(const _Locinfo&) = delete;

private:
 



	_Lockit _Lock;	
 #line 227 "d:\\programs overflow\\vc\\include\\xlocinfo"

	_Yarn<char> _Days;	
	_Yarn<char> _Months;	
	_Yarn<wchar_t> _W_Days;	
	_Yarn<wchar_t> _W_Months;	
	_Yarn<char> _Oldlocname;	
	_Yarn<char> _Newlocname;	
	};

		
template<class _Elem> inline
	int __cdecl _LStrcoll(const _Elem *_First1, const _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (*_First1 < *_First2)
			return (-1);	
		else if (*_First2 < *_First1)
			return (+1);	
	return (_First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0);
	}

template<> inline
	int __cdecl _LStrcoll(const char *_First1, const char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	int __cdecl _LStrcoll(const wchar_t *_First1, const wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

		
template<class _Elem> inline
	size_t __cdecl _LStrxfrm(_Elem *_First1, _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	
	size_t _Count = _Last2 - _First2;
	if (_Count <= (size_t)(_Last1 - _First1))
		::memcpy_s((_First1), ((_Last1 - _First1) * sizeof (_Elem)), (_First2), (_Count * sizeof (_Elem)));
#line 276 "d:\\programs overflow\\vc\\include\\xlocinfo"
	return (_Count);
	}

template<> inline
	size_t __cdecl _LStrxfrm( 
		  char *_First1,   char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	size_t __cdecl _LStrxfrm( 
		  wchar_t *_First1,   wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 301 "d:\\programs overflow\\vc\\include\\xlocinfo"
#line 302 "d:\\programs overflow\\vc\\include\\xlocinfo"





#line 11 "d:\\programs overflow\\vc\\include\\xlocale"
#line 1 "d:\\programs overflow\\vc\\include\\xdebug"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)

 
  
 
  

namespace std {
struct _DebugHeapTag_t
	{	
	int _Type;
	};
}

		

 
   
   
   

  
  #line 1 "d:\\programs overflow\\vc\\include\\xmemory"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4700)

namespace std {
		
template<class _Ty> inline
	pair<_Ty *, ptrdiff_t>

		get_temporary_buffer(ptrdiff_t _Count) throw ()

	{	
	_Ty *_Pbuf;

	if (_Count < 0)
		_Count = 0;
	else if (((size_t)(-1) / sizeof (_Ty) < _Count))
		_Xbad_alloc();	
	for (_Pbuf = 0; 0 < _Count; _Count /= 2)
		if ((_Pbuf = (_Ty *)operator new(
			(size_t)_Count * sizeof (_Ty), nothrow)) != 0)
			break;

	return (pair<_Ty *, ptrdiff_t>(_Pbuf, _Count));
	}

		
template<class _Ty> inline
	void return_temporary_buffer(_Ty *_Pbuf)
	{	
	operator delete(_Pbuf);
	}

		
template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, input_iterator_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	_Construct(&*_Dest, *_First);	
	while (0 < --_Count)
		_Construct(&*++_Dest, *++_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Destroy(&*_Next);
	throw;
	}
	return (++_Dest);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, forward_iterator_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	for (; 0 < _Count; --_Count, ++_Dest, ++_First)
		_Construct(&*_Dest, *_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Destroy(&*_Next);
	throw;
	}
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	return (_Uninitialized_copy_n(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	
	return (_Uninitialized_copy_n(_First, _Count,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 














#line 131 "d:\\programs overflow\\vc\\include\\xmemory"
template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n2(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _Mutable_iterator_tag)
	{	
	return (_Uninitialized_copy_n(_First, _Count,
		_Dest));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n2(_InIt _First, _Diff _Count,
		_FwdIt _Dest, random_access_iterator_tag)
	{	
	_FwdIt _Ans = _Dest + _Count;	
	_Uninitialized_copy_n(_First, _Count,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n1(_InIt _First, _Diff _Count,
		_FwdIt _Dest, input_iterator_tag)
	{	
	return (_Uninitialized_copy_n2(_First, _Count,
		_Dest, _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n1(_InIt _First, _Diff _Count,
		_FwdIt _Dest, random_access_iterator_tag)
	{	
	_InIt _Last = _First + _Count;	
	_Last = _Last;	
	return (_Uninitialized_copy_n2(_Unchecked(_First), _Count,
		_Dest, _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, true_type)
	{	
	return (_Uninitialized_copy_n1(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest, false_type)
	{	
	return (_Uninitialized_copy_n1(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	
	_Debug_pointer(_First, L"d:\\programs overflow\\vc\\include\\xmemory", 202);
	_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xmemory", 203);
	if (_Count <= 0)
		return (_Dest);
	else
		return (_Uninitialized_copy_n(_First,
			_Count, _Dest, _Is_checked(_Dest)));
	}

 
template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_FwdIt _Dest)
	{	
	return (::std:: uninitialized_copy_n(_Array_iterator<_InTy, _InSize>(_First),
		_Count, _Dest));
	}

template<class _InIt,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *uninitialized_copy_n(_InIt _First, _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: uninitialized_copy_n(_First,
			_Count, _Array_iterator<_OutTy, _OutSize>(_Dest))));
	}

template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *uninitialized_copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: uninitialized_copy_n(_Array_iterator<_InTy, _InSize>(_First),
			_Count, _Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 248 "d:\\programs overflow\\vc\\include\\xmemory"
 #line 249 "d:\\programs overflow\\vc\\include\\xmemory"

		
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, ++_First)
		_Construct(&*_Dest, *_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Destroy(&*_Next);
	throw;
	}
	return (_Dest);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _Scalar_ptr_iterator_tag)
	{	
	ptrdiff_t _Count = _Last - _First;
	:: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	
	return (_Uninitialized_copy0(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 










#line 301 "d:\\programs overflow\\vc\\include\\xmemory"
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, input_iterator_tag, forward_iterator_tag)
	{	
	return (_Uninitialized_copy0(_First, _Last,
		_Dest));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	_FwdIt _Ans = _Dest + (_Last - _First);	
	_Uninitialized_copy0(_First, _Last,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, true_type)
	{	
	return (_Uninitialized_copy0(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _FwdIt> inline
__declspec(deprecated("Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'"))
	_FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
		_FwdIt _Dest, false_type)
	{	
	return (_Uninitialized_copy0(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt uninitialized_copy(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	
	_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xmemory", 345);
	_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xmemory", 346);
	return (_Uninitialized_copy0(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *uninitialized_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: uninitialized_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 363 "d:\\programs overflow\\vc\\include\\xmemory"
 #line 364 "d:\\programs overflow\\vc\\include\\xmemory"

		
template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _Nonscalar_ptr_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xmemory", 372);
	_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xmemory", 373);
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, ++_First)
		_Al.construct(_Dest, *_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	return (_Dest);
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _Scalar_ptr_iterator_tag)
	{	
	return (_Uninit_copy(_First, _Last, _Dest,
		_Al, _Nonscalar_ptr_iterator_tag()));
	}

template<class _Ty1,
	class _Ty2> inline
	_Ty2 *_Uninit_copy(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
		_Wrap_alloc<allocator<_Ty2> >&, _Scalar_ptr_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xmemory", 402);
	_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xmemory", 403);
	size_t _Count = (size_t)(_Last - _First);
	return ((_Ty2 *):: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First)) + _Count);	
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (_Uninit_copy(_First, _Last, _Dest, _Al,
		_Ptr_cat(_First, _Dest)));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (_Rechecked(_Dest,
		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest), _Al)));
	}

		
template<class _InIt,
	class _FwdIt,
	class _Alloc,
	class _Valty> inline
	_FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _Valty *, _Nonscalar_ptr_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xmemory", 438);
	_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xmemory", 439);
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, ++_First)
		_Al.construct(_Dest, (_Valty&&)*_First);
	} catch (...) {
	for (; _Next != _Dest; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	return (_Dest);
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc,
	class _Valty> inline
	_FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _Valty *, _Scalar_ptr_iterator_tag)
	{	
	return (_Uninit_move(_First, _Last, _Dest,
		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));
	}

template<class _Ty1,
	class _Ty2,
	class _Valty> inline
	_Ty2 *_Uninit_move(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
		_Wrap_alloc<allocator<_Ty2> >&, _Valty *, _Scalar_ptr_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xmemory", 470);
	_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xmemory", 471);
	size_t _Count = (size_t)(_Last - _First);
	return ((_Ty2 *):: memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First)) + _Count);	
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (_Uninit_move(_First, _Last, _Dest, _Al,
		_Val_type(_First), _Ptr_cat(_First, _Dest)));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	
	return (_Rechecked(_Dest,
		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest), _Al)));
	}

		
template<class _FwdIt,
	class _Tval> inline
	void _Uninit_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val,
		_Nonscalar_ptr_iterator_tag)
	{	
	_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xmemory", 504);
	_FwdIt _Next = _First;

	try {
	for (; _First != _Last; ++_First)
		_Construct(&*_First, _Val);
	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Destroy(&*_Next);
	throw;
	}
	}

template<class _Ty,
	class _Tval> inline
	void _Uninit_fill(_Ty *_First, _Ty *_Last, const _Tval& _Val,
		_Scalar_ptr_iterator_tag)
	{	
	::std:: fill(_First, _Last, _Val);
	}

template<class _FwdIt,
	class _Tval> inline
	void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
	{	
	_Uninit_fill(_First, _Last, _Val, _Ptr_cat(_First, _First));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val,
		_Nonscalar_ptr_iterator_tag)
	{	
 


 #line 543 "d:\\programs overflow\\vc\\include\\xmemory"

	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, ++_First)
		_Construct(&*_First, _Val);
	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Destroy(&*_Next);
	throw;
	}

	return (_First);
	}

template<class _Ty,
	class _Diff,
	class _Tval> inline
	_Ty *_Uninit_fill_n(_Ty *_First, _Diff _Count, const _Tval& _Val,
		_Scalar_ptr_iterator_tag)
	{	
	return (_Fill_n(_First, _Count, _Val));
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val)
	{	
	return (_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First)));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc,
	class _Valty> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval *_Pval, _Wrap_alloc<_Alloc>& _Al,
			_Valty *, _Nonscalar_ptr_iterator_tag)
	{	
 


 #line 590 "d:\\programs overflow\\vc\\include\\xmemory"

	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, ++_First)
		_Al.construct(_First, *_Pval);
	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc,
	class _Valty> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval *_Pval, _Wrap_alloc<_Alloc>& _Al,
			_Valty *, _Scalar_ptr_iterator_tag)
	{	
	_Uninit_fill_n(_First, _Count,
		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
	}

template<class _Ty,
	class _Diff,
	class _Tval,
	class _Valty> inline
	void _Uninit_fill_n(_Ty *_First, _Diff _Count,
		const _Tval *_Pval, _Wrap_alloc<allocator<_Ty> >&,
			_Valty *, _Scalar_ptr_iterator_tag)
	{	
	_Fill_n(_First, _Count, *_Pval);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
	void _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval *_Pval, _Alloc& _Al)
	{	
	_Uninit_fill_n(_First, _Count, _Pval, _Al,
		_Val_type(_First), _Ptr_cat(_First, _First));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Alloc,
	class _Valty> inline
	void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
		_Wrap_alloc<_Alloc>& _Al, _Valty *, _Nonscalar_ptr_iterator_tag)
	{	
 


 #line 650 "d:\\programs overflow\\vc\\include\\xmemory"

	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, ++_First)

		_Al.construct(_First);

	} catch (...) {
	for (; _Next != _First; ++_Next)
		_Al.destroy(_Next);
	throw;
	}
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc,
	class _Valty> inline
	void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
		_Wrap_alloc<_Alloc>& _Al, _Valty *, _Scalar_ptr_iterator_tag)
	{	
	_Uninit_def_fill_n(_First, _Count,
		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
	}

template<class _Ty,
	class _Diff,
	class _Valty> inline
	void _Uninit_def_fill_n(_Ty *_First, _Diff _Count,
		_Wrap_alloc<allocator<_Ty> >&, _Valty *, _Scalar_ptr_iterator_tag)
	{	
	_Fill_n(_First, _Count, (_Valty)0);
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	void _Uninitialized_default_fill_n(_FwdIt _First, _Diff _Count,
		_Alloc& _Al)
	{	
	_Uninit_def_fill_n(_First, _Count, _Al,
		_Val_type(_First), _Ptr_cat(_First, _First));
	}

		
template<class _OutIt,
	class _Ty>
	class raw_storage_iterator
		: public _Outit
	{	
public:
	typedef _OutIt iterator_type;	
	typedef _OutIt iter_type;	
	typedef _Ty element_type;	

	explicit raw_storage_iterator(_OutIt _First)
		: _Next(_First)
		{	
		}

	raw_storage_iterator<_OutIt, _Ty>& operator*()
		{	
		return (*this);
		}

	raw_storage_iterator<_OutIt, _Ty>& operator=(const _Ty& _Val)
		{	
		_Construct(&*_Next, _Val);
		return (*this);
		}

	raw_storage_iterator<_OutIt, _Ty>& operator++()
		{	
		++_Next;
		return (*this);
		}

	raw_storage_iterator<_OutIt, _Ty> operator++(int)
		{	
		raw_storage_iterator<_OutIt, _Ty> _Ans = *this;
		++_Next;
		return (_Ans);
		}

private:
	_OutIt _Next;	
	};

		
template<class _Ty>
	class _Temp_iterator
		: public _Outit
	{	
public:
	typedef _Ty *_Pty;

	_Temp_iterator(ptrdiff_t _Count = 0)
		{	
		_Buf._Begin = 0;
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = _Count;	
		_Pbuf = &_Buf;
		}

	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)
		{	
		_Buf._Begin = 0;	
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = 0;
		*this = _Right;
		}

	~_Temp_iterator() throw ()
		{	
		if (_Buf._Begin != 0)
			{	
			for (_Pty _Next = _Buf._Begin;
				_Next != _Buf._Hiwater; ++_Next)
				_Destroy(&*_Next);
			::std:: return_temporary_buffer(_Buf._Begin);
			}
		}

	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
		{	
		_Pbuf = _Right._Pbuf;
		return (*this);
		}

	_Temp_iterator<_Ty>& operator=(const _Ty& _Val)
		{	
		if (_Pbuf->_Current < _Pbuf->_Hiwater)
			*_Pbuf->_Current++ = _Val;	
		else
			{	
			_Pty _Ptr = &*_Pbuf->_Current;
			_Construct(_Ptr, _Val);
			_Pbuf->_Hiwater = ++_Pbuf->_Current;
			}
		return (*this);
		}

	_Temp_iterator<_Ty>& operator=(_Ty&& _Val)
		{	
		if (_Pbuf->_Current < _Pbuf->_Hiwater)
			*_Pbuf->_Current++ =
				::std:: forward<_Ty>(_Val);	
		else
			{	
			_Pty _Ptr = &*_Pbuf->_Current;
			_Construct(_Ptr, ::std:: forward<_Ty>(_Val));
			_Pbuf->_Hiwater = ++_Pbuf->_Current;
			}
		return (*this);
		}

	_Temp_iterator<_Ty>& operator*()
		{	
		return (*this);
		}

	_Temp_iterator<_Ty>& operator++()
		{	
		return (*this);
		}

	_Temp_iterator<_Ty>& operator++(int)
		{	
		return (*this);
		}

	_Temp_iterator<_Ty>& _Init()
		{	
		_Pbuf->_Current = _Pbuf->_Begin;
		return (*this);
		}

	_Pty _First() const
		{	
		return (_Pbuf->_Begin);
		}

	_Pty _Last() const
		{	
		return (_Pbuf->_Current);
		}

	ptrdiff_t _Maxlen()
		{	
		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)
			{	
			pair<_Pty, ptrdiff_t> _Pair =

				::std:: get_temporary_buffer<_Ty>(_Pbuf->_Size);

			_Pbuf->_Begin = _Pair.first;
			_Pbuf->_Current = _Pair.first;
			_Pbuf->_Hiwater = _Pair.first;
			_Pbuf->_Size = _Pair.second;
			}
		return (_Pbuf->_Size);
		}

private:
	struct _Bufpar
		{	
		_Pty _Begin;	
		_Pty _Current;	
		_Pty _Hiwater;	
		ptrdiff_t _Size;	
		};
	_Bufpar _Buf;	
	_Bufpar *_Pbuf;	
	};

		
template<class _Ty>
	class auto_ptr;

template<class _Ty>
	struct auto_ptr_ref
		{	
	explicit auto_ptr_ref(_Ty *_Right)
		: _Ref(_Right)
		{	
		}

	_Ty *_Ref;	
	};

template<class _Ty>
	class auto_ptr
		{	
public:
	typedef auto_ptr<_Ty> _Myt;
	typedef _Ty element_type;

	explicit auto_ptr(_Ty *_Ptr = 0) throw ()
		: _Myptr(_Ptr)
		{	
		}

	auto_ptr(_Myt& _Right) throw ()
		: _Myptr(_Right.release())
		{	
		}

	auto_ptr(auto_ptr_ref<_Ty> _Right) throw ()
		{	
		_Ty *_Ptr = _Right._Ref;
		_Right._Ref = 0;	
		_Myptr = _Ptr;	
		}

	template<class _Other>
		operator auto_ptr<_Other>() throw ()
		{	
		return (auto_ptr<_Other>(*this));
		}

	template<class _Other>
		operator auto_ptr_ref<_Other>() throw ()
		{	
		_Other *_Cvtptr = _Myptr;	
		auto_ptr_ref<_Other> _Ans(_Cvtptr);
		_Myptr = 0;	
		return (_Ans);
		}

	template<class _Other>
		_Myt& operator=(auto_ptr<_Other>& _Right) throw ()
		{	
		reset(_Right.release());
		return (*this);
		}

	template<class _Other>
		auto_ptr(auto_ptr<_Other>& _Right) throw ()
		: _Myptr(_Right.release())
		{	
		}

	_Myt& operator=(_Myt& _Right) throw ()
		{	
		reset(_Right.release());
		return (*this);
		}

	_Myt& operator=(auto_ptr_ref<_Ty> _Right) throw ()
		{	
		_Ty *_Ptr = _Right._Ref;
		_Right._Ref = 0;	
		reset(_Ptr);	
		return (*this);
		}

	~auto_ptr() throw ()
		{	
		delete _Myptr;
		}

	_Ty& operator*() const throw ()
		{	
 
		if (_Myptr == 0)
			_Debug_message(L"auto_ptr not dereferencable", L"d:\\programs overflow\\vc\\include\\xmemory", 958);
 #line 960 "d:\\programs overflow\\vc\\include\\xmemory"

		return (*get());
		}

	_Ty *operator->() const throw ()
		{	
 
		if (_Myptr == 0)
			_Debug_message(L"auto_ptr not dereferencable", L"d:\\programs overflow\\vc\\include\\xmemory", 968);
 #line 970 "d:\\programs overflow\\vc\\include\\xmemory"

		return (get());
		}

	_Ty *get() const throw ()
		{	
		return (_Myptr);
		}

	_Ty *release() throw ()
		{	
		_Ty *_Tmp = _Myptr;
		_Myptr = 0;
		return (_Tmp);
		}

	void reset(_Ty *_Ptr = 0)
		{	
		if (_Ptr != _Myptr)
			delete _Myptr;
		_Myptr = _Ptr;
		}

private:
	_Ty *_Myptr;	
	};
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1002 "d:\\programs overflow\\vc\\include\\xmemory"
#line 1003 "d:\\programs overflow\\vc\\include\\xmemory"





#line 32 "d:\\programs overflow\\vc\\include\\xdebug"

    __declspec(dllimport) void * __cdecl operator new(size_t _Size,
	const ::std:: _DebugHeapTag_t&,   char *, int)
		throw (...);	

    __declspec(dllimport) void * __cdecl operator new[](size_t _Size,
	const ::std:: _DebugHeapTag_t&,   char *, int)
		throw (...);	

__declspec(dllimport) void __cdecl operator delete(void *,
	const ::std:: _DebugHeapTag_t&,   char *, int)
		throw ();	

__declspec(dllimport) void __cdecl operator delete[](void *,
	const ::std:: _DebugHeapTag_t&,   char *, int)
		throw ();	

namespace std {

__declspec(dllimport) const _DebugHeapTag_t& __cdecl _DebugHeapTag_func();

		
template<class _Ty>
	void __cdecl _DebugHeapDelete(_Ty *_Ptr)
	{	
	if (_Ptr != 0)
		{	
		_Ptr->~_Ty();
		
		
		free(_Ptr);
		}
	}

}

  



#line 73 "d:\\programs overflow\\vc\\include\\xdebug"

 
 

 #pragma warning(pop)
 #pragma pack(pop)


#line 82 "d:\\programs overflow\\vc\\include\\xdebug"
#line 83 "d:\\programs overflow\\vc\\include\\xdebug"





#line 12 "d:\\programs overflow\\vc\\include\\xlocale"

#line 1 "d:\\programs overflow\\vc\\include\\xfacet"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 






namespace std {
	
class __declspec(dllimport) _Facet_base
	{	
public:
	virtual  ~_Facet_base() throw ()
		{	
		}

	
	virtual void  _Incref() = 0;

	
	virtual _Facet_base *  _Decref() = 0;
	};

 


#line 38 "d:\\programs overflow\\vc\\include\\xfacet"
void __cdecl _Facet_Register(_Facet_base *);
 #line 40 "d:\\programs overflow\\vc\\include\\xfacet"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 45 "d:\\programs overflow\\vc\\include\\xfacet"
#line 46 "d:\\programs overflow\\vc\\include\\xfacet"

 



#line 14 "d:\\programs overflow\\vc\\include\\xlocale"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412 28197)

namespace std {
		
template<class _Dummy>
	class _Locbase
	{	
public:
	 static const int collate = ((1 << (1)) >> 1);
	 static const int ctype = ((1 << (2)) >> 1);
	 static const int monetary = ((1 << (3)) >> 1);
	 static const int numeric = ((1 << (4)) >> 1);
	 static const int time = ((1 << (5)) >> 1);
	 static const int messages = ((1 << (6)) >> 1);
	 static const int all = (((1 << ((6 + 1))) >> 1) - 1);
	 static const int none = 0;
	};

template<class _Dummy>
	const int _Locbase<_Dummy>::collate;
template<class _Dummy>
	const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
	const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
	const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
	const int _Locbase<_Dummy>::time;
template<class _Dummy>
	const int _Locbase<_Dummy>::messages;
template<class _Dummy>
	const int _Locbase<_Dummy>::all;
template<class _Dummy>
	const int _Locbase<_Dummy>::none;

		
class locale;
template<class _Facet>
	const _Facet& __cdecl use_facet(const locale&);
template<class _Elem>
	class collate;

class locale
	: public _Locbase<int>
	{	
public:
	typedef int category;

			
	class __declspec(dllimport) id
		{	
	public:
		 id(size_t _Val = 0)
			: _Id(_Val)
			{	
			}

		 operator size_t()
			{	
			if (_Id == 0)
				{	
				{ ::std:: _Lockit _Lock(0);
					if (_Id == 0)
						_Id = ++_Id_cnt;
				}
				}
			return (_Id);
			}

	private:
		size_t _Id;	

		 static int _Id_cnt;

	public:
		 id(const id&) = delete;
		id&  operator=(const id&) = delete;
		};

	class _Locimp;

			
	class __declspec(dllimport) facet
		: public _Facet_base
		{	
		friend class locale;
		friend class _Locimp;

		template<class _Ty>
			friend void __cdecl _DebugHeapDelete(_Ty *_Ptr);

	public:
		static size_t __cdecl _Getcat(const facet ** = 0,
			const locale * = 0)
			{	
			return ((size_t)(-1));
			}

  
		void *__cdecl operator new(size_t _Size)
			{	
			return (operator new(_Size, _DebugHeapTag_func(),
				"d:\\programs overflow\\vc\\include\\xlocale", 122));
			}

		void *__cdecl operator new(size_t _Size,
			const _DebugHeapTag_t& _Tag, char *_File, int _Line)
			{	
			return (::operator new(_Size, _Tag, _File, _Line));
			}

		void __cdecl operator delete(void *_Ptr,
			const _DebugHeapTag_t&, char *, int)
			{	
			operator delete(_Ptr);
			}

		void __cdecl operator delete(void *_Ptr)
			{	
			_DebugHeapDelete((facet *)_Ptr);
			}
  #line 142 "d:\\programs overflow\\vc\\include\\xlocale"

		virtual void  _Incref()
			{   
			_InterlockedIncrement(reinterpret_cast<volatile long *>(&_Refs));
			}

		virtual _Facet_base * _Decref()
			{   
			if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Refs)) == 0)
				return (this);
			else
				return (0);
			}

	private:
		_Atomic_counter_t _Refs;	

	protected:
		explicit  facet(size_t _Initrefs = 0)
			{	
			_Init_atomic_counter(_Refs, (_Atomic_integral_t)_Initrefs);
			}

		virtual  ~facet() throw ()
			{	
			}

	public:
		 facet(const facet&) = delete;
		facet&  operator=(const facet&) = delete;
		};

			
 #pragma warning(push)
 #pragma warning(disable: 4275)

	class __declspec(dllimport) _Locimp
		: public facet
		{	
	protected:
		 ~_Locimp() throw ()
		{	
		_Locimp_dtor(this);
		}

	private:
		static  _Locimp *__cdecl
			_New_Locimp(bool _Transparent = false);
		static  _Locimp *__cdecl
			_New_Locimp(const _Locimp& _Right);

		static  void __cdecl
			_Locimp_dtor(_Locimp *);
		static  void __cdecl
			_Locimp_Addfac(_Locimp *, facet *, size_t);	
		static void __cdecl
			_Locimp_ctor(_Locimp *, const _Locimp&);

		friend class locale;

		 _Locimp(bool _Transparent)
			: locale::facet(1), _Facetvec(0), _Facetcount(0),
				_Catmask(none), _Xparent(_Transparent),
					_Name("*")
			{	
			}

		 _Locimp(const _Locimp& _Right)
			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
					_Name(_Right._Name.c_str())
			{	
			_Locimp_ctor(this, _Right);
			}

		void  _Addfac(facet *_Pfacet, size_t _Id)
			{	
			_Locimp_Addfac(this, _Pfacet, _Id);
			}

		static _Locimp *__cdecl _Makeloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

		static void __cdecl _Makewloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

 
		static void __cdecl _Makeushloc(const _Locinfo&,
			category, _Locimp *, const locale *);	
 #line 232 "d:\\programs overflow\\vc\\include\\xlocale"

		static void __cdecl _Makexloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

		facet **_Facetvec;	
		size_t _Facetcount;	
		category _Catmask;	
		bool _Xparent;	
		_Yarn<char> _Name;	

		 static _Locimp *_Clocptr;

public:
		_Locimp&  operator=(const _Locimp&) = delete;
		};

 #pragma warning(pop)

	template<class _Elem,
		class _Traits,
		class _Alloc>
		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
		{	
		const ::std:: collate<_Elem>& _Coll_fac =
			use_facet<::std:: collate<_Elem> >(*this);

		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
		}

	template<class _Facet>
		locale combine(const locale& _Loc) const
		{	
		_Facet *_Facptr;

		try {
			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
		} catch (...) {
			_Xruntime_error("locale::combine facet missing");
		}

		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
		_Newimp->_Addfac(_Facptr, _Facet::id);
		_Newimp->_Catmask = 0;
		_Newimp->_Name = "*";
		return (locale(_Newimp));
		}

	template<class _Facet>
		locale(const locale& _Loc, const _Facet *_Facptr)
			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		if (_Facptr != 0)
			{	
			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
			if (_Facet::_Getcat() != (size_t)(-1))
				{	
				_Ptr->_Catmask = 0;
				_Ptr->_Name = "*";
				}
			}
		}

	locale(_Uninitialized)
		{	
		}

 



















#line 321 "d:\\programs overflow\\vc\\include\\xlocale"
	locale(const locale& _Right) throw ()
		: _Ptr(_Right._Ptr)
		{	
		_Ptr->_Incref();
		}

	locale() throw ()
		: _Ptr(_Init(true))
		{	
		}

 
	locale(const locale& _Loc, const locale& _Other,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		try {
		{ _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str());
			_Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
				_Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
		}
		} catch (...) {
		::std:: _DebugHeapDelete(_Ptr->_Decref());
		throw;
		}
		}

private:
	void _Construct(const string &_Str,
		category _Cat)	
		{	
		bool _Bad = false;
		try {
		_Init();
		{ _Locinfo _Lobj(_Cat, _Str.c_str());
			if (_Badname(_Lobj))
				_Bad = true;
			else
				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
		}
		} catch (...) {
		::std:: _DebugHeapDelete(_Ptr->_Decref());
		throw;
		}

		if (_Bad)
			{	
			::std:: _DebugHeapDelete(_Ptr->_Decref());
			_Xruntime_error("bad locale name");
			}
		}

	void _Construct(const locale& _Loc, const string &_Str,
		category _Cat)
		{	
		bool _Bad = false;
		try {
		{ _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str());
			bool _Hadname = !_Badname(_Lobj);
			_Lobj._Addcats(_Cat, _Str.c_str());

			if (_Hadname && _Badname(_Lobj))
				_Bad = true;
			else
				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
		}
		} catch (...) {
		::std:: _DebugHeapDelete(_Ptr->_Decref());
		throw;
		}

		if (_Bad)
			{	
			::std:: _DebugHeapDelete(_Ptr->_Decref());
			_Xruntime_error("bad locale name");
			}
		}

public:
	explicit locale(const char *_Locname,
		category _Cat = all)	
		: _Ptr(_Locimp::_New_Locimp())
		{	
		
		
		if (_Locname == 0)
			_Xruntime_error("bad locale name");
		_Construct(_Locname, _Cat);
		}

	locale(const locale& _Loc, const char *_Locname,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		
		
		if (_Locname == 0)
			_Xruntime_error("bad locale name");
		_Construct(_Loc, _Locname, _Cat);
		}

	explicit locale(const string& _Str,
		category _Cat = all)	
		: _Ptr(_Locimp::_New_Locimp())
		{	
		_Construct(_Str, _Cat);
		}

	locale(const locale& _Loc, const string& _Str,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		_Construct(_Loc, _Str, _Cat);
		}
 #line 436 "d:\\programs overflow\\vc\\include\\xlocale"

	~locale() throw ()
		{	
		if (_Ptr != 0)
			::std:: _DebugHeapDelete(_Ptr->_Decref());
		}

	locale& operator=(const locale& _Right) throw ()
		{	
		if (_Ptr != _Right._Ptr)
			{	
			::std:: _DebugHeapDelete(_Ptr->_Decref());
			_Ptr = _Right._Ptr;
			_Ptr->_Incref();
			}
		return (*this);
		}
 #line 454 "d:\\programs overflow\\vc\\include\\xlocale"

	string name() const
		{	
		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
		}

	const char *c_str() const
		{	
		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
		}

	const facet *_Getfacet(size_t _Id) const
		{	
		const facet *_Facptr = _Id < _Ptr->_Facetcount
			? _Ptr->_Facetvec[_Id] : 0;	
		if (_Facptr != 0 || !_Ptr->_Xparent)
			return (_Facptr);	
		else
			{	
			locale::_Locimp *_Ptr = _Getgloballocale();
			return (_Id < _Ptr->_Facetcount
				? _Ptr->_Facetvec[_Id]	
				: 0);	
			}
		}

	bool operator==(const locale& _Loc) const
		{	
		return (_Ptr == _Loc._Ptr
			|| (name().compare("*") != 0
				&& name().compare(_Loc.name()) == 0));
		}

	bool operator!=(const locale& _Right) const
		{	
		return (!(*this == _Right));
		}

	static __declspec(dllimport) const locale& __cdecl
		classic();	

	static __declspec(dllimport) locale __cdecl
		global(const locale&);	

	static __declspec(dllimport) locale __cdecl
		empty();	

private:
	locale(_Locimp *_Ptrimp)
		: _Ptr(_Ptrimp)
		{	
		}

    static __declspec(dllimport) _Locimp *__cdecl
		_Init(bool _Do_incref = false);	
	static __declspec(dllimport) _Locimp *__cdecl
		_Getgloballocale();
	static __declspec(dllimport) void __cdecl
		_Setgloballocale(void *);

	bool _Badname(const _Locinfo& _Lobj)
		{	
		return (:: strcmp(_Lobj._Getname(), "*") == 0);
		}

	_Locimp *_Ptr;	
	};

		

 
















#line 542 "d:\\programs overflow\\vc\\include\\xlocale"

template<class _Facet>
	struct _Facetptr
	{	
	 static const locale::facet *_Psave;
	};

template<class _Facet>
	 const locale::facet *_Facetptr<_Facet>::
		_Psave = 0;

  

  


template<class _Facet> inline
	const _Facet& __cdecl use_facet(const locale& _Loc)

	{	
 



#line 567 "d:\\programs overflow\\vc\\include\\xlocale"
	{ ::std:: _Lockit _Lock(0);	
		const locale::facet *_Psave =
			_Facetptr<_Facet>::_Psave;	

		size_t _Id = _Facet::id;
		const locale::facet *_Pf = _Loc._Getfacet(_Id);

		if (_Pf != 0)
			;	
		else if (_Psave != 0)
			_Pf = _Psave;	
		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

 

			throw ::std:: bad_cast();	

 

#line 587 "d:\\programs overflow\\vc\\include\\xlocale"

		else
			{	
			_Pf = _Psave;
			_Facetptr<_Facet>::_Psave = _Psave;

			locale::facet *_Pfmod = (_Facet *)_Psave;
			_Pfmod->_Incref();

 


#line 600 "d:\\programs overflow\\vc\\include\\xlocale"
			_Facet_Register(_Pfmod);
 #line 602 "d:\\programs overflow\\vc\\include\\xlocale"
			}

		return ((const _Facet&)(*_Pf));	
	}
 #line 607 "d:\\programs overflow\\vc\\include\\xlocale"
	}	

		
template<class _Elem,
	class _InIt> inline
	int __cdecl _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
		const _Elem *_Ptr)
	{	
	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
		if (_Ptr[_Off] == _Ptr[0])
			++_Numfields;	
	string _Str(_Numfields, '\0');	

	int _Ans = -2;	
	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)
		{	
		bool _Prefix = false;	
		size_t _Off = 0;	
		size_t _Field = 0;	

		for (; _Field < _Numfields; ++_Field)
			{	
			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
				;	

			if (_Str[_Field] != '\0')
				_Off += _Str[_Field];	
			else if (_Ptr[_Off += _Column] == _Ptr[0]
				|| _Ptr[_Off] == (_Elem)0)
				{	
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	
				_Ans = (int)_Field;	
				}
			else if (_First == _Last || _Ptr[_Off] != *_First)
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	
			else
				_Prefix = true;	
			}

		if (!_Prefix || _First == _Last)
			break;	
		}
	return (_Ans);	
	}

		



template<class _Elem> inline
	char __cdecl _Maklocbyte(_Elem _Char,
		const _Locinfo::_Cvtvec&)
	{	
	return ((char)(unsigned char)_Char);
	}

template<> inline
	char __cdecl _Maklocbyte(wchar_t _Char,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	char _Byte = '\0';
	mbstate_t _Mbst1 = {0};
	_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}

 
template<> inline
	char __cdecl _Maklocbyte(unsigned short _Char,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	char _Byte = '\0';
	mbstate_t _Mbst1 = {0};
	_Wcrtomb(&_Byte, (wchar_t)_Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}
 #line 686 "d:\\programs overflow\\vc\\include\\xlocale"

		



template<class _Elem> inline
	_Elem __cdecl _Maklocchr(char _Byte, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	
	return ((_Elem)(unsigned char)_Byte);
	}

template<> inline
	wchar_t __cdecl _Maklocchr(char _Byte, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	wchar_t _Wc = L'\0';
	mbstate_t _Mbst1 = {0};
	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}

 
template<> inline
	unsigned short __cdecl _Maklocchr(char _Byte, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	unsigned short _Wc = (unsigned short)0;
	mbstate_t _Mbst1 = {0};
	_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}
 #line 719 "d:\\programs overflow\\vc\\include\\xlocale"

		



template<class _Elem> inline
	_Elem *__cdecl _Maklocstr(const char *_Ptr, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	
	size_t _Count = :: strlen(_Ptr) + 1;
	_Elem *_Ptrdest = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xlocale", 729) _Elem[_Count];

 #pragma warning(push)
 #pragma warning(disable: 6011)	
	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;
 #pragma warning(pop)

	return (_Ptrdest);
	}

template<> inline
	wchar_t *__cdecl _Maklocstr(const char *_Ptr, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	wchar_t _Wc;
	mbstate_t _Mbst1 = {0};

	_Count1 = :: strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	

	wchar_t *_Ptrdest = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xlocale", 758) wchar_t[_Wchars];
	wchar_t *_Ptrnext = _Ptrdest;
	mbstate_t _Mbst2 = {0};

 #pragma warning(push)
 #pragma warning(disable: 6011)	
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
 #pragma warning(pop)

	return (_Ptrdest);
	}

 
template<> inline
	unsigned short *__cdecl _Maklocstr(const char *_Ptr, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	unsigned short _Wc;
	mbstate_t _Mbst1 = {0};

	_Count1 = :: strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes =
			_Mbrtowc((wchar_t *)&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	

	wchar_t *_Ptrdest = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xlocale", 794) wchar_t[_Wchars];
	wchar_t *_Ptrnext = _Ptrdest;
	mbstate_t _Mbst2 = {0};
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
	return ((unsigned short *)_Ptrdest);
	}
 #line 805 "d:\\programs overflow\\vc\\include\\xlocale"

		
 #pragma warning(push)
 #pragma warning(disable: 4275)

class __declspec(dllimport) codecvt_base
	: public locale::facet
	{	
public:
	enum
		{	
		ok, partial, error, noconv};
	typedef int result;

	 codecvt_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}

	bool  always_noconv() const throw ()
		{	
		return (do_always_noconv());
		}

	int  max_length() const throw ()
		{	
		return (do_max_length());
		}

	int  encoding() const throw ()
		{	
		return (do_encoding());
		}

	 ~codecvt_base() throw ()
		{	
		}

protected:
	virtual bool  do_always_noconv() const throw ()
		{	
		return (false);
		}

	virtual int  do_max_length() const throw ()
		{	
		return (1);
		}

	virtual int  do_encoding() const throw ()
		{	
		return (1);	
		}
	};

 #pragma warning(pop)

		
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt
		: public codecvt_base
	{	
public:
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State, _First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;	

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Locinfo());
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xlocale", 920) codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() throw ()
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

	virtual bool  do_always_noconv() const throw ()
		{	
		return (is_same<_Byte, _Elem>::value);
		}

	virtual result  do_in(_Statype&,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		_Mid1 = _First1, _Mid2 = _First2;
		if (is_same<_Byte, _Elem>::value)
			return (noconv);	
		else
			{	
			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
				*_Mid2 = (_Elem)*_Mid1;
			return (ok);
			}
		}

	virtual result  do_out(_Statype&,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Mid1 = _First1, _Mid2 = _First2;
		if (is_same<_Byte, _Elem>::value)
			return (noconv);	
		else
			{	
			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
				*_Mid2 = (_Byte)*_Mid1;
			return (ok);
			}
		}

	virtual result  do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *&_Mid2) const
		{	
		_Mid2 = _First2;
		return (ok);	
		}

	virtual int  do_length(_Statype&, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return ((int)(_Count < (size_t)(_Last1 - _First1)
			? _Count : _Last1 - _First1));	
		}
	};

		
template<class _Elem,
	class _Byte,
	class _Statype>
	 locale::id codecvt<_Elem, _Byte, _Statype>::id;

 




















































































































































































































































































































































































































































































































































































































#line 1588 "d:\\programs overflow\\vc\\include\\xlocale"

		
template<>
	class __declspec(dllimport) codecvt<wchar_t, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef wchar_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xlocale", 1651) codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() throw ()
		{	
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"d:\\programs overflow\\vc\\include\\xlocale", 1670);
		_Debug_range(_First2, _Last2, L"d:\\programs overflow\\vc\\include\\xlocale", 1671);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	
			case -2:	
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	
				return (error);

			case 0:	
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"d:\\programs overflow\\vc\\include\\xlocale", 1706);
		_Debug_range(_First2, _Last2, L"d:\\programs overflow\\vc\\include\\xlocale", 1707);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if ((int)___mb_cur_max_func() <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
			else
				{	
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else if (_Last2 - _Mid2 < _Bytes)
					{	
					_State = _Stsave;
					return (_Ans);
					}
				else
					{	
					:: memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
					}
				}
		return (_Ans);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First2, _Last2, L"d:\\programs overflow\\vc\\include\\xlocale", 1744);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	
		else if (_Last2 - _Mid2 < --_Bytes)
			{	
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	
			:: memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		_Debug_range(_First1, _Last1, L"d:\\programs overflow\\vc\\include\\xlocale", 1769);
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	
			case -2:	
				return (_Wchars);

			case -1:	
				return (_Wchars);

			case 0:	
				if (_Ch == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool  do_always_noconv() const throw ()
		{	
		return (false);
		}

	virtual int  do_max_length() const throw ()
		{	
		return (5);
		}

	virtual int  do_encoding() const throw ()
		{	
		return (0);	
		}

private:
	_Locinfo::_Cvtvec _Cvt;	
	};

 
		
template<>
	class __declspec(dllimport) codecvt<unsigned short, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef unsigned short _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xlocale", 1886) codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() throw ()
		{	
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"d:\\programs overflow\\vc\\include\\xlocale", 1905);
		_Debug_range(_First2, _Last2, L"d:\\programs overflow\\vc\\include\\xlocale", 1906);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc((wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	
			case -2:	
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	
				return (error);

			case 0:	
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"d:\\programs overflow\\vc\\include\\xlocale", 1941);
		_Debug_range(_First2, _Last2, L"d:\\programs overflow\\vc\\include\\xlocale", 1942);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if ((int)___mb_cur_max_func() <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
			else
				{	
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else if (_Last2 - _Mid2 < _Bytes)
					{	
					_State = _Stsave;
					return (_Ans);
					}
				else
					{	
					:: memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
					}
				}
		return (_Ans);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First2, _Last2, L"d:\\programs overflow\\vc\\include\\xlocale", 1979);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	
		else if (_Last2 - _Mid2 < --_Bytes)
			{	
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	
			:: memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		_Debug_range(_First1, _Last1, L"d:\\programs overflow\\vc\\include\\xlocale", 2004);
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc((wchar_t *)&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	
			case -2:	
				return (_Wchars);

			case -1:	
				return (_Wchars);

			case 0:	
				if (_Ch == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool  do_always_noconv() const throw ()
		{	
		return (false);
		}

	virtual int  do_max_length() const throw ()
		{	
		return (5);
		}

	virtual int  do_encoding() const throw ()
		{	
		return (0);	
		}

private:
	_Locinfo::_Cvtvec _Cvt;	
	};
 #line 2058 "d:\\programs overflow\\vc\\include\\xlocale"

		
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt_byname
		: public codecvt<_Elem, _Byte, _Statype>
	{	
public:
	explicit  codecvt_byname(const char *_Locname, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
		{	
		}

	explicit  codecvt_byname(const string& _Str, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~codecvt_byname() throw ()
		{	
		}
	};

		
 #pragma warning(push)
 #pragma warning(disable: 4275)

struct __declspec(dllimport) ctype_base
	: public locale::facet
	{	
	enum
		{	
		alnum = 0x4 | 0x2 | 0x1 | 0x100, alpha = 0x2 | 0x1 | 0x100,
		cntrl = 0x20, digit = 0x4, graph = 0x4 | 0x2 | 0x10 | 0x1 | 0x100,
		lower = 0x2, print = 0x4 | 0x2 | 0x10 | 0x40 | 0x1 | 0x100 | 0x80,
		punct = 0x10, space = 0x8 | 0x40 | 0x000, upper = 0x1,
		xdigit = 0x80, blank = 0x8 | 0x40 | 0x000 | 0x000};
	typedef short mask;	

	 ctype_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}

	 ~ctype_base() throw ()
		{	
		}
	};

 #pragma warning(pop)

		
template<class _Elem>
	class ctype
		: public ctype_base
	{	
public:
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xlocale", 2204) ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() throw ()
		{	
		if (_Ctype._Delfl)
			free((void *)_Ctype._Table);

		free((void *)_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
			& _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2233);
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xlocale", 2234);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
		return (_First);
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2243);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2252);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Tolower(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2270);
		for (; _First != _Last; ++_First)
			{	
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Tolower(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Toupper(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2292);
		for (; _First != _Last; ++_First)
			{	
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Toupper(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Maklocchr(_Byte, (_Elem *)0, _Cvt));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2310);
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xlocale", 2311);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Maklocchr(*_First, (_Elem *)0, _Cvt);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Byte;
		if (_Ch == (_Elem)0)
			return ('\0');
		else if ((_Byte = _Maklocbyte((_Elem)_Ch, _Cvt)) == '\0')
			return (_Dflt);
		else
			return (_Byte);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2336);
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xlocale", 2337);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};

		
template<class _Elem>
	locale::id ctype<_Elem>::id;

		
template<>
	class __declspec(dllimport) ctype<char>
	: public ctype_base
	{	
	typedef ctype<char> _Myt;

public:
	typedef char _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
		}

	const _Elem * is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2371);
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xlocale", 2372);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)*_First];
		return (_First);
		}

	const _Elem * scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2381);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	const _Elem * scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2390);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const _Elem * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	_Elem  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(const mask *_Table = 0,
		bool _Deletetable = false,
		size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}

		_Tidy();	
		if (_Table != 0)
			{	
			_Ctype._Table = _Table;
			_Ctype._Delfl = _Deletetable ? -1 : 0;
			}
		else
			{	
			_Ctype._Table = classic_table();
			_Ctype._Delfl = 0;
			}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xlocale", 2472) ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

	const mask * table() const throw ()
		{	
		return (_Ctype._Table);
		}

	static const mask *__cdecl classic_table() throw ()
		{	
		const _Myt& _Ctype_fac = use_facet< _Myt >(locale::classic());
		return (_Ctype_fac.table());
		}

	 static const size_t table_size =
		1 << 8;	

protected:
	virtual  ~ctype() throw ()
		{	
		_Tidy();
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		}

	void  _Tidy()
		{	
		if (0 < _Ctype._Delfl)
			free((void *)_Ctype._Table);
		else if (_Ctype._Delfl < 0)
			delete[] (void *)_Ctype._Table;

		free((void *)_Ctype._LocaleName);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2520);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2534);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Byte);
		}

	virtual const _Elem * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2548);
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xlocale", 2549);
		:: memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

	virtual _Elem  do_narrow(_Elem _Ch, char) const
		{	
		return (_Ch);
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char, char *_Dest) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2562);
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xlocale", 2563);
		:: memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	};

		
template<>
	class __declspec(dllimport) ctype<wchar_t>
	: public ctype_base
	{	
	typedef ctype<wchar_t> _Myt;

public:
	typedef wchar_t _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xlocale", 2668) ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() throw ()
		{	
		if (_Ctype._Delfl)
			free((void *)_Ctype._Table);

		free((void *)_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2696);
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xlocale", 2697);
		return (:: _Getwctypes(_First, _Last, _Dest, &_Ctype));
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2704);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2713);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2727);
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2741);
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem  _Dowiden(char _Byte) const
		{	
		mbstate_t _Mbst = {0};
		wchar_t _Wc;
		return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (wchar_t)(wint_t)(0xFFFF) : _Wc);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Dowiden(_Byte));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2763);
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xlocale", 2764);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Buf[5];
		mbstate_t _Mbst = {0};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2786);
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xlocale", 2787);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};

 
		
template<>
	class __declspec(dllimport) ctype<unsigned short>
	: public ctype_base
	{	
	typedef ctype<unsigned short> _Myt;

public:
	typedef unsigned short _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xlocale", 2895) ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() throw ()
		{	
		if (_Ctype._Delfl)
			free((void *)_Ctype._Table);

		free((void *)_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2923);
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xlocale", 2924);
		return ((const _Elem *):: _Getwctypes((const wchar_t *)_First,
			(const wchar_t *)_Last, _Dest, &_Ctype));
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2932);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2941);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2955);
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2969);
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem  _Dowiden(char _Byte) const
		{	
		mbstate_t _Mbst = {0};
		unsigned short _Wc;
		return (_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (unsigned short)(wint_t)(0xFFFF) : _Wc);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Dowiden(_Byte));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 2991);
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xlocale", 2992);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Buf[5];
		mbstate_t _Mbst = {0};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocale", 3014);
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xlocale", 3015);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};
 #line 3026 "d:\\programs overflow\\vc\\include\\xlocale"

		
template<class _Elem>
	class ctype_byname
	: public ctype<_Elem>
	{	
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Locname), _Refs)
		{	
		}

	explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~ctype_byname() throw ()
		{	
		}
	};

		
template<>
	class ctype_byname<char>
	: public ctype<char>
	{	
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Locname), _Refs)
		{	
		}

	explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~ctype_byname() throw ()
		{	
		}
	};

 

  
template class __declspec(dllimport) codecvt<char, char, _Mbstatet>;
  #line 3076 "d:\\programs overflow\\vc\\include\\xlocale"
 #line 3077 "d:\\programs overflow\\vc\\include\\xlocale"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3082 "d:\\programs overflow\\vc\\include\\xlocale"
#line 3083 "d:\\programs overflow\\vc\\include\\xlocale"






#line 7 "d:\\programs overflow\\vc\\include\\xiosbase"

 #line 1 "d:\\programs overflow\\vc\\include\\system_error"

#pragma once



#line 1 "d:\\programs overflow\\vc\\include\\cerrno"

#pragma once











 #line 1 "d:\\programs overflow\\vc\\include\\errno.h"















#pragma once




#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "d:\\programs overflow\\vc\\include\\errno.h"


extern "C" {
#line 26 "d:\\programs overflow\\vc\\include\\errno.h"



























































#line 86 "d:\\programs overflow\\vc\\include\\errno.h"
#line 87 "d:\\programs overflow\\vc\\include\\errno.h"
















































}
#line 137 "d:\\programs overflow\\vc\\include\\errno.h"

#line 139 "d:\\programs overflow\\vc\\include\\errno.h"
#line 15 "d:\\programs overflow\\vc\\include\\cerrno"
#line 16 "d:\\programs overflow\\vc\\include\\cerrno"




#line 21 "d:\\programs overflow\\vc\\include\\cerrno"
#line 22 "d:\\programs overflow\\vc\\include\\cerrno"





#line 7 "d:\\programs overflow\\vc\\include\\system_error"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 



namespace std {
		

enum class errc {	
	address_family_not_supported = 102,
	address_in_use = 100,
	address_not_available = 101,
	already_connected = 113,
	argument_list_too_long = 7,
	argument_out_of_domain = 33,
	bad_address = 14,
	bad_file_descriptor = 9,
	bad_message = 104,
	broken_pipe = 32,
	connection_aborted = 106,
	connection_already_in_progress = 103,
	connection_refused = 107,
	connection_reset = 108,
	cross_device_link = 18,
	destination_address_required = 109,
	device_or_resource_busy = 16,
	directory_not_empty = 41,
	executable_format_error = 8,
	file_exists = 17,
	file_too_large = 27,
	filename_too_long = 38,
	function_not_supported = 40,
	host_unreachable = 110,
	identifier_removed = 111,
	illegal_byte_sequence = 42,
	inappropriate_io_control_operation = 25,
	interrupted = 4,
	invalid_argument = 22,
	invalid_seek = 29,
	io_error = 5,
	is_a_directory = 21,
	message_size = 115,
	network_down = 116,
	network_reset = 117,
	network_unreachable = 118,
	no_buffer_space = 119,
	no_child_process = 10,
	no_link = 121,
	no_lock_available = 39,
	no_message_available = 120,
	no_message = 122,
	no_protocol_option = 123,
	no_space_on_device = 28,
	no_stream_resources = 124,
	no_such_device_or_address = 6,
	no_such_device = 19,
	no_such_file_or_directory = 2,
	no_such_process = 3,
	not_a_directory = 20,
	not_a_socket = 128,
	not_a_stream = 125,
	not_connected = 126,
	not_enough_memory = 12,
	not_supported = 129,
	operation_canceled = 105,
	operation_in_progress = 112,
	operation_not_permitted = 1,
	operation_not_supported = 130,
	operation_would_block = 140,
	owner_dead = 133,
	permission_denied = 13,
	protocol_error = 134,
	protocol_not_supported = 135,
	read_only_file_system = 30,
	resource_deadlock_would_occur = 36,
	resource_unavailable_try_again = 11,
	result_out_of_range = 34,
	state_not_recoverable = 127,
	stream_timeout = 137,
	text_file_busy = 139,
	timed_out = 138,
	too_many_files_open_in_system = 23,
	too_many_files_open = 24,
	too_many_links = 31,
	too_many_symbolic_link_levels = 114,
	value_too_large = 132,
	wrong_protocol_type = 136
	};

typedef errc generic_errno;

		

enum class io_errc {	
	stream = 1
	};

typedef io_errc _Io_errc;

		
template<class _Enum>
	struct is_error_code_enum
		: public false_type
	{	
	};

template<>
	struct is_error_code_enum<_Io_errc>
		: public true_type
	{	
	};

		
template<class _Enum>
	struct is_error_condition_enum
		: public false_type
	{	
	};

template<>
	struct is_error_condition_enum<generic_errno>
		: public true_type
	{	
	};

class error_code;
class error_condition;
error_code make_error_code(generic_errno) throw ();
error_code make_error_code(_Io_errc) throw ();
error_condition make_error_condition(generic_errno) throw ();
error_condition make_error_condition(_Io_errc) throw ();

		
class error_category;

const error_category& generic_category() throw ();
const error_category& iostream_category() throw ();
const error_category& system_category() throw ();

class error_category
	{	
public:
	error_category()
		{	
		}

	virtual ~error_category() throw ()
		{	
		}

	virtual const char *name() const throw () = 0;

	virtual string message(int _Errval) const = 0;

	virtual error_condition
		default_error_condition(int _Errval) const throw ();

	virtual bool equivalent(int _Errval,
		const error_condition& _Cond) const throw ();

	virtual bool equivalent(const error_code& _Code,
		int _Errval) const throw ();

	bool operator==(const error_category& _Right) const throw ()
		{	
		return (this == &_Right);
		}

	bool operator!=(const error_category& _Right) const throw ()
		{	
		return (!(*this == _Right));
		}

	bool operator<(const error_category& _Right) const throw ()
		{	
		return (this < &_Right);
		}

	error_category(const error_category&) = delete;
	error_category& operator=(const error_category&) = delete;
	};

		
class error_code
	{	
public:
	typedef error_code _Myt;

	error_code()
		: _Myval(0),
			_Mycat(&system_category())
		{	
		}

	error_code(int _Val, const error_category& _Cat)
		: _Myval(_Val), _Mycat(&_Cat)
		{	
		}

	template<class _Enum,
		class = typename enable_if<is_error_code_enum<_Enum>::value,
			void>::type>
		error_code(_Enum _Errcode)
		: _Myval(0), _Mycat(0)
		{	
		*this = make_error_code(_Errcode);	
		}

	void assign(int _Val, const error_category& _Cat)
		{	
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum>
		typename enable_if<is_error_code_enum<_Enum>::value,
			error_code>::type& operator=(_Enum _Errcode)
		{	
		*this = make_error_code(_Errcode);	
		return (*this);
		}

	void clear() throw ()
		{	
		_Myval = 0;
		_Mycat = &system_category();
		}

	int value() const
		{	
		return (_Myval);
		}

	const error_category& category() const
		{	
		return (*_Mycat);
		}

	error_condition default_error_condition() const;

	string message() const
		{	
		return (category().message(value()));
		}

	explicit operator bool() const throw ()
		{	
		return (value() != 0);
		}

	bool operator==(const error_code& _Right) const throw ()
		{	
		return (category() == _Right.category()
			&& value() == _Right.value());
		}

	bool operator!=(const error_code& _Right) const throw ()
		{	
		return (!(*this == _Right));
		}

	bool operator<(const error_code& _Right) const throw ()
		{	
		return (category() < _Right.category()
			|| (category() == _Right.category()
				&& value() < _Right.value()));
		}

private:
	int _Myval;	
	const error_category *_Mycat;	
	};

		
class error_condition
	{	
public:
	typedef error_condition _Myt;

	error_condition() throw ()
		: _Myval(0),
			_Mycat(&generic_category())
		{	
		}

	error_condition(int _Val, const error_category& _Cat) throw ()
		: _Myval(_Val), _Mycat(&_Cat)
		{	
		}

	template<class _Enum,
		class = typename enable_if<is_error_condition_enum<_Enum>::value,
			void>::type>
		error_condition(_Enum _Errcode) throw ()
		: _Myval(0), _Mycat(0)
		{	
		*this = make_error_condition(_Errcode);	
		}

	void assign(int _Val, const error_category& _Cat) throw ()
		{	
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum>
		typename enable_if<is_error_condition_enum<_Enum>::value,
			error_condition>::type& operator=(_Enum _Errcode) throw ()
		{	
		*this = make_error_condition(_Errcode);	
		return (*this);
		}

	void clear() throw ()
		{	
		_Myval = 0;
		_Mycat = &generic_category();
		}

	int value() const throw ()
		{	
		return (_Myval);
		}

	const error_category& category() const throw ()
		{	
		return (*_Mycat);
		}

	string message() const
		{	
		return (category().message(value()));
		}

	explicit operator bool() const throw ()
		{	
		return (value() != 0);
		}

	bool operator==(const error_condition& _Right) const throw ()
		{	
		return (category() == _Right.category()
			&& value() == _Right.value());
		}

	bool operator!=(const error_condition& _Right) const throw ()
		{	
		return (!(*this == _Right));
		}

	bool operator<(const error_condition& _Right) const throw ()
		{	
		return (category() < _Right.category()
			|| (category() == _Right.category()
				&& value() < _Right.value()));
		}

private:
	int _Myval;	
	const error_category *_Mycat;	
	};

		
inline error_condition
	error_category::default_error_condition(int _Errval) const throw ()
	{	
	return (error_condition(_Errval, *this));
	}

inline bool
	error_category::equivalent(int _Errval,
		const error_condition& _Cond) const throw ()
	{	
	return (default_error_condition(_Errval) == _Cond);
	}

inline bool
	error_category::equivalent(const error_code& _Code,
		int _Errval) const throw ()
	{	
	return (*this == _Code.category() && _Code.value() == _Errval);
	}

		
inline error_condition error_code::default_error_condition() const
	{	
	return (category().default_error_condition(value()));
	}

		
inline bool operator==(
	const error_code& _Left,
	const error_condition& _Right) throw ()
	{	
	return (_Left.category().equivalent(_Left.value(), _Right)
		|| _Right.category().equivalent(_Left, _Right.value()));
	}

inline bool operator==(
	const error_condition& _Left,
	const error_code& _Right) throw ()
	{	
	return (_Right.category().equivalent(_Right.value(), _Left)
		|| _Left.category().equivalent(_Right, _Left.value()));
	}

		
inline bool operator!=(
	const error_code& _Left,
	const error_condition& _Right) throw ()
	{	
	return (!(_Left == _Right));
	}

inline bool operator!=(
	const error_condition& _Left,
	const error_code& _Right) throw ()
	{	
	return (!(_Left == _Right));
	}

		
inline error_code make_error_code(generic_errno _Errno) throw ()
	{	
	return (error_code((int)_Errno, generic_category()));
	}

inline error_code make_error_code(_Io_errc _Errno) throw ()
	{	
	return (error_code((int)_Errno, iostream_category()));
	}

		
inline error_condition make_error_condition(generic_errno _Errno) throw ()
	{	
	return (error_condition((int)_Errno, generic_category()));
	}

inline error_condition make_error_condition(_Io_errc _Errno) throw ()
	{	
	return (error_condition((int)_Errno, iostream_category()));
	}

		
template<>
	struct hash<error_code>
		: public unary_function<error_code, size_t>
	{	
	typedef error_code _Kty;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (hash<int>()(_Keyval.value()));
		}
	};

		
class _System_error
	: public runtime_error
	{	
private:
	static string _Makestr(error_code _Errcode, string _Message)
		{	
		if (!_Message.empty())
			_Message.append(": ");
		_Message.append(_Errcode.message());
		return (_Message);
		}

protected:
	_System_error(error_code _Errcode, const string& _Message)
		: runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode)
		{	
		}

	error_code _Mycode;	
	};

class system_error
	: public _System_error
	{	
private:
	typedef _System_error _Mybase;

public:
	explicit system_error(error_code _Errcode)
		: _Mybase(_Errcode, "")
		{	
		}

	system_error(error_code _Errcode, const string& _Message)
		: _Mybase(_Errcode, _Message)
		{	
		}

	system_error(error_code _Errcode, const char *_Message)
		: _Mybase(_Errcode, _Message)
		{	
		}

	system_error(int _Errval, const error_category& _Errcat)
		: _Mybase(error_code(_Errval, _Errcat), "")
		{	
		}

	system_error(int _Errval, const error_category& _Errcat,
		const string& _Message)
		: _Mybase(error_code(_Errval, _Errcat), _Message)
		{	
		}

	system_error(int _Errval, const error_category& _Errcat,
		const char *_Message)
		: _Mybase(error_code(_Errval, _Errcat), _Message)
		{	
		}

	const error_code& code() const throw ()
		{	
		return (_Mycode);
		}

 

 





#line 543 "d:\\programs overflow\\vc\\include\\system_error"
	};

__declspec(dllimport) const char *__cdecl _Syserror_map(int);
__declspec(dllimport) const char *__cdecl _Winerror_map(int);

		
class _Generic_error_category
	: public error_category
	{	
public:
	_Generic_error_category()
		{	
		}

	virtual const char *name() const throw ()
		{	
		return ("generic");
		}

	virtual string message(int _Errcode) const
		{	
		const char *_Name = _Syserror_map(_Errcode);
		return (string(_Name != 0 ? _Name : "unknown error"));
		}
	};

		
class _Iostream_error_category
	: public _Generic_error_category
	{	
public:
	_Iostream_error_category()
		{	
		}

	virtual const char *name() const throw ()
		{	
		return ("iostream");
		}

	virtual string message(int _Errcode) const
		{	
		if (_Errcode == (int)io_errc::stream)
			return ("iostream stream error");
		else
			return (_Generic_error_category::message(_Errcode));
		}
	};

		
class _System_error_category
	: public _Generic_error_category
	{	
public:
	_System_error_category()
		{	
		}

	virtual const char *name() const throw ()
		{	
		return ("system");
		}

	virtual string message(int _Errcode) const
		{	
		const char *_Name = _Winerror_map(_Errcode);
		return (string(_Name != 0 ? _Name : "unknown error"));
		}

	virtual error_condition
		default_error_condition(int _Errval) const throw ()
		{	
		if (_Syserror_map(_Errval))
			return (error_condition(_Errval, generic_category()));
		else
			return (error_condition(_Errval, system_category()));
		}
	};

template<class _Cat>
	struct _Error_objects
	{	
	_Error_objects()
		{	
		}

	static _Generic_error_category _Generic_object;
	static _Iostream_error_category _Iostream_object;
	static _System_error_category _System_object;
	};

template<class _Cat>
	_Generic_error_category _Error_objects<_Cat>::_Generic_object;
template<class _Cat>
	_Iostream_error_category _Error_objects<_Cat>::_Iostream_object;
template<class _Cat>
	_System_error_category _Error_objects<_Cat>::_System_object;

inline const error_category& generic_category() throw ()
	{	
	return (_Error_objects<int>::_Generic_object);
	}

inline const error_category& iostream_category() throw ()
	{	
	return (_Error_objects<int>::_Iostream_object);
	}

inline const error_category& system_category() throw ()
	{	
	return (_Error_objects<int>::_System_object);
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 660 "d:\\programs overflow\\vc\\include\\system_error"
#line 661 "d:\\programs overflow\\vc\\include\\system_error"





#line 9 "d:\\programs overflow\\vc\\include\\xiosbase"

 #line 1 "d:\\programs overflow\\vc\\include\\share.h"












#pragma once






#line 21 "d:\\programs overflow\\vc\\include\\share.h"













#line 35 "d:\\programs overflow\\vc\\include\\share.h"

#line 37 "d:\\programs overflow\\vc\\include\\share.h"
#line 11 "d:\\programs overflow\\vc\\include\\xiosbase"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412)

 

namespace std {
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 
 

 
 
 

		
template<class _Dummy>
	class _Iosb
	{	
public:
	enum _Dummy_enum {_Dummy_enum_val = 1};	
	enum _Fmtflags
		{	
		_Fmtmask = 0xffff, _Fmtzero = 0};

	static const _Fmtflags skipws = (_Fmtflags)0x0001;
	static const _Fmtflags unitbuf = (_Fmtflags)0x0002;
	static const _Fmtflags uppercase = (_Fmtflags)0x0004;
	static const _Fmtflags showbase = (_Fmtflags)0x0008;
	static const _Fmtflags showpoint = (_Fmtflags)0x0010;
	static const _Fmtflags showpos = (_Fmtflags)0x0020;
	static const _Fmtflags left = (_Fmtflags)0x0040;
	static const _Fmtflags right = (_Fmtflags)0x0080;
	static const _Fmtflags internal = (_Fmtflags)0x0100;
	static const _Fmtflags dec = (_Fmtflags)0x0200;
	static const _Fmtflags oct = (_Fmtflags)0x0400;
	static const _Fmtflags hex = (_Fmtflags)0x0800;
	static const _Fmtflags scientific = (_Fmtflags)0x1000;
	static const _Fmtflags fixed = (_Fmtflags)0x2000;

	static const _Fmtflags hexfloat =
		(_Fmtflags)0x3000;	

	static const _Fmtflags boolalpha = (_Fmtflags)0x4000;
	static const _Fmtflags _Stdio = (_Fmtflags)0x8000;
	static const _Fmtflags adjustfield = (_Fmtflags)(0x0040
		| 0x0080 | 0x0100);
	static const _Fmtflags basefield = (_Fmtflags)(0x0200
		| 0x0400 | 0x0800);
	static const _Fmtflags floatfield = (_Fmtflags)(0x1000
		| 0x2000);

	enum _Iostate
		{	
		_Statmask = 0x17};

	static const _Iostate goodbit = (_Iostate)0x0;
	static const _Iostate eofbit = (_Iostate)0x1;
	static const _Iostate failbit = (_Iostate)0x2;
	static const _Iostate badbit = (_Iostate)0x4;
	static const _Iostate _Hardfail = (_Iostate)0x10;

	enum _Openmode
		{	
		_Openmask = 0xff};

	static const _Openmode in = (_Openmode)0x01;
	static const _Openmode out = (_Openmode)0x02;
	static const _Openmode ate = (_Openmode)0x04;
	static const _Openmode app = (_Openmode)0x08;
	static const _Openmode trunc = (_Openmode)0x10;
	static const _Openmode _Nocreate = (_Openmode)0x40;
	static const _Openmode _Noreplace = (_Openmode)0x80;
	static const _Openmode binary = (_Openmode)0x20;

	enum _Seekdir
		{	
		_Seekmask = 0x3};

	static const _Seekdir beg = (_Seekdir)0;
	static const _Seekdir cur = (_Seekdir)1;
	static const _Seekdir end = (_Seekdir)2;

	enum
		{	
		_Openprot = 0x40};
	};

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags
		_Iosb<_Dummy>::hexfloat;	

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::_Hardfail;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;

		
class __declspec(dllimport) ios_base
	: public _Iosb<int>
	{	
public:
	typedef int fmtflags;
	typedef int iostate;
	typedef int openmode;
	typedef int seekdir;

	typedef ::std:: streamoff streamoff;
	typedef ::std:: streampos streampos;

	enum event
		{	
		erase_event, imbue_event, copyfmt_event};

	typedef void (__cdecl *event_callback)(event, ios_base&, int);
	typedef unsigned int io_state, open_mode, seek_dir;

			
	class failure

		: public system_error
		{	
	public:
		explicit failure(const string &_Message,
			const error_code& _Errcode = make_error_code(io_errc::stream))
			: system_error(_Errcode, _Message)
			{	
			}

		explicit failure(const char *_Message,
			const error_code& _Errcode = make_error_code(io_errc::stream))
			: system_error(_Errcode, _Message)
			{	
			}


 

 





#line 246 "d:\\programs overflow\\vc\\include\\xiosbase"
		};

			
	class __declspec(dllimport) Init
		{	
	public:
		 Init()
			{	
			_Init_ctor(this);
			}

		 ~Init() throw ()
			{	
			_Init_dtor(this);
			}

	private:
		static  void __cdecl _Init_ctor(Init *);
		static  void __cdecl _Init_dtor(Init *);

		 static int _Init_cnt;	

		static  int& __cdecl _Init_cnt_func();
		};

	explicit  operator bool() const
		{	
		return (!fail());
		}

	bool  operator!() const
		{	
		return (fail());
		}

	void  clear(iostate _State, bool _Reraise)
		{	
		_Mystate = (iostate)(_State & _Statmask);
		if ((_Mystate & _Except) == 0)
			;
		else if (_Reraise)
			throw;
		else if (_Mystate & _Except & badbit)
			throw failure("ios_base::badbit set");
		else if (_Mystate & _Except & failbit)
			throw failure("ios_base::failbit set");
		else
			throw failure("ios_base::eofbit set");
		}

	void  clear(iostate _State = goodbit)
		{	
		clear(_State, false);
		}

	void  clear(io_state _State)
		{	
		clear((iostate)_State);
		}

	iostate  rdstate() const
		{	
		return (_Mystate);
		}

	void  setstate(iostate _State, bool _Exreraise)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
		}

	void  setstate(iostate _State)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), false);
		}

	void  setstate(io_state _State)
		{	
		setstate((iostate)_State);
		}

	bool  good() const
		{	
		return (rdstate() == goodbit);
		}

	bool  eof() const
		{	
		return ((int)rdstate() & (int)eofbit);
		}

	bool  fail() const
		{	
		return (((int)rdstate()
			& ((int)badbit | (int)failbit)) != 0);
		}

	bool  bad() const
		{	
		return (((int)rdstate() & (int)badbit) != 0);
		}

	iostate  exceptions() const
		{	
		return (_Except);
		}

	void  exceptions(iostate _Newexcept)
		{	
		_Except = (iostate)((int)_Newexcept & (int)_Statmask);
		clear(_Mystate);
		}

	void  exceptions(io_state _State)
		{	
		exceptions((iostate)_State);
		}

	fmtflags  flags() const
		{	
		return (_Fmtfl);
		}

	fmtflags  flags(fmtflags _Newfmtflags)
		{	
		fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Newfmtflags & (int)_Fmtmask);
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags)
		{	
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Fmtfl
			| ((int)_Newfmtflags & (int)_Fmtmask));
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags, fmtflags _Mask)
		{	
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
			| ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));
		return (_Oldfmtflags);
		}

	void  unsetf(fmtflags _Mask)
		{	
		_Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_Mask);
		}

	streamsize  precision() const
		{	
		return (_Prec);
		}

	streamsize  precision(streamsize _Newprecision)
		{	
		streamsize _Oldprecision = _Prec;
		_Prec = _Newprecision;
		return (_Oldprecision);
		}

	streamsize  width() const
		{	
		return (_Wide);
		}

	streamsize  width(streamsize _Newwidth)
		{	
		streamsize _Oldwidth = _Wide;
		_Wide = _Newwidth;
		return (_Oldwidth);
		}

	locale  getloc() const
		{	
		return (*_Ploc);
		}

	locale  imbue(const locale& _Loc)
		{	
		locale _Oldlocale = *_Ploc;
		*_Ploc = _Loc;
		_Callfns(imbue_event);
		return (_Oldlocale);
		}

	static int __cdecl xalloc()
		{	
		{ ::std:: _Lockit _Lock(2);	
			return (_Index++);
		}
		}

	long&  iword(int _Idx)
		{	
		return (_Findarr(_Idx)._Lo);
		}

	void *&  pword(int _Idx)
		{	
		return (_Findarr(_Idx)._Vp);
		}

	void  register_callback(event_callback _Pfn,
		int _Idx)
		{	
		_Calls = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xiosbase", 455) _Fnarray(_Idx, _Pfn, _Calls);
		}

	ios_base&  copyfmt(const ios_base& _Other)
		{	
		if (this != &_Other)
			{	
			_Tidy();
			*_Ploc = *_Other._Ploc;
			_Fmtfl = _Other._Fmtfl;
			_Prec = _Other._Prec;
			_Wide = _Other._Wide;
			_Iosarray *_Ptr = _Other._Arr;

			for (_Arr = 0; _Ptr != 0; _Ptr = _Ptr->_Next)
				if (_Ptr->_Lo != 0 || _Ptr->_Vp != 0)
					{	
					iword(_Ptr->_Index) = _Ptr->_Lo;
					pword(_Ptr->_Index) = _Ptr->_Vp;
					}

			for (_Fnarray *_Pfa = _Other._Calls; _Pfa != 0;
				_Pfa = _Pfa->_Next)
				register_callback(_Pfa->_Pfn, _Pfa->_Index);

			_Callfns(copyfmt_event);	
			exceptions(_Other._Except);	
			}
		return (*this);
		}

	static bool __cdecl sync_with_stdio(bool _Newsync = true)
		{	
		{ ::std:: _Lockit _Lock(2);	
			const bool _Oldsync = _Sync;
			_Sync = _Newsync;
			return (_Oldsync);
		}
		}

	void  swap(ios_base& _Right)
		{	
		if (this != &_Right)
			{	
			::std:: swap(_Mystate, _Right._Mystate);
			::std:: swap(_Except, _Right._Except);
			::std:: swap(_Fmtfl, _Right._Fmtfl);
			::std:: swap(_Prec, _Right._Prec);
			::std:: swap(_Wide, _Right._Wide);

			::std:: swap(_Arr, _Right._Arr);
			::std:: swap(_Calls, _Right._Calls);
			::std:: swap(_Ploc, _Right._Ploc);
			}
		}

	virtual  ~ios_base() throw ()	
		{	
		_Ios_base_dtor(this);
		}

	static  void __cdecl
		_Addstd(ios_base *);	

	size_t _Stdstr;	

protected:
	 ios_base()
		{	
		}

	void  _Init()
		{	
		_Ploc = 0;
		_Stdstr = 0;
		_Except = goodbit;
		_Fmtfl = (fmtflags)(skipws | dec);
		_Prec = 6;
		_Wide = 0;
		_Arr = 0;
		_Calls = 0;
		clear(goodbit);
		_Ploc = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xiosbase", 537) locale;
		}

private:
			
	struct _Iosarray
		{	
	public:
		 _Iosarray(int _Idx, _Iosarray *_Link)
			: _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
			{	
			}

		_Iosarray *_Next;	
		int _Index;	
		long _Lo;	
		void *_Vp;	
		};

			
	struct _Fnarray
		{	
		 _Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link)
			: _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
			{	
			}

		_Fnarray *_Next;	
		int _Index;	
		event_callback _Pfn;	
		};

	void  _Callfns(event _Ev)
		{	
		for (_Fnarray *_Pfa = _Calls; _Pfa != 0; _Pfa = _Pfa->_Next)
			(*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
		}

	_Iosarray&  _Findarr(int _Idx)
		{	
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr, _Ptr2 = 0; _Ptr1 != 0; _Ptr1 = _Ptr1->_Next)
			if (_Ptr1->_Index == _Idx)
				return (*_Ptr1);	
			else if (_Ptr2 == 0 && _Ptr1->_Lo == 0 && _Ptr1->_Vp == 0)
				_Ptr2 = _Ptr1;	

		if (_Ptr2 != 0)
			{	
			_Ptr2->_Index = _Idx;
			return (*_Ptr2);
			}

		_Arr = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xiosbase", 591) _Iosarray(_Idx, _Arr);	
		return (*_Arr);
		}

	void  _Tidy()
		{	
		_Callfns(erase_event);
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr; _Ptr1 != 0; _Ptr1 = _Ptr2)
			{	
			_Ptr2 = _Ptr1->_Next;
			::std:: _DebugHeapDelete(_Ptr1);
			}
		_Arr = 0;

		_Fnarray *_Pfa1, *_Pfa2;
		for (_Pfa1 = _Calls; _Pfa1 != 0; _Pfa1 = _Pfa2)
			{	
			_Pfa2 = _Pfa1->_Next;
			::std:: _DebugHeapDelete(_Pfa1);
			}
		_Calls = 0;
		}

	iostate _Mystate;	
	iostate _Except;	
	fmtflags _Fmtfl;	
	streamsize _Prec;	
	streamsize _Wide;	
	_Iosarray *_Arr;	
	_Fnarray *_Calls;	
	locale *_Ploc;	

	 static int _Index;
	 static bool _Sync;

	static  void __cdecl
		_Ios_base_dtor(ios_base *);

public:
	ios_base(const ios_base&) = delete;
	ios_base& operator=(const ios_base&) = delete;
	};





}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 645 "d:\\programs overflow\\vc\\include\\xiosbase"
#line 646 "d:\\programs overflow\\vc\\include\\xiosbase"





#line 7 "d:\\programs overflow\\vc\\include\\streambuf"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4251)

namespace std {
		
template<class _Elem,
	class _Traits>
	class basic_streambuf
	{	
	typedef basic_streambuf<_Elem, _Traits> _Myt;

protected:
	 basic_streambuf()
		: _Plocale(new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\streambuf", 25) locale)
		{	
		_Init();
		}

	 basic_streambuf(_Uninitialized)
		{	
		}

	 basic_streambuf(const _Myt& _Right)
		: _Plocale(new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\streambuf", 35) locale(_Right.getloc()))
		{	
		_Init();
		setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
		setg(_Right.eback(), _Right.gptr(), _Right.egptr());
		}

	_Myt&  operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			pubimbue(_Right.getloc());
			}
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Elem *_Pfirst = pbase();
			_Elem *_Pnext = pptr();
			_Elem *_Pend = epptr();
			_Elem *_Gfirst = eback();
			_Elem *_Gnext = gptr();
			_Elem *_Gend = egptr();

			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			_Right.setp(_Pfirst, _Pnext, _Pend);

			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			_Right.setg(_Gfirst, _Gnext, _Gend);

			::std:: swap(_Plocale, _Right._Plocale);
			}
		}

public:
	typedef _Elem char_type;
	typedef _Traits traits_type;

	virtual  ~basic_streambuf() throw ()
		{	
		::std:: _DebugHeapDelete(_Plocale);
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	pos_type  pubseekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		return (seekoff(_Off, _Way, _Mode));
		}

	pos_type  pubseekoff(off_type _Off,
		ios_base::seek_dir _Way,
		ios_base::open_mode _Mode)
		{	
		return (pubseekoff(_Off, (ios_base::seekdir)_Way,
			(ios_base::openmode)_Mode));
		}

	pos_type  pubseekpos(pos_type _Pos,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		return (seekpos(_Pos, _Mode));
		}

	pos_type  pubseekpos(pos_type _Pos,
		ios_base::open_mode _Mode)
		{	
		return (seekpos(_Pos, (ios_base::openmode)_Mode));
		}

	_Myt * pubsetbuf(_Elem *_Buffer,
		streamsize _Count)
		{	
		return (setbuf(_Buffer, _Count));
		}

	locale  pubimbue(const locale &_Newlocale)
		{	
		locale _Oldlocale = *_Plocale;
		imbue(_Newlocale);
		*_Plocale = _Newlocale;
		return (_Oldlocale);
		}

	locale  getloc() const
		{	
		return (*_Plocale);
		}

	streamsize  in_avail()
		{	
		streamsize _Res = _Gnavail();
		return (0 < _Res ? _Res : showmanyc());
		}

	int  pubsync()
		{	
		return (sync());
		}

	int_type  sbumpc()
		{	
		return (0 < _Gnavail()
			? _Traits::to_int_type(*_Gninc()) : uflow());
		}

	int_type  sgetc()
		{	
		return (0 < _Gnavail()
			? _Traits::to_int_type(*gptr()) : underflow());
		}

	streamsize  sgetn(_Elem *_Ptr,
		streamsize _Count)
		{	
		return (xsgetn(_Ptr, _Count));
		}

	int_type  snextc()
		{	
		return (1 < _Gnavail()
			? _Traits::to_int_type(*_Gnpreinc())
			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
				? _Traits::eof() : sgetc());
		}

	int_type  sputbackc(_Elem _Ch)
		{	
		return (gptr() != 0 && eback() < gptr()
			&& _Traits::eq(_Ch, gptr()[-1])
			? _Traits::to_int_type(*_Gndec())
			: pbackfail(_Traits::to_int_type(_Ch)));
		}

	void  stossc()
		{	
		if (0 < _Gnavail())
			_Gninc();
		else
			uflow();
		}

	int_type  sungetc()
		{	
		return (gptr() != 0 && eback() < gptr()
			? _Traits::to_int_type(*_Gndec()) : pbackfail());
		}

	int_type  sputc(_Elem _Ch)
		{	
		return (0 < _Pnavail()
			? _Traits::to_int_type(*_Pninc() = _Ch)
			: overflow(_Traits::to_int_type(_Ch)));
		}

	streamsize  sputn(const _Elem *_Ptr,
		streamsize _Count)
		{	
		return (xsputn(_Ptr, _Count));
		}

	virtual void  _Lock()
		{	
		}

	virtual void  _Unlock()
		{	
		}

protected:
	_Elem * eback() const
		{	
		return (*_IGfirst);
		}

	_Elem * gptr() const
		{	
		return (*_IGnext);
		}

	_Elem * pbase() const
		{	
		return (*_IPfirst);
		}

	_Elem * pptr() const
		{	
		return (*_IPnext);
		}

	_Elem * egptr() const
		{	
		return (*_IGnext + *_IGcount);
		}

	void  gbump(int _Off)
		{	
		*_IGcount -= _Off;
		*_IGnext += _Off;
		}

	void  setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	
		*_IGfirst = _First;
		*_IGnext = _Next;
		*_IGcount = (int)(_Last - _Next);
		}

	_Elem * epptr() const
		{	
		return (*_IPnext + *_IPcount);
		}

	_Elem * _Gndec()
		{	
		++*_IGcount;
		return (--*_IGnext);
		}

	_Elem * _Gninc()
		{	
		--*_IGcount;
		return ((*_IGnext)++);
		}

	_Elem * _Gnpreinc()
		{	
		--*_IGcount;
		return (++(*_IGnext));
		}

	streamsize  _Gnavail() const
		{	
		return (*_IGnext != 0 ? *_IGcount : 0);
		}

	void  pbump(int _Off)
		{	
		*_IPcount -= _Off;
		*_IPnext += _Off;
		}

	void  setp(_Elem *_First, _Elem *_Last)
		{	
		*_IPfirst = _First;
		*_IPnext = _First;
		*_IPcount = (int)(_Last - _First);
		}

	void  setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	
		*_IPfirst = _First;
		*_IPnext = _Next;
		*_IPcount = (int)(_Last - _Next);
		}

	_Elem * _Pninc()
		{	
		--*_IPcount;
		return ((*_IPnext)++);
		}

	streamsize  _Pnavail() const
		{	
		return (*_IPnext != 0 ? *_IPcount : 0);
		}

	void  _Init()
		{	
		_IGfirst = &_Gfirst;
		_IPfirst = &_Pfirst;
		_IGnext = &_Gnext;
		_IPnext = &_Pnext;
		_IGcount = &_Gcount;
		_IPcount = &_Pcount;
		setp(0, 0);
		setg(0, 0, 0);
		}

	void  _Init(_Elem **_Gf, _Elem **_Gn, int *_Gc,
		_Elem **_Pf, _Elem **_Pn, int *_Pc)
		{	
		_IGfirst = _Gf;
		_IPfirst = _Pf;
		_IGnext = _Gn;
		_IPnext = _Pn;
		_IGcount = _Gc;
		_IPcount = _Pc;
		}

	virtual int_type  overflow(int_type = _Traits::eof())
		{	
		return (_Traits::eof());
		}

	virtual int_type  pbackfail(int_type = _Traits::eof())
		{	
		return (_Traits::eof());
		}

	virtual streamsize  showmanyc()
		{	
		return (0);
		}

	virtual int_type  underflow()
		{	
		return (_Traits::eof());
		}

	virtual int_type  uflow()
		{	
		return (_Traits::eq_int_type(_Traits::eof(), underflow())
			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
		}

	virtual streamsize  xsgetn(_Elem * _Ptr,
		streamsize _Count)
		{	
		int_type _Meta;
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Size = _Gnavail()))
				{	
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(_Ptr, gptr(), (size_t)_Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				gbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
				break;	
			else
				{	
				*_Ptr++ = _Traits::to_char_type(_Meta);
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual streamsize  xsputn(const _Elem *_Ptr,
		streamsize _Count)
		{	
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Size = _Pnavail()))
				{	
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(pptr(), _Ptr, (size_t)_Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				pbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(),
				overflow(_Traits::to_int_type(*_Ptr))))
				break;	
			else
				{	
				++_Ptr;
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual pos_type  seekoff(off_type,
		ios_base::seekdir,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	
		return (streampos(_BADOFF));
		}

	virtual pos_type  seekpos(pos_type,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	
		return (streampos(_BADOFF));
		}

	virtual _Myt * setbuf(_Elem *, streamsize)
		{	
		return (this);
		}

	virtual int  sync()
		{	
		return (0);
		}

	virtual void  imbue(const locale&)
		{	
		}

private:
	_Elem *_Gfirst;	
	_Elem *_Pfirst;	
	_Elem **_IGfirst;	
	_Elem **_IPfirst;	
	_Elem *_Gnext;	
	_Elem *_Pnext;	
	_Elem **_IGnext;	
	_Elem **_IPnext;	

	int _Gcount;	
	int _Pcount;	
	int *_IGcount;	
	int *_IPcount;	

protected:
	locale *_Plocale;	
	};

 

  
template class __declspec(dllimport) basic_streambuf<char, char_traits<char> >;
template class __declspec(dllimport) basic_streambuf<wchar_t, char_traits<wchar_t> >;
  #line 470 "d:\\programs overflow\\vc\\include\\streambuf"

  



 #line 476 "d:\\programs overflow\\vc\\include\\streambuf"

		
template<class _Elem,
	class _Traits>
	class istreambuf_iterator
		: public iterator<input_iterator_tag,
			_Elem, typename _Traits::off_type, const _Elem *, _Elem>
	{	
	typedef istreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_istream<_Elem, _Traits> istream_type;

	typedef typename traits_type::int_type int_type;
	typedef const _Elem *pointer;

	istreambuf_iterator(streambuf_type *_Sb = 0) throw ()
		: _Strbuf(_Sb), _Got(_Sb == 0)
		{	
		}

	istreambuf_iterator(istream_type& _Istr) throw ()
		: _Strbuf(_Istr.rdbuf()), _Got(_Istr.rdbuf() == 0)
		{	
		}

	_Elem operator*() const
		{	
		if (!_Got)
			_Peek();

 
		if (_Strbuf == 0)
			_Debug_message(L"istreambuf_iterator is not dereferencable", L"d:\\programs overflow\\vc\\include\\streambuf", 511);
 #line 513 "d:\\programs overflow\\vc\\include\\streambuf"

		return (_Val);
		}

	const _Elem *operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
 
		if (_Strbuf == 0)
			_Debug_message(L"istreambuf_iterator is not incrementable", L"d:\\programs overflow\\vc\\include\\streambuf", 526);
 #line 528 "d:\\programs overflow\\vc\\include\\streambuf"

		_Inc();
		return (*this);
		}

	_Myt operator++(int)
		{	
		if (!_Got)
			_Peek();
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	bool equal(const _Myt& _Right) const
		{	
		if (!_Got)
			_Peek();
		if (!_Right._Got)
			_Right._Peek();
		return ((_Strbuf == 0 && _Right._Strbuf == 0)
			|| (_Strbuf != 0 && _Right._Strbuf != 0));
		}

private:
	void _Inc()
		{	
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Strbuf->sbumpc()))
			_Strbuf = 0, _Got = true;
		else
			_Got = false;
		}

	_Elem _Peek() const
		{	
		int_type _Meta;
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Meta = _Strbuf->sgetc()))
			_Strbuf = 0;
		else
			_Val = traits_type::to_char_type(_Meta);
		_Got = true;
		return (_Val);
		}

	mutable streambuf_type *_Strbuf;	
	mutable bool _Got;	
	mutable _Elem _Val;	
	};

template<class _Elem,
	class _Traits>
	struct _Is_checked_helper<istreambuf_iterator<_Elem, _Traits> >
		: public true_type
	{	
	};

		
template<class _Elem,
	class _Traits> inline
	bool  operator==(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	
	return (_Left.equal(_Right));
	}

template<class _Elem,
	class _Traits> inline
	bool  operator!=(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	
	return (!(_Left == _Right));
	}

		
template<class _Elem,
	class _Traits>
	class ostreambuf_iterator
		: public _Outit
	{	
	typedef ostreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_ostream<_Elem, _Traits> ostream_type;

	ostreambuf_iterator(streambuf_type *_Sb) throw ()
		: _Failed(false), _Strbuf(_Sb)
		{	
		}

	ostreambuf_iterator(ostream_type& _Ostr) throw ()
		: _Failed(false), _Strbuf(_Ostr.rdbuf())
		{	
		}

	_Myt& operator=(_Elem _Right)
		{	
		if (_Strbuf == 0
			|| traits_type::eq_int_type(_Traits::eof(),
				_Strbuf->sputc(_Right)))
			_Failed = true;
		return (*this);
		}

	_Myt& operator*()
		{	
		return (*this);
		}

	_Myt& operator++()
		{	
		return (*this);
		}

	_Myt& operator++(int)
		{	
		return (*this);
		}

	bool failed() const throw ()
		{	
		return (_Failed);
		}

private:
	bool _Failed;	
	streambuf_type *_Strbuf;	
	};

template<class _Elem,
	class _Traits>
	struct _Is_checked_helper<ostreambuf_iterator<_Elem, _Traits> >
		: public true_type
	{	
	};
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 676 "d:\\programs overflow\\vc\\include\\streambuf"
#line 677 "d:\\programs overflow\\vc\\include\\streambuf"





#line 11 "d:\\programs overflow\\vc\\include\\xlocnum"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189 4275)

		

 
extern "C" {
 #line 24 "d:\\programs overflow\\vc\\include\\xlocnum"

extern __declspec(dllimport) float __cdecl _Stofx(const char *,
	    char **,
	long, int *);
extern __declspec(dllimport) double __cdecl _Stodx(const char *,
	    char **,
	long, int *);
extern __declspec(dllimport) long double __cdecl _Stoldx(const char *,
	    char **,
	long, int *);
extern __declspec(dllimport) long __cdecl _Stolx(const char *,
	    char **,
	int, int *);
extern __declspec(dllimport) unsigned long __cdecl _Stoulx(const char *,
	    char **,
	int, int *);
extern __declspec(dllimport) __int64 __cdecl _Stollx(const char *,
	    char **,
	int, int *);
extern __declspec(dllimport) unsigned __int64 __cdecl _Stoullx(const char *,
	    char **,
	int, int *);

 
}
 #line 50 "d:\\programs overflow\\vc\\include\\xlocnum"

namespace std {

template<class _Elem> inline
	size_t _Find_elem(_Elem *_Base, _Elem _Ch)
	{	
	_Elem *_Ptr = _Base;
	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)
		;
	return ((size_t)(_Ptr - _Base));
	}

inline wchar_t *_Maklocwcs(const wchar_t *_Ptr)
	{	
	size_t _Count = :: wcslen(_Ptr) + 1;
	wchar_t *_Ptrdest = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xlocnum", 65) wchar_t[_Count];
	:: wmemcpy(_Ptrdest, _Ptr, _Count);
	return (_Ptrdest);
	}

		
template<class _Elem>
	class numpunct
		: public locale::facet
	{	
public:
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;
	typedef _Elem char_type;

	 __declspec(dllimport) static locale::id id;	

	_Elem decimal_point() const
		{	
		return (do_decimal_point());
		}

	_Elem thousands_sep() const
		{	
		return (do_thousands_sep());
		}

	string grouping() const
		{	
		return (do_grouping());
		}

	string_type falsename() const
		{	
		return (do_falsename());
		}

	string_type truename() const
		{	
		return (do_truename());
		}

	explicit numpunct(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
			if (_Kseparator == 0)
				_Kseparator =	
					_Maklocchr(',', (_Elem *)0, _Lobj._Getcvt());
		}
		}

	numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj, _Isdef);
		}

	static size_t _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xlocnum", 128) numpunct<_Elem>(
				_Locinfo(_Ploc->c_str()), 0, true);
		return (4);
		}

protected:
	virtual  ~numpunct() throw ()
		{	
		_Tidy();
		}

	numpunct(const char *_Locname, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj, _Isdef);
		}
		}

	template<class _Elem2>
		void _Getvals(_Elem2, const lconv *_Ptr, _Locinfo::_Cvtvec _Cvt)
		{	
		_Dp = _Maklocchr(_Ptr->decimal_point[0], (_Elem2 *)0, _Cvt);
		_Kseparator = _Maklocchr(_Ptr->thousands_sep[0], (_Elem2 *)0, _Cvt);
		}

	template<>
		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)
		{	
		_Dp = (_Elem)_Ptr->_W_decimal_point[0];
		_Kseparator = (_Elem)_Ptr->_W_thousands_sep[0];
		}

	void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
		{	
		const lconv *_Ptr = _Lobj._Getlconv();
		_Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();	

		_Grouping = 0;
		_Falsename = 0;
		_Truename = 0;

		try {
		_Grouping = _Maklocstr(_Isdef ? "" : _Ptr->grouping, (char *)0, _Lobj._Getcvt());
#line 173 "d:\\programs overflow\\vc\\include\\xlocnum"
		_Falsename = _Maklocstr(_Lobj._Getfalse(), (_Elem *)0, _Cvt);
		_Truename = _Maklocstr(_Lobj._Gettrue(), (_Elem *)0, _Cvt);
		} catch (...) {
		_Tidy();
		throw;
		}

		if (_Isdef)
			{	

			_Dp = _Maklocchr('.', (_Elem *)0, _Cvt);
			_Kseparator = _Maklocchr(',', (_Elem *)0, _Cvt);
			}
		else
			_Getvals((_Elem)0, _Ptr, _Cvt);
		}

	virtual _Elem  do_decimal_point() const
		{	
		return (_Dp);
		}

	virtual _Elem  do_thousands_sep() const
		{	
		return (_Kseparator);
		}

	virtual string  do_grouping() const
		{	
		return (string(_Grouping));
		}

	virtual string_type  do_falsename() const
		{	
		return (string_type(_Falsename));
		}

	virtual string_type  do_truename() const
		{	
		return (string_type(_Truename));
		}

private:
	void _Tidy()
		{	
		::std:: _DebugHeapDelete((void *)(void *)_Grouping);
		::std:: _DebugHeapDelete((void *)(void *)_Falsename);
		::std:: _DebugHeapDelete((void *)(void *)_Truename);
		}

	const char *_Grouping;	
	_Elem _Dp;	
	_Elem _Kseparator;	
	const _Elem *_Falsename;	
	const _Elem *_Truename;	
	};

		
template<class _Elem>
	class numpunct_byname
		: public numpunct<_Elem>
	{	
public:
	explicit numpunct_byname(const char *_Locname, size_t _Refs = 0)
		: numpunct<_Elem>(_Locname, _Refs)
		{	
		}

	explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
		: numpunct<_Elem>(_Str.c_str(), _Refs)
		{	
		}

protected:
	virtual  ~numpunct_byname() throw ()
		{	
		}
	};

		
template<class _Elem>
	 locale::id numpunct<_Elem>::id;

		
template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_get
		: public locale::facet
	{	
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xlocnum", 271) num_get<_Elem, _InIt>(
				_Locinfo(_Ploc->c_str()));
		return (4);
		}

	 static locale::id id;	

protected:
	virtual  ~num_get() throw ()
		{	
		}

	void _Init(const _Locinfo&)
		{	
		}

public:
	explicit  num_get(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _InIt iter_type;

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			_Bool& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			unsigned short& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			unsigned int& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

 
	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			__int64& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned __int64& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}
 #line 355 "d:\\programs overflow\\vc\\include\\xlocnum"

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

protected:
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			_Bool& _Val) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocnum", 389);
		int _Ans = -1;	

		if (_Iosbase.flags() & ios_base::boolalpha)
			{	
			typedef typename _Mystr::size_type _Mystrsize;
			const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
			_Mystr _Str((_Mystrsize)1, (char_type)0);
			_Str += _Punct_fac.falsename();
			_Str += (char_type)0;
			_Str += _Punct_fac.truename();	
			_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
			}
		else
			{	
			char _Ac[32], *_Ep;
			int _Errno = 0;
			const unsigned long _Ulo = :: _Stoulx(_Ac, &_Ep,
				_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
					_Iosbase.getloc()), &_Errno);
			if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)
				_Ans = _Ulo;
			}

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ans < 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans != 0;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned short& _Val) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocnum", 426);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
		const unsigned long _Ans =
			:: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || 0xffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = (unsigned short)(_Ac[0] == '-'
				? 0 -_Ans : _Ans);	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned int& _Val) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocnum", 449);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
		const unsigned long _Ans =
			:: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || 0xffffffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = _Ac[0] == '-' ? 0 -_Ans : _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocnum", 471);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const long _Ans = :: _Stolx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocnum", 491);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const unsigned long _Ans = :: _Stoulx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

 
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			__int64& _Val) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocnum", 512);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const __int64 _Ans = :: _Stollx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned __int64& _Val) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocnum", 532);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const unsigned __int64 _Ans = :: _Stoullx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}
 #line 548 "d:\\programs overflow\\vc\\include\\xlocnum"

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocnum", 553);
		char _Ac[8 + 36 + 16], *_Ep;
		int _Errno = 0;
		int _Hexexp = 0;
		float _Ans = :: _Stofx(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 0)
			_Ans = :: ldexpf(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocnum", 577);
		char _Ac[8 + 36 + 16], *_Ep;
		int _Errno = 0;
		int _Hexexp = 0;
		double _Ans = :: _Stodx(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 0)
			_Ans = :: ldexp(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocnum", 601);
		char _Ac[8 + 36 + 16], *_Ep;
		int _Errno = 0;
		int _Hexexp = 0;
		long double _Ans = :: _Stoldx(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 0)
			_Ans = :: ldexpl(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xlocnum", 625);
		char _Ac[32], *_Ep;
		int _Errno = 0;

 
		int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,
			_Iosbase.getloc());	
		const unsigned __int64 _Ans =
			(sizeof (void *) == sizeof (unsigned long))
				? (unsigned __int64):: _Stoulx(_Ac, &_Ep, _Base, &_Errno)
				: :: _Stoullx(_Ac, &_Ep, _Base, &_Errno);

 



#line 642 "d:\\programs overflow\\vc\\include\\xlocnum"

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = (void *)((char *)0 + _Ans);	
		return (_First);
		}

private:
	int __cdecl _Getifld(char *_Ac,
		_InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
			const locale& _Loc) const
		{	
		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Loc);
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Grouping.size() == 0
			? (_Elem)0 : _Punct_fac.thousands_sep();

		enum {
			_NUMGET_SIGNOFF = 22,
			_NUMGET_XOFF = 24};
		static const char _Src[] = {"0123456789ABCDEFabcdef-+Xx"};
		_Elem _Atoms[sizeof (_Src) - 1];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Loc);
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src) - 1], _Atoms);

		char *_Ptr = _Ac;

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		_Basefield &= ios_base::basefield;
		int _Base = _Basefield == ios_base::oct ? 8
			: _Basefield == ios_base::hex ? 16
			: _Basefield == ios_base::_Fmtzero ? 0 : 10;

		bool _Seendigit = false;	
		bool _Nonzero = false;	

		if (_First != _Last && *_First == _Atoms[0])
			{	
			_Seendigit = true, ++_First;
			if (_First != _Last && (*_First == _Atoms[_NUMGET_XOFF + 1]
					|| *_First == _Atoms[_NUMGET_XOFF])
				&& (_Base == 0 || _Base == 16))
				_Base = 16, _Seendigit = false, ++_First;
			else if (_Base == 0)
				_Base = 8;
			}

		size_t _Dlen = _Base == 0 || _Base == 10 ? 10
			: _Base == 8 ? 8 : 16 + 6;
		string _Groups((size_t)1, (char)_Seendigit);
		size_t _Group = 0;

		for (char *const _Pe = &_Ac[32 - 1];
			_First != _Last; ++_First)
			{	
			size_t _Idx = _Find_elem(_Atoms, *_First);
			if (_Idx < _Dlen)
				{	
				*_Ptr = _Src[_Idx];
				if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
					++_Ptr, _Nonzero = true;
				_Seendigit = true;
				if (_Groups[_Group] != 127)
					++_Groups[_Group];
				}
			else if (_Groups[_Group] == '\0'
				|| _Kseparator == (_Elem)0
				|| *_First != _Kseparator)
				break;	
			else
				{	
				_Groups.append((string::size_type)1, '\0');
				++_Group;
				}
			}

		if (_Group == 0)
			;	
		else if ('\0' < _Groups[_Group])
			++_Group;	
		else
			_Seendigit = false;	

		for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )
			if (*_Pg == 127)
				break;	
			else if ((0 < --_Group && *_Pg != _Groups[_Group])
				|| (0 == _Group && *_Pg < _Groups[_Group]))
				_Seendigit = false;	
			else if ('\0' < _Pg[1])
				++_Pg;	

		if (_Seendigit && !_Nonzero)
			*_Ptr++ = '0';	
		else if (!_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		return (_Base);
		}

	int __cdecl _Getffld(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	
		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)
			return (_Getffldx(_Ac, _First, _Last,
				_Iosbase, _Phexexp));	

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		char *_Ptr = _Ac;
		bool _Bad = false;

		enum {
			_NUMGET_SIGNOFF = 10,
			_NUMGET_EOFF = 12};
		static const char _Src[] = {"0123456789-+Ee"};
		_Elem _Atoms[sizeof (_Src) - 1];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src) - 1], _Atoms);

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		bool _Seendigit = false;	
		int _Significant = 0;	
		int _Pten = 0;	
		size_t _Idx;

		const char *_Pg = &_Grouping[0];
		if (*_Pg == 127 || *_Pg <= '\0')
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
					_Seendigit = true, ++_First)
				if (36 <= _Significant)
					++_Pten;	
				else if (_Idx == 0 && _Significant == 0)
					;	
				else
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
		else
			{	
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)
					{	
					_Seendigit = true;
					if (36 <= _Significant)
						++_Pten;	
					else if (_Idx == 0 && _Significant == 0)
						;	
					else
						{	
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}
					if (_Groups[_Group] != 127)
						++_Groups[_Group];
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					break;	
				else
					{	
					_Groups.append((size_t)1, '\0');
					++_Group;
					}
			if (_Group == 0)
				;	
			else if ('\0' < _Groups[_Group])
				++_Group;	
			else
				_Bad = true;	

			while (!_Bad && 0 < _Group)
				if (*_Pg == 127)
					break;	
				else if ((0 < --_Group && *_Pg != _Groups[_Group])
					|| (0 == _Group && *_Pg < _Groups[_Group]))
					_Bad = true;	
				else if ('\0' < _Pg[1])
					++_Pg;	
			}

		if (_Seendigit && _Significant == 0)
			*_Ptr++ = '0';	

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	

		if (_Significant == 0)
			{	
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, ++_First)
				--_Pten;	
			if (_Pten < 0)
				*_Ptr++ = '0', ++_Pten;	
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, ++_First)
			if (_Significant < 36)
				{	
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_NUMGET_EOFF + 1]
				|| *_First == _Atoms[_NUMGET_EOFF]))
			{	
			*_Ptr++ = 'e', ++_First;
			_Seendigit = false, _Significant = 0;

			if (_First == _Last)
				;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
				*_Ptr++ = '+', ++_First;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF])
				*_Ptr++ = '-', ++_First;	
			for (; _First != _Last && *_First == _Atoms[0]; )
				_Seendigit = true, ++_First;	
			if (_Seendigit)
				*_Ptr++ = '0';	
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, ++_First)
				if (_Significant < 8)
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		return (_Pten);
		}

	int __cdecl _Getffldx(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	
		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();

		enum {
			_NUMGET_SIGNOFF = 22,
			_NUMGET_XOFF = 24,
			_NUMGET_POFF = 26};
		static const char _Src[] = {"0123456789ABCDEFabcdef-+XxPp"};
		_Elem _Atoms[sizeof (_Src) - 1];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src) - 1], _Atoms);

		char *_Ptr = _Ac;
		bool _Bad = false;
		size_t _Idx;

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		*_Ptr++ = '0';
		*_Ptr++ = 'x';

		bool _Seendigit = false;	
		int _Significant = 0;	
		int _Phex = 0;	

		if (_First == _Last || *_First != _Atoms[0])
			;
		else if (++_First != _Last
			&& (*_First == _Atoms[_NUMGET_XOFF + 1]
				 || *_First == _Atoms[_NUMGET_XOFF]))
			++_First;	
		else
			_Seendigit = true;	

		const char *_Pg = &_Grouping[0];
		if (*_Pg == 127 || *_Pg <= '\0')
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
					_Seendigit = true, ++_First)
				if (36 <= _Significant)
					++_Phex;	
				else if (_Idx == 0 && _Significant == 0)
					;	
				else
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
		else
			{	
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				if ((_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF)
					{	
					_Seendigit = true;
					if (36 <= _Significant)
						++_Phex;	
					else if (_Idx == 0 && _Significant == 0)
						;	
					else
						{	
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}
					if (_Groups[_Group] != 127)
						++_Groups[_Group];
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					break;	
				else
					{	
					_Groups.append((size_t)1, '\0');
					++_Group;
					}
			if (_Group == 0)
				;	
			else if ('\0' < _Groups[_Group])
				++_Group;	
			else
				_Bad = true;	

			while (!_Bad && 0 < _Group)
				if (*_Pg == 127)
					break;	
				else if ((0 < --_Group && *_Pg != _Groups[_Group])
					|| (0 == _Group && *_Pg < _Groups[_Group]))
					_Bad = true;	
				else if ('\0' < _Pg[1])
					++_Pg;	
			}

		if (_Seendigit && _Significant == 0)
			*_Ptr++ = '0';	

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	

		if (_Significant == 0)
			{	
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, ++_First)
				--_Phex;	
			if (_Phex < 0)
				*_Ptr++ = '0', ++_Phex;	
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
				_Seendigit = true, ++_First)
			if (_Significant < 36)
				{	
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_NUMGET_POFF + 1]
				|| *_First == _Atoms[_NUMGET_POFF]))
			{	
			*_Ptr++ = 'p', ++_First;
			_Seendigit = false, _Significant = 0;

			if (_First == _Last)
				;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
				*_Ptr++ = '+', ++_First;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF])
				*_Ptr++ = '-', ++_First;	
			for (; _First != _Last && *_First == _Atoms[0]; )
				_Seendigit = true, ++_First;	
			if (_Seendigit)
				*_Ptr++ = '0';	
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
				_Seendigit = true, ++_First)
				if (_Significant < 8)
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		*_Phexexp = _Phex;	
		return (0);	
		}
	};

		
template<class _Elem,
	class _InIt>
	 locale::id num_get<_Elem, _InIt>::id;

		
template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_put
		: public locale::facet
	{	
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new(::std:: _DebugHeapTag_func(), "d:\\programs overflow\\vc\\include\\xlocnum", 1092) num_put<_Elem, _OutIt>(
				_Locinfo(_Ploc->c_str()));
		return (4);
		}

	 static locale::id id;	

protected:
	virtual  ~num_put() throw ()
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

public:
	explicit  num_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _OutIt iter_type;

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, _Bool _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

 
	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, __int64 _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned __int64 _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}
 #line 1157 "d:\\programs overflow\\vc\\include\\xlocnum"

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

protected:
	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, _Bool _Val) const
		{	
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xlocnum", 1180);
		if (!(_Iosbase.flags() & ios_base::boolalpha))
			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
		else
			{	
			const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
			_Mystr _Str;
			if (_Val)
				_Str.assign(_Punct_fac.truename());
			else
				_Str.assign(_Punct_fac.falsename());

			size_t _Fillcount = _Iosbase.width() <= 0
				|| (size_t)_Iosbase.width() <= _Str.size()
					? 0 : (size_t)_Iosbase.width() - _Str.size();

			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
				{	
				_Dest = _Rep(_Dest, _Fill, _Fillcount);
				_Fillcount = 0;
				}
			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	
			_Iosbase.width(0);
			return (_Rep(_Dest, _Fill, _Fillcount));	
			}
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
				_Iosbase.flags()), _Val)));
		}

 
	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, __int64 _Val) const
		{	
		char _Buf[2 * 32], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned __int64 _Val) const
		{	
		char _Buf[2 * 32], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
				_Iosbase.flags()), _Val)));
		}
 #line 1248 "d:\\programs overflow\\vc\\include\\xlocnum"

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	
		char _Buf[8 + 36 + 64], _Fmt[8];
		streamsize _Precision = _Iosbase.precision() <= 0
			&& !(_Iosbase.flags() & ios_base::fixed)
				? 6 : _Iosbase.precision();	
		int _Significance = 36 < _Precision
			? 36 : (int)_Precision;	
		_Precision -= _Significance;
		size_t _Beforepoint = 0;	
		size_t _Afterpoint = 0;	

		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed
			&& _Val * 0.5 != _Val)	
			{	
			bool _Signed = _Val < 0;
			if (_Signed)
				_Val = -_Val;

			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)
				_Val /= 1e10;	

			if (0 < _Val)
				for (; 10 <= _Precision && _Val <= 1e-35
					&& _Afterpoint < 5000; _Afterpoint += 10)
					{	
					_Val *= 1e10;
					_Precision -= 10;
					}

			if (_Signed)
				_Val = -_Val;
			}

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
			_Beforepoint, _Afterpoint, (size_t)_Precision,
				:: sprintf_s(_Buf, sizeof (_Buf),
					_Ffmt(_Fmt, 0, _Iosbase.flags()),
					_Significance, _Val)));	
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	
		char _Buf[8 + 36 + 64], _Fmt[8];
		streamsize _Precision = _Iosbase.precision() <= 0
			&& !(_Iosbase.flags() & ios_base::fixed)
				? 6 : _Iosbase.precision();	
		int _Significance = 36 < _Precision
			? 36 : (int)_Precision;	
		_Precision -= _Significance;
		size_t _Beforepoint = 0;	
		size_t _Afterpoint = 0;	

		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)
			{	
			bool _Signed = _Val < 0;
			if (_Signed)
				_Val = -_Val;

			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)
				_Val /= 1e10;	

			if (0 < _Val)
				for (; 10 <= _Precision && _Val <= 1e-35
					&& _Afterpoint < 5000; _Afterpoint += 10)
					{	
					_Val *= 1e10;
					_Precision -= 10;
					}

			if (_Signed)
				_Val = -_Val;
			}

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
			_Beforepoint, _Afterpoint, (size_t)_Precision,
				:: sprintf_s(_Buf, sizeof (_Buf),
					_Ffmt(_Fmt, 'L', _Iosbase.flags()),
					_Significance, _Val)));	
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	
		char _Buf[2 * 32];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), "%p", _Val)));
		}

private:
	char *__cdecl _Ffmt(char *_Fmt,
		char _Spec, ios_base::fmtflags _Flags) const
		{	
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showpoint)
			*_Ptr++ = '#';
		*_Ptr++ = '.';
		*_Ptr++ = '*';	
		if (_Spec != '\0')
			*_Ptr++ = _Spec;	

		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
		if (_Flags & ios_base::uppercase)
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'A'	
				: _Ffl == ios_base::scientific ? 'E' : 'G';	
		else
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'a'	
				: _Ffl == ios_base::scientific ? 'e' : 'g';	

		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Fput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
			size_t _Beforepoint, size_t _Afterpoint,
				size_t _Trailing, size_t _Count) const
		{	
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xlocnum", 1376);
		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
			? 1 : 0;

		const char *_Exps;
		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)
			_Exps = "eE";
		else
			{	
			_Exps = "pP";
			if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
				&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
				_Prefix += 2;
			}
		const size_t _Eoff =
			:: strcspn(&_Buf[0], _Exps);	
		char _Dp[2] = {"."};
		_Dp[0] = :: localeconv()->decimal_point[0];
		const size_t _Poff =
			:: strcspn(&_Buf[0], &_Dp[0]);	

		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		const _Elem _E0 = _Ctype_fac.widen('0');
		_Mystr _Groupstring(_Count, _Elem(0));	
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Punct_fac.thousands_sep();

		size_t _Off = _Beforepoint;	
		if (_Poff == _Count)
			{	
			_Off += _Eoff;
			_Groupstring.insert(_Eoff, _Beforepoint, _E0);
			}
		else
			{	
			_Off += _Poff;
			_Groupstring.insert(_Eoff, _Trailing, _E0);
			_Groupstring.insert(_Poff + 1, _Afterpoint, _E0);
			_Groupstring[_Poff] = _Punct_fac.decimal_point();
			_Groupstring.insert(_Poff, _Beforepoint, _E0);
			}

		const char *_Pg = &_Grouping[0];
		while (*_Pg != 127 && '\0' < *_Pg
			&& (size_t)*_Pg < _Off - _Prefix)
			{	
			_Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);
			if ('\0' < _Pg[1])
				++_Pg;	
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	
		}

	char *__cdecl _Ifmt(char *_Fmt,
		const char *_Spec, ios_base::fmtflags _Flags) const
		{	
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showbase)
			*_Ptr++ = '#';
		if (_Spec[0] != 'L')
			*_Ptr++ = _Spec[0];	
		else

			{	
			*_Ptr++ = 'I';
			*_Ptr++ = '6';
			*_Ptr++ = '4';
			}

		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
			: _Basefield != ios_base::hex ? _Spec[1]	
			: _Flags & ios_base::uppercase ? 'X' : 'x';
		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Iput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, char *_Buf, size_t _Count) const
		{	
		_Debug_pointer(_Dest, L"d:\\programs overflow\\vc\\include\\xlocnum", 1490);
		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
			? 1 : 0;
		if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
			&& _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
			_Prefix += 2;

		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Mystr _Groupstring(_Count, _Elem(0));	
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const char *_Pg = &_Grouping[0];
		if (*_Pg != 127 && '\0' < *_Pg)
			{	
			const _Elem _Kseparator = _Punct_fac.thousands_sep();
			while (*_Pg != 127 && '\0' < *_Pg
				&& (size_t)*_Pg < _Count - _Prefix)
				{	
				_Count -= *_Pg;
				_Groupstring.insert(_Count, 1, _Kseparator);
				if ('\0' < _Pg[1])
					++_Pg;	
				}
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	
		}

	_OutIt __cdecl _Put(_OutIt _Dest,
		const _Elem *_Ptr, size_t _Count) const
		{	
		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)
			*_Dest = *_Ptr;
		return (_Dest);
		}

	_OutIt __cdecl _Rep(_OutIt _Dest,
		_Elem _Ch, size_t _Count) const
		{	
		for (; 0 < _Count; --_Count, ++_Dest)
			*_Dest = _Ch;
		return (_Dest);
		}
	};

		
template<class _Elem,
	class _OutIt>
	 locale::id num_put<_Elem, _OutIt>::id;

 

  
template  locale::id numpunct<char>::id;
template class __declspec(dllimport) num_get<char,
	istreambuf_iterator<char, char_traits<char> > >;
template class __declspec(dllimport) num_put<char,
	ostreambuf_iterator<char, char_traits<char> > >;

template  locale::id numpunct<wchar_t>::id;
template class __declspec(dllimport) num_get<wchar_t,
	istreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
template class __declspec(dllimport) num_put<wchar_t,
	ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
  #line 1584 "d:\\programs overflow\\vc\\include\\xlocnum"

  






 #line 1593 "d:\\programs overflow\\vc\\include\\xlocnum"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1598 "d:\\programs overflow\\vc\\include\\xlocnum"
#line 1599 "d:\\programs overflow\\vc\\include\\xlocnum"






#line 7 "d:\\programs overflow\\vc\\include\\ios"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)

namespace std {
		
template<class _Elem,
	class _Traits>
	class basic_ios
		: public ios_base
	{	
public:
	typedef basic_ios<_Elem, _Traits> _Myt;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ctype<_Elem> _Ctype;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_ios(_Mysb *_Strbuf)
		{	
		init(_Strbuf);
		}

	virtual  ~basic_ios() throw ()
		{	
		}

	void  clear(iostate _State = goodbit,
		bool _Reraise = false)
		{	
		ios_base::clear((iostate)(_Mystrbuf == 0
			? (int)_State | (int)badbit : (int)_State), _Reraise);
		}

	void  clear(io_state _State)
		{	
		clear((iostate)_State);
		}

	void  setstate(iostate _State,
		bool _Reraise = false)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Reraise);
		}

	void  setstate(io_state _State)
		{	
		setstate((iostate)_State);
		}

	_Myt&  copyfmt(const _Myt& _Right)
		{	
		_Tiestr = _Right.tie();
		_Fillch = _Right.fill();
		ios_base::copyfmt(_Right);
		return (*this);
		}

	_Myos * tie() const
		{	
		return (_Tiestr);
		}

	_Myos * tie(_Myos *_Newtie)
		{	
		_Myos *_Oldtie = _Tiestr;
		_Tiestr = _Newtie;
		return (_Oldtie);
		}

	_Mysb * rdbuf() const
		{	
		return (_Mystrbuf);
		}

	_Mysb * rdbuf(_Mysb *_Strbuf)
		{	
		_Mysb *_Oldstrbuf = _Mystrbuf;
		_Mystrbuf = _Strbuf;
		clear();
		return (_Oldstrbuf);
		}

	locale  imbue(const locale& _Loc)
		{	
		locale _Oldlocale = ios_base::imbue(_Loc);
		if (rdbuf() != 0)
			rdbuf()->pubimbue(_Loc);
		return (_Oldlocale);
		}

	_Elem  fill() const
		{	
		return (_Fillch);
		}

	_Elem  fill(_Elem _Newfill)
		{	
		_Elem _Oldfill = _Fillch;
		_Fillch = _Newfill;
		return (_Oldfill);
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
		return (_Ctype_fac.narrow(_Ch, _Dflt));
		}

	_Elem  widen(char _Byte) const
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
		return (_Ctype_fac.widen(_Byte));
		}

	void  move(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mystrbuf = 0;
			_Tiestr = 0;
			this->swap(_Right);
			}
		}

	void  move(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Mystrbuf = 0;
			_Tiestr = 0;
			this->swap(_Right);
			}
		}

	void  swap(_Myt& _Right) throw ()
		{	
		ios_base::swap(_Right);
		::std:: swap(_Fillch, _Right._Fillch);
		::std:: swap(_Tiestr, _Right._Tiestr);
		}

	void  set_rdbuf(_Mysb *_Strbuf)
		{	
		_Mystrbuf = _Strbuf;
		}

protected:
	void  init(_Mysb *_Strbuf = 0,
		bool _Isstd = false)
		{	
		_Init();	
		_Mystrbuf = _Strbuf;
		_Tiestr = 0;
		_Fillch = widen(' ');

		if (_Mystrbuf == 0)
			setstate(badbit);

		if (_Isstd)
			_Addstd(this);	
		}

	 basic_ios()
		{	
		}

private:
	_Mysb *_Mystrbuf;	
	_Myos *_Tiestr;	
	_Elem _Fillch;	

public:
	 basic_ios(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;
	};

 

  
template class __declspec(dllimport) basic_ios<char,
	char_traits<char> >;
template class __declspec(dllimport) basic_ios<wchar_t,
	char_traits<wchar_t> >;
  #line 201 "d:\\programs overflow\\vc\\include\\ios"

  



 #line 207 "d:\\programs overflow\\vc\\include\\ios"

		
inline ios_base& __cdecl boolalpha(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl dec(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::dec, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl defaultfloat(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl fixed(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::fixed, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hex(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::hex, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hexfloat(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
	return (_Iosbase);
	}

namespace tr1 {	
using ::std:: hexfloat;
}	

inline ios_base& __cdecl internal(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::internal, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl left(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::left, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowbase(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpos(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl noskipws(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl nouppercase(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::uppercase);
	return (_Iosbase);
	}

inline ios_base& __cdecl oct(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::oct, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl right(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::right, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl scientific(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::scientific, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl showbase(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpoint(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpos(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl skipws(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl unitbuf(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl uppercase(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::uppercase);
	return (_Iosbase);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 362 "d:\\programs overflow\\vc\\include\\ios"
#line 363 "d:\\programs overflow\\vc\\include\\ios"





#line 7 "d:\\programs overflow\\vc\\include\\ostream"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189 4390)

namespace std {
		

 
 

 



 



 



#line 34 "d:\\programs overflow\\vc\\include\\ostream"

 #pragma vtordisp(push, 2)	

		
template<class _Elem,
	class _Traits>
	class basic_ostream
		: virtual public basic_ios<_Elem, _Traits>
	{	
public:
	typedef basic_ostream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
	typedef num_put<_Elem, _Iter> _Nput;

	explicit  basic_ostream(
		basic_streambuf<_Elem, _Traits> *_Strbuf,

		bool _Isstd = false)
		{	
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_ostream(_Uninitialized, bool _Addit = true)
		{	
		if (_Addit)
			this->_Addstd(this);	
		}

protected:
	 basic_ostream(_Myt&& _Right)
		{	
		_Myios::init();
		_Myios::move(::std:: move(_Right));
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			_Myios::swap(_Right);
		}

public:
	 basic_ostream(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;

	virtual  ~basic_ostream() throw ()
		{	
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	class _Sentry_base
		{	
	public:
		 _Sentry_base(_Myt& _Ostr)
			: _Myostr(_Ostr)
			{	
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Lock();
			}

		 ~_Sentry_base() throw ()
			{	
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Unlock();
			}

		_Myt& _Myostr;	

	private:
		_Sentry_base& operator=(const _Sentry_base&);
		};

	class sentry
		: public _Sentry_base
		{	
	public:
		explicit  sentry(_Myt& _Ostr)
			: _Sentry_base(_Ostr)
			{	
			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)
				_Ostr.tie()->flush();
			_Ok = _Ostr.good();	
			}

		 ~sentry() throw ()
			{	
 
			if (!::std:: uncaught_exception())
				this->_Myostr._Osfx();

 

#line 138 "d:\\programs overflow\\vc\\include\\ostream"
			}

		explicit  operator bool() const
			{	
			return (_Ok);
			}

	private:
		bool _Ok;	

	public:
		 sentry(const sentry&) = delete;
		sentry&  operator=(const sentry&) = delete;
		};

	bool  opfx()
		{	
		if (this->good() && _Myios::tie() != 0 && _Myios::tie() != this)
			_Myios::tie()->flush();
		return (this->good());
		}

	void  osfx()
		{	
		_Osfx();
		}

	void  _Osfx()
		{	
		try {
		if (this->good() && this->flags() & ios_base::unitbuf)
			if (_Myios::rdbuf()->pubsync() == -1)	
				_Myios::setstate(ios_base::badbit);
		} catch (...) {
		}
		}

  





















	_Myt&  operator<<(_Myt& (__cdecl *_Pfn)(_Myt&))
		{	
		_Debug_pointer(_Pfn, L"d:\\programs overflow\\vc\\include\\ostream", 199);
		return ((*_Pfn)(*this));
		}

	_Myt&  operator<<(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	
		_Debug_pointer(_Pfn, L"d:\\programs overflow\\vc\\include\\ostream", 205);
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt&  operator<<(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	
		_Debug_pointer(_Pfn, L"d:\\programs overflow\\vc\\include\\ostream", 212);
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt&  operator<<(_Bool _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(short _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned short)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}










	_Myt&  operator<<(unsigned short _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(int _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned int)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned int _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

 
	_Myt&  operator<<(__int64 _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned __int64 _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}
 #line 417 "d:\\programs overflow\\vc\\include\\ostream"

	_Myt&  operator<<(float _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (double)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(double _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long double _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(const void *_Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(_Mysb *_Strbuf)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			for (int_type _Meta = _Traits::eof(); ; _Copied = true)
				{	
				try {
				_Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
					? _Strbuf->sgetc() : _Strbuf->snextc();
				} catch (...) {
					_Myios::setstate(ios_base::failbit);
					throw;
				}

				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					break;	

				try {
					if (_Traits::eq_int_type(_Traits::eof(),
						_Myios::rdbuf()->sputc(
							_Traits::to_char_type(_Meta))))
						{	
						_State |= ios_base::badbit;
						break;
						}
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

		this->width(0);
		_Myios::setstate(_Strbuf == 0 ? ios_base::badbit
			: !_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt&  put(_Elem _Ch)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputc(_Ch)))
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  write(const _Elem *_Str,
		streamsize _Count)
		{	
 
		if (0 < _Count)
			_Debug_pointer(_Str, L"d:\\programs overflow\\vc\\include\\ostream", 560);
 #line 562 "d:\\programs overflow\\vc\\include\\ostream"

		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else
			{	
			try {
			if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  flush()
		{	
		if (_Myios::rdbuf() != 0)
			{	
			const sentry _Ok(*this);

			if (_Ok && _Myios::rdbuf()->pubsync() == -1)
				_Myios::setstate(ios_base::badbit);	
			}
		return (*this);
		}

	_Myt&  seekp(pos_type _Pos)
		{	
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	_Myt&  seekp(off_type _Off, ios_base::seekdir _Way)
		{	
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	pos_type  tellp()
		{	
		const sentry _Ok(*this);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::out));
		else
			return (pos_type(_BADOFF));
		}
	};

 #pragma vtordisp(pop)	

	

  

















































 

  
template class __declspec(dllimport) basic_ostream<char,
	char_traits<char> >;
template class __declspec(dllimport) basic_ostream<wchar_t,
	char_traits<wchar_t> >;
  #line 688 "d:\\programs overflow\\vc\\include\\ostream"

  



 #line 694 "d:\\programs overflow\\vc\\include\\ostream"

		

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const char *_Val)
	{	
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize):: strlen(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, char _Ch)
	{	
	ios_base::iostate _State = ios_base::goodbit;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr,
		const char *_Val)
	{	
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, char _Ch)
	{	
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const _Elem *_Val)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const signed char *_Val)
	{	
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
	{	
	return (_Ostr << (char)_Ch);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const unsigned char *_Val)
	{	
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
	{	
	return (_Ostr << (char)_Ch);
	}

template<class _Elem,
	class _Traits,
	class _Ty> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>&& _Ostr, const _Ty& _Val)
	{	
	return (_Ostr << _Val);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl endl(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.put(_Ostr.widen('\n'));
	_Ostr.flush();
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.put(_Elem());
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.flush();
	return (_Ostr);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
			const error_code& _Errcode)
	{	
	return (_Ostr << _Errcode.category().name() << ':' << _Errcode.value());
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1037 "d:\\programs overflow\\vc\\include\\ostream"
#line 1038 "d:\\programs overflow\\vc\\include\\ostream"





#line 7 "d:\\programs overflow\\vc\\include\\istream"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)

namespace std {
 #pragma vtordisp(push, 2)	

		
template<class _Elem,
	class _Traits>
	class basic_istream
		: virtual public basic_ios<_Elem, _Traits>
	{	
public:
	typedef basic_istream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef istreambuf_iterator<_Elem, _Traits> _Iter;
	typedef ctype<_Elem> _Ctype;
	typedef num_get<_Elem, _Iter> _Nget;

  







#line 41 "d:\\programs overflow\\vc\\include\\istream"

	explicit  basic_istream(_Mysb *_Strbuf,
		bool _Isstd = false)

		: _Chcount(0)
		{	
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_istream(_Uninitialized)
		{	
		this->_Addstd(this);
		}

protected:
	 basic_istream(_Myt&& _Right)
		: _Chcount(_Right._Chcount)
		{	
		_Myios::init();
		_Myios::move(::std:: move(_Right));
		_Right._Chcount = 0;
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		_Myios::swap(_Right);
		::std:: swap(_Chcount, _Right._Chcount);
		}

public:
	 basic_istream(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;

	virtual  ~basic_istream() throw ()
		{	
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

		
	class _Sentry_base
		{	
	public:
		 _Sentry_base(_Myt& _Istr)
			: _Myistr(_Istr)
			{	
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Lock();
			}

		 ~_Sentry_base() throw ()
			{	
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Unlock();
			}

		_Myt& _Myistr;	

	private:
		_Sentry_base& operator=(const _Sentry_base&);
		};

	class sentry
		: public _Sentry_base
		{	
	public:
		explicit  sentry(_Myt& _Istr, bool _Noskip = false)
			: _Sentry_base(_Istr)
			{	
			_Ok = this->_Myistr._Ipfx(_Noskip);
			}

		explicit  operator bool() const
			{	
			return (_Ok);
			}

	private:
		bool _Ok;	

	public:
		 sentry(const sentry&) = delete;
		sentry&  operator=(const sentry&) = delete;
		};

	bool  _Ipfx(bool _Noskip = false)
		{	
		if (this->good())
			{	
			if (_Myios::tie() != 0)
				_Myios::tie()->flush();

			if (!_Noskip && this->flags() & ios_base::skipws)
				{	
				const _Ctype& _Ctype_fac = use_facet< _Ctype >(this->getloc());

				try {
				int_type _Meta = _Myios::rdbuf()->sgetc();

				for (; ; _Meta = _Myios::rdbuf()->snextc())
					if (_Traits::eq_int_type(_Traits::eof(), _Meta))
						{	
						_Myios::setstate(ios_base::eofbit);
						break;
						}
					else if (!_Ctype_fac.is(_Ctype::space,
						_Traits::to_char_type(_Meta)))
						break;	
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

			if (this->good())
				return (true);
			}
		_Myios::setstate(ios_base::failbit);
		return (false);
		}

	bool  ipfx(bool _Noskip = false)
		{	
		return (_Ipfx(_Noskip));
		}

	void  isfx()
		{	
		}

  





















	_Myt&  operator>>(_Myt& (__cdecl *_Pfn)(_Myt&))
		{	
		_Debug_pointer(_Pfn, L"d:\\programs overflow\\vc\\include\\istream", 200);
		return ((*_Pfn)(*this));
		}

	_Myt&  operator>>(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	
		_Debug_pointer(_Pfn, L"d:\\programs overflow\\vc\\include\\istream", 206);
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt&  operator>>(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	
		_Debug_pointer(_Pfn, L"d:\\programs overflow\\vc\\include\\istream", 213);
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt&  operator>>(_Bool& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(short& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			long _Tmp = 0;
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-32768) || 32767 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = (short)_Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}










	_Myt&  operator>>(unsigned short& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(int& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			long _Tmp = 0;
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-2147483647 - 1) || 2147483647 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = _Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned int& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

 
	_Myt&  operator>>(__int64& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned __int64& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}
 #line 410 "d:\\programs overflow\\vc\\include\\istream"

	_Myt&  operator>>(float& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(double& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long double& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(void *& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(_Mysb *_Strbuf)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					try {
						if (_Traits::eq_int_type(_Traits::eof(),
							_Strbuf->sputc(_Traits::to_char_type(_Meta))))
							break;
					} catch (...) {
						break;
					}
					_Copied = true;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(!_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	int_type  get()
		{	
		int_type _Meta = 0;
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	
		else
			{	
			try {
			_Meta = _Myios::rdbuf()->sgetc();

			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				_State |= ios_base::eofbit | ios_base::failbit;	
			else
				{	
				_Myios::rdbuf()->sbumpc();
				++_Chcount;
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt&  get(_Elem *_Str, streamsize _Count)
		{	
		return (get(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt&  get(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	
		_Debug_pointer(_Str, L"d:\\programs overflow\\vc\\include\\istream", 556);
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Traits::to_char_type(_Meta) == _Delim)
					break;	
				else
					{	
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_Chcount == 0
			? _State | ios_base::failbit : _State);
		*_Str = _Elem();	
		return (*this);
		}

	_Myt&  get(_Elem& _Ch)
		{	
		int_type _Meta = get();
		if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
			_Ch = _Traits::to_char_type(_Meta);
		return (*this);
		}

	_Myt&  get(_Mysb& _Strbuf)
		{	
		return (get(_Strbuf, _Myios::widen('\n')));
		}

	_Myt&  get(_Mysb& _Strbuf, _Elem _Delim)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					try {
						_Elem _Ch = _Traits::to_char_type(_Meta);
						if (_Ch == _Delim
							|| _Traits::eq_int_type(_Traits::eof(),
								_Strbuf.sputc(_Ch)))
							break;
					} catch (...) {
						break;
					}
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		if (_Chcount == 0)
			_State |= ios_base::failbit;
		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  getline(_Elem *_Str, streamsize _Count)
		{	
		return (getline(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt&  getline(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	
		_Debug_pointer(_Str, L"d:\\programs overflow\\vc\\include\\istream", 648);
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			int_type _Metadelim = _Traits::to_int_type(_Delim);

			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Meta == _Metadelim)
					{	
					++_Chcount;
					_Myios::rdbuf()->sbumpc();
					break;
					}
				else if (--_Count <= 0)
					{	
					_State |= ios_base::failbit;
					break;
					}
				else
					{	
					++_Chcount;
					*_Str++ = _Traits::to_char_type(_Meta);
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		*_Str = _Elem();	
		_Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt&  ignore(streamsize _Count = 1,
		int_type _Metadelim = _Traits::eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			for (; ; )
				{	
				int_type _Meta;
				if (_Count != 2147483647 && --_Count < 0)
					break;	
				else if (_Traits::eq_int_type(_Traits::eof(),
					_Meta = _Myios::rdbuf()->sbumpc()))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					++_Chcount;
					if (_Meta == _Metadelim)
						break;	
					}
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  read(_Elem *_Str, streamsize _Count)
		{	
		_Debug_pointer(_Str, L"d:\\programs overflow\\vc\\include\\istream", 727);
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
			_Chcount += _Num;
			if (_Num != _Count)
				_State |= ios_base::eofbit | ios_base::failbit;	
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize  readsome(_Elem *_Str,
		streamsize _Count)
		{	
		_Debug_pointer(_Str, L"d:\\programs overflow\\vc\\include\\istream", 749);
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		streamsize _Num;

		if (!_Ok)
			_State |= ios_base::failbit;	
		else if ((_Num = _Myios::rdbuf()->in_avail()) < 0)
			_State |= ios_base::eofbit;	
		else if (0 < _Num)
			read(_Str, _Num < _Count ? _Num : _Count);	

		_Myios::setstate(_State);
		return (gcount());
		}

	int_type  peek()
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		int_type _Meta = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	
		else
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Meta = _Myios::rdbuf()->sgetc()))
				_State |= ios_base::eofbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt&  putback(_Elem _Ch)
		{	
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputbackc(_Ch)))
				_State |= ios_base::badbit | _Oldstate;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  unget()
		{	
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sungetc()))
				_State |= ios_base::badbit | _Oldstate;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize  gcount() const
		{	
		return (_Chcount);
		}

	int  sync()
		{	
		const sentry _Ok(*this, true);

		if (_Myios::rdbuf() == 0)
			return (-1);
		else if (_Myios::rdbuf()->pubsync() == -1)
			{	
			_Myios::setstate(ios_base::badbit);
			return (-1);
			}
		else
			return (0);
		}

	_Myt&  seekg(pos_type _Pos)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::in) == _BADOFF)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	_Myt&  seekg(off_type _Off, ios_base::seekdir _Way)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::in) == _BADOFF)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	pos_type  tellg()
		{	
		const sentry _Ok(*this, true);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::in));
		else
			return (pos_type(_BADOFF));
		}

private:
	streamsize _Chcount;	
	};

	

 #pragma vtordisp(pop)	

  






















 

  
template class __declspec(dllimport) basic_istream<char, char_traits<char> >;
template class __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >;
  #line 926 "d:\\programs overflow\\vc\\include\\istream"

  



 #line 932 "d:\\programs overflow\\vc\\include\\istream"

		
template<class _Elem,
	class _Traits>
	class basic_iostream
	: public basic_istream<_Elem, _Traits>,
		public basic_ostream<_Elem, _Traits>
	{	
public:
	typedef basic_iostream<_Elem, _Traits> _Myt;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_iostream(basic_streambuf<_Elem, _Traits> *_Strbuf)
		: _Myis(_Strbuf, false),
			_Myos(_Noinit, false)
		{	
		}

protected:
	 basic_iostream(_Myt&& _Right)
		: _Myis(_Right.rdbuf(), false),
			_Myos(_Noinit, false)
		{	
		_Myios::init();
		_Myios::move(::std:: forward<_Myt>(_Right));
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			_Myios::swap(_Right);
		}

public:
	 basic_iostream(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;

	virtual  ~basic_iostream() throw ()
		{	
		}
	};

	

 

  
template class __declspec(dllimport) basic_iostream<char, char_traits<char> >;
template class __declspec(dllimport) basic_iostream<wchar_t, char_traits<wchar_t> >;
  #line 995 "d:\\programs overflow\\vc\\include\\istream"

  



 #line 1001 "d:\\programs overflow\\vc\\include\\istream"

		

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem *_Str)
	{	
	_Debug_pointer(_Str, L"d:\\programs overflow\\vc\\include\\istream", 1009);
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;
	ios_base::iostate _State = ios_base::goodbit;
	_Elem *_Str0 = _Str;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

		try {
		streamsize _Count = 0 < _Istr.width() ? _Istr.width() : 2147483647;
		typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
		_Elem _Ch;
		for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Ch = _Traits::to_char_type(_Meta))
					|| _Ch == _Elem())
				break;	
			else
				*_Str++ = _Traits::to_char_type(_Meta);	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	*_Str = _Elem();	
	_Istr.width(0);
	_Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;

	typename _Myis::int_type _Meta;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		try {
		_Meta = _Istr.rdbuf()->sbumpc();
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			_State |= ios_base::eofbit | ios_base::failbit;	
		else
			_Ch = _Traits::to_char_type(_Meta);	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char *_Str)
	{	
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char& _Ch)
	{	
	return (_Istr >> (char&)_Ch);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char *_Str)
	{	
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char& _Ch)
	{	
	return (_Istr >> (char&)_Ch);
	}

template<class _Elem,
	class _Traits,
	class _Ty> inline
	basic_istream<_Elem, _Traits>&
		operator>>(basic_istream<_Elem, _Traits>&& _Istr, _Ty& _Val)
	{	
	return (_Istr >> _Val);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>&
		__cdecl ws(basic_istream<_Elem, _Traits>& _Istr)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;

	if (!_Istr.eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const typename _Myis::sentry _Ok(_Istr, true);

		if (_Ok)
			{	
			const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

			try {
			for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(_Ctype::space,
					_Traits::to_char_type(_Meta)))
					break;	
			} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}

__declspec(dllimport) inline basic_istream<char, char_traits<char> >&
	__cdecl ws(basic_istream<char, char_traits<char> >& _Istr)
	{	
	typedef char _Elem;
	typedef char_traits<_Elem> _Traits;

	if (!_Istr.eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

		if (_Ok)
			{	
			const ctype<_Elem>& _Ctype_fac =
				use_facet< ctype<_Elem> >(_Istr.getloc());

			try {
			for (_Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(ctype<_Elem>::space,
					_Traits::to_char_type(_Meta)))
					break;	
			} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}

__declspec(dllimport) inline basic_istream<wchar_t, char_traits<wchar_t> >&
	__cdecl ws(basic_istream<wchar_t, char_traits<wchar_t> >& _Istr)
	{	
	typedef wchar_t _Elem;
	typedef char_traits<_Elem> _Traits;

	if (!_Istr.eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

		if (_Ok)
			{	
			const ctype<_Elem>& _Ctype_fac =
				use_facet< ctype<_Elem> >(_Istr.getloc());

			try {
			for (_Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(ctype<_Elem>::space,
					_Traits::to_char_type(_Meta)))
					break;	
			} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}

 
__declspec(dllimport) inline basic_istream<unsigned short, char_traits<unsigned short> >&
	__cdecl ws(basic_istream<unsigned short, char_traits<unsigned short> >& _Istr)
	{	
	typedef unsigned short _Elem;
	typedef char_traits<_Elem> _Traits;

	if (!_Istr.eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

		if (_Ok)
			{	
			const ctype<_Elem>& _Ctype_fac =
				use_facet< ctype<_Elem> >(_Istr.getloc());

			try {
			for (_Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(ctype<_Elem>::space,
					_Traits::to_char_type(_Meta)))
					break;	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}
 #line 1251 "d:\\programs overflow\\vc\\include\\istream"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1257 "d:\\programs overflow\\vc\\include\\istream"
#line 1258 "d:\\programs overflow\\vc\\include\\istream"






#line 7 "d:\\programs overflow\\vc\\include\\fstream"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
 #pragma warning(disable: 4127)

extern __declspec(dllimport) _iobuf *__cdecl _Fiopen(
	const char *,
	ios_base::openmode, int);
extern __declspec(dllimport) _iobuf *__cdecl _Fiopen(
	const wchar_t *,
	ios_base::openmode, int);

 
extern __declspec(dllimport) _iobuf *__cdecl _Fiopen(
	const unsigned short *,
	ios_base::openmode, int);
 #line 28 "d:\\programs overflow\\vc\\include\\fstream"

		
template<class _Elem> inline
	bool _Fgetc(_Elem& _Ch, _iobuf *_File)
	{	
	return (fread(&_Ch, sizeof (_Elem), 1, _File) == 1);
	}

template<> inline bool _Fgetc(char& _Byte, _iobuf *_File)
	{	
	int _Meta;
	if ((_Meta = fgetc(_File)) == (-1))
		return (false);
	else
		{	
		_Byte = (char)_Meta;
		return (true);
		}
	}

template<> inline bool _Fgetc(wchar_t& _Wchar, _iobuf *_File)
	{	
	wint_t _Meta;
	if ((_Meta = :: fgetwc(_File)) == (wint_t)(0xFFFF))
		return (false);
	else
		{	
		_Wchar = (wchar_t)_Meta;
		return (true);
		}
	}

 
template<> inline bool _Fgetc(unsigned short& _Wchar, _iobuf *_File)
	{	
	wint_t _Meta;
	if ((_Meta = :: fgetwc(_File)) == (wint_t)(0xFFFF))
		return (false);
	else
		{	
		_Wchar = (unsigned short)_Meta;
		return (true);
		}
	}
 #line 73 "d:\\programs overflow\\vc\\include\\fstream"

		
template<class _Elem> inline
	bool _Fputc(_Elem _Ch, _iobuf *_File)
	{	
	return (fwrite(&_Ch, 1, sizeof (_Elem), _File) == sizeof (_Elem));
	}

template<> inline bool _Fputc(char _Byte, _iobuf *_File)
	{	
	return (fputc(_Byte, _File) != (-1));
	}

template<> inline bool _Fputc(wchar_t _Wchar, _iobuf *_File)
	{	
	return (:: fputwc(_Wchar, _File) != (wint_t)(0xFFFF));
	}

 
template<> inline bool _Fputc(unsigned short _Wchar, _iobuf *_File)
	{	
	return (:: fputwc(_Wchar, _File) != (wint_t)(0xFFFF));
	}
 #line 97 "d:\\programs overflow\\vc\\include\\fstream"

		
template<class _Elem> inline
	bool _Ungetc(const _Elem& _Ch, _iobuf *_File)
	{	
	return (false);
	}

template<> inline bool _Ungetc(const char& _Byte, _iobuf *_File)
	{	
	return (ungetc((unsigned char)_Byte, _File) != (-1));
	}

template<> inline bool _Ungetc(const signed char& _Byte, _iobuf *_File)
	{	
	return (ungetc((unsigned char)_Byte, _File) != (-1));
	}

template<> inline bool _Ungetc(const unsigned char& _Byte, _iobuf *_File)
	{	
	return (ungetc(_Byte, _File) != (-1));
	}

template<> inline bool _Ungetc(const wchar_t& _Wchar, _iobuf *_File)
	{	
	return (:: ungetwc(_Wchar, _File) != (wint_t)(0xFFFF));
	}

 
template<> inline bool _Ungetc(const unsigned short& _Wchar, _iobuf *_File)
	{	
	return (:: ungetwc(_Wchar, _File) != (wint_t)(0xFFFF));
	}
 #line 131 "d:\\programs overflow\\vc\\include\\fstream"

		
template<class _Elem,
	class _Traits>
	class basic_filebuf
		: public basic_streambuf<_Elem, _Traits>
	{	
public:
	typedef basic_filebuf<_Elem, _Traits> _Myt;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef typename _Traits::state_type _Myst;
	typedef codecvt<_Elem, char, typename _Traits::state_type> _Cvt;

	basic_filebuf(_iobuf *_File = 0)
		: _Mysb()
		{	
		_Init(_File, _Newfl);
		}

	virtual  ~basic_filebuf() throw ()
		{	
		if (_Myfile != 0)
			_Reset_back();	
		if (_Closef)
			close();
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	basic_filebuf(_Uninitialized)
		: _Mysb(_Noinit)
		{	
		}

	basic_filebuf(_Myt&& _Right)
		{	
		_Init(_Right._Myfile, _Newfl);	
		_Init((_iobuf *)0, _Closefl);	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			
			_iobuf *_Myfile_sav = _Myfile;
			const _Cvt *_Pcvt_sav = _Pcvt;
			typename _Traits::state_type _State_sav = _State;
			bool _Wrotesome_sav = _Wrotesome;
			bool _Closef_sav = _Closef;
			bool _Set_eback_sav = _Mysb::eback() == &_Mychar;
			bool _Set_eback_live = _Mysb::gptr() == &_Mychar;

			_Elem *_Pfirst = _Mysb::pbase();
			_Elem *_Pnext = _Mysb::pptr();
			_Elem *_Pend = _Mysb::epptr();
			_Elem *_Gfirst = _Mysb::eback();
			_Elem *_Gnext = _Mysb::gptr();
			_Elem *_Gend = _Mysb::egptr();

			
			_Init(_Right._Myfile, _Right._Myfile != 0 ? _Openfl : _Newfl);
			_Mysb::setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			if (_Right.eback() != &_Right._Mychar)
				_Mysb::setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			else if (_Right.gptr() != &_Right._Mychar)
				_Mysb::setg(&_Mychar, &_Mychar + 1, &_Mychar + 1);
			else
				_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);

			_Pcvt = _Right._Pcvt;
			_State = _Right._State;
			_Wrotesome = _Right._Wrotesome;
			_Closef = _Right._Closef;

			
			_Right._Init(_Myfile_sav, _Myfile_sav != 0 ? _Openfl : _Newfl);
			_Right.setp(_Pfirst, _Pnext, _Pend);
			if (!_Set_eback_sav)
				_Right.setg(_Gfirst, _Gnext, _Gend);
			else if (!_Set_eback_live)
				_Right.setg(&_Right._Mychar, &_Right._Mychar + 1,
					&_Right._Mychar + 1);
			else
				_Right.setg(&_Right._Mychar, &_Right._Mychar,
					&_Right._Mychar + 1);

			_Right._Pcvt = _Pcvt_sav;
			_Right._State = _State_sav;
			_Right._Wrotesome = _Wrotesome_sav;
			_Right._Closef = _Closef_sav;

			
			::std:: swap(_Set_eback, _Right._Set_eback);
			::std:: swap(_Set_egptr, _Right._Set_egptr);

			::std:: swap(_Mychar, _Right._Mychar);
			::std:: swap(_Mysb::_Plocale, _Right._Plocale);
			}
		}

	basic_filebuf(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	enum _Initfl
		{	
		_Newfl, _Openfl, _Closefl};

	bool is_open() const
		{	
		return (_Myfile != 0);
		}

	_Myt *open(const char *_Filename,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		_iobuf *_File;
		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
			return (0);	

		_Init(_File, _Openfl);
		_Initcvt(&use_facet< _Cvt >(_Mysb::getloc()));
		return (this);	
		}

	_Myt *open(const string& _Str,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		return (open(_Str.c_str(), _Mode, _Prot));
		}

	_Myt *open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		return (open(_Filename, (ios_base::openmode)_Mode));
		}

	_Myt *open(const wchar_t *_Filename,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		_iobuf *_File;
		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
			return (0);	

		_Init(_File, _Openfl);
		_Initcvt(&use_facet< _Cvt >(_Mysb::getloc()));
		return (this);	
		}

	_Myt *open(const wstring& _Str,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		return (open(_Str.c_str(), _Mode, _Prot));
		}

	_Myt *open(const wchar_t *_Filename,
		ios_base::open_mode _Mode)
		{	
		return (open(_Filename, (ios_base::openmode)_Mode));
		}

 
	_Myt *open(const unsigned short *_Filename,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		_iobuf *_File;
		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
			return (0);	

		_Init(_File, _Openfl);
		_Initcvt(&use_facet< _Cvt >(_Mysb::getloc()));
		return (this);	
		}

	_Myt *open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		return (open(_Filename, (ios_base::openmode)_Mode));
		}
 #line 333 "d:\\programs overflow\\vc\\include\\fstream"

	_Myt *close()
		{	
		_Myt *_Ans = this;
		if (_Myfile == 0)
			_Ans = 0;
		else
			{	
			if (!_Endwrite())
				_Ans = 0;
			if (fclose(_Myfile) != 0)
				_Ans = 0;
			}
		_Init(0, _Closefl);
		return (_Ans);
		}

	virtual void  _Lock()
		{	
		if (_Myfile)
			:: _lock_file(_Myfile);
		}

	virtual void  _Unlock()
		{	
		if (_Myfile)
			:: _unlock_file(_Myfile);
		}

protected:
	virtual int_type  overflow(int_type _Meta =
		_Traits::eof())
		{	
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			return (_Traits::not_eof(_Meta));	
		else if (_Mysb::pptr() != 0
			&& _Mysb::pptr() < _Mysb::epptr())
			{	
			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
			return (_Meta);
			}
		else if (_Myfile == 0)
			return (_Traits::eof());	
		_Reset_back();	
		if (_Pcvt == 0)
			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)
				? _Meta : _Traits::eof());	
		else
			{	
			const int _STRING_INC = 8;
			const _Elem _Ch = _Traits::to_char_type(_Meta);
			const _Elem *_Src;
			char *_Dest;

			string _Str(_STRING_INC, '\0');
			for (; ; )
				switch (_Pcvt->out(_State,
					&_Ch, &_Ch + 1, _Src,
					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
				{	
				case codecvt_base::partial:
				case codecvt_base::ok:
					{	
					size_t _Count = _Dest - &*_Str.begin();
					if (0 < _Count && _Count !=
						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
						return (_Traits::eof());	

					_Wrotesome = true;	
					if (_Src != &_Ch)
						return (_Meta);	

					if (0 < _Count)
						;
					else if (_Str.size() < 4 * _STRING_INC)
						_Str.append(_STRING_INC, '\0');	
					else
						return (_Traits::eof());	
					break;
					}

				case codecvt_base::noconv:
					return (_Fputc(_Ch, _Myfile) ? _Meta
						: _Traits::eof());	

				default:
					return (_Traits::eof());	
				}
			}
	}

	virtual int_type  pbackfail(int_type _Meta =
		_Traits::eof())
		{	
		if (_Mysb::gptr() != 0
			&& _Mysb::eback() < _Mysb::gptr()
			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)
			|| _Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]),
				_Meta)))
			{	
			_Mysb::_Gndec();
			return (_Traits::not_eof(_Meta));
			}
		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))
			return (_Traits::eof());	
		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))
			return (_Meta);	
		else if (_Mysb::gptr() != &_Mychar)
			{	
			_Mychar = _Traits::to_char_type(_Meta);
			_Set_back();	
			return (_Meta);
			}
		else
			return (_Traits::eof());	
	}

	virtual int_type  underflow()
		{	
		int_type _Meta;
		if (_Mysb::gptr() != 0
			&& _Mysb::gptr() < _Mysb::egptr())
			return (_Traits::to_int_type(*_Mysb::gptr()));	
		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
			return (_Meta);	
		else
			{	
			pbackfail(_Meta);
			return (_Meta);
			}
		}

	virtual int_type  uflow()
		{	
		if (_Mysb::gptr() != 0
			&& _Mysb::gptr() < _Mysb::egptr())
			return (_Traits::to_int_type(
				*_Mysb::_Gninc()));	
		else if (_Myfile == 0)
			return (_Traits::eof());	
		_Reset_back();	
		if (_Pcvt == 0)
			{	
			_Elem _Ch = 0;
			return (_Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch)
				: _Traits::eof());
			}
		else
			{	
			string _Str;

			for (; ; )
				{	
				_Elem _Ch, *_Dest;
				const char *_Src;
				int _Nleft;
				int _Meta = fgetc(_Myfile);

				if (_Meta == (-1))
					return (_Traits::eof());	

				_Str.append(1, (char)_Meta);	
				switch (_Pcvt->in(_State,
					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
					&_Ch, &_Ch + 1, _Dest))
					{	
				case codecvt_base::partial:
				case codecvt_base::ok:
					if (_Dest != &_Ch)
						{	
						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);
						for (; 0 < _Nleft; )
							ungetc(_Src[--_Nleft], _Myfile);
						return (_Traits::to_int_type(_Ch));
						}
					else
						_Str.erase((size_t)0,	
							(size_t)(_Src - &*_Str.begin()));
					break;

				case codecvt_base::noconv:
					if (_Str.size() < sizeof (_Elem))
						break;	

					::memcpy_s((&_Ch), (sizeof (_Elem)), (&*_Str.begin()), (sizeof (_Elem)));	
#line 519 "d:\\programs overflow\\vc\\include\\fstream"

					return (_Traits::to_int_type(_Ch));	

				default:
					return (_Traits::eof());	
					}
				}
			}
		}

	virtual pos_type  seekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode =
			(ios_base::openmode)(ios_base::in | ios_base::out))
		{	
		fpos_t _Fileposition;

		if (_Mysb::gptr() == &_Mychar	
			&& _Way == ios_base::cur	
			&& _Pcvt == 0)	
			_Off -= (off_type)sizeof (_Elem);	

		if (_Myfile == 0 || !_Endwrite()
			|| ((_Off != 0 || _Way != ios_base::cur)
				&& _fseeki64(_Myfile, _Off, _Way) != 0)
			|| fgetpos(_Myfile, &_Fileposition) != 0)
			return (pos_type(_BADOFF));	

		_Reset_back();	
		return (pos_type(_State, _Fileposition));	
#line 550 "d:\\programs overflow\\vc\\include\\fstream"
		}

	virtual pos_type  seekpos(pos_type _Pos,
		ios_base::openmode =
			(ios_base::openmode)(ios_base::in | ios_base::out))
		{	
		fpos_t _Fileposition = _Pos.seekpos();
		off_type _Off = (off_type)_Pos - (off_type)((long long)(_Fileposition));

		if (_Myfile == 0 || !_Endwrite()
			|| fsetpos(_Myfile, &_Fileposition) != 0
			|| (_Off != 0 && _fseeki64(_Myfile, _Off, 1) != 0)
			|| fgetpos(_Myfile, &_Fileposition) != 0)
			return (pos_type(_BADOFF));	

		_State = _Pos.state();

		_Reset_back();	
		return (pos_type(_State, _Fileposition));	
#line 570 "d:\\programs overflow\\vc\\include\\fstream"
		}

	virtual _Mysb * setbuf(_Elem *_Buffer, streamsize _Count)
		{	
		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,
			_Buffer == 0 && _Count == 0 ? 0x0004 : 0x0000,
			(size_t)_Count * sizeof (_Elem)) != 0)
			return (0);	
		else
			{	
			_Init(_Myfile, _Openfl);
			return (this);
			}
		}

	virtual int  sync()
		{	
		return (_Myfile == 0
			|| _Traits::eq_int_type(_Traits::eof(), overflow())
			|| 0 <= fflush(_Myfile) ? 0 : -1);
		}

	virtual void  imbue(const locale& _Loc)
		{	
		_Initcvt(&use_facet< _Cvt >(_Loc));
		}

	void _Init(_iobuf *_File, _Initfl _Which)
		{	
		 static _Myst _Stinit;	

		_Closef = _Which == _Openfl;
		_Wrotesome = false;

		_Mysb::_Init();	

 
  
  
 #line 610 "d:\\programs overflow\\vc\\include\\fstream"

  #pragma warning(push)
  #pragma warning(disable: 6240)	
		if (_File != 0 && sizeof (_Elem) == 1)
  #pragma warning(pop)

			{	
			_Elem **_Pb = (_Elem **)&_File->_base;
			_Elem **_Pn = (_Elem **)&_File->_ptr;
			int *_Nr = (int *)&_File->_cnt;
			int *_Nw = (int *)&_File->_cnt;
			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
			}

		_Myfile = _File;
		_State = _Stinit;
		_Pcvt = 0;	
		}

	bool _Endwrite()
		{	
		if (_Pcvt == 0 || !_Wrotesome)
			return (true);
		else
			{	
			const int _STRING_INC = 8;
			char *_Dest;
			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
				return (false);

			string _Str(_STRING_INC, '\0');
			for (; ; )
				switch (_Pcvt->unshift(_State,
					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
				{	
				case codecvt_base::ok:
					_Wrotesome = false;	

				case codecvt_base::partial:	
					{	
					size_t _Count = _Dest - &*_Str.begin();
					if (0 < _Count && _Count !=
						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
						return (false);	
					if (!_Wrotesome)
						return (true);
					if (_Count == 0)
						_Str.append(_STRING_INC, '\0');	
					break;
					}

				case codecvt_base::noconv:
					return (true);	

				default:
					return (false);	
				}
			}
		}

	void _Initcvt(const _Cvt *_Newpcvt)
		{	
		if (_Newpcvt->always_noconv())
			_Pcvt = 0;	
		else
			{	
			_Pcvt = _Newpcvt;
			_Mysb::_Init();	
			}
		}

private:
	void _Reset_back()
		{	
		if (_Mysb::eback() == &_Mychar)
			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
		}

	void _Set_back()
		{	
		if (_Mysb::eback() != &_Mychar)
			{	
			_Set_eback = _Mysb::eback();
			_Set_egptr = _Mysb::egptr();
			}
		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
		}

	_Elem *_Set_eback;	
	_Elem *_Set_egptr;	

	const _Cvt *_Pcvt;	
	_Elem _Mychar;	
	bool _Wrotesome;	
	typename _Traits::state_type _State;	
	bool _Closef;	
	_iobuf *_Myfile;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_filebuf<_Elem, _Traits>& _Left,
		basic_filebuf<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits>
	class basic_ifstream
		: public basic_istream<_Elem, _Traits>
	{	
public:
	typedef basic_ifstream<_Elem, _Traits> _Myt;
	typedef basic_istream<_Elem, _Traits> _Mybase;
	typedef basic_filebuf<_Elem, _Traits> _Myfb;
	typedef basic_ios<_Elem, _Traits> _Myios;

	basic_ifstream()
		: _Mybase(&_Filebuffer)
		{	
		}

	explicit basic_ifstream(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ifstream(const string& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ifstream(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ifstream(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

 
	explicit basic_ifstream(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}
 #line 781 "d:\\programs overflow\\vc\\include\\fstream"

	explicit basic_ifstream(_iobuf *_File)
		: _Mybase(&_Filebuffer),
			_Filebuffer(_File)
		{	
		}

	basic_ifstream(_Myt&& _Right)
		: _Mybase(&_Filebuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Filebuffer.close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Filebuffer.swap(_Right._Filebuffer);
			}
		}

	basic_ifstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	void open(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}

 
	void open(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 860 "d:\\programs overflow\\vc\\include\\fstream"

	virtual  ~basic_ifstream() throw ()
		{	
		}

	_Myfb *rdbuf() const
		{	
		return ((_Myfb *)&_Filebuffer);
		}

	bool is_open() const
		{	
		return (_Filebuffer.is_open());
		}

	void open(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const string& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

	void open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}

	void close()
		{	
		if (_Filebuffer.close() == 0)
			_Myios::setstate(ios_base::failbit);
		}

private:
	_Myfb _Filebuffer;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_ifstream<_Elem, _Traits>& _Left,
		basic_ifstream<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits>
	class basic_ofstream
		: public basic_ostream<_Elem, _Traits>
	{	
public:
	typedef basic_ofstream<_Elem, _Traits> _Myt;
	typedef basic_ostream<_Elem, _Traits> _Mybase;
	typedef basic_filebuf<_Elem, _Traits> _Myfb;
	typedef basic_ios<_Elem, _Traits> _Myios;

	basic_ofstream()
		: _Mybase(&_Filebuffer)
		{	
		}

	explicit basic_ofstream(const char *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ofstream(const string& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ofstream(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ofstream(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

 
	explicit basic_ofstream(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}
 #line 979 "d:\\programs overflow\\vc\\include\\fstream"

	explicit basic_ofstream(_iobuf *_File)
		: _Mybase(&_Filebuffer),
			_Filebuffer(_File)
		{	
		}

	basic_ofstream(_Myt&& _Right)
		: _Mybase(&_Filebuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Filebuffer.close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Filebuffer.swap(_Right._Filebuffer);
			}
		}

	basic_ofstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	void open(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}

 
	void open(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1058 "d:\\programs overflow\\vc\\include\\fstream"

	virtual  ~basic_ofstream() throw ()
		{	
		}

	_Myfb *rdbuf() const
		{	
		return ((_Myfb *)&_Filebuffer);
		}

	bool is_open() const
		{	
		return (_Filebuffer.is_open());
		}

	void open(const char *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const string& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

	void open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}

	void close()
		{	
		if (_Filebuffer.close() == 0)
			_Myios::setstate(ios_base::failbit);
		}

private:
	_Myfb _Filebuffer;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_ofstream<_Elem, _Traits>& _Left,
		basic_ofstream<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits>
	class basic_fstream
		: public basic_iostream<_Elem, _Traits>
	{	
public:
	typedef basic_fstream<_Elem, _Traits> _Myt;
	typedef basic_iostream<_Elem, _Traits> _Mybase;
	typedef basic_filebuf<_Elem, _Traits> _Myfb;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	basic_fstream()
		: _Mybase(&_Filebuffer)
		{	
		}

	explicit basic_fstream(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_fstream(const string& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_fstream(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_fstream(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

 
	explicit basic_fstream(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}
 #line 1182 "d:\\programs overflow\\vc\\include\\fstream"

	explicit basic_fstream(_iobuf *_File)
		: _Mybase(&_Filebuffer),
			_Filebuffer(_File)
		{	
		}

	basic_fstream(_Myt&& _Right)
		: _Mybase(&_Filebuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Filebuffer.close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Filebuffer.swap(_Right._Filebuffer);
			}
		}

	basic_fstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	void open(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}

 
	void open(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1261 "d:\\programs overflow\\vc\\include\\fstream"

	virtual  ~basic_fstream() throw ()
		{	
		}

	_Myfb *rdbuf() const
		{	
		return ((_Myfb *)&_Filebuffer);
		}

	bool is_open() const
		{	
		return (_Filebuffer.is_open());
		}

	void open(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const string& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

	void open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}

	void close()
		{	
		if (_Filebuffer.close() == 0)
			_Myios::setstate(ios_base::failbit);
	}

private:
	_Myfb _Filebuffer;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_fstream<_Elem, _Traits>& _Left,
		basic_fstream<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1322 "d:\\programs overflow\\vc\\include\\fstream"
#line 1323 "d:\\programs overflow\\vc\\include\\fstream"






#line 6 "d:\\my documents\\programs\\jotunengine2\\stdafx.h"
#line 1 "d:\\programs overflow\\vc\\include\\iostream"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {
  











		
 extern __declspec(dllimport) istream cin, *_Ptr_cin;
 extern __declspec(dllimport) ostream cout, *_Ptr_cout;
 extern __declspec(dllimport) ostream cerr, *_Ptr_cerr;
 extern __declspec(dllimport) ostream clog, *_Ptr_clog;

 extern __declspec(dllimport) wistream wcin, *_Ptr_wcin;
 extern __declspec(dllimport) wostream wcout, *_Ptr_wcout;
 extern __declspec(dllimport) wostream wcerr, *_Ptr_wcerr;
 extern __declspec(dllimport) wostream wclog, *_Ptr_wclog;

		
class __declspec(dllimport) _Winit {
public:
	__thiscall _Winit();
	__thiscall ~_Winit() throw ();
private:
	 static int _Init_cnt;
	};
  #line 45 "d:\\programs overflow\\vc\\include\\iostream"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 50 "d:\\programs overflow\\vc\\include\\iostream"
#line 51 "d:\\programs overflow\\vc\\include\\iostream"





#line 7 "d:\\my documents\\programs\\jotunengine2\\stdafx.h"
#line 1 "d:\\programs overflow\\vc\\include\\map"

#pragma once



#line 1 "d:\\programs overflow\\vc\\include\\xtree"

#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4127)
namespace std {
		
template<class _Mytree,
	class _Base = _Iterator_base0>
	class _Tree_unchecked_const_iterator
		: public _Iterator012<bidirectional_iterator_tag,
			typename _Mytree::value_type,
			typename _Mytree::difference_type,
			typename _Mytree::const_pointer,
			typename _Mytree::const_reference,
			_Base>
	{	
public:
	typedef _Tree_unchecked_const_iterator<_Mytree, _Base> _Myiter;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mytree::_Nodeptr _Nodeptr;
	typedef typename _Mytree::value_type value_type;
	typedef typename _Mytree::difference_type difference_type;
	typedef typename _Mytree::const_pointer pointer;
	typedef typename _Mytree::const_reference reference;

	_Tree_unchecked_const_iterator()
		: _Ptr(0)
		{	
		}

	_Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Ptr(_Pnode)
		{	
		this->_Adopt(_Plist);
		}

	reference operator*() const
		{	
		return (_Mytree::_Myval(_Ptr));
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		if (_Mytree::_Isnil(_Ptr))
			;	
		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
			_Ptr = _Mytree::_Min(
				_Mytree::_Right(_Ptr));	
		else
			{	
			_Nodeptr _Pnode;
			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
				&& _Ptr == _Mytree::_Right(_Pnode))
				_Ptr = _Pnode;	
			_Ptr = _Pnode;	
			}
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		if (_Mytree::_Isnil(_Ptr))
			_Ptr = _Mytree::_Right(_Ptr);	
		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
			_Ptr = _Mytree::_Max(
				_Mytree::_Left(_Ptr));	
		else
			{	
			_Nodeptr _Pnode;
			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
				&& _Ptr == _Mytree::_Left(_Pnode))
				_Ptr = _Pnode;	
			if (_Mytree::_Isnil(_Ptr))
				;	
			else
				_Ptr = _Pnode;	
			}
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	bool operator==(const _Myiter& _Right) const
		{	
		return (_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	_Nodeptr _Mynode() const
		{	
		return (_Ptr);
		}

	_Nodeptr _Ptr;	
	};

	
template<class _Mytree>
	class _Tree_unchecked_iterator
		: public _Tree_unchecked_const_iterator<_Mytree>
	{	
public:
	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mytree::_Nodeptr _Nodeptr;
	typedef typename _Mytree::value_type value_type;
	typedef typename _Mytree::difference_type difference_type;
	typedef typename _Mytree::pointer pointer;
	typedef typename _Mytree::reference reference;

	_Tree_unchecked_iterator()
		{	
		}

	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Mybase(_Pnode, _Plist)
		{	
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++(*(_Mybase *)this);
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--(*(_Mybase *)this);
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}
	};

	
template<class _Mytree>
	class _Tree_const_iterator
		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
	{	
public:
	typedef _Tree_const_iterator<_Mytree> _Myiter;
	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mytree::_Nodeptr _Nodeptr;
	typedef typename _Mytree::value_type value_type;
	typedef typename _Mytree::difference_type difference_type;
	typedef typename _Mytree::const_pointer pointer;
	typedef typename _Mytree::const_reference reference;

	_Tree_const_iterator()
		: _Mybase()
		{	
		}

	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Mybase(_Pnode, _Plist)
		{	
		}

	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right._Ptr;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
		}

	reference operator*() const
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
			{	
			_Debug_message(L"map/set iterator not dereferencable", L"d:\\programs overflow\\vc\\include\\xtree", 237);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\xtree", 238, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\xtree", 238, 0); };
			}

 



#line 246 "d:\\programs overflow\\vc\\include\\xtree"

		return (_Mytree::_Myval(this->_Ptr));
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| _Mytree::_Isnil(this->_Ptr))
			{	
			_Debug_message(L"map/set iterator not incrementable", L"d:\\programs overflow\\vc\\include\\xtree", 262);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\xtree", 263, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\xtree", 263, 0); };
			}

 


#line 270 "d:\\programs overflow\\vc\\include\\xtree"

		++(*(_Mybase *)this);
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0)
			{	
			_Debug_message(L"map/set iterator not decrementable", L"d:\\programs overflow\\vc\\include\\xtree", 288);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\xtree", 289, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\xtree", 289, 0); };
			}

		_Nodeptr _Ptrsav = this->_Ptr;
		--(*(_Mybase *)this);
		if (_Ptrsav == this->_Ptr)
			{	
			_Debug_message(L"map/set iterator not decrementable", L"d:\\programs overflow\\vc\\include\\xtree", 296);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\xtree", 297, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\xtree", 297, 0); };
			}

 








#line 310 "d:\\programs overflow\\vc\\include\\xtree"

		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	bool operator==(const _Myiter& _Right) const
		{	
 
		if (this->_Getcont() == 0
			|| this->_Getcont() != _Right._Getcont())
			{	
			_Debug_message(L"map/set iterators incompatible", L"d:\\programs overflow\\vc\\include\\xtree", 327);
			{ (void) ((!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\xtree", 328, 0, L"%s", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\xtree", 328, 0); };
			}

 


#line 335 "d:\\programs overflow\\vc\\include\\xtree"

		return (this->_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}
	};

template<class _Mytree> inline
	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mytree> inline
	_Tree_const_iterator<_Mytree>&
		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
			typename _Tree_const_iterator<_Mytree>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

	
template<class _Mytree>
	class _Tree_iterator
		: public _Tree_const_iterator<_Mytree>
	{	
public:
	typedef _Tree_iterator<_Mytree> _Myiter;
	typedef _Tree_const_iterator<_Mytree> _Mybase;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mytree::_Nodeptr _Nodeptr;
	typedef typename _Mytree::value_type value_type;
	typedef typename _Mytree::difference_type difference_type;

	typedef typename _Mytree::pointer pointer;
	typedef typename _Mytree::reference reference;

	_Tree_iterator()
		{	
		}

	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Mybase(_Pnode, _Plist)
		{	
		}

	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right._Ptr;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++(*(_Mybase *)this);
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--(*(_Mybase *)this);
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}
	};

template<class _Mytree> inline
	typename _Tree_iterator<_Mytree>::_Unchecked_type
		_Unchecked(_Tree_iterator<_Mytree> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mytree> inline
	_Tree_iterator<_Mytree>&
		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
			typename _Tree_iterator<_Mytree>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

		
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference,
	class _Nodeptr_type>
	struct _Tree_iter_types
	{	
	typedef _Value_type value_type;
	typedef _Size_type size_type;
	typedef _Difference_type difference_type;
	typedef _Pointer pointer;
	typedef _Const_pointer const_pointer;
	typedef _Reference reference;
	typedef _Const_reference const_reference;
	typedef _Nodeptr_type _Nodeptr;
	};

template<class _Value_type,
	class _Voidptr>
	struct _Tree_node
		{	
		_Voidptr _Left;	
		_Voidptr _Parent;	
		_Voidptr _Right;	
		char _Color;	
		char _Isnil;	
		_Value_type _Myval;	

	private:
		_Tree_node& operator=(const _Tree_node&);
		};

template<class _Value_type>
	struct _Tree_node<_Value_type, void *>
		{	
		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
		_Nodeptr _Left;	
		_Nodeptr _Parent;	
		_Nodeptr _Right;	
		char _Color;	
		char _Isnil;	
		_Value_type _Myval;	

	private:
		_Tree_node& operator=(const _Tree_node&);
		};

template<class _Ty>
	struct _Tree_simple_types
		: public _Simple_types<_Ty>
	{	
	typedef _Tree_node<_Ty, void *> _Node;
	typedef _Node *_Nodeptr;
	};

template<class _Ty,
	class _Alloc0>
	struct _Tree_base_types
	{	
	typedef _Alloc0 _Alloc;
	typedef _Tree_base_types<_Ty, _Alloc> _Myt;

	typedef _Wrap_alloc<_Alloc> _Alty0;
	typedef typename _Alty0::template rebind<_Ty>::other _Alty;


	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
		_Voidptr;
	typedef _Tree_node<typename _Alty::value_type,
		_Voidptr> _Node;

	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
	typedef typename _Alnod_type::pointer _Nodeptr;
	typedef _Nodeptr& _Nodepref;

	typedef typename _If<_Is_simple_alloc<_Alty>::value,
		_Tree_simple_types<typename _Alty::value_type>,
		_Tree_iter_types<typename _Alty::value_type,
			typename _Alty::size_type,
			typename _Alty::difference_type,
			typename _Alty::pointer,
			typename _Alty::const_pointer,
			typename _Alty::reference,
			typename _Alty::const_reference,
			_Nodeptr> >::type
		_Val_types;
	};

		
template<class _Val_types>
	class _Tree_val
		: public _Container_base
	{	
public:
	typedef _Tree_val<_Val_types> _Myt;

	typedef typename _Val_types::_Nodeptr _Nodeptr;
	typedef _Nodeptr& _Nodepref;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _Tree_const_iterator<_Myt> const_iterator;
	typedef _Tree_iterator<_Myt> iterator;

	_Tree_val()
		{	
		this->_Myhead = 0;
		this->_Mysize = 0;
		}

	enum _Redbl
		{	
		_Red, _Black};

	static char& _Color(_Nodeptr _Pnode)
		{	
		return ((char&)_Pnode->_Color);
		}

	static char& _Isnil(_Nodeptr _Pnode)
		{	
		return ((char&)_Pnode->_Isnil);
		}

	static _Nodepref _Left(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)_Pnode->_Left);
		}

	static _Nodepref _Parent(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)_Pnode->_Parent);
		}

	static _Nodepref _Right(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)_Pnode->_Right);
		}

	static reference _Myval(_Nodeptr _Pnode)
		{	
		return ((reference)_Pnode->_Myval);
		}

	static _Nodeptr _Max(_Nodeptr _Pnode)
		{	
		while (!_Isnil(_Right(_Pnode)))
			_Pnode = _Right(_Pnode);
		return (_Pnode);
		}

	static _Nodeptr _Min(_Nodeptr _Pnode)
		{	
		while (!_Isnil(_Left(_Pnode)))
			_Pnode = _Left(_Pnode);
		return (_Pnode);
		}

	_Nodeptr _Myhead;	
	size_type _Mysize;	
	};

		
template<bool _Al_has_storage,
	class _Alloc_types>
	class _Tree_alloc
		: public _Tree_val<typename _Alloc_types::_Val_types>
	{	
public:
	typename _Alloc_types::_Alnod_type _Alnod;	

	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;
	typedef typename _Alloc_types::_Alnod_type _Alty;
	typedef typename _Alloc_types::_Node _Node;
	typedef typename _Alloc_types::_Nodeptr _Nodeptr;

 





















#line 663 "d:\\programs overflow\\vc\\include\\xtree"
	_Tree_alloc(const _Alloc& _Al = _Alloc())
		: _Alnod(_Al)
		{	
		this->_Myhead = _Buyheadnode();
		try {
		_Alloc_proxy();
		} catch (...) {
		_Freeheadnode(this->_Myhead);
		throw;
		}
		}

	~_Tree_alloc() throw ()
		{	
		_Freeheadnode(this->_Myhead);
		_Free_proxy();
		}

	void _Change_alloc(const _Alty& _Al)
		{	
		_Free_proxy();
		this->_Alnod = _Al;
		_Alloc_proxy();
		}

	void _Swap_alloc(_Myt& _Right)
		{	
		_Swap_adl(this->_Alnod, _Right._Alnod);
		_Swap_adl(this->_Myproxy, _Right._Myproxy);
		}

	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(this->_Alnod);
		this->_Myproxy = _Alproxy.allocate(1);
		_Alproxy.construct(this->_Myproxy, _Container_proxy());
		this->_Myproxy->_Mycont = this;
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(this->_Alnod);
		this->_Orphan_all();
		_Alproxy.destroy(this->_Myproxy);
		_Alproxy.deallocate(this->_Myproxy, 1);
		this->_Myproxy = 0;
		}
 #line 713 "d:\\programs overflow\\vc\\include\\xtree"

	_Nodeptr _Buyheadnode()
		{	
		_Nodeptr _Pnode = this->_Alnod.allocate(1);

		try {
		this->_Alnod.construct(
			::std:: addressof(this->_Left(_Pnode)), _Pnode);
		this->_Alnod.construct(
			::std:: addressof(this->_Parent(_Pnode)), _Pnode);
		this->_Alnod.construct(
			::std:: addressof(this->_Right(_Pnode)), _Pnode);
		} catch (...) {
		this->_Alnod.deallocate(_Pnode, 1);
		throw;
		}

		this->_Color(_Pnode) = this->_Black;
		this->_Isnil(_Pnode) = true;
		return (_Pnode);
		}

	void _Freeheadnode(_Nodeptr _Pnode)
		{	
		this->_Alnod.destroy(
			::std:: addressof(this->_Left(_Pnode)));
		this->_Alnod.destroy(
			::std:: addressof(this->_Parent(_Pnode)));
		this->_Alnod.destroy(
			::std:: addressof(this->_Right(_Pnode)));
		this->_Alnod.deallocate(_Pnode, 1);
		}

	_Alty& _Getal()
		{	
		return (this->_Alnod);
		}

	const _Alty& _Getal() const
		{	
		return (this->_Alnod);
		}
	};

		
template<class _Alloc_types>
	class _Tree_alloc<false, _Alloc_types>
		: public _Tree_val<typename _Alloc_types::_Val_types>
	{	
public:
	typedef _Tree_alloc<false, _Alloc_types> _Myt;
	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
	typedef typename _Alloc_types::_Alloc _Alloc;
	typedef typename _Alloc_types::_Alnod_type _Alty;
	typedef typename _Alloc_types::_Node _Node;
	typedef typename _Alloc_types::_Nodeptr _Nodeptr;

 


















#line 790 "d:\\programs overflow\\vc\\include\\xtree"
	_Tree_alloc(const _Alloc& = _Alloc())
		{	
		this->_Myhead = _Buyheadnode();
		try {
		_Alloc_proxy();
		} catch (...) {
		_Freeheadnode(this->_Myhead);
		throw;
		}
		}

	~_Tree_alloc() throw ()
		{	
		_Freeheadnode(this->_Myhead);
		_Free_proxy();
		}

	void _Change_alloc(const _Alty&)
		{	
		}

	void _Swap_alloc(_Myt&)
		{	
		}

	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		this->_Myproxy = _Alproxy.allocate(1);
		_Alproxy.construct(this->_Myproxy, _Container_proxy());
		this->_Myproxy->_Mycont = this;
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		this->_Orphan_all();
		_Alproxy.destroy(this->_Myproxy);
		_Alproxy.deallocate(this->_Myproxy, 1);
		this->_Myproxy = 0;
		}
 #line 834 "d:\\programs overflow\\vc\\include\\xtree"

	_Nodeptr _Buyheadnode()
		{	
		_Nodeptr _Pnode = this->_Getal().allocate(1);

		try {
		this->_Getal().construct(
			::std:: addressof(this->_Left(_Pnode)), _Pnode);
		this->_Getal().construct(
			::std:: addressof(this->_Parent(_Pnode)), _Pnode);
		this->_Getal().construct(
			::std:: addressof(this->_Right(_Pnode)), _Pnode);
		} catch (...) {
		this->_Getal().deallocate(_Pnode, 1);
		throw;
		}

		this->_Color(_Pnode) = this->_Black;
		this->_Isnil(_Pnode) = true;
		return (_Pnode);
		}

	void _Freeheadnode(_Nodeptr _Pnode)
		{	
		this->_Getal().destroy(
			::std:: addressof(this->_Left(_Pnode)));
		this->_Getal().destroy(
			::std:: addressof(this->_Parent(_Pnode)));
		this->_Getal().destroy(
			::std:: addressof(this->_Right(_Pnode)));
		this->_Getal().deallocate(_Pnode, 1);
		}

	_Alty _Getal() const
		{	
		return (_Alty());
		}
	};

		
template<class _Ty,
	class _Alloc>
	class _Tree_buy
		: public _Tree_alloc<!is_empty<_Alloc>::value,
			_Tree_base_types<_Ty, _Alloc> >
	{	
public:
	typedef _Tree_alloc<!is_empty<_Alloc>::value,
		_Tree_base_types<_Ty, _Alloc> > _Mybase;
	typedef typename _Mybase::_Alty _Alty;
	typedef typename _Mybase::_Nodeptr _Nodeptr;
	typedef typename _Mybase::value_type value_type;

	_Tree_buy(const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	
		}

	_Nodeptr _Buynode0()
		{	
		_Nodeptr _Pnode = this->_Getal().allocate(1);

		try {
		this->_Getal().construct(
			::std:: addressof(this->_Left(_Pnode)), this->_Myhead);
		this->_Getal().construct(
			::std:: addressof(this->_Parent(_Pnode)), this->_Myhead);
		this->_Getal().construct(
			::std:: addressof(this->_Right(_Pnode)), this->_Myhead);
		} catch (...) {
		this->_Getal().deallocate(_Pnode, 1);
		throw;
		}

		return (_Pnode);
		}

	void _Freenode0(_Nodeptr _Pnode)
		{	
		this->_Getal().destroy(
			::std:: addressof(this->_Left(_Pnode)));
		this->_Getal().destroy(
			::std:: addressof(this->_Parent(_Pnode)));
		this->_Getal().destroy(
			::std:: addressof(this->_Right(_Pnode)));
		this->_Getal().deallocate(_Pnode, 1);
		}

	template<class... _Valty>
		_Nodeptr _Buynode(_Valty&&... _Val)
		{	
		_Nodeptr _Pnode = _Buynode0();

		this->_Color(_Pnode) = this->_Red;
		this->_Isnil(_Pnode) = false;

		try {
		this->_Getal().construct(
			::std:: addressof(this->_Myval(_Pnode)),
				::std:: forward<_Valty>(_Val)...);
		} catch (...) {
		_Freenode0(_Pnode);
		throw;
		}

		return (_Pnode);
		}

	};

		
template<bool _Pr_has_storage,
	class _Traits>
	class _Tree_comp
		: public _Tree_buy<typename _Traits::value_type,
			typename _Traits::allocator_type>
	{	
public:
	typedef _Tree_comp<_Pr_has_storage, _Traits> _Myt;
	typedef _Tree_buy<typename _Traits::value_type,
		typename _Traits::allocator_type> _Mybase;

	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;

	_Tree_comp(const key_compare& _Parg, const allocator_type& _Al)
		: _Mybase(_Al), comp(_Parg)
		{	
		}

	key_compare& _Getcomp()
		{	
		return (comp);
		}

	const key_compare& _Getcomp() const
		{	
		return (comp);
		}

	void _Setcomp(const key_compare& _Right)
		{	
		comp = _Right;
		}

	void _Swapcomp(key_compare& _Right)
		{	
		_Swap_adl(comp, _Right);
		}

	key_compare comp;
	};

template<class _Traits>
	class _Tree_comp<false, _Traits>
		: public _Tree_buy<typename _Traits::value_type,
			typename _Traits::allocator_type>
	{	
public:
	typedef _Tree_comp<false, _Traits> _Myt;
	typedef _Tree_buy<typename _Traits::value_type,
		typename _Traits::allocator_type> _Mybase;

	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;

	_Tree_comp(const key_compare&, const allocator_type& _Al)
		: _Mybase(_Al)
		{	
		}

	key_compare _Getcomp() const
		{	
		return (key_compare());
		}

	void _Setcomp(const key_compare&)
		{	
		}

	void _Swapcomp(const key_compare&)
		{	
		}
	};

		
template<class _Traits>
	class _Tree
		: public _Tree_comp<
			!is_empty<typename _Traits::key_compare>::value, _Traits>
	{	
public:
	typedef _Tree<_Traits> _Myt;
	typedef _Tree_comp<
		!is_empty<typename _Traits::key_compare>::value, _Traits> _Mybase;

	typedef typename _Traits::key_type key_type;
	typedef typename _Traits::value_compare value_compare;
	enum
		{	
		_Multi = _Traits::_Multi};

	typedef typename _Mybase::_Node _Node;
	typedef typename _Mybase::_Nodeptr _Nodeptr;
	typedef typename _Mybase::_Alty _Alty;

	typedef typename _Mybase::key_compare key_compare;
	typedef typename _Mybase::allocator_type allocator_type;

	typedef typename _Mybase::value_type value_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;

	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _If<is_same<key_type, value_type>::value,
		typename _Mybase::const_iterator,
		typename _Mybase::iterator>::type iterator;

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	typedef pair<iterator, bool> _Pairib;
	typedef pair<iterator, iterator> _Pairii;
	typedef pair<const_iterator, const_iterator> _Paircc;

	_Tree(const key_compare& _Parg,
		const allocator_type& _Al)
		: _Mybase(_Parg, _Al)
		{	
		}

	_Tree(const value_type *_First, const value_type *_Last,
		const key_compare& _Parg, const allocator_type& _Al)
		: _Mybase(_Parg, _Al)
		{	
		try {
		insert(_First, _Last);
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	_Tree(const _Myt& _Right, const allocator_type& _Al)
		: _Mybase(_Right.key_comp(), _Al)
		{	
		try {
		_Copy(_Right, false_type());
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	_Tree(_Myt&& _Right)
		: _Mybase(_Right.key_comp(), _Right._Getal())
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right), true_type());
		}

	_Tree(_Myt&& _Right, const allocator_type& _Al)
		: _Mybase(_Right.key_comp(), _Al)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			clear();
			if (_Alty::propagate_on_container_move_assignment::value
				&& this->_Getal() != _Right._Getal())
				this->_Change_alloc(_Right._Getal());

			_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right, true_type)
		{	
		this->_Swap_all(_Right);
		this->_Swapcomp(_Right._Getcomp());
		_Swap_adl(this->_Myhead, _Right._Myhead);
		::std:: swap(this->_Mysize, _Right._Mysize);
		}

	void _Assign_rv(_Myt&& _Right, false_type)
		{	
		if (get_allocator() == _Right.get_allocator())
			_Assign_rv(::std:: forward<_Myt>(_Right), true_type());
		else
			_Copy(_Right, true_type());
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right),
			typename _Alty::propagate_on_container_move_assignment());
		}


	_Pairib insert(value_type&& _Val)
		{	
		return (_Insert_nohint(false,
			::std:: forward<value_type>(_Val), _Nil_obj));
		}

	iterator insert(const_iterator _Where, value_type&& _Val)
		{	
		return (_Insert_hint(_Where,
			::std:: forward<value_type>(_Val), _Nil_obj));
		}

	template<class _Valty>
		typename enable_if<is_convertible<_Valty, value_type>::value,
			_Pairib>::type
		insert(_Valty&& _Val)
		{	
		_Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val));
		return (_Insert_nohint(false,
			this->_Myval(_Newnode), _Newnode));
		}

	template<class _Valty>
		typename enable_if<is_convertible<_Valty, value_type>::value,
			iterator>::type
		insert(const_iterator _Where, _Valty&& _Val)
		{	
		_Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val));
		return (_Insert_hint(_Where,
			this->_Myval(_Newnode), _Newnode));
		}

	template<class... _Valty>
		_Pairib emplace(_Valty&&... _Val)
		{	
		_Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val)...);
		return (_Insert_nohint(false,
			this->_Myval(_Newnode), _Newnode));
		}

	template<class... _Valty>
		iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)
		{	
		_Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val)...);
		return (_Insert_hint(_Where,
			this->_Myval(_Newnode), _Newnode));
		}


	~_Tree() throw ()
		{	
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			clear();
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_copy_assignment::value)
				this->_Change_alloc(_Right._Getal());

			this->_Setcomp(_Right._Getcomp());
			_Copy(_Right, false_type());
			}
		return (*this);
		}

	iterator begin() throw ()
		{	
		return (iterator(_Lmost(), this));
		}

	const_iterator begin() const throw ()
		{	
		return (const_iterator(_Lmost(), this));
		}

	iterator end() throw ()
		{	
		return (iterator(this->_Myhead, this));
		}

	const_iterator end() const throw ()
		{	
		return (const_iterator(this->_Myhead, this));
		}

	reverse_iterator rbegin() throw ()
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const throw ()
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() throw ()
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const throw ()
		{	
		return (const_reverse_iterator(begin()));
		}

	const_iterator cbegin() const throw ()
		{	
		return (((const _Myt *)this)->begin());
		}

	const_iterator cend() const throw ()
		{	
		return (((const _Myt *)this)->end());
		}

	const_reverse_iterator crbegin() const throw ()
		{	
		return (((const _Myt *)this)->rbegin());
		}

	const_reverse_iterator crend() const throw ()
		{	
		return (((const _Myt *)this)->rend());
		}

	size_type size() const throw ()
		{	
		return (this->_Mysize);
		}

	size_type max_size() const throw ()
		{	
		return (this->_Getal().max_size());
		}

	bool empty() const throw ()
		{	
		return (size() == 0);
		}

	allocator_type get_allocator() const throw ()
		{	
		return (this->_Getal());
		}

	key_compare key_comp() const
		{	
		return (this->_Getcomp());
		}

	value_compare value_comp() const
		{	
		return (value_compare(key_comp()));
		}

	_Pairib insert(const value_type& _Val)
		{	
		return (_Insert_nohint(false,
			_Val, _Nil_obj));
		}

	iterator insert(const_iterator _Where,
		const value_type& _Val)
		{	
		return (_Insert_hint(_Where,
			_Val, _Nil_obj));
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\xtree", 1316);
		for (; _First != _Last; ++_First)

			emplace_hint(end(), *_First);
		}

	void insert(::std:: initializer_list<value_type> _Ilist)
		{	
		insert(_Ilist.begin(), _Ilist.end());
		}

	iterator erase(const_iterator _Where)
		{	
 
		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
			_Debug_message(L"map/set erase iterator outside range", L"d:\\programs overflow\\vc\\include\\xtree", 1331);
		_Nodeptr _Erasednode = _Where._Mynode();	
		++_Where;	
		_Orphan_ptr(*this, _Erasednode);

 


#line 1340 "d:\\programs overflow\\vc\\include\\xtree"

		_Nodeptr _Fixnode;	
		_Nodeptr _Fixnodeparent;	
		_Nodeptr _Pnode = _Erasednode;

		if (this->_Isnil(this->_Left(_Pnode)))
			_Fixnode = this->_Right(_Pnode);	
		else if (this->_Isnil(this->_Right(_Pnode)))
			_Fixnode = this->_Left(_Pnode);	
		else
			{	
			_Pnode = _Where._Mynode();	
			_Fixnode = this->_Right(_Pnode);	
			}

		if (_Pnode == _Erasednode)
			{	
			_Fixnodeparent = this->_Parent(_Erasednode);
			if (!this->_Isnil(_Fixnode))
				this->_Parent(_Fixnode) = _Fixnodeparent;	

			if (_Root() == _Erasednode)
				_Root() = _Fixnode;	
			else if (this->_Left(_Fixnodeparent) == _Erasednode)
				this->_Left(_Fixnodeparent) = _Fixnode;	
			else
				this->_Right(_Fixnodeparent) =
					_Fixnode;	

			if (_Lmost() == _Erasednode)
				_Lmost() = this->_Isnil(_Fixnode)
					? _Fixnodeparent	
					: this->_Min(_Fixnode);	

			if (_Rmost() == _Erasednode)
				_Rmost() = this->_Isnil(_Fixnode)
					? _Fixnodeparent	
					: this->_Max(_Fixnode);	
			}
		else
			{	
			this->_Parent(this->_Left(_Erasednode)) =
				_Pnode;	
			this->_Left(_Pnode) =
				this->_Left(_Erasednode);	

			if (_Pnode == this->_Right(_Erasednode))
				_Fixnodeparent = _Pnode;	
			else
				{	
				_Fixnodeparent =
					this->_Parent(_Pnode);	
				if (!this->_Isnil(_Fixnode))
					this->_Parent(_Fixnode) = _Fixnodeparent;	
				this->_Left(_Fixnodeparent) = _Fixnode;	
				this->_Right(_Pnode) =
					this->_Right(_Erasednode);	
				this->_Parent(this->_Right(_Erasednode)) =
					_Pnode;	
				}

			if (_Root() == _Erasednode)
				_Root() = _Pnode;	
			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
				this->_Left(this->_Parent(_Erasednode)) =
					_Pnode;	
			else
				this->_Right(this->_Parent(_Erasednode)) =
					_Pnode;	

			this->_Parent(_Pnode) =
				this->_Parent(_Erasednode);	
			::std:: swap(this->_Color(_Pnode),
				this->_Color(_Erasednode));	
			}

		if (this->_Color(_Erasednode) == this->_Black)
			{	
			for (; _Fixnode != _Root()
				&& this->_Color(_Fixnode) == this->_Black;
				_Fixnodeparent = this->_Parent(_Fixnode))
				if (_Fixnode == this->_Left(_Fixnodeparent))
					{	
					_Pnode = this->_Right(_Fixnodeparent);
					if (this->_Color(_Pnode) == this->_Red)
						{	
						this->_Color(_Pnode) = this->_Black;
						this->_Color(_Fixnodeparent) = this->_Red;
						_Lrotate(_Fixnodeparent);
						_Pnode = this->_Right(_Fixnodeparent);
						}

					if (this->_Isnil(_Pnode))
						_Fixnode = _Fixnodeparent;	
					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
						{	
						this->_Color(_Pnode) = this->_Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{	
						if (this->_Color(this->_Right(_Pnode))
							== this->_Black)
							{	
							this->_Color(this->_Left(_Pnode)) = this->_Black;
							this->_Color(_Pnode) = this->_Red;
							_Rrotate(_Pnode);
							_Pnode = this->_Right(_Fixnodeparent);
							}

						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
						this->_Color(_Fixnodeparent) = this->_Black;
						this->_Color(this->_Right(_Pnode)) = this->_Black;
						_Lrotate(_Fixnodeparent);
						break;	
						}
					}
				else
					{	
					_Pnode = this->_Left(_Fixnodeparent);
					if (this->_Color(_Pnode) == this->_Red)
						{	
						this->_Color(_Pnode) = this->_Black;
						this->_Color(_Fixnodeparent) = this->_Red;
						_Rrotate(_Fixnodeparent);
						_Pnode = this->_Left(_Fixnodeparent);
						}

					if (this->_Isnil(_Pnode))
						_Fixnode = _Fixnodeparent;	
					else if (this->_Color(this->_Right(_Pnode)) ==
						this->_Black
						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
						{	
						this->_Color(_Pnode) = this->_Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{	
						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
							{	
							this->_Color(this->_Right(_Pnode)) = this->_Black;
							this->_Color(_Pnode) = this->_Red;
							_Lrotate(_Pnode);
							_Pnode = this->_Left(_Fixnodeparent);
							}

						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
						this->_Color(_Fixnodeparent) = this->_Black;
						this->_Color(this->_Left(_Pnode)) = this->_Black;
						_Rrotate(_Fixnodeparent);
						break;	
						}
					}

			this->_Color(_Fixnode) = this->_Black;	
			}

		this->_Getal().destroy(
			::std:: addressof(this->_Myval(_Erasednode)));	

		this->_Getal().deallocate(_Erasednode, 1);

		if (0 < this->_Mysize)
			--this->_Mysize;

		return (iterator(_Where._Ptr, this));	
		}

	iterator erase(const_iterator _First, const_iterator _Last)
		{	
		if (_First == begin() && _Last == end())
			{	
			clear();
			return (begin());
			}
		else
			{	
			while (_First != _Last)
				erase(_First++);
			return (iterator(_First._Ptr, this));
			}
		}

	size_type erase(const key_type& _Keyval)
		{	
		_Pairii _Where = equal_range(_Keyval);
		size_type _Num = 0;
		_Distance(_Where.first, _Where.second, _Num);
		erase(_Where.first, _Where.second);
		return (_Num);
		}

	void clear() throw ()
		{	
 
		this->_Orphan_ptr(*this, 0);
 #line 1539 "d:\\programs overflow\\vc\\include\\xtree"

		_Erase(_Root());
		_Root() = this->_Myhead;
		_Lmost() = this->_Myhead;
		_Rmost() = this->_Myhead;
		this->_Mysize = 0;
		}

	iterator find(const key_type& _Keyval)
		{	
		iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Where._Mynode()), L"d:\\programs overflow\\vc\\include\\xtree", 1552)
#line 1553 "d:\\programs overflow\\vc\\include\\xtree"
					? end() : _Where);
		}

	const_iterator find(const key_type& _Keyval) const
		{	
		const_iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Where._Mynode()), L"d:\\programs overflow\\vc\\include\\xtree", 1561)
#line 1562 "d:\\programs overflow\\vc\\include\\xtree"
					? end() : _Where);
		}

	size_type count(const key_type& _Keyval) const
		{	
		_Paircc _Ans = equal_range(_Keyval);
		size_type _Num = 0;
		_Distance(_Ans.first, _Ans.second, _Num);
		return (_Num);
		}

	iterator lower_bound(const key_type& _Keyval)
		{	
		return (iterator(_Lbound(_Keyval), this));
		}

	const_iterator lower_bound(const key_type& _Keyval) const
		{	
		return (const_iterator(_Lbound(_Keyval), this));
		}

	iterator upper_bound(const key_type& _Keyval)
		{	
		return (iterator(_Ubound(_Keyval), this));
		}

	const_iterator upper_bound(const key_type& _Keyval) const
		{	
		return (const_iterator(_Ubound(_Keyval), this));
		}

	_Pairii equal_range(const key_type& _Keyval)
		{	
		return (_Eqrange(_Keyval));
		}

	_Paircc equal_range(const key_type& _Keyval) const
		{	
		return (_Eqrange(_Keyval));
		}

	void swap(_Myt& _Right)
		{	
		if (this == &_Right)
			;	
		else if (this->_Getal() == _Right._Getal())
			{	
			this->_Swap_all(_Right);
			this->_Swapcomp(_Right._Getcomp());
			_Swap_adl(this->_Myhead, _Right._Myhead);
			::std:: swap(this->_Mysize, _Right._Mysize);
			}

		else if (_Alty::propagate_on_container_swap::value)
			{	
			this->_Swap_alloc(_Right);
			this->_Swapcomp(_Right._Getcomp());
			_Swap_adl(this->_Myhead, _Right._Myhead);
			::std:: swap(this->_Mysize, _Right._Mysize);
			}

		else
			{	
 
			_Debug_message(L"map/set containers incompatible for swap", L"d:\\programs overflow\\vc\\include\\xtree", 1626);

 

#line 1631 "d:\\programs overflow\\vc\\include\\xtree"
			}
		}

protected:
	template<class _Valty>
		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
		{	
		return (_Node);
		}

	template<class _Valty>
		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
		{	
		return (this->_Buynode(::std:: forward<_Valty>(_Val)));
		}

	void _Destroy_if_not_nil(_Nodeptr _Newnode)
		{	
		this->_Getal().destroy(
			::std:: addressof(this->_Myval(_Newnode)));

		this->_Getal().deallocate(_Newnode, 1);
		}

	void _Destroy_if_not_nil(_Nil)
		{	
		}

	template<class _Valty,
		class _Nodety>
		iterator _Insert_hint(const_iterator _Where,
			_Valty&& _Val, _Nodety _Newnode)
		{	
		const_iterator _Next;
		bool _Leftish = false;	

		try {

 
		if (_Where._Getcont() != this)
			_Debug_message(L"map/set insert iterator outside range", L"d:\\programs overflow\\vc\\include\\xtree", 1671);
 #line 1673 "d:\\programs overflow\\vc\\include\\xtree"

		if (size() == 0)
			return (_Insert_at(true, this->_Myhead,
				::std:: forward<_Valty>(_Val), _Newnode));	
		else if (this->_Multi)
			{	
			if (_Where == begin())
				{	
				if (!_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Mynode()), this->_Kfn(_Val), L"d:\\programs overflow\\vc\\include\\xtree", 1682))
#line 1683 "d:\\programs overflow\\vc\\include\\xtree"
					return (_Insert_at(true, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				_Leftish = true;	
				}
			else if (_Where == end())
				{	
				if (!_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Rmost()), L"d:\\programs overflow\\vc\\include\\xtree", 1690))
#line 1691 "d:\\programs overflow\\vc\\include\\xtree"
					return (_Insert_at(false, _Rmost(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (!_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Mynode()), this->_Kfn(_Val), L"d:\\programs overflow\\vc\\include\\xtree", 1695)
#line 1696 "d:\\programs overflow\\vc\\include\\xtree"
				&& !_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key((--(_Next = _Where))._Mynode()), L"d:\\programs overflow\\vc\\include\\xtree", 1698))
#line 1699 "d:\\programs overflow\\vc\\include\\xtree"
				{	
				if (this->_Isnil(this->_Right(_Next._Mynode())))
					return (_Insert_at(false, _Next._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				else
					return (_Insert_at(true, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (!_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Where._Mynode()), L"d:\\programs overflow\\vc\\include\\xtree", 1708)
#line 1709 "d:\\programs overflow\\vc\\include\\xtree"
				&& (++(_Next = _Where) == end()
					|| !_Debug_lt_pred(this->_Getcomp(), this->_Key(_Next._Mynode()), this->_Kfn(_Val), L"d:\\programs overflow\\vc\\include\\xtree", 1711)))
#line 1712 "d:\\programs overflow\\vc\\include\\xtree"
				{	
				if (this->_Isnil(this->_Right(_Where._Mynode())))
					return (_Insert_at(false, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				else
					return (_Insert_at(true, _Next._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else
				_Leftish = true;	
			}
		else
			{	
			if (_Where == begin())
				{	
				if (_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Where._Mynode()), L"d:\\programs overflow\\vc\\include\\xtree", 1728))
#line 1729 "d:\\programs overflow\\vc\\include\\xtree"
					return (_Insert_at(true, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (_Where == end())
				{	
				if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Rmost()), this->_Kfn(_Val), L"d:\\programs overflow\\vc\\include\\xtree", 1735))
#line 1736 "d:\\programs overflow\\vc\\include\\xtree"
					return (_Insert_at(false, _Rmost(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Where._Mynode()), L"d:\\programs overflow\\vc\\include\\xtree", 1740)
#line 1741 "d:\\programs overflow\\vc\\include\\xtree"
				&& _Debug_lt_pred(this->_Getcomp(), this->_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val), L"d:\\programs overflow\\vc\\include\\xtree", 1743))
#line 1744 "d:\\programs overflow\\vc\\include\\xtree"
				{	
				if (this->_Isnil(this->_Right(_Next._Mynode())))
					return (_Insert_at(false, _Next._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				else
					return (_Insert_at(true, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Mynode()), this->_Kfn(_Val), L"d:\\programs overflow\\vc\\include\\xtree", 1753)
#line 1754 "d:\\programs overflow\\vc\\include\\xtree"
				&& (++(_Next = _Where) == end()
					|| _Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Next._Mynode()), L"d:\\programs overflow\\vc\\include\\xtree", 1756)))
#line 1757 "d:\\programs overflow\\vc\\include\\xtree"
				{	
				if (this->_Isnil(this->_Right(_Where._Mynode())))
					return (_Insert_at(false, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				else
					return (_Insert_at(true, _Next._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			}
		} catch (...) {
		_Destroy_if_not_nil(_Newnode);
		throw;
		}

		return (_Insert_nohint(_Leftish,
			::std:: forward<_Valty>(_Val), _Newnode).first);
		}

	template<class _Valty,
		class _Nodety>
		_Pairib _Insert_nohint(bool _Leftish,
			_Valty&& _Val, _Nodety _Newnode)
		{	
		try {
		_Nodeptr _Trynode = _Root();
		_Nodeptr _Wherenode = this->_Myhead;
		bool _Addleft = true;	

		while (!this->_Isnil(_Trynode))
			{	
			_Wherenode = _Trynode;
			if (_Leftish)
				_Addleft = !_Debug_lt_pred(this->_Getcomp(), this->_Key(_Trynode), this->_Kfn(_Val), L"d:\\programs overflow\\vc\\include\\xtree", 1791);	
#line 1792 "d:\\programs overflow\\vc\\include\\xtree"
			else
				_Addleft = _Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Trynode), L"d:\\programs overflow\\vc\\include\\xtree", 1795);	
#line 1796 "d:\\programs overflow\\vc\\include\\xtree"
			_Trynode = _Addleft ? this->_Left(_Trynode)
				: this->_Right(_Trynode);
			}

		if (this->_Multi)
			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
				::std:: forward<_Valty>(_Val), _Newnode), true));
		else
			{	
			iterator _Where = iterator(_Wherenode, this);
			if (!_Addleft)
				;	
			else if (_Where == begin())
				return (_Pairib(_Insert_at(true, _Wherenode,
					::std:: forward<_Valty>(_Val), _Newnode), true));
			else
				--_Where;	

			if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Mynode()), this->_Kfn(_Val), L"d:\\programs overflow\\vc\\include\\xtree", 1816))
#line 1817 "d:\\programs overflow\\vc\\include\\xtree"
				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
					::std:: forward<_Valty>(_Val), _Newnode), true));
			else
				{	
				_Destroy_if_not_nil(_Newnode);
				return (_Pairib(_Where, false));
				}
			}
		} catch (...) {
		_Destroy_if_not_nil(_Newnode);
		throw;
		}
		}

	template<class _Valty,
		class _Nodety>
		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
		_Valty&& _Val, _Nodety _Node)
		{	
		if (max_size() - 1 <= this->_Mysize)
			{	
			_Destroy_if_not_nil(_Node);
			_Xlength_error("map/set<T> too long");
			}
		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
			::std:: forward<_Valty>(_Val));

		++this->_Mysize;
		_Newnode->_Parent = _Wherenode;

		if (_Wherenode == this->_Myhead)
			{	
			_Root() = _Newnode;
			_Lmost() = _Newnode;
			_Rmost() = _Newnode;
			}
		else if (_Addleft)
			{	
			this->_Left(_Wherenode) = _Newnode;
			if (_Wherenode == _Lmost())
				_Lmost() = _Newnode;
			}
		else
			{	
			this->_Right(_Wherenode) = _Newnode;
			if (_Wherenode == _Rmost())
				_Rmost() = _Newnode;
			}

		for (_Nodeptr _Pnode = _Newnode;
			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
			if (this->_Parent(_Pnode)
				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
				{	
				_Wherenode =
					this->_Right(this->_Parent(this->_Parent(_Pnode)));
				if (this->_Color(_Wherenode) == this->_Red)
					{	
					this->_Color(this->_Parent(_Pnode)) = this->_Black;
					this->_Color(_Wherenode) = this->_Black;
					this->_Color(this->_Parent(this->_Parent(_Pnode)))
						= this->_Red;
					_Pnode = this->_Parent(this->_Parent(_Pnode));
					}
				else
					{	
					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
						{	
						_Pnode = this->_Parent(_Pnode);
						_Lrotate(_Pnode);
						}
					this->_Color(this->_Parent(_Pnode)) =
						this->_Black;	
					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
						this->_Red;
					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
					}
				}
			else
				{	
				_Wherenode =
					this->_Left(this->_Parent(this->_Parent(_Pnode)));
				if (this->_Color(_Wherenode) == this->_Red)
					{	
					this->_Color(this->_Parent(_Pnode)) = this->_Black;
					this->_Color(_Wherenode) = this->_Black;
					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
						this->_Red;
					_Pnode = this->_Parent(this->_Parent(_Pnode));
					}
				else
					{	
					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
						{	
						_Pnode = this->_Parent(_Pnode);
						_Rrotate(_Pnode);
						}
					this->_Color(this->_Parent(_Pnode)) =
						this->_Black;	
					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
						this->_Red;
					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
					}
				}

		this->_Color(_Root()) = this->_Black;	
		return (iterator(_Newnode, this));
		}

	template<class _Moveit>
		void _Copy(const _Myt& _Right,
			_Moveit _Movefl)
		{	
		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
		this->_Mysize = _Right.size();
		if (!this->_Isnil(_Root()))
			{	
			_Lmost() = this->_Min(_Root());
			_Rmost() = this->_Max(_Root());
			}
		else
			{	
			_Lmost() = this->_Myhead;
			_Rmost() = this->_Myhead;
			}
		}

	template<class _Want_to_move,
		class _Can_move,
		class _Is_set,
		class _Dummy>
		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
			_Can_move, _Is_set, _Dummy)
		{	
		return (this->_Buynode(this->_Myval(_Rootnode)));
		}

	template<class _Dummy>
		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
			true_type, true_type, _Dummy)
		{	
		return (this->_Buynode(
			::std:: forward<value_type>(this->_Myval(_Rootnode))));
		}

	template<class _Dummy>
		_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
			true_type, false_type, _Dummy)
		{	
		return (this->_Buynode(
			::std:: forward<key_type>(const_cast<key_type&>(
				this->_Myval(_Rootnode).first)),
			::std:: forward<typename value_type::second_type>(this->_Myval(
				_Rootnode).second)));
		}

	template<class _Moveit>
		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
			_Moveit _Movefl)
		{	
		_Nodeptr _Newroot = this->_Myhead;	

		if (!this->_Isnil(_Rootnode))
			{	
			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
				typename is_move_constructible<value_type>::type(),
				typename is_same<key_type, value_type>::type(), 0);
			_Pnode->_Parent = _Wherenode;
			_Pnode->_Color = this->_Color(_Rootnode);
			if (this->_Isnil(_Newroot))
				_Newroot = _Pnode;	

			try {
			this->_Left(_Pnode) =
				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
			this->_Right(_Pnode) =
				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
			} catch (...) {
			_Erase(_Newroot);	
			throw;
			}
			}

		return (_Newroot);	
		}

	_Paircc _Eqrange(const key_type& _Keyval) const
		{	
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Lonode = this->_Myhead;	
		_Nodeptr _Hinode = this->_Myhead;	

		while (!this->_Isnil(_Pnode))
			if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Pnode), _Keyval, L"d:\\programs overflow\\vc\\include\\xtree", 2010))
				_Pnode = this->_Right(_Pnode);	
			else
				{	
				if (this->_Isnil(_Hinode)
						&& _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Pnode), L"d:\\programs overflow\\vc\\include\\xtree", 2016))
#line 2017 "d:\\programs overflow\\vc\\include\\xtree"
					_Hinode = _Pnode;	
				_Lonode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}

		_Pnode = this->_Isnil(_Hinode) ? _Root()
			: this->_Left(_Hinode);	
		while (!this->_Isnil(_Pnode))
			if (_Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Pnode), L"d:\\programs overflow\\vc\\include\\xtree", 2025))
				{	
				_Hinode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}
			else
				_Pnode = this->_Right(_Pnode);	

		const_iterator _First = const_iterator(_Lonode, this);
		const_iterator _Last = const_iterator(_Hinode, this);
		return (_Paircc(_First, _Last));
		}

	_Pairii _Eqrange(const key_type& _Keyval)
		{	
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Lonode = this->_Myhead;	
		_Nodeptr _Hinode = this->_Myhead;	

		while (!this->_Isnil(_Pnode))
			if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Pnode), _Keyval, L"d:\\programs overflow\\vc\\include\\xtree", 2045))
				_Pnode = this->_Right(_Pnode);	
			else
				{	
				if (this->_Isnil(_Hinode)
						&& _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Pnode), L"d:\\programs overflow\\vc\\include\\xtree", 2051))
#line 2052 "d:\\programs overflow\\vc\\include\\xtree"
					_Hinode = _Pnode;	
				_Lonode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}

		_Pnode = this->_Isnil(_Hinode) ? _Root()
			: this->_Left(_Hinode);	
		while (!this->_Isnil(_Pnode))
			if (_Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Pnode), L"d:\\programs overflow\\vc\\include\\xtree", 2060))
				{	
				_Hinode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}
			else
				_Pnode = this->_Right(_Pnode);	

		iterator _First = iterator(_Lonode, this);
		iterator _Last = iterator(_Hinode, this);
		return (_Pairii(_First, _Last));
		}

	void _Erase(_Nodeptr _Rootnode)
		{	
		for (_Nodeptr _Pnode = _Rootnode;
			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
			{	
			_Erase(this->_Right(_Pnode));
			_Pnode = this->_Left(_Pnode);
			this->_Getal().destroy(
				::std:: addressof(this->_Myval(_Rootnode)));

			this->_Getal().deallocate(_Rootnode, 1);
			}
		}

	_Nodeptr _Lbound(const key_type& _Keyval) const
		{	
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Wherenode = this->_Myhead;	

		while (!this->_Isnil(_Pnode))
			if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Pnode), _Keyval, L"d:\\programs overflow\\vc\\include\\xtree", 2093))
				_Pnode = this->_Right(_Pnode);	
			else
				{	
				_Wherenode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}

		return (_Wherenode);	
		}

	_Nodeptr _Lbound(const key_type& _Keyval)
		{	
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Wherenode = this->_Myhead;	

		while (!this->_Isnil(_Pnode))
			if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Pnode), _Keyval, L"d:\\programs overflow\\vc\\include\\xtree", 2110))
				_Pnode = this->_Right(_Pnode);	
			else
				{	
				_Wherenode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}

		return (_Wherenode);	
		}

	_Nodeptr& _Lmost() const
		{	
		return (this->_Left(this->_Myhead));
		}

	void _Lrotate(_Nodeptr _Wherenode)
		{	
		_Nodeptr _Pnode = this->_Right(_Wherenode);
		this->_Right(_Wherenode) = this->_Left(_Pnode);

		if (!this->_Isnil(this->_Left(_Pnode)))
			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

		if (_Wherenode == _Root())
			_Root() = _Pnode;
		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
		else
			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

		this->_Left(_Pnode) = _Wherenode;
		this->_Parent(_Wherenode) = _Pnode;
		}

	_Nodeptr& _Rmost() const
		{	
		return (this->_Right(this->_Myhead));
		}

	_Nodeptr& _Root() const
		{	
		return (this->_Parent(this->_Myhead));
		}

	void _Rrotate(_Nodeptr _Wherenode)
		{	
		_Nodeptr _Pnode = this->_Left(_Wherenode);
		this->_Left(_Wherenode) = this->_Right(_Pnode);

		if (!this->_Isnil(this->_Right(_Pnode)))
			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

		if (_Wherenode == _Root())
			_Root() = _Pnode;
		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
		else
			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

		this->_Right(_Pnode) = _Wherenode;
		this->_Parent(_Wherenode) = _Pnode;
		}

	_Nodeptr _Ubound(const key_type& _Keyval) const
		{	
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Wherenode = this->_Myhead;	

		while (!this->_Isnil(_Pnode))
			if (_Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Pnode), L"d:\\programs overflow\\vc\\include\\xtree", 2182))
				{	
				_Wherenode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}
			else
				_Pnode = this->_Right(_Pnode);	

		return (_Wherenode);	
		}

	_Nodeptr _Ubound(const key_type& _Keyval)
		{	
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Wherenode = this->_Myhead;	

		while (!this->_Isnil(_Pnode))
			if (_Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Pnode), L"d:\\programs overflow\\vc\\include\\xtree", 2199))
				{	
				_Wherenode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}
			else
				_Pnode = this->_Right(_Pnode);	

		return (_Wherenode);	
		}

 
	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
		{	
		_Lockit _Lock(3);
		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
		if (_Pnext != 0)
			while (*_Pnext != 0)
				if ((*_Pnext)->_Ptr == this->_Myhead
					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
				else
					{	
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
		}
 #line 2227 "d:\\programs overflow\\vc\\include\\xtree"

	void _Tidy()
		{	
		erase(begin(), end());
		}

	const key_type& _Kfn(const value_type& _Val) const
		{	
		return (_Traits::_Kfn(_Val));
		}

	const key_type& _Key(_Nodeptr _Pnode) const
		{	
		return ((const key_type&)this->_Kfn(this->_Myval(_Pnode)));
		}
	};

		
template<class _Traits> inline
	bool operator==(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Traits> inline
	bool operator!=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Traits> inline
	bool operator<(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Traits> inline
	bool operator>(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Traits> inline
	bool operator<=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Traits> inline
	bool operator>=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (!(_Left < _Right));
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 2288 "d:\\programs overflow\\vc\\include\\xtree"
#line 2289 "d:\\programs overflow\\vc\\include\\xtree"























#line 7 "d:\\programs overflow\\vc\\include\\map"

#line 1 "d:\\programs overflow\\vc\\include\\tuple"

#pragma once







 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4100 4521 4522)

namespace std {
	
template<class _Src,
	class _Dest>
	struct _Tuple_enable
	{	
	};

template<>
	struct _Tuple_enable<tuple<>, tuple<> >
	{	
	typedef void ** type;
	};

template<class _Src0,
	class... _Types1,
	class _Dest0,
	class... _Types2>
	struct _Tuple_enable<tuple<_Src0, _Types1...>,
		tuple<_Dest0, _Types2...> >
	: _If<is_convertible<_Src0, _Dest0>::value,
		_Tuple_enable<tuple<_Types1...>, tuple<_Types2...> >,
		_Tuple_enable<int, int>
	>::type
	{	
	};


	
class _Ignore
	{	
public:
	_Ignore()
		{	
		}

	template<class _Ty>
		void operator=(const _Ty&) const
		{	
		}
	};

const _Ignore ignore;

		
struct _Tuple_alloc_t
	{	
	};

const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	
template<class _Ty>
	struct _Tuple_val
	{	
	_Tuple_val()
		: _Val()
		{	
		}

	template<class _Other>
		_Tuple_val(_Other&& _Arg)
		: _Val(::std:: forward<_Other>(_Arg))
		{	
		}

	template<class _Other>
		_Tuple_val& operator=(_Other&& _Right)
		{	
		_Val = ::std:: forward<_Other>(_Right);
		return (*this);
		}

	template<class _Alloc,
		class... _Other>
		_Tuple_val(const _Alloc&,
			typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
				_Tuple_alloc_t>::type, _Other&&... _Arg)
		: _Val(::std:: forward<_Other>(_Arg)...)
		{	
		}

	template<class _Alloc,
		class... _Other>
		_Tuple_val(const _Alloc& _Al,
			typename enable_if<uses_allocator<_Ty, _Alloc>::value
				&& is_constructible<_Ty,
					allocator_arg_t, _Alloc>::value,
				_Tuple_alloc_t>::type, _Other&&... _Arg)
		: _Val(allocator_arg, _Al, ::std:: forward<_Other>(_Arg)...)
		{	
		}

	template<class _Alloc,
		class... _Other>
		_Tuple_val(const _Alloc& _Al,
			typename enable_if<uses_allocator<_Ty, _Alloc>::value
				&& !is_constructible<_Ty,
					allocator_arg_t, _Alloc>::value,
				_Tuple_alloc_t>::type, _Other&&... _Arg)
		: _Val(::std:: forward<_Other>(_Arg)..., _Al)
		{	
		}


	_Ty _Val;
	};

	
template<class... _Types>
	class tuple;

template<>
	class tuple<>
	{	
public:
	typedef tuple<> _Myt;

	tuple()
		{	
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc&) throw ()
		{	
		}

	tuple(const tuple&) throw ()
		{	
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc&, const tuple&) throw ()
		{	
		}

	void swap(_Myt&) throw ()
		{	
		}

	bool _Equals(const _Myt&) const throw ()
		{	
		return (true);
		}

	bool _Less(const _Myt&) const throw ()
		{	
		return (false);
		}
	};

template<class _This,
	class... _Rest>
	class tuple<_This, _Rest...>
		: private tuple<_Rest...>
	{	
public:
	typedef _This _This_type;
	typedef tuple<_This, _Rest...> _Myt;
	typedef tuple<_Rest...> _Mybase;
	static const size_t _Mysize = 1 + sizeof...(_Rest);

	tuple()
		: _Mybase(),
			_Myfirst()
		{	
		}

	template<class... _Rest2>
		explicit tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
			: _Mybase(::std:: forward<_Rest2>(_Rest_arg)...),
				_Myfirst(allocator_arg)
		{	
		}

	template<class... _Other,
		class = typename _Tuple_enable<
			tuple<const _Other&...>, _Myt>::type>
		tuple(const tuple<_Other...>& _Right)
		: _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
		{	
		}

	template<class _Alloc,
		class... _Other,
		class = typename _Tuple_enable<
			tuple<const _Other&...>, _Myt>::type>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const tuple<_Other...>& _Right)
		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
			_Myfirst(_Al, _Tuple_alloc,
				_Right._Myfirst._Val)
		{	
		}

	explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
		: _Mybase(_Rest_arg...),
			_Myfirst(_This_arg)
		{	
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const _This& _This_arg, const _Rest&... _Rest_arg)
		: _Mybase(allocator_arg, _Al, _Rest_arg...),
			_Myfirst(_Al, _Tuple_alloc, _This_arg)
		{	
		}

	template<class _This2,
		class... _Rest2,
		class = typename _Tuple_enable<
			tuple<_This2, _Rest2...>, _Myt>::type>
		explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
		: _Mybase(::std:: forward<_Rest2>(_Rest_arg)...),
			_Myfirst(::std:: forward<_This2>(_This_arg))
		{	
		}

	template<class _Alloc,
		class _This2,
		class... _Rest2,
		class = typename _Tuple_enable<
			tuple<_This2, _Rest2...>, _Myt>::type>
		tuple(allocator_arg_t, const _Alloc& _Al,
			_This2&& _This_arg, _Rest2&&... _Rest_arg)
		: _Mybase(allocator_arg, _Al,
				::std:: forward<_Rest2>(_Rest_arg)...),
			_Myfirst(_Al, _Tuple_alloc,
				::std:: forward<_This2>(_This_arg))
		{	
		}

	template<class... _Other,
		class = typename _Tuple_enable<
			tuple<_Other...>, _Myt>::type>
		tuple(tuple<_Other...>&& _Right)
		: _Mybase(::std:: forward<typename tuple<_Other...>::_Mybase>
			(_Right._Get_rest())),
			_Myfirst(::std:: forward<typename tuple<_Other...>::_This_type>
				(_Right._Myfirst._Val))
		{	
		}

	template<class _Alloc,
		class... _Other,
		class = typename _Tuple_enable<
			tuple<_Other...>, _Myt>::type>
		tuple(allocator_arg_t, const _Alloc& _Al,
			tuple<_Other...>&& _Right)
		: _Mybase(allocator_arg, _Al,
				::std:: forward<typename tuple<_Other...>::_Mybase>
					(_Right._Get_rest())),
			_Myfirst(_Al, _Tuple_alloc,
				::std:: forward<typename tuple<_Other...>::_This_type>
					(_Right._Myfirst._Val))
		{	
		}

	template<class... _Other>
		_Myt& operator=(const tuple<_Other...>& _Right)
		{	
		_Myfirst._Val = _Right._Myfirst._Val;
		(_Mybase&)*this = _Right._Get_rest();
		return (*this);
		}

	template<class... _Other>
		_Myt& operator=(tuple<_Other...>&& _Right)
		{	
		_Myfirst._Val = ::std:: forward<typename tuple<_Other...>::_This_type>
			(_Right._Myfirst._Val);
		(_Mybase&)*this = ::std:: forward<typename tuple<_Other...>::_Mybase>
			(_Right._Get_rest());
		return (*this);
		}

	template<class... _Other>
		bool _Equals(const tuple<_Other...>& _Right) const
		{	
		static_assert(_Mysize == sizeof...(_Other),
			"comparing tuple to object with different size");
		return (_Myfirst._Val == _Right._Myfirst._Val
			&& _Mybase::_Equals(_Right._Get_rest()));
		}

	template<class... _Other>
		bool _Less(const tuple<_Other...>& _Right) const
		{	
		static_assert(_Mysize == sizeof...(_Other),
			"comparing tuple to object with different size");
		return (_Myfirst._Val < _Right._Myfirst._Val
			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
				&& _Mybase::_Less(_Right._Get_rest())));
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc& _Al)
		: _Mybase(allocator_arg, _Al),
			_Myfirst(_Al, _Tuple_alloc)
		{	
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const _Myt& _Right)
		: _Mybase(allocator_arg, _Al, _Right._Get_rest()),
			_Myfirst(_Al, _Tuple_alloc,
				_Right._Myfirst._Val)
		{	
		}

	template<class _First,
		class _Second,
		class = typename _Tuple_enable<
			tuple<const _First&, const _Second&>, _Myt>::type>
		tuple(const pair<_First, _Second>& _Right)

		: _Mybase(tuple<_Second>(_Right.second)),
			_Myfirst(_Right.first)
		{	
		
		}

	template<class _Alloc,
		class _First,
		class _Second,
		class = typename _Tuple_enable<
			tuple<const _First&, const _Second&>, _Myt>::type>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const pair<_First, _Second>& _Right)

		: _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
			_Myfirst(_Al, _Tuple_alloc,
				_Right.first)
		{	
		
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		_Myfirst._Val = _Right._Myfirst._Val;
		(_Mybase&)*this = _Right._Get_rest();
		return (*this);
		}

	template<class _First,
		class _Second>
		_Myt& operator=(const pair<_First, _Second>& _Right)
		{	
		static_assert(_Mysize == 2,
			"assigning to tuple from object with different size");
		_Myfirst._Val = _Right.first;
		(_Mybase&)*this = tuple<_Second>(_Right.second);
		return (*this);
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc& _Al,
			_Myt&& _Right)
		: _Mybase(allocator_arg, _Al,
				::std:: forward<_Mybase>(_Right._Get_rest())),
			_Myfirst(_Al, _Tuple_alloc,
				::std:: forward<_This>(_Right._Myfirst._Val))
		{	
		}

	template<class _First,
		class _Second,
		class = typename _Tuple_enable<
			tuple<_First, _Second>, _Myt>::type>
		tuple(pair<_First, _Second>&& _Right)

		: _Mybase(tuple<_Second>(::std:: forward<_Second>(_Right.second))),
			_Myfirst(::std:: forward<_First>(_Right.first))
		{	
		
		}

	template<class _Alloc,
		class _First,
		class _Second,
		class = typename _Tuple_enable<
			tuple<_First, _Second>, _Myt>::type>
		tuple(allocator_arg_t, const _Alloc& _Al,
			pair<_First, _Second>&& _Right)

		: _Mybase(allocator_arg, _Al,
				tuple<_Second>(::std:: forward<_Second>(_Right.second))),
			_Myfirst(_Al, _Tuple_alloc,
				::std:: forward<_First>(_Right.first))
		{	
		
		}

	_Myt& operator=(_Myt&& _Right)
		
#line 415 "d:\\programs overflow\\vc\\include\\tuple"
		{	
		_Myfirst = ::std:: forward<_This>(_Right._Myfirst._Val);
		(_Mybase&)*this = ::std:: forward<_Mybase>(_Right._Get_rest());
		return (*this);
		}

	template<class _First,
		class _Second>
		_Myt& operator=(pair<_First, _Second>&& _Right)
		
#line 428 "d:\\programs overflow\\vc\\include\\tuple"
		{	
		static_assert(_Mysize == 2,
			"assigning to tuple from object with different size");
		_Myfirst._Val = ::std:: forward<_First>(_Right.first);
		(_Mybase&)*this =
			tuple<_Second>(::std:: forward<_Second>(_Right.second));
		return (*this);
		}

	_Mybase& _Get_rest()
		{	
		return (*this);
		}

	const _Mybase& _Get_rest() const
		{	
		return (*this);
		}

	void swap(tuple& _Right)
		
#line 451 "d:\\programs overflow\\vc\\include\\tuple"
		{	
		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
		_Mybase::swap((_Mybase&)_Right);
		}

	_Tuple_val<_This> _Myfirst;	
	};


	

template<class... _Types1,
	class... _Types2> inline
	bool operator==(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (_Left._Equals(_Right));
	}

template<class... _Types1,
	class... _Types2> inline
	bool operator!=(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class... _Types1,
	class... _Types2> inline
	bool operator<(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (_Left._Less(_Right));
	}

template<class... _Types1,
	class... _Types2> inline
	bool operator>=(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class... _Types1,
	class... _Types2> inline
	bool operator>(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (_Right < _Left);
	}

template<class... _Types1,
	class... _Types2> inline
	bool operator<=(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class... _Types> inline
	void swap(tuple<_Types...>& _Left,
		tuple<_Types...>& _Right)
			
	{	
	return (_Left.swap(_Right));
	}


	
template<size_t _Index,
	class _Tuple>
	struct tuple_element;

template<class _This,
	class... _Rest>
	struct tuple_element<0, tuple<_This, _Rest...> >
	{	
	typedef _This type;
	typedef typename add_lvalue_reference<const _This>::type _Ctype;
	typedef typename add_lvalue_reference<_This>::type _Rtype;
	typedef typename add_rvalue_reference<_This>::type _RRtype;
	typedef tuple<_This, _Rest...> _Ttype;
	};

template<size_t _Index,
	class _This,
	class... _Rest>
	struct tuple_element<_Index, tuple<_This, _Rest...> >
		: public tuple_element<_Index - 1, tuple<_Rest...> >
	{	
	};


template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, const _Tuple>
	: public tuple_element<_Index, _Tuple>
	{	
	typedef tuple_element<_Index, _Tuple> _Mybase;
	typedef typename add_const<typename _Mybase::type>::type type;
	};

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, volatile _Tuple>
	: public tuple_element<_Index, _Tuple>
	{	
	typedef tuple_element<_Index, _Tuple> _Mybase;
	typedef typename add_volatile<typename _Mybase::type>::type type;
	};

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, const volatile _Tuple>
	: public tuple_element<_Index, _Tuple>
	{	
	typedef tuple_element<_Index, _Tuple> _Mybase;
	typedef typename add_cv<typename _Mybase::type>::type type;
	};

	
template<size_t _Index,
	class... _Types> inline
	typename tuple_element<_Index, tuple<_Types...> >::_Rtype
		get(tuple<_Types...>& _Tuple)
	{	
	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
		_Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<size_t _Index,
	class... _Types> inline
	typename tuple_element<_Index, tuple<_Types...> >::_Ctype
		get(const tuple<_Types...>& _Tuple)
	{	
	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
		_Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<size_t _Index,
	class... _Types> inline
	typename tuple_element<_Index, tuple<_Types...> >::_RRtype
		get(tuple<_Types...>&& _Tuple)
	{	
	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
		_Ttype;
	typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
		_RRtype;
	return (::std:: forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

	
template<class... _Types> inline
	tuple<typename _Unrefwrap<_Types>::type...>
		make_tuple(_Types&&... _Args)
	{	
	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
	return (_Ttype(::std:: forward<_Types>(_Args)...));
	}

	
template<class... _Types> inline
	tuple<_Types&...>
		tie(_Types&... _Args) throw ()
	{	
	typedef tuple<_Types&...> _Ttype;
	return (_Ttype(_Args...));
	}


	

template<class... _Types> inline
	tuple<_Types&&...>
		forward_as_tuple(_Types&&... _Args) throw ()
	{	
	return (tuple<_Types&&...>(::std:: forward<_Types>(_Args)...));
	}


	
template<class _Arg_idx_type,
	class... _Types>
	struct _Make_arg_idx1
	{	
	typedef _Arg_idx_type type;
	};

template<size_t... _Indexes,
	class _Ty,
	class... _Types>
	struct _Make_arg_idx1<_Arg_idx<_Indexes...>, _Ty, _Types...>
		: _Make_arg_idx1<_Arg_idx<sizeof...(_Types), _Indexes...>, _Types...>
	{	
	};

template<class... _Types>
	struct _Make_arg_idx
		: _Make_arg_idx1<_Arg_idx<>, _Types...>
	{	
	};

template<class _Arg_idx_type1,
	class _Arg_idx_type2>
	struct _Cat_arg_idx;

template<size_t... _Indexes1,
	size_t... _Indexes2>
	struct _Cat_arg_idx<_Arg_idx<_Indexes1...>, _Arg_idx<_Indexes2...> >
	{	
	typedef _Arg_idx<_Indexes1..., _Indexes2...> type;
	};

template<size_t _Nx,
	class _Ty>
	struct _Repeat_for
		: integral_constant<size_t, _Nx>
	{	
	};

	
template<class _Ret,
	class _Kx_arg,
	class _Ix_arg,
	size_t _Ix_next,
	class... _Tuples>
	struct _Tuple_cat2
	{	
	static_assert(sizeof...(_Tuples) == 0,
		"Unsupported tuple_cat arguments.");
	typedef _Ret type;
	typedef _Kx_arg _Kx_arg_idx;
	typedef _Ix_arg _Ix_arg_idx;
	};

template<class... _Types1,
	class _Kx_arg,
	size_t... _Ix,
	size_t _Ix_next,
	class... _Types2,
	class... _Rest>
	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, _Arg_idx<_Ix...>, _Ix_next,
		tuple<_Types2...>, _Rest...>
		: _Tuple_cat2<
			tuple<_Types1..., _Types2...>,
			typename _Cat_arg_idx<_Kx_arg,
				typename _Make_arg_idx<_Types2...>::type>::type,
			_Arg_idx<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
			_Ix_next + 1,
			_Rest...>
	{	
	};

template<class... _Tuples>
	struct _Tuple_cat1
		: _Tuple_cat2<tuple<>, _Arg_idx<>, _Arg_idx<>, 0,
			typename decay<_Tuples>::type...>
	{	
	};

template<class _Ret,
	size_t... _Kx,
	size_t... _Ix,
	class _Ty> inline
	_Ret _Tuple_cat(_Arg_idx<_Kx...>, _Arg_idx<_Ix...>, _Ty&& _Arg)
	{	
	return (_Ret(::std:: get<_Kx>(::std:: get<_Ix>(::std:: forward<_Ty>(_Arg)))...));
	}

template<class... _Tuples> inline
	typename _Tuple_cat1<_Tuples...>::type
		tuple_cat(_Tuples&&... _Tpls)
	{	
	typedef _Tuple_cat1<_Tuples...> _Cat1;
	return (_Tuple_cat<typename _Cat1::type>(
		typename _Cat1::_Kx_arg_idx(), typename _Cat1::_Ix_arg_idx(),
		::std:: forward_as_tuple(::std:: forward<_Tuples>(_Tpls)...)));
	}


	
template<class _Ty1,
	class _Ty2>
	template<class _Tuple1,
		class _Tuple2,
		size_t... _Indexes1,
		size_t... _Indexes2> inline
		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
			_Tuple2& _Val2,
			_Arg_idx<_Indexes1...>,
			_Arg_idx<_Indexes2...>)
		: first(::std:: get<_Indexes1>(::std:: move(_Val1))...),
			second(::std:: get<_Indexes2>(::std:: move(_Val2))...)
		{	
		}

	
template<class _Ty1,
	class _Ty2>
	template<class... _Types1,
		class... _Types2> inline
		pair<_Ty1, _Ty2>::pair(piecewise_construct_t,
			tuple<_Types1...> _Val1,
			tuple<_Types2...> _Val2)
			
#line 759 "d:\\programs overflow\\vc\\include\\tuple"
		: pair(_Val1, _Val2,
			typename _Make_arg_idx<_Types1...>::type(),
			typename _Make_arg_idx<_Types2...>::type())
		{	
		}
}

namespace std {
	
template<class... _Types,
	class _Alloc>
	struct uses_allocator<tuple<_Types...>, _Alloc>
		: true_type
	{	
	};

}	

namespace std {
namespace tr1 {	
using ::std:: get;
using ::std:: ignore;
using ::std:: make_tuple;
using ::std:: ref;
using ::std:: tie;
using ::std:: tuple;
using ::std:: tuple_element;
}	
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 793 "d:\\programs overflow\\vc\\include\\tuple"
#line 794 "d:\\programs overflow\\vc\\include\\tuple"





#line 9 "d:\\programs overflow\\vc\\include\\map"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		
template<class _Kty,	
	class _Ty,	
	class _Pr,	
	class _Alloc,	
	bool _Mfl>	
	class _Tmap_traits
	{	
public:
	typedef _Kty key_type;
	typedef pair<const _Kty, _Ty> value_type;
	typedef _Pr key_compare;
	typedef _Alloc allocator_type;

	enum
		{	
		_Multi = _Mfl};

	class value_compare
		: public binary_function<value_type, value_type, bool>
		{	
		friend class _Tmap_traits<_Kty, _Ty, _Pr, _Alloc, _Mfl>;

	public:
		bool operator()(const value_type& _Left,
			const value_type& _Right) const
			{	
			return (comp(_Left.first, _Right.first));
			}

		value_compare(key_compare _Pred)
			: comp(_Pred)
			{	
			}

	protected:
		key_compare comp;	
		};

	template<class _Ty1,
		class _Ty2>
		static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val)
		{	
		return (_Val.first);
		}
	};

		
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<pair<const _Kty, _Ty> > >
	class map
		: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> >
	{	
public:
	typedef map<_Kty, _Ty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> > _Mybase;
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Ty referent_type;	
	typedef _Pr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	map()
		: _Mybase(key_compare(), allocator_type())
		{	
		}

	explicit map(const allocator_type& _Al)
		: _Mybase(key_compare(), _Al)
		{	
		}

	map(const _Myt& _Right)

		: _Mybase(_Right,
			_Right._Getal().select_on_container_copy_construction())


		{	
		}

	map(const _Myt& _Right, const allocator_type& _Al)
		: _Mybase(_Right, _Al)
		{	
		}

	explicit map(const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		}

	map(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	
		_Mybase::insert(_First, _Last);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last,
			const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		_Mybase::insert(_First, _Last);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		_Mybase::insert(_First, _Last);
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	map(_Myt&& _Right)
		: _Mybase(::std:: move(_Right))
		{	
		}

	map(_Myt&& _Right, const allocator_type& _Al)
		: _Mybase(::std:: move(_Right), _Al)
		{	
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Mybase::operator=(::std:: move(_Right));
		return (*this);
		}

	mapped_type& operator[](key_type&& _Keyval)
		{	
		iterator _Where = this->lower_bound(_Keyval);
		if (_Where == this->end()
			|| this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))

			_Where = this->emplace_hint(_Where,
				piecewise_construct,
				::std:: forward_as_tuple(::std:: move(_Keyval)),
				tuple<>());


		return (_Where->second);
		}

	void swap(_Myt& _Right)
		{	
		_Mybase::swap(_Right);
		}

	map(::std:: initializer_list<value_type> _Ilist)
		: _Mybase(key_compare(), allocator_type())
		{	
		this->insert(_Ilist.begin(), _Ilist.end());
		}

	map(::std:: initializer_list<value_type> _Ilist,
		const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		this->insert(_Ilist.begin(), _Ilist.end());
		}

	map(::std:: initializer_list<value_type> _Ilist,
		const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		this->insert(_Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<value_type> _Ilist)
		{	
		this->clear();
		this->insert(_Ilist.begin(), _Ilist.end());
		return (*this);
		}






	mapped_type& operator[](const key_type& _Keyval)
		{	
		iterator _Where = this->lower_bound(_Keyval);
		if (_Where == this->end()
			|| this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))

			_Where = this->emplace_hint(_Where,
				piecewise_construct,
				::std:: forward_as_tuple(_Keyval),
				tuple<>());


		return (_Where->second);
		}

	mapped_type& at(const key_type& _Keyval)
		{	
		iterator _Where = this->lower_bound(_Keyval);
		if (_Where == this->end()
			|| this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))
			_Xout_of_range("invalid map<K, T> key");
		return (_Where->second);
		}

	const mapped_type& at(const key_type& _Keyval) const
		{	
		const_iterator _Where = this->lower_bound(_Keyval);
		if (_Where == this->end()
			|| this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))
			_Xout_of_range("invalid map<K, T> key");
		return (_Where->second);
		}
	};

template<class _Kty,
	class _Ty,
	class _Pr,
	class _Alloc> inline
	void swap(map<_Kty, _Ty, _Pr, _Alloc>& _Left,
		map<_Kty, _Ty, _Pr, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<pair<const _Kty, _Ty> > >
	class multimap
		: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> >
	{	
public:
	typedef multimap<_Kty, _Ty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> > _Mybase;
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Ty referent_type;	
	typedef _Pr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	multimap()
		: _Mybase(key_compare(), allocator_type())
		{	
		}

	explicit multimap(const allocator_type& _Al)
		: _Mybase(key_compare(), _Al)
		{	
		}

	multimap(const _Myt& _Right)

		: _Mybase(_Right,
			_Right._Getal().select_on_container_copy_construction())


		{	
		}

	multimap(const _Myt& _Right, const allocator_type& _Al)
		: _Mybase(_Right, _Al)
		{	
		}

	explicit multimap(const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		}

	multimap(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	
		_Mybase::insert(_First, _Last);
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last,
			const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		_Mybase::insert(_First, _Last);
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		_Mybase::insert(_First, _Last);
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	multimap(_Myt&& _Right)
		: _Mybase(::std:: move(_Right))
		{	
		}

	multimap(_Myt&& _Right, const allocator_type& _Al)
		: _Mybase(::std:: move(_Right), _Al)
		{	
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Mybase::operator=(::std:: move(_Right));
		return (*this);
		}

	template<class _Valty>
		typename enable_if<is_convertible<_Valty, value_type>::value,
			iterator>::type
		insert(_Valty&& _Val)
		{	
		return (_Mybase::insert(::std:: forward<_Valty>(_Val)).first);
		}

	template<class _Valty>
		typename enable_if<is_convertible<_Valty, value_type>::value,
			iterator>::type
		insert(const_iterator _Where, _Valty&& _Val)
		{	
		return (_Mybase::insert(_Where, ::std:: forward<_Valty>(_Val)));
		}

	template<class... _Valty>
		iterator emplace(_Valty&&... _Val)
		{	
		return (_Mybase::emplace(::std:: forward<_Valty>(_Val)...).first);
		}


	void swap(_Myt& _Right)
		{	
		_Mybase::swap(_Right);
		}

	multimap(::std:: initializer_list<value_type> _Ilist)
		: _Mybase(key_compare(), allocator_type())
		{	
		this->insert(_Ilist.begin(), _Ilist.end());
		}

	multimap(::std:: initializer_list<value_type> _Ilist,
		const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	
		this->insert(_Ilist.begin(), _Ilist.end());
		}

	multimap(::std:: initializer_list<value_type> _Ilist,
		const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		this->insert(_Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<value_type> _Ilist)
		{	
		this->clear();
		this->insert(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void insert(::std:: initializer_list<value_type> _Ilist)
		{	
		this->insert(_Ilist.begin(), _Ilist.end());
		}

	iterator insert(const value_type& _Val)
		{	
		return (_Mybase::insert(_Val).first);
		}

	iterator insert(const_iterator _Where, const value_type& _Val)
		{	
		return (_Mybase::insert(_Where, _Val));
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	
		_Mybase::insert(_First, _Last);
		}
	};

template<class _Kty,
	class _Ty,
	class _Pr,
	class _Alloc> inline
	void swap(multimap<_Kty, _Ty, _Pr, _Alloc>& _Left,
		multimap<_Kty, _Ty, _Pr, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 468 "d:\\programs overflow\\vc\\include\\map"
#line 469 "d:\\programs overflow\\vc\\include\\map"





#line 8 "d:\\my documents\\programs\\jotunengine2\\stdafx.h"
#line 1 "d:\\programs overflow\\vc\\include\\string"

#pragma once



#line 1 "d:\\programs overflow\\vc\\include\\iterator"

#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		
template<class _Container>
	class back_insert_iterator
		: public _Outit
	{	
public:
	typedef back_insert_iterator<_Container> _Myt;
	typedef _Container container_type;
	typedef typename _Container::value_type _Valty;

	explicit back_insert_iterator(_Container& _Cont)
		: container(::std:: addressof(_Cont))
		{	
		}

	_Myt& operator=(const _Valty& _Val)
		{	
		container->push_back(_Val);
		return (*this);
		}

	_Myt& operator=(_Valty&& _Val)
		{	
		container->push_back(::std:: forward<_Valty>(_Val));
		return (*this);
		}

	_Myt& operator*()
		{	
		return (*this);
		}

	_Myt& operator++()
		{	
		return (*this);
		}

	_Myt operator++(int)
		{	
		return (*this);
		}

protected:
	_Container *container;	
	};

template<class _Container>
	struct _Is_checked_helper<back_insert_iterator<_Container> >
		: public true_type
	{	
	};

		
template<class _Container> inline
	back_insert_iterator<_Container> back_inserter(_Container& _Cont)
	{	
	return (::std:: back_insert_iterator<_Container>(_Cont));
	}

		
template<class _Container>
	class front_insert_iterator
		: public _Outit
	{	
public:
	typedef front_insert_iterator<_Container> _Myt;
	typedef _Container container_type;
	typedef typename _Container::value_type _Valty;

	explicit front_insert_iterator(_Container& _Cont)
		: container(::std:: addressof(_Cont))
		{	
		}

	_Myt& operator=(const _Valty& _Val)
		{	
		container->push_front(_Val);
		return (*this);
		}

	_Myt& operator=(_Valty&& _Val)
		{	
		container->push_front(::std:: forward<_Valty>(_Val));
		return (*this);
		}

	_Myt& operator*()
		{	
		return (*this);
		}

	_Myt& operator++()
		{	
		return (*this);
		}

	_Myt operator++(int)
		{	
		return (*this);
		}

protected:
	_Container *container;	
	};

template<class _Container>
	struct _Is_checked_helper<front_insert_iterator<_Container> >
		: public true_type
	{	
	};

		
template<class _Container> inline
	front_insert_iterator<_Container> front_inserter(_Container& _Cont)
	{	
	return (::std:: front_insert_iterator<_Container>(_Cont));
	}

		
template<class _Container>
	class insert_iterator
		: public _Outit
	{	
public:
	typedef insert_iterator<_Container> _Myt;
	typedef _Container container_type;
	typedef typename _Container::value_type _Valty;

	insert_iterator(_Container& _Cont, typename _Container::iterator _Where)
		: container(::std:: addressof(_Cont)), iter(_Where)
		{	
		}

	_Myt& operator=(const _Valty& _Val)
		{	
		iter = container->insert(iter, _Val);
		++iter;
		return (*this);
		}

	_Myt& operator=(_Valty&& _Val)
		{	
		iter = container->insert(iter, ::std:: forward<_Valty>(_Val));
		++iter;
		return (*this);
		}

	_Myt& operator*()
		{	
		return (*this);
		}

	_Myt& operator++()
		{	
		return (*this);
		}

	_Myt& operator++(int)
		{	
		return (*this);
		}

protected:
	_Container *container;	
	typename _Container::iterator iter;	
	};

template<class _Container>
	struct _Is_checked_helper<insert_iterator<_Container> >
		: public true_type
	{	
	};

		
template<class _Container> inline
	insert_iterator<_Container> inserter(_Container& _Cont,
		typename _Container::iterator _Where)
	{	
	return (::std:: insert_iterator<_Container>(_Cont, _Where));
	}

		

template<class _Ty,
	class _Elem = char,
	class _Traits = char_traits<_Elem>,
	class _Diff = ptrdiff_t>
	class istream_iterator
		: public iterator<input_iterator_tag, _Ty, _Diff,
			const _Ty *, const _Ty&>
	{	
	typedef istream_iterator<_Ty, _Elem, _Traits, _Diff> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_istream<_Elem, _Traits> istream_type;

	typedef const _Ty *pointer;

	istream_iterator()
		: _Myistr(0)
		{	
		}

	istream_iterator(istream_type& _Istr)
		: _Myistr(&_Istr)
		{	
		_Getval();
		}

	const _Ty& operator*() const
		{	
		return (_Myval);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
		_Getval();
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	bool _Equal(const _Myt& _Right) const
		{	
		return (_Myistr == _Right._Myistr);
		}

protected:
	void _Getval()
		{	
		if (_Myistr != 0 && !(*_Myistr >> _Myval))
			_Myistr = 0;
		}

	istream_type *_Myistr;	
	_Ty _Myval;	
	};

template<class _Ty,
	class _Elem,
	class _Traits,
	class _Diff>
	struct _Is_checked_helper<istream_iterator<_Ty, _Elem, _Traits, _Diff> >
		: public true_type
	{	
	};

		
template<class _Ty,
	class _Elem,
	class _Traits,
	class _Diff> inline
	bool operator==(
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
	{	
	return (_Left._Equal(_Right));
	}

template<class _Ty,
	class _Elem,
	class _Traits,
	class _Diff> inline
	bool operator!=(
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
		const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
	{	
	return (!(_Left == _Right));
	}

		

template<class _Ty,
	class _Elem = char,
	class _Traits = char_traits<_Elem> >
	class ostream_iterator
		: public _Outit
	{	
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_ostream<_Elem, _Traits> ostream_type;

	ostream_iterator(ostream_type& _Ostr,
		const _Elem *_Delim = 0)
		: _Myostr(&_Ostr), _Mydelim(_Delim)
		{	
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator=(const _Ty& _Val)
		{	
		*_Myostr << _Val;
		if (_Mydelim != 0)
			*_Myostr << _Mydelim;
		return (*this);
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator*()
		{	
		return (*this);
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator++()
		{	
		return (*this);
		}

	ostream_iterator<_Ty, _Elem, _Traits>& operator++(int)
		{	
		return (*this);
		}

protected:
	const _Elem *_Mydelim;	
	ostream_type *_Myostr;	
	};

template<class _Ty,
	class _Elem,
	class _Traits>
	struct _Is_checked_helper<ostream_iterator<_Ty, _Elem, _Traits> >
		: public true_type
	{	
	};
}

namespace stdext {
using ::std:: iterator_traits;
using ::std:: size_t;

		
template<class _Iterator>
	class checked_array_iterator
	{	
public:
	typedef checked_array_iterator<_Iterator> _Myt;

	typedef typename iterator_traits<_Iterator>::iterator_category
		iterator_category;
	typedef typename iterator_traits<_Iterator>::value_type
		value_type;
	typedef typename iterator_traits<_Iterator>::difference_type
		difference_type;
	typedef typename iterator_traits<_Iterator>::difference_type
		distance_type;	
	typedef typename iterator_traits<_Iterator>::pointer
		pointer;
	typedef typename iterator_traits<_Iterator>::reference
		reference;

	checked_array_iterator()
		: _Myarray(), _Mysize(0), _Myindex(0)
		{	
		}

	checked_array_iterator(_Iterator _Array, size_t _Size,
		size_t _Index = 0)
		: _Myarray(_Array), _Mysize(_Size), _Myindex(_Index)
		{	
		{ if (!(_Index <= _Size)) { (void) ((!!(("_Index <= _Size" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\iterator", 385, 0, L"%s", L"\"_Index <= _Size\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\iterator", 385, 0); } ; };
		}

	_Iterator base() const
		{	
		return (_Myarray + _Myindex);
		}

	typedef _Iterator _Unchecked_type;

	_Myt& _Rechecked(_Unchecked_type _Right)
		{	
		_Myindex = _Right - _Myarray;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (base());
		}

	reference operator*() const
		{	
		{ if (!(_Myarray != 0 && _Myindex < _Mysize)) { (void) ((!!(("_Myarray != 0 && _Myindex < _Mysize" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\iterator", 409, 0, L"%s", L"\"_Myarray != 0 && _Myindex < _Mysize\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\iterator", 409, 0); } ; };
#line 410 "d:\\programs overflow\\vc\\include\\iterator"
		return (_Myarray[_Myindex]);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
		{ if (!(_Myarray != 0 && _Myindex < _Mysize)) { (void) ((!!(("_Myarray != 0 && _Myindex < _Mysize" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\iterator", 421, 0, L"%s", L"\"_Myarray != 0 && _Myindex < _Mysize\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\iterator", 421, 0); } ; };
#line 422 "d:\\programs overflow\\vc\\include\\iterator"
		++_Myindex;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		{ if (!(_Myarray != 0 && 0 < _Myindex)) { (void) ((!!(("_Myarray != 0 && 0 < _Myindex" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\iterator", 436, 0, L"%s", L"\"_Myarray != 0 && 0 < _Myindex\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\iterator", 436, 0); } ; };
#line 437 "d:\\programs overflow\\vc\\include\\iterator"
		--_Myindex;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt& operator+=(difference_type _Off)
		{	
		{ if (!(_Myarray != 0 && _Myindex + _Off <= _Mysize)) { (void) ((!!(("_Myarray != 0 && _Myindex + _Off <= _Mysize" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\iterator", 451, 0, L"%s", L"\"_Myarray != 0 && _Myindex + _Off <= _Mysize\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\iterator", 451, 0); } ; };
#line 452 "d:\\programs overflow\\vc\\include\\iterator"
		_Myindex += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myt operator-(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myt& _Right) const
		{	
		{ if (!(_Myarray == _Right._Myarray)) { (void) ((!!(("_Myarray == _Right._Myarray" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\iterator", 475, 0, L"%s", L"\"_Myarray == _Right._Myarray\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\iterator", 475, 0); } ; };
		return (_Myindex - _Right._Myindex);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myt& _Right) const
		{	
		{ if (!(_Myarray == _Right._Myarray)) { (void) ((!!(("_Myarray == _Right._Myarray" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\iterator", 486, 0, L"%s", L"\"_Myarray == _Right._Myarray\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\iterator", 486, 0); } ; };
		return (_Myindex == _Right._Myindex);
		}

	bool operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myt& _Right) const
		{	
		{ if (!(_Myarray == _Right._Myarray)) { (void) ((!!(("_Myarray == _Right._Myarray" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\iterator", 497, 0, L"%s", L"\"_Myarray == _Right._Myarray\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\iterator", 497, 0); } ; };
		return (_Myindex < _Right._Myindex);
		}

	bool operator>(const _Myt& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myt& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myt& _Right) const
		{	
		return (!(*this < _Right));
		}

private:
	_Iterator _Myarray;	
	size_t _Mysize;	
	size_t _Myindex;	
	};

template<class _Iterator> inline
	typename checked_array_iterator<_Iterator>::_Unchecked_type
		_Unchecked(checked_array_iterator<_Iterator> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Iterator> inline
	checked_array_iterator<_Iterator>&
		_Rechecked(checked_array_iterator<_Iterator>& _Iter,
			typename checked_array_iterator<_Iterator>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Iterator> inline
	checked_array_iterator<_Iterator> operator+(
		typename checked_array_iterator<_Iterator>::difference_type _Off,
		checked_array_iterator<_Iterator> _Next)
	{	
	return (_Next += _Off);
	}

template<class _Iterator> inline
	checked_array_iterator<_Iterator> make_checked_array_iterator(
		_Iterator _Array, size_t _Size, size_t _Index = 0)
	{	
	return (checked_array_iterator<_Iterator>(_Array, _Size, _Index));
	}

		
template<class _Iterator>
	class unchecked_array_iterator
	{	
public:
	typedef unchecked_array_iterator<_Iterator> _Myt;

	typedef typename iterator_traits<_Iterator>::iterator_category
		iterator_category;
	typedef typename iterator_traits<_Iterator>::value_type
		value_type;
	typedef typename iterator_traits<_Iterator>::difference_type
		difference_type;
	typedef typename iterator_traits<_Iterator>::difference_type
		distance_type;	
	typedef typename iterator_traits<_Iterator>::pointer
		pointer;
	typedef typename iterator_traits<_Iterator>::reference
		reference;

	unchecked_array_iterator()
		: _Myptr()
		{	
		}

	explicit unchecked_array_iterator(_Iterator _Ptr)
		: _Myptr(_Ptr)
		{	
		}

	_Iterator base() const
		{	
		return (_Myptr);
		}

	typedef _Iterator _Unchecked_type;

	_Myt& _Rechecked(_Unchecked_type _Right)
		{	
		_Myptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (base());
		}

	reference operator*() const
		{	
		return (*_Myptr);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
		++_Myptr;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		--_Myptr;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt& operator+=(difference_type _Off)
		{	
		_Myptr += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myt operator-(difference_type _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myt& _Right) const
		{	
		return (_Myptr - _Right._Myptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myt& _Right) const
		{	
		return (_Myptr == _Right._Myptr);
		}

	bool operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myt& _Right) const
		{	
		return (_Myptr < _Right._Myptr);
		}

	bool operator>(const _Myt& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myt& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myt& _Right) const
		{	
		return (!(*this < _Right));
		}

private:
	_Iterator _Myptr;	
	};

template<class _Iterator> inline
	typename unchecked_array_iterator<_Iterator>::_Unchecked_type
		_Unchecked(unchecked_array_iterator<_Iterator> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Iterator> inline
	unchecked_array_iterator<_Iterator>&
		_Rechecked(unchecked_array_iterator<_Iterator>& _Iter,
			typename unchecked_array_iterator<_Iterator>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Iterator> inline
	unchecked_array_iterator<_Iterator> operator+(
		typename unchecked_array_iterator<_Iterator>::difference_type _Off,
		unchecked_array_iterator<_Iterator> _Next)
	{	
	return (_Next += _Off);
	}

template<class _Iterator> inline
	unchecked_array_iterator<_Iterator> make_unchecked_array_iterator(
		_Iterator _Ptr)
	{	
	return (unchecked_array_iterator<_Iterator>(_Ptr));
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 740 "d:\\programs overflow\\vc\\include\\iterator"
#line 741 "d:\\programs overflow\\vc\\include\\iterator"






















#line 7 "d:\\programs overflow\\vc\\include\\string"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)
 #pragma warning(disable: 4172)

namespace std {
		
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	typedef ctype<_Elem> _Ctype;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());
		_Str.erase();

		try {
		_Mysizt _Size = 0 < _Istr.width()
			&& (_Mysizt)_Istr.width() < _Str.max_size()
				? (_Mysizt)_Istr.width() : _Str.max_size();
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())
			if(_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Traits::to_char_type(_Meta)))
				break;	
			else
				{	
				_Str.append(1, _Traits::to_char_type(_Meta));
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.width(0);
	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr, true);

	if (_Ok)
		{	
		try {
		_Str.erase();
		const typename _Traits::int_type _Metadelim =
			_Traits::to_int_type(_Delim);
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; ; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Traits::eq_int_type(_Meta, _Metadelim))
				{	
				_Changed = true;
				_Istr.rdbuf()->sbumpc();
				break;
				}
			else if (_Str.max_size() <= _Str.size())
				{	
				_State |= ios_base::failbit;
				break;
				}
			else
				{	
				_Str += _Traits::to_char_type(_Meta);
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (getline(_Istr, _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (::std:: move(_Istr) >> _Str);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	
	return (getline(::std:: move(_Istr), _Str, _Delim));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (getline(::std:: move(_Istr), _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr,
		const basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	_Mysizt _Size = _Str.size();
	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
		? 0 : (_Mysizt)_Ostr.width() - _Size;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
	try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)
				!= (streamsize)_Size)
				_State |= ios_base::badbit;
		else
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

		











inline int stoi(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if ((*_errno()) == 34 || _Ans < (-2147483647 - 1) != 2147483647 < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stol argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	unsigned long _Ans = :: strtoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline _Longlong stoll(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	_Longlong _Ans = :: _strtoi64(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline _ULonglong stoull(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	char *_Eptr;
	_ULonglong _Ans = :: _strtoui64(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	char *_Eptr;
	float _Ans = (float):: strtod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stof argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	char *_Eptr;
	double _Ans = :: strtod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stod argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	char *_Eptr;
	long double _Ans = :: strtod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stold argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		
inline int stoi(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if ((*_errno()) == 34 || _Ans < (-2147483647 - 1) != 2147483647 < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stol argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	unsigned long _Ans = :: wcstoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline _Longlong stoll(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	_Longlong _Ans = :: _wcstoi64(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline _ULonglong stoull(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	wchar_t *_Eptr;
	_ULonglong _Ans = :: _wcstoui64(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	wchar_t *_Eptr;
	float _Ans = (float):: wcstod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stof argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	wchar_t *_Eptr;
	double _Ans = :: wcstod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stod argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	(*_errno()) = 0;
	wchar_t *_Eptr;
	long double _Ans = :: wcstod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stold argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		

 

 


inline string to_string(int _Val)
	{	
	char _Buf[2 * 32];

	:: sprintf_s(_Buf, sizeof (_Buf), "%d", _Val);
	return (string(_Buf));
	}

inline string to_string(unsigned int _Val)
	{	
	char _Buf[2 * 32];

	:: sprintf_s(_Buf, sizeof (_Buf), "%u", _Val);
	return (string(_Buf));
	}

inline string to_string(long _Val)
	{	
	char _Buf[2 * 32];

	:: sprintf_s(_Buf, sizeof (_Buf), "%ld", _Val);
	return (string(_Buf));
	}

inline string to_string(unsigned long _Val)
	{	
	char _Buf[2 * 32];

	:: sprintf_s(_Buf, sizeof (_Buf), "%lu", _Val);
	return (string(_Buf));
	}

inline string to_string(_Longlong _Val)
	{	
	char _Buf[2 * 32];

	:: sprintf_s(_Buf, sizeof (_Buf), "%I64" "d", _Val);
	return (string(_Buf));
	}

inline string to_string(_ULonglong _Val)
	{	
	char _Buf[2 * 32];

	:: sprintf_s(_Buf, sizeof (_Buf), "%I64" "u", _Val);
	return (string(_Buf));
	}

inline string to_string(long double _Val)
	{	
	typedef back_insert_iterator<string> _Iter;
	typedef num_put<char, _Iter> _Nput;
	const _Nput& _Nput_fac = use_facet<_Nput>(locale());
	ostream _Ios((streambuf *)0);
	string _Str;

	_Ios.setf(ios_base::fixed);
	_Nput_fac.put(_Iter(_Str), _Ios, ' ', _Val);
	return (_Str);
	}

inline string to_string(double _Val)
	{	
	return (to_string((long double)_Val));
	}

inline string to_string(float _Val)
	{	
	return (to_string((long double)_Val));
	}

		

 

 


inline wstring to_wstring(int _Val)
	{	
	wchar_t _Buf[2 * 32];

	:: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%d", _Val);
	return (wstring(_Buf));
	}

inline wstring to_wstring(unsigned int _Val)
	{	
	wchar_t _Buf[2 * 32];

	:: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%u", _Val);
	return (wstring(_Buf));
	}

inline wstring to_wstring(long _Val)
	{	
	wchar_t _Buf[2 * 32];

	:: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%ld", _Val);
	return (wstring(_Buf));
	}

inline wstring to_wstring(unsigned long _Val)
	{	
	wchar_t _Buf[2 * 32];

	:: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%lu", _Val);
	return (wstring(_Buf));
	}

inline wstring to_wstring(_Longlong _Val)
	{	
	wchar_t _Buf[2 * 32];

	:: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%I64" L"d", _Val);
	return (wstring(_Buf));
	}

inline wstring to_wstring(_ULonglong _Val)
	{	
	wchar_t _Buf[2 * 32];

	:: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%I64" L"u", _Val);
	return (wstring(_Buf));
	}

inline wstring to_wstring(long double _Val)
	{	
	typedef back_insert_iterator<wstring> _Iter;
	typedef num_put<wchar_t, _Iter> _Nput;
	const _Nput& _Nput_fac = use_facet<_Nput>(locale());
	ostream _Ios((streambuf *)0);
	wstring _Str;

	_Ios.setf(ios_base::fixed);
	_Nput_fac.put(_Iter(_Str), _Ios, L' ', _Val);
	return (_Str);
	}

inline wstring to_wstring(double _Val)
	{	
	return (to_wstring((long double)_Val));
	}

inline wstring to_wstring(float _Val)
	{	
	return (to_wstring((long double)_Val));
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 654 "d:\\programs overflow\\vc\\include\\string"
#line 655 "d:\\programs overflow\\vc\\include\\string"





#line 9 "d:\\my documents\\programs\\jotunengine2\\stdafx.h"
#line 1 "d:\\programs overflow\\vc\\include\\vector"

#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4127)
 #pragma warning(disable: 4244)

namespace std {
 

		
template<class _Myvec>
	class _Vector_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			typename _Myvec::value_type,
			typename _Myvec::difference_type,
			typename _Myvec::const_pointer,
			typename _Myvec::const_reference,
			_Iterator_base>
	{	
public:
	typedef _Vector_const_iterator<_Myvec> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Myvec::value_type value_type;
	typedef typename _Myvec::difference_type difference_type;
	typedef typename _Myvec::const_pointer pointer;
	typedef typename _Myvec::const_reference reference;
	typedef typename _Myvec::pointer _Tptr;

	_Vector_const_iterator()
		: _Ptr()
		{	
		}

	_Vector_const_iterator(_Tptr _Parg, const _Container_base *_Pvector)
		: _Ptr(_Parg)
		{	
		this->_Adopt(_Pvector);
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = (_Tptr)_Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr));
		}

	reference operator*() const
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
			{	
			_Debug_message(L"vector iterator not dereferencable", L"d:\\programs overflow\\vc\\include\\vector", 72);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\vector", 73, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\vector", 73, 0); };
			}

 





#line 83 "d:\\programs overflow\\vc\\include\\vector"

		;

		return (*this->_Ptr);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
			{	
			_Debug_message(L"vector iterator not incrementable", L"d:\\programs overflow\\vc\\include\\vector", 101);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\vector", 102, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\vector", 102, 0); };
			}

 




#line 111 "d:\\programs overflow\\vc\\include\\vector"

		++this->_Ptr;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == 0
			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
			{	
			_Debug_message(L"vector iterator not decrementable", L"d:\\programs overflow\\vc\\include\\vector", 130);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\vector", 131, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\vector", 131, 0); };
			}

 




#line 140 "d:\\programs overflow\\vc\\include\\vector"

		--this->_Ptr;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
			{	
			_Debug_message(L"vector iterator + offset out of range", L"d:\\programs overflow\\vc\\include\\vector", 159);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\vector", 160, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\vector", 160, 0); };
			}

 




#line 169 "d:\\programs overflow\\vc\\include\\vector"

		_Ptr += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr - _Right._Ptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (this->_Ptr < _Right._Ptr);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Myiter& _Right) const
		{	
		if (this->_Getcont() == 0
			|| this->_Getcont() != _Right._Getcont())
			{	
			_Debug_message(L"vector iterators incompatible", L"d:\\programs overflow\\vc\\include\\vector", 240);
			{ (void) ((!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\vector", 241, 0, L"%s", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\vector", 241, 0); };
			}
		}

 










#line 257 "d:\\programs overflow\\vc\\include\\vector"

	_Tptr _Ptr;	
	};

template<class _Myvec> inline
	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Myvec> inline
	_Vector_const_iterator<_Myvec>&
		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
			typename _Vector_const_iterator<_Myvec>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Myvec> inline
	_Vector_const_iterator<_Myvec> operator+(
		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
		_Vector_const_iterator<_Myvec> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Myvec>
	class _Vector_iterator
		: public _Vector_const_iterator<_Myvec>
	{	
public:
	typedef _Vector_iterator<_Myvec> _Myiter;
	typedef _Vector_const_iterator<_Myvec> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Myvec::value_type value_type;
	typedef typename _Myvec::difference_type difference_type;
	typedef typename _Myvec::pointer pointer;
	typedef typename _Myvec::reference reference;

	_Vector_iterator()
		{	
		}

	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
		: _Mybase(_Parg, _Pvector)
		{	
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr));
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (::std:: pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Myvec> inline
	typename _Vector_iterator<_Myvec>::_Unchecked_type
		_Unchecked(_Vector_iterator<_Myvec> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Myvec> inline
	_Vector_iterator<_Myvec>&
		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
			typename _Vector_iterator<_Myvec>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Myvec> inline
	_Vector_iterator<_Myvec> operator+(
		typename _Vector_iterator<_Myvec>::difference_type _Off,
		_Vector_iterator<_Myvec> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference>
	struct _Vec_iter_types
	{	
	typedef _Value_type value_type;
	typedef _Size_type size_type;
	typedef _Difference_type difference_type;
	typedef _Pointer pointer;
	typedef _Const_pointer const_pointer;
	typedef _Reference reference;
	typedef _Const_reference const_reference;
	};

template<class _Ty,
	class _Alloc0>
	struct _Vec_base_types
	{	
	typedef _Alloc0 _Alloc;
	typedef _Vec_base_types<_Ty, _Alloc> _Myt;

	typedef _Wrap_alloc<_Alloc> _Alty0;
	typedef typename _Alty0::template rebind<_Ty>::other _Alty;


	typedef typename _Alty::pointer _Tptr;
	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;

	typedef typename _If<_Is_simple_alloc<_Alty>::value,
		_Simple_types<typename _Alty::value_type>,
		_Vec_iter_types<typename _Alty::value_type,
			typename _Alty::size_type,
			typename _Alty::difference_type,
			typename _Alty::pointer,
			typename _Alty::const_pointer,
			typename _Alty::reference,
			typename _Alty::const_reference> >::type
		_Val_types;
	};

		
template<class _Val_types>
	class _Vector_val
		: public _Container_base
	{	
public:
	typedef _Vector_val<_Val_types> _Myt;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _Vector_iterator<_Myt> iterator;
	typedef _Vector_const_iterator<_Myt> const_iterator;

	_Vector_val()
		{	
		_Myfirst = pointer();
		_Mylast = pointer();
		_Myend = pointer();
		}

	pointer _Myfirst;	
	pointer _Mylast;	
	pointer _Myend;	
	};

		
template<bool _Al_has_storage,
	class _Alloc_types>
	class _Vector_alloc
		: public _Vector_val<typename _Alloc_types::_Val_types>
	{	
public:
	typename _Alloc_types::_Alty _Alval;	

	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;
	typedef typename _Alloc_types::_Alty _Alty;

 















#line 522 "d:\\programs overflow\\vc\\include\\vector"
	_Vector_alloc(const _Alty& _Al = _Alty())
		: _Alval(_Al)
		{	
		_Alloc_proxy();
		}

	~_Vector_alloc() throw ()
		{	
		_Free_proxy();
		}

	void _Change_alloc(const _Alty& _Al)
		{	
		_Free_proxy();
		this->_Alval = _Al;
		_Alloc_proxy();
		}

	void _Swap_alloc(_Myt& _Right)
		{	
		_Swap_adl(this->_Alval, _Right._Alval);
		_Swap_adl(this->_Myproxy, _Right._Myproxy);
		}

	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(this->_Alval);
		this->_Myproxy = _Alproxy.allocate(1);
		_Alproxy.construct(this->_Myproxy, _Container_proxy());
		this->_Myproxy->_Mycont = this;
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(this->_Alval);
		this->_Orphan_all();
		_Alproxy.destroy(this->_Myproxy);
		_Alproxy.deallocate(this->_Myproxy, 1);
		this->_Myproxy = 0;
		}
 #line 565 "d:\\programs overflow\\vc\\include\\vector"

	_Alty& _Getal()
		{	
		return (this->_Alval);
		}

	const _Alty& _Getal() const
		{	
		return (this->_Alval);
		}
	};

template<class _Alloc_types>
	class _Vector_alloc<false, _Alloc_types>
		: public _Vector_val<typename _Alloc_types::_Val_types>
	{	
public:
	typedef _Vector_alloc<false, _Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;

	typedef typename _Alloc_types::_Alty _Alty;

 












#line 601 "d:\\programs overflow\\vc\\include\\vector"
	_Vector_alloc(const _Alloc& = _Alloc())
		{	
		_Alloc_proxy();
		}

	~_Vector_alloc() throw ()
		{	
		_Free_proxy();
		}

	void _Change_alloc(const _Alty&)
		{	
		}

	void _Swap_alloc(_Myt& _Right)
		{	
		_Swap_adl(this->_Myproxy, _Right._Myproxy);
		}

	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy;
		this->_Myproxy = _Alproxy.allocate(1);
		_Alproxy.construct(this->_Myproxy, _Container_proxy());
		this->_Myproxy->_Mycont = this;
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy;
		this->_Orphan_all();
		_Alproxy.destroy(this->_Myproxy);
		_Alproxy.deallocate(this->_Myproxy, 1);
		this->_Myproxy = 0;
		}
 #line 639 "d:\\programs overflow\\vc\\include\\vector"

	_Alty _Getal() const
		{	
		return (_Alty());
		}
	};

		
template<class _Ty,
	class _Alloc = allocator<_Ty> >
	class vector
		: public _Vector_alloc<!is_empty<_Alloc>::value,
			_Vec_base_types<_Ty, _Alloc> >
	{	
public:
	typedef vector<_Ty, _Alloc> _Myt;
	typedef _Vector_alloc<!is_empty<_Alloc>::value,
		_Vec_base_types<_Ty, _Alloc> > _Mybase;
	typedef _Alloc allocator_type;

	typedef typename _Mybase::_Alty _Alty;

	typedef typename _Mybase::value_type value_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;

 
 

	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	vector()
		: _Mybase()
		{	
		}

	explicit vector(const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		}

	explicit vector(size_type _Count)
		: _Mybase()
		{	
		if (_Buy(_Count))
			{	
			_Alty _Alval(this->_Getal());
			try {
			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
			this->_Mylast += _Count;
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	vector(size_type _Count, const value_type& _Val)
		: _Mybase()
		{	
		_Construct_n(_Count, ::std:: addressof(_Val));
		}

	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Construct_n(_Count, ::std:: addressof(_Val));
		}

	vector(const _Myt& _Right)

		: _Mybase(_Right._Getal().select_on_container_copy_construction())


		{	
		if (_Buy(_Right.size()))
			try {
			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
				this->_Myfirst);
			} catch (...) {
			_Tidy();
			throw;
			}
		}

	vector(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		if (_Buy(_Right.size()))
			try {
			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
				this->_Myfirst);
			} catch (...) {
			_Tidy();
			throw;
			}
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>:: type>
		vector(_Iter _First, _Iter _Last)
		: _Mybase()
		{	
		_Construct(_First, _Last);
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>:: type>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Construct(_First, _Last);
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last)
		{	
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
		{	
		try {

		for (; _First != _Last; ++_First)
			emplace_back(*_First);

		} catch (...) {
		_Tidy();
		throw;
		}
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
		{	
		if (_Buy(::std:: distance(_First, _Last)))
			{	
			try {
			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	void _Construct_n(size_type _Count, const value_type *_Pval)
		{	
		if (_Buy(_Count))
			{	
			try {
			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	vector(_Myt&& _Right)
		: _Mybase(_Right._Getal())
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right), true_type());
		}

	vector(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Tidy();
			if (_Alty::propagate_on_container_move_assignment::value
				&& this->_Getal() != _Right._Getal())
				this->_Change_alloc(_Right._Getal());

			_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right, true_type)
		{	
		this->_Swap_all((_Myt&)_Right);
		this->_Myfirst = _Right._Myfirst;
		this->_Mylast = _Right._Mylast;
		this->_Myend = _Right._Myend;

		_Right._Myfirst = pointer();
		_Right._Mylast = pointer();
		_Right._Myend = pointer();
		}

	void _Assign_rv(_Myt&& _Right, false_type)
		{	
		if (get_allocator() == _Right.get_allocator())
			_Assign_rv(::std:: forward<_Myt>(_Right), true_type());
		else
			_Construct(::std:: make_move_iterator(_Right.begin()),
				::std:: make_move_iterator(_Right.end()));
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right),
			typename _Alty::propagate_on_container_move_assignment());
		}


	void push_back(value_type&& _Val)
		{	
		if (_Inside(::std:: addressof(_Val)))
			{	
			size_type _Idx = ::std:: addressof(_Val) - this->_Myfirst;
			if (this->_Mylast == this->_Myend)
				_Reserve(1);
			_Orphan_range(this->_Mylast, this->_Mylast);
			this->_Getal().construct(this->_Mylast,
				::std:: forward<value_type>(this->_Myfirst[_Idx]));
			++this->_Mylast;
			}
		else
			{	
			if (this->_Mylast == this->_Myend)
				_Reserve(1);
			_Orphan_range(this->_Mylast, this->_Mylast);
			this->_Getal().construct(this->_Mylast,
				::std:: forward<value_type>(_Val));
			++this->_Mylast;
			}
		}

	iterator insert(const_iterator _Where, _Ty&& _Val)
		{	
		return (emplace(_Where, ::std:: move(_Val)));
		}

	template<class... _Valty>
		void emplace_back(_Valty&&... _Val)
		{	
		if (this->_Mylast == this->_Myend)
			_Reserve(1);
		_Orphan_range(this->_Mylast, this->_Mylast);
		this->_Getal().construct(this->_Mylast,
			::std:: forward<_Valty>(_Val)...);
		++this->_Mylast;
		}

	template<class... _Valty>
		iterator emplace(const_iterator _Where, _Valty&&... _Val)
		{	
		size_type _Off = (_Where)._Ptr - this->_Myfirst;

 
		if (size() < _Off)
			_Debug_message(L"vector emplace iterator outside range", L"d:\\programs overflow\\vc\\include\\vector", 910);
 #line 912 "d:\\programs overflow\\vc\\include\\vector"

		emplace_back(::std:: forward<_Valty>(_Val)...);
		::std:: rotate(begin() + _Off, end() - 1, end());
		return (begin() + _Off);
		}


	vector(::std:: initializer_list<value_type> _Ilist,
		const _Alloc& _Al = allocator_type())
		: _Mybase(_Al)
		{	
		insert(begin(), _Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<value_type> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void assign(::std:: initializer_list<value_type> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		}

	iterator insert(const_iterator _Where,
		::std:: initializer_list<value_type> _Ilist)
		{	
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	~vector() throw ()
		{	
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_copy_assignment::value)
				{	
				_Tidy();
				this->_Change_alloc(_Right._Getal());
				}

			this->_Orphan_all();

			if (_Right.empty())
				clear();	
			else if (_Right.size() <= size())
				{	
				pointer _Ptr = _Copy_impl(_Right._Myfirst,
					_Right._Mylast, this->_Myfirst);	
				_Destroy(_Ptr, this->_Mylast);	
				this->_Mylast = this->_Myfirst + _Right.size();
				}
			else if (_Right.size() <= capacity())
				{	
				pointer _Ptr = _Right._Myfirst + size();
				_Copy_impl(_Right._Myfirst,
					_Ptr, this->_Myfirst);
				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
				}
			else
				{	
				if (this->_Myfirst != pointer())
					{	
					_Destroy(this->_Myfirst, this->_Mylast);
					this->_Getal().deallocate(this->_Myfirst,
						this->_Myend - this->_Myfirst);
					}
				if (_Buy(_Right.size()))
					try {
					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
						this->_Myfirst);
					} catch (...) {
					_Tidy();
					throw;
					}
				}
			}
		return (*this);
		}

	void reserve(size_type _Count)
		{	
		if (capacity() < _Count)
			{	
			if (max_size() < _Count)
				_Xlen();
			_Reallocate(_Count);
			}
		}

	size_type capacity() const throw ()
		{	
		return (this->_Myend - this->_Myfirst);
		}

	size_type _Unused_capacity() const throw ()
		{	
		return (this->_Myend - this->_Mylast);
		}

	size_type _Has_unused_capacity() const throw ()
		{	
		return (this->_Myend != this->_Mylast);
		}

	iterator begin() throw ()
		{	
		return (iterator(this->_Myfirst, this));
		}

	const_iterator begin() const throw ()
		{	
		return (const_iterator(this->_Myfirst, this));
		}

	iterator end() throw ()
		{	
		return (iterator(this->_Mylast, this));
		}

	const_iterator end() const throw ()
		{	
		return (const_iterator(this->_Mylast, this));
		}

	iterator _Make_iter(const_iterator _Where) const
		{	
		return (iterator(_Where._Ptr, this));
		}

	reverse_iterator rbegin() throw ()
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const throw ()
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() throw ()
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const throw ()
		{	
		return (const_reverse_iterator(begin()));
		}

	const_iterator cbegin() const throw ()
		{	
		return (((const _Myt *)this)->begin());
		}

	const_iterator cend() const throw ()
		{	
		return (((const _Myt *)this)->end());
		}

	const_reverse_iterator crbegin() const throw ()
		{	
		return (((const _Myt *)this)->rbegin());
		}

	const_reverse_iterator crend() const throw ()
		{	
		return (((const _Myt *)this)->rend());
		}

	void shrink_to_fit()
		{	
		if (_Has_unused_capacity())
			{	
			if (empty())
				_Tidy();
			else
				_Reallocate(size());
			}
		}

	void resize(size_type _Newsize)
		{	
		if (_Newsize < size())
			_Pop_back_n(size() - _Newsize);
		else if (size() < _Newsize)
			{	
			_Alty _Alval(this->_Getal());
			_Reserve(_Newsize - size());
			try {
			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
				_Alval);
			} catch (...) {
			_Tidy();
			throw;
			}
			this->_Mylast += _Newsize - size();
			}
		}

	void resize(size_type _Newsize, const value_type& _Val)
		{	
		if (_Newsize < size())
			_Pop_back_n(size() - _Newsize);
		else if (size() < _Newsize)
			{	
			const value_type *_Ptr = ::std:: addressof(_Val);

			if (_Inside(_Ptr))
				{	
				const difference_type _Idx = _Ptr
					- ::std:: addressof(*this->_Myfirst);
				_Reserve(_Newsize - size());
				_Ptr = ::std:: addressof(*this->_Myfirst) + _Idx;
				}
			else
				_Reserve(_Newsize - size());

			try {
			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
			} catch (...) {
			_Tidy();
			throw;
			}
			this->_Mylast += _Newsize - size();
			}
		}

	size_type size() const throw ()
		{	
		return (this->_Mylast - this->_Myfirst);
		}

	size_type max_size() const throw ()
		{	
		return (this->_Getal().max_size());
		}

	bool empty() const throw ()
		{	
		return (this->_Myfirst == this->_Mylast);
		}

	_Alloc get_allocator() const throw ()
		{	
		return (this->_Getal());
		}

	const_reference at(size_type _Pos) const
		{	
		if (size() <= _Pos)
			_Xran();
		return (*(this->_Myfirst + _Pos));
		}

	reference at(size_type _Pos)
		{	
		if (size() <= _Pos)
			_Xran();
		return (*(this->_Myfirst + _Pos));
		}

	const_reference operator[](size_type _Pos) const
		{	
 
		if (size() <= _Pos)
			{	
			_Debug_message(L"vector subscript out of range", L"d:\\programs overflow\\vc\\include\\vector", 1185);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\vector", 1186, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\vector", 1186, 0); };
			}

 

#line 1192 "d:\\programs overflow\\vc\\include\\vector"

		return (*(this->_Myfirst + _Pos));
		}

	reference operator[](size_type _Pos)
		{	
 
		if (size() <= _Pos)
			{	
			_Debug_message(L"vector subscript out of range", L"d:\\programs overflow\\vc\\include\\vector", 1201);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\vector", 1202, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\vector", 1202, 0); };
			}

 

#line 1208 "d:\\programs overflow\\vc\\include\\vector"

		return (*(this->_Myfirst + _Pos));
		}

	pointer data() throw ()
		{	
		return (this->_Myfirst);
		}

	const_pointer data() const throw ()
		{	
		return (this->_Myfirst);
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	void push_back(const value_type& _Val)
		{	
		if (_Inside(::std:: addressof(_Val)))
			{	
			size_type _Idx = ::std:: addressof(_Val) - this->_Myfirst;
			if (this->_Mylast == this->_Myend)
				_Reserve(1);
			_Orphan_range(this->_Mylast, this->_Mylast);
			this->_Getal().construct(this->_Mylast,
				this->_Myfirst[_Idx]);
			++this->_Mylast;
			}
		else
			{	
			if (this->_Mylast == this->_Myend)
				_Reserve(1);
			_Orphan_range(this->_Mylast, this->_Mylast);
			this->_Getal().construct(this->_Mylast,
				_Val);
			++this->_Mylast;
			}
		}

 
	void pop_back()
		{	
		if (empty())
			_Debug_message(L"vector empty before pop", L"d:\\programs overflow\\vc\\include\\vector", 1269);
		else
			{	
			_Orphan_range(this->_Mylast - 1, this->_Mylast);
			this->_Getal().destroy(this->_Mylast - 1);
			--this->_Mylast;
			}
		}

 





#line 1285 "d:\\programs overflow\\vc\\include\\vector"

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			void>::type
		assign(_Iter _First, _Iter _Last)
		{	
		clear();
		_Assign(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{	
		for (; _First != _Last; ++_First)
			emplace_back(*_First);
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
		{	
		if (_First == _Last)
			return;	

		size_type _Newsize = ::std:: distance(_First, _Last);

		if (capacity() < _Newsize)
			{	
			size_type _Newcapacity = _Grow_to(_Newsize);
			_Tidy();
			_Buy(_Newcapacity);
			}

		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
		}

	void assign(size_type _Count, const value_type& _Val)
		{	
		clear();
		insert(begin(), _Count, _Val);
		}

	iterator insert(const_iterator _Where, const _Ty& _Val)
		{	
		return (_Insert_n(_Where, (size_type)1, _Val));
		}

	iterator insert(const_iterator _Where, size_type _Count,
		const _Ty& _Val)
		{	
		return (_Insert_n(_Where, _Count, _Val));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = (_Where)._Ptr - this->_Myfirst;
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		return (begin() + _Off);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
			input_iterator_tag)
		{	
		size_type _Off = (_Where)._Ptr - this->_Myfirst;

 
		if (size() < _Off)
			_Debug_message(L"vector insert iterator outside range", L"d:\\programs overflow\\vc\\include\\vector", 1355);
 #line 1357 "d:\\programs overflow\\vc\\include\\vector"

		if (_First != _Last)
			{	
			size_type _Oldsize = size();

			try {
			for (; _First != _Last; ++_First)
				push_back(*_First);	

			} catch (...) {
			erase(begin() + _Oldsize, end());
			throw;
			}

			::std:: rotate(begin() + _Off, begin() + _Oldsize, end());
			}
		}

	template<class _Iter>
		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	
 
		if (_Where._Getcont() != this
			|| (_Where)._Ptr < this->_Myfirst
			|| this->_Mylast < (_Where)._Ptr)
			_Debug_message(L"vector insert iterator outside range", L"d:\\programs overflow\\vc\\include\\vector", 1383);
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\vector", 1384);
 #line 1386 "d:\\programs overflow\\vc\\include\\vector"

		size_type _Count = 0;
		_Distance(_First, _Last, _Count);

		if (_Count == 0)
			;
		else if (_Unused_capacity() < _Count)
			{	
			if (max_size() - size() < _Count)
				_Xlen();	

			size_type _Capacity = _Grow_to(size() + _Count);
			pointer _Newvec = this->_Getal().allocate(_Capacity);
			pointer _Ptr = _Newvec;

			try {
			_Ptr = _Umove(this->_Myfirst, (_Where)._Ptr,
				_Newvec);	
			_Ptr = _Ucopy(_First, _Last, _Ptr);	
			_Umove((_Where)._Ptr, this->_Mylast,
				_Ptr);	
			} catch (...) {
			_Destroy(_Newvec, _Ptr);
			this->_Getal().deallocate(_Newvec, _Capacity);
			throw;
			}

			_Count += size();
			if (this->_Myfirst != pointer())
				{	
				_Destroy(this->_Myfirst, this->_Mylast);
				this->_Getal().deallocate(this->_Myfirst,
					this->_Myend - this->_Myfirst);
				}

			this->_Orphan_all();
			this->_Myend = _Newvec + _Capacity;
			this->_Mylast = _Newvec + _Count;
			this->_Myfirst = _Newvec;
			}
		else
			{	
			_Ucopy(_First, _Last, this->_Mylast);
			::std:: rotate((_Where)._Ptr, this->_Mylast,
				this->_Mylast + _Count);
			this->_Mylast += _Count;
			_Orphan_range((_Where)._Ptr, this->_Mylast);
			}
		}

 
	iterator erase(const_iterator _Where)
		{	
		if (_Where._Getcont() != this
			|| (_Where)._Ptr < this->_Myfirst
			|| this->_Mylast <= (_Where)._Ptr)
			_Debug_message(L"vector erase iterator outside range", L"d:\\programs overflow\\vc\\include\\vector", 1442);
		_Move((_Where)._Ptr + 1, this->_Mylast, (_Where)._Ptr);
		_Destroy(this->_Mylast - 1, this->_Mylast);
		_Orphan_range((_Where)._Ptr, this->_Mylast);
		--this->_Mylast;
		return (_Make_iter(_Where));
		}

 








#line 1460 "d:\\programs overflow\\vc\\include\\vector"

	iterator erase(const_iterator _First_arg,
		const_iterator _Last_arg)
		{	
		if (_First_arg == begin() && _Last_arg == end())
			clear();
		else if (_First_arg != _Last_arg)
			{	
			iterator _First = _Make_iter(_First_arg);
			iterator _Last = _Make_iter(_Last_arg);

			if (_First != _Last)
				{	
 
				if (_Last < _First || _First._Getcont() != this
					|| (_First)._Ptr < this->_Myfirst
					|| this->_Mylast < (_Last)._Ptr)
					_Debug_message(L"vector erase iterator outside range", L"d:\\programs overflow\\vc\\include\\vector", 1477);
				pointer _Ptr = _Move((_Last)._Ptr, this->_Mylast,
					(_First)._Ptr);
				_Orphan_range((_First)._Ptr, this->_Mylast);

 


#line 1486 "d:\\programs overflow\\vc\\include\\vector"

				_Destroy(_Ptr, this->_Mylast);
				this->_Mylast = _Ptr;
				}
			}
		return (_Make_iter(_First_arg));
		}

	void _Pop_back_n(size_type _Count)
		{	
		pointer _Ptr = this->_Mylast - _Count;

 
		_Orphan_range(_Ptr, this->_Mylast);
 #line 1501 "d:\\programs overflow\\vc\\include\\vector"

		_Destroy(_Ptr, this->_Mylast);
		this->_Mylast = _Ptr;
		}

	void clear() throw ()
		{	
		this->_Orphan_all();
		_Destroy(this->_Myfirst, this->_Mylast);
		this->_Mylast = this->_Myfirst;
		}

	void swap(_Myt& _Right)
		{	
		if (this == &_Right)
			;	
		else if (this->_Getal() == _Right._Getal())
			{	
			this->_Swap_all(_Right);
			_Swap_adl(this->_Myfirst, _Right._Myfirst);
			_Swap_adl(this->_Mylast, _Right._Mylast);
			_Swap_adl(this->_Myend, _Right._Myend);
			}

		else if (_Alty::propagate_on_container_swap::value)
			{	
			this->_Swap_alloc(_Right);
			_Swap_adl(this->_Myfirst, _Right._Myfirst);
			_Swap_adl(this->_Mylast, _Right._Mylast);
			_Swap_adl(this->_Myend, _Right._Myend);
			}

		else
			{	
 
			_Debug_message(L"vector containers incompatible for swap", L"d:\\programs overflow\\vc\\include\\vector", 1536);

 

#line 1541 "d:\\programs overflow\\vc\\include\\vector"
			}
		}

protected:
	bool _Buy(size_type _Capacity)
		{	
		this->_Myfirst = pointer();
		this->_Mylast = pointer();
		this->_Myend = pointer();

		if (_Capacity == 0)
			return (false);
		else if (max_size() < _Capacity)
			_Xlen();	
		else
			{	
			this->_Myfirst = this->_Getal().allocate(_Capacity);
			this->_Mylast = this->_Myfirst;
			this->_Myend = this->_Myfirst + _Capacity;
			}
		return (true);
		}

	void _Destroy(pointer _First, pointer _Last)
		{	
		_Alty _Alval(this->_Getal());
		_Destroy_range(_First, _Last, _Alval);
		}

	size_type _Grow_to(size_type _Count) const
		{	
		size_type _Capacity = capacity();

		_Capacity = max_size() - _Capacity / 2 < _Capacity
			? 0 : _Capacity + _Capacity / 2;	
		if (_Capacity < _Count)
			_Capacity = _Count;
		return (_Capacity);
		}

	bool _Inside(const value_type *_Ptr) const
		{	
		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
		}

	void _Reallocate(size_type _Count)
		{	
		pointer _Ptr = this->_Getal().allocate(_Count);

		try {
		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
		} catch (...) {
		this->_Getal().deallocate(_Ptr, _Count);
		throw;
		}

		size_type _Size = size();
		if (this->_Myfirst != pointer())
			{	
			_Destroy(this->_Myfirst, this->_Mylast);
			this->_Getal().deallocate(this->_Myfirst,
				this->_Myend - this->_Myfirst);
			}

		this->_Orphan_all();
		this->_Myend = _Ptr + _Count;
		this->_Mylast = _Ptr + _Size;
		this->_Myfirst = _Ptr;
		}

	void _Reserve(size_type _Count)
		{	
		if (_Unused_capacity() < _Count)
			{	
			if (max_size() - size() < _Count)
				_Xlen();
			_Reallocate(_Grow_to(size() + _Count));
			}
		}

	void _Tidy()
		{	
		if (this->_Myfirst != pointer())
			{	
			this->_Orphan_all();
			_Destroy(this->_Myfirst, this->_Mylast);
			this->_Getal().deallocate(this->_Myfirst,
				this->_Myend - this->_Myfirst);
			this->_Myfirst = pointer();
			this->_Mylast = pointer();
			this->_Myend = pointer();
			}
		}

	template<class _Iter>
		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
		{	
		_Alty _Alval(this->_Getal());
		return (_Uninitialized_copy(_First, _Last,
			_Ptr, _Alval));
		}

	template<class _Iter>
		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
		{	
		_Alty _Alval(this->_Getal());
		return (_Uninitialized_move(_First, _Last,
			_Ptr, _Alval));
		}

	iterator _Insert_n(const_iterator _Where,
		size_type _Count, const value_type& _Val)
		{	
 
		if (_Where._Getcont() != this
			|| (_Where)._Ptr < this->_Myfirst
			|| this->_Mylast < (_Where)._Ptr)
			_Debug_message(L"vector insert iterator outside range", L"d:\\programs overflow\\vc\\include\\vector", 1658);
 #line 1660 "d:\\programs overflow\\vc\\include\\vector"

		size_type _Off = (_Where)._Ptr - this->_Myfirst;
		if (_Count == 0)
			;
		else if (_Unused_capacity() < _Count)
			{	
			if (max_size() - size() < _Count)
				_Xlen();	

			size_type _Capacity = _Grow_to(size() + _Count);
			pointer _Newvec = this->_Getal().allocate(_Capacity);
			size_type _Whereoff = (_Where)._Ptr - this->_Myfirst;
			int _Ncopied = 0;

			try {
			_Ufill(_Newvec + _Whereoff, _Count,
				::std:: addressof(_Val));	
			++_Ncopied;
			_Umove(this->_Myfirst, (_Where)._Ptr,
				_Newvec);	
			++_Ncopied;
			_Umove((_Where)._Ptr, this->_Mylast,
				_Newvec + (_Whereoff + _Count));	
			} catch (...) {
			if (1 < _Ncopied)
				_Destroy(_Newvec, _Newvec + _Whereoff);
			if (0 < _Ncopied)
				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
			this->_Getal().deallocate(_Newvec, _Capacity);
			throw;
			}

			_Count += size();
			if (this->_Myfirst != pointer())
				{	
				_Destroy(this->_Myfirst, this->_Mylast);
				this->_Getal().deallocate(this->_Myfirst,
					this->_Myend - this->_Myfirst);
				}

			this->_Orphan_all();
			this->_Myend = _Newvec + _Capacity;
			this->_Mylast = _Newvec + _Count;
			this->_Myfirst = _Newvec;
			}
		else if ((size_type)(this->_Mylast - (_Where)._Ptr)
			< _Count)
			{	
			value_type _Tmp = _Val;	

			_Umove((_Where)._Ptr, this->_Mylast,
				(_Where)._Ptr + _Count);	

			try {
			_Ufill(this->_Mylast,
				_Count - (this->_Mylast - (_Where)._Ptr),
				::std:: addressof(_Tmp));	
			} catch (...) {
			_Destroy((_Where)._Ptr + _Count,
				this->_Mylast + _Count);
			throw;
			}

			this->_Mylast += _Count;
			_Orphan_range((_Where)._Ptr, this->_Mylast);
			::std:: fill((_Where)._Ptr, this->_Mylast - _Count,
				_Tmp);	
			}
		else
			{	
			value_type _Tmp = _Val;	

			pointer _Oldend = this->_Mylast;
			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
				this->_Mylast);	

			_Orphan_range((_Where)._Ptr, this->_Mylast);
			_Copy_backward((_Where)._Ptr, _Oldend - _Count,
				_Oldend);	
			::std:: fill((_Where)._Ptr,
				(_Where)._Ptr + _Count, _Tmp);	
			}
		return (begin() + _Off);
		}

	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
		{	
		_Alty _Alval(this->_Getal());
		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
		return (_Ptr + _Count);
		}

	__declspec(noreturn) void _Xlen() const
		{	
		_Xlength_error("vector<T> too long");
		}

	__declspec(noreturn) void _Xran() const
		{	
		_Xout_of_range("invalid vector<T> subscript");
		}

 
	void _Orphan_range(pointer _First, pointer _Last) const
		{	
		_Lockit _Lock(3);
		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();
		if (_Pnext != 0)
			while (*_Pnext != 0)
				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
				else
					{	
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
		}

 



#line 1783 "d:\\programs overflow\\vc\\include\\vector"
	};

		

template<class _Ty,
	class _Alloc> inline
	void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator==(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator!=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}




typedef unsigned int _Vbase;	
const int _VBITS = 8 * sizeof (_Vbase);	

		
template<class _Alloc>
	class _Vb_iter_base
		: public _Iterator012<random_access_iterator_tag,
			_Bool,
			typename _Alloc::difference_type,
			bool *,
			bool,
			_Iterator_base>
	{	
public:
	typedef typename _Alloc::size_type _Sizet;
	typedef vector<_Bool, _Alloc> _Mycont;

	_Vb_iter_base()
		: _Myptr(0), _Myoff(0)
		{	
		}

	_Vb_iter_base(const _Vbase *_Ptr, _Sizet _Off,
		const _Container_base *_Mypvbool)
		: _Myptr(_Ptr), _Myoff(_Off)
		{	
		this->_Adopt(_Mypvbool);
		}

	void _Advance(_Sizet _Off)
		{	
		_Myoff += _Off;
		_Myptr += _Myoff / _VBITS;
		_Myoff %= _VBITS;
		}

	int _Valid(_Sizet _Inc) const
		{	
 
		_Sizet _Mysize = ((_Mycont *)this->_Getcont())->_Mysize;

		_Inc += _Myoff;
		_Inc += _VBITS * (_Myptr
			- (((_Mycont *)this->_Getcont())->_Myvec)._Myfirst);
		return (_Inc < _Mysize ? -1 : _Inc == _Mysize ? 0 : +1);

 


#line 1897 "d:\\programs overflow\\vc\\include\\vector"
		}

	const _Vbase *_Myptr;
	_Sizet _Myoff;
	};

		
template<class _Alloc>
	class _Vb_reference
		: public _Vb_iter_base<_Alloc>
	{	
	typedef _Vb_iter_base<_Alloc> _Mybase;
	typedef _Vb_reference<_Alloc> _Mytype;

	_Vb_reference() throw ()
		{	
		}

public:
	_Vb_reference(const _Mybase& _Right)
		: _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont())
		{	
		}

	_Mytype& operator=(const _Mytype& _Right) throw ()
		{	
		return (*this = bool(_Right));
		}

	_Mytype& operator=(bool _Val) throw ()
		{	
		if (_Val)
			*(_Vbase *)_Getptr() |= _Mask();
		else
			*(_Vbase *)_Getptr() &= (~_Mask());	
		return (*this);
		}

	void flip() throw ()
		{	
		*(_Vbase *)_Getptr() ^= _Mask();
		}

	operator bool() const throw ()
		{	
		return ((*_Getptr() & _Mask()) != 0);
		}

	const _Vbase *_Getptr() const
		{	
 
		if (this->_Getcont() == 0
			|| this->_Myptr == 0
			|| 0 <= this->_Valid(0))
			{	
			_Debug_message(L"vector<bool> iterator not dereferencable", L"d:\\programs overflow\\vc\\include\\vector", 1952);
			{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\vector", 1953, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\vector", 1953, 0); };
			}

 


#line 1960 "d:\\programs overflow\\vc\\include\\vector"

		return (this->_Myptr);
		}

protected:
	_Vbase _Mask() const
		{	
		return ((_Vbase)(1 << this->_Myoff));
		}
	};

template<class _Alloc> inline
	void swap(_Vb_reference<_Alloc> _Left,
		_Vb_reference<_Alloc> _Right)
	{	
	bool _Val = _Left;	
	_Left = _Right;
	_Right = _Val;
	}

		
template<class _Alloc>
	class _Vb_const_iterator
		: public _Vb_iter_base<_Alloc>
	{	
public:
	typedef _Vb_iter_base<_Alloc> _Mybase;
	typedef _Vb_const_iterator<_Alloc> _Mytype;

	typedef _Vb_reference<_Alloc> _Reft;
	typedef bool const_reference;

	typedef random_access_iterator_tag iterator_category;
	typedef _Bool value_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef const_reference *pointer;
	typedef const_reference reference;

	_Vb_const_iterator()
		{	
		}

	_Vb_const_iterator(const _Vbase *_Ptr, const _Container_base *_Mypvbool)
		: _Mybase(_Ptr, 0, _Mypvbool)
		{	
		}

	const_reference operator*() const
		{	
		return (_Reft(*this));
		}

	_Mytype& operator++()
		{	
		_Inc();
		return (*this);
		}

	_Mytype operator++(int)
		{	
		_Mytype _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Mytype& operator--()
		{	
		_Dec();
		return (*this);
		}

	_Mytype operator--(int)
		{	
		_Mytype _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Mytype& operator+=(difference_type _Off)
		{	
		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)
			{	
			this->_Myoff += _Off;
			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;
			this->_Myoff %= _VBITS;
			}
		else
			{	
			this->_Myoff += _Off;
			this->_Myptr += this->_Myoff / _VBITS;
			this->_Myoff %= _VBITS;
			}
		return (*this);
		}

	_Mytype operator+(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Mytype& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Mytype operator-(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(
		const _Mytype& _Right) const
		{	
		_Compat(_Right);
		return (_VBITS * (this->_Myptr - _Right._Myptr)
			+ (difference_type)this->_Myoff
			- (difference_type)_Right._Myoff);
		}

	const_reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Mytype& _Right) const
		{	
		_Compat(_Right);
		return (this->_Myptr == _Right._Myptr
			&& this->_Myoff == _Right._Myoff);
		}

	bool operator!=(const _Mytype& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Mytype& _Right) const
		{	
		_Compat(_Right);
		return (this->_Myptr < _Right._Myptr
			|| (this->_Myptr == _Right._Myptr
				&& this->_Myoff < _Right._Myoff));
		}

	bool operator>(const _Mytype& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Mytype& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Mytype& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Mytype& _Right) const
		{	
		if (this->_Getcont() == 0
			|| this->_Getcont() != _Right._Getcont())
			_Debug_message(L"vector<bool> iterators incompatible", L"d:\\programs overflow\\vc\\include\\vector", 2127);
		}

 










#line 2142 "d:\\programs overflow\\vc\\include\\vector"

	void _Dec()
		{	
		if (this->_Myoff != 0)
			--this->_Myoff;
		else
			{	
 
			if (this->_Getcont() == 0 || 0 < this->_Valid((size_type)-1))
				{	
				_Debug_message(L"vector<bool> iterator not decrementable", L"d:\\programs overflow\\vc\\include\\vector", 2152);
				{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\vector", 2153, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\vector", 2153, 0); };
				}

 


#line 2160 "d:\\programs overflow\\vc\\include\\vector"

			this->_Myoff = _VBITS - 1;
			--this->_Myptr;
			}
		}

	void _Inc()
		{	
		if (this->_Myoff < _VBITS - 1)
			++this->_Myoff;
		else
			{	
 
			if (this->_Getcont() == 0 || 0 < this->_Valid(1))
				{	
				_Debug_message(L"vector<bool> iterator not incrementable", L"d:\\programs overflow\\vc\\include\\vector", 2175);
				{ (void) ((!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"d:\\programs overflow\\vc\\include\\vector", 2176, 0, L"%s", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"d:\\programs overflow\\vc\\include\\vector", 2176, 0); };
				}

 


#line 2183 "d:\\programs overflow\\vc\\include\\vector"

			this->_Myoff = 0;
			++this->_Myptr;
			}
		}
	};

template<class _Alloc> inline
	_Vb_const_iterator<_Alloc> operator+(
		typename _Alloc::difference_type _Off,
		_Vb_const_iterator<_Alloc> _Right)
		{	
		return (_Right += _Off);
		}

template<class _Alloc>
	struct _Is_checked_helper<_Vb_const_iterator<_Alloc> >
		: public true_type
	{	
	};

	
template<class _Alloc>
	class _Vb_iterator
		: public _Vb_const_iterator<_Alloc>
	{	
public:
	typedef _Vb_const_iterator<_Alloc> _Mybase;
	typedef _Vb_iterator<_Alloc> _Mytype;

	typedef _Vb_reference<_Alloc> _Reft;
	typedef bool const_reference;

	typedef random_access_iterator_tag iterator_category;
	typedef _Bool value_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef _Reft *pointer;
	typedef _Reft reference;

	_Vb_iterator()
		{	
		}

	_Vb_iterator(_Vbase *_Ptr, _Container_base *_Mypvbool)
		: _Mybase(_Ptr, _Mypvbool)
		{	
		}

	reference operator*() const
		{	
		return (_Reft(*this));
		}

	_Mytype& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Mytype operator++(int)
		{	
		_Mytype _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Mytype& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Mytype operator--(int)
		{	
		_Mytype _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Mytype& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Mytype operator+(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Mytype& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Mytype operator-(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Alloc> inline
	_Vb_iterator<_Alloc> operator+(typename _Alloc::difference_type _Off,
		_Vb_iterator<_Alloc> _Right)
		{	
		return (_Right += _Off);
		}

template<class _Alloc>
	struct _Is_checked_helper<_Vb_iterator<_Alloc> >
		: public true_type
	{	
	};

		
template<class _Alloc>
	class _Vb_val
		: public _Container_base
	{	
public:
	typedef ::std:: vector<_Vbase, _Alloc> _Vectype;
	typedef typename _Vectype::_Alty _Alty;
	typedef typename _Alty::size_type size_type;

	_Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
		: _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)
		{	
		_Alloc_proxy();
		_Mysize = 0;
		}

	_Vb_val(const _Vb_val& _Right)
		: _Myvec(_Right._Myvec),
			_Mysize(_Right._Mysize)
		{	
		_Alloc_proxy();
		}

	_Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
		: _Myvec(_Right._Myvec, _Al),
			_Mysize(_Right._Mysize)
		{	
		_Alloc_proxy();
		}

	_Vb_val(_Vb_val&& _Right)
		: _Myvec(::std:: forward<_Vectype>(_Right._Myvec)),
			_Mysize(_Right._Mysize)
		{	
		_Right._Mysize = 0;
		_Alloc_proxy();
		}

	_Vb_val(_Vb_val&& _Right, const _Alloc& _Al)
		: _Myvec(::std:: forward<_Vectype>(_Right._Myvec), _Al),
			_Mysize(_Right._Mysize)
		{	
		_Right._Mysize = 0;
		_Alloc_proxy();
		}

	~_Vb_val() throw ()
		{	
		_Free_proxy();
		}

 












#line 2376 "d:\\programs overflow\\vc\\include\\vector"
	void _Swap_alloc(_Vb_val& _Right)
		{	
		_Swap_adl(this->_Myproxy, _Right._Myproxy);
		}

	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Myvec.get_allocator());
		this->_Myproxy = _Alproxy.allocate(1);
		_Alproxy.construct(this->_Myproxy, _Container_proxy());
		this->_Myproxy->_Mycont = this;
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Myvec.get_allocator());
		this->_Orphan_all();
		_Alproxy.destroy(this->_Myproxy);
		_Alproxy.deallocate(this->_Myproxy, 1);
		this->_Myproxy = 0;
		}
 #line 2400 "d:\\programs overflow\\vc\\include\\vector"

	static size_type _Nw(size_type _Count)
		{	
		return ((_Count + _VBITS - 1) / _VBITS);
		}

	_Vectype _Myvec;	
	typename _Alty::size_type _Mysize;	
	};

		

template<class _Alloc>
	class vector<_Bool, _Alloc>
		: public _Vb_val<_Alloc>
	{	
public:
	typedef ::std:: vector<_Bool, _Alloc> _Myt;
	typedef _Vb_val<_Alloc> _Mybase;
	typedef typename _Mybase::_Alty _Alty;
	typedef typename _Mybase::_Vectype _Vectype;

	typedef typename _Alty::size_type size_type;
	typedef typename _Alty::difference_type difference_type;
	typedef _Bool _Ty;
	typedef _Alloc allocator_type;

	typedef _Vb_reference<_Alty> reference;
	typedef bool const_reference;
	typedef bool value_type;

	typedef reference _Reft;
	typedef _Vb_const_iterator<_Alty> const_iterator;
	typedef _Vb_iterator<_Alty> iterator;

	typedef iterator pointer;
	typedef const_iterator const_pointer;
	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	static const int _VBITS = ::std:: _VBITS;
	enum {_EEN_VBITS = _VBITS};	
	vector()
		: _Mybase(0, false)
		{	
		}

	explicit vector(const _Alloc& _Al)
		: _Mybase(0, false, _Al)
		{	
		}

	explicit vector(size_type _Count, const bool& _Val = false)
		: _Mybase(_Count, _Val)
		{	
		_Trim(_Count);
		}

	vector(size_type _Count, const bool& _Val, const _Alloc& _Al)
		: _Mybase(_Count, _Val, _Al)
		{	
		_Trim(_Count);
		}

	vector(const _Myt& _Right)
		: _Mybase(_Right)
		{	
		}

	vector(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Right, _Al)
		{	
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		vector(_Iter _First, _Iter _Last)
		: _Mybase(0, false)
		{	
		_BConstruct(_First, _Last);
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mybase(0, false, _Al)
		{	
		_BConstruct(_First, _Last);
		}

	template<class _Iter>
		void _BConstruct(_Iter _First, _Iter _Last)
		{	
		insert(begin(), _First, _Last);
		}

	vector(_Myt&& _Right)
		: _Mybase(::std:: forward<_Myt>(_Right))
		{	
		}

	vector(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(::std:: forward<_Myt>(_Right), _Al)
		{	
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			clear();

			if (_Alty::propagate_on_container_move_assignment::value
				&& this->get_allocator() != _Right.get_allocator())
				{	
				this->_Free_proxy();
				this->_Myvec = ::std:: move(_Right._Myvec);
				this->_Alloc_proxy();
				}
			else
				this->_Myvec = ::std:: move(_Right._Myvec);


			this->_Mysize = _Right._Mysize;
			_Right._Mysize = 0;
			}
		return (*this);
		}

	vector(::std:: initializer_list<bool> _Ilist,
			const _Alloc& _Al = allocator_type())
		: _Mybase(0, false, _Al)
		{	
		insert(begin(), _Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<bool> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void assign(::std:: initializer_list<bool> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		}

	iterator insert(const_iterator _Where,
			::std:: initializer_list<bool> _Ilist)
		{	
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	~vector() throw ()
		{	
		this->_Mysize = 0;
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		this->_Mysize = _Right._Mysize;
		this->_Myvec = _Right._Myvec;
		return (*this);
		}

	void reserve(size_type _Count)
		{	
		this->_Myvec.reserve(this->_Nw(_Count));
		}

	size_type capacity() const throw ()
		{	
		return (this->_Myvec.capacity() * _VBITS);
		}

	iterator begin() throw ()
		{	
		return (iterator((_Vbase *)this->_Myvec._Myfirst, this));
		}

	const_iterator begin() const throw ()
		{	
		return (const_iterator((_Vbase *)this->_Myvec._Myfirst, this));
		}

	iterator end() throw ()
		{	
		iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += this->_Mysize;
		return (_Tmp);
		}

	const_iterator end() const throw ()
		{	
		const_iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += this->_Mysize;
		return (_Tmp);
		}

	const_iterator cbegin() const throw ()
		{	
		return (((const _Myt *)this)->begin());
		}

	const_iterator cend() const throw ()
		{	
		return (((const _Myt *)this)->end());
		}

	const_reverse_iterator crbegin() const throw ()
		{	
		return (((const _Myt *)this)->rbegin());
		}

	const_reverse_iterator crend() const throw ()
		{	
		return (((const _Myt *)this)->rend());
		}

	void shrink_to_fit()
		{	
		if (this->_Myvec._Has_unused_capacity())
			{	
			_Myt _Tmp(*this);
			swap(_Tmp);
			}
		}

	iterator _Make_iter(const_iterator _Where)
		{	
		iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += _Where - begin();
		return (_Tmp);
		}

	reverse_iterator rbegin() throw ()
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const throw ()
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() throw ()
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const throw ()
		{	
		return (const_reverse_iterator(begin()));
		}

	void resize(size_type _Newsize, bool _Val = false)
		{	
		if (size() < _Newsize)
			_Insert_n(end(), _Newsize - size(), _Val);
		else if (_Newsize < size())
			erase(begin() + _Newsize, end());
		}

	size_type size() const throw ()
		{	
		return (this->_Mysize);
		}

	size_type max_size() const throw ()
		{	
		const size_type _Maxsize = this->_Myvec.max_size();
		return (_Maxsize < (size_type)(-1) / _VBITS
			? _Maxsize * _VBITS : (size_type)(-1));
		}

	bool empty() const throw ()
		{	
		return (size() == 0);
		}

	_Alloc get_allocator() const throw ()
		{	
		return (this->_Myvec.get_allocator());
		}

	const_reference at(size_type _Off) const
		{	
		if (size() <= _Off)
			_Xran();
		return ((*this)[_Off]);
		}

	reference at(size_type _Off)
		{	
		if (size() <= _Off)
			_Xran();
		return ((*this)[_Off]);
		}

	const_reference operator[](size_type _Off) const
		{	
		const_iterator _It = begin();
		_It._Advance(_Off);
		return (*_It);
		}

	reference operator[](size_type _Off)
		{	
		iterator _It = begin();
		_It._Advance(_Off);
		return (*_It);
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	void push_back(const bool& _Val)
		{	
		insert(end(), _Val);
		}

	void pop_back()
		{	
		erase(end() - 1);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			void>::type
		assign(_Iter _First, _Iter _Last)
		{	
		erase(begin(), end());
		insert(begin(), _First, _Last);
		}

	void assign(size_type _Count, const bool& _Val)
		{	
		erase(begin(), end());
		_Insert_n(begin(), _Count, _Val);
		}

	iterator insert(const_iterator _Where, const bool& _Val)
		{	
		return (_Insert_n(_Where, (size_type)1, _Val));
		}

	iterator insert(const_iterator _Where, size_type _Count,
		const bool& _Val)
		{	
		return (_Insert_n(_Where, _Count, _Val));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = _Where - begin();
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		return (begin() + _Off);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
			input_iterator_tag)
		{	
		size_type _Off = _Where - begin();

		for (; _First != _Last; ++_First, ++_Off)
			insert(begin() + _Off, *_First);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	
		_Debug_range(_First, _Last, L"d:\\programs overflow\\vc\\include\\vector", 2799);
		size_type _Count = 0;
		_Distance(_First, _Last, _Count);

		size_type _Off = _Insert_x(_Where, _Count);
		::std:: copy(_First, _Last, begin() + _Off);
		}

	iterator erase(const_iterator _Where_arg)
		{	
		iterator _Where = _Make_iter(_Where_arg);
		size_type _Off = _Where - begin();

 
		if (end() <= _Where)
			_Debug_message(L"vector<bool> erase iterator outside range", L"d:\\programs overflow\\vc\\include\\vector", 2814);
		::std:: copy(_Where + 1, end(), _Where);
		_Orphan_range(_Off, this->_Mysize);

 

#line 2821 "d:\\programs overflow\\vc\\include\\vector"

		_Trim(this->_Mysize - 1);
		return (begin() + _Off);
		}

	iterator erase(const_iterator _First_arg, const_iterator _Last_arg)
		{	
		iterator _First = _Make_iter(_First_arg);
		iterator _Last = _Make_iter(_Last_arg);
		size_type _Off = _First - begin();

		if (_First != _Last)
			{	
 
			if (_Last < _First || end() < _Last)
				_Debug_message(L"vector<bool> erase iterator outside range", L"d:\\programs overflow\\vc\\include\\vector", 2836);
			iterator _Next = ::std:: copy(_Last, end(), _First);
			size_type _Newsize = _Next - begin();
			_Orphan_range(_Newsize, this->_Mysize);
			_Trim(_Newsize);

 


#line 2846 "d:\\programs overflow\\vc\\include\\vector"
			}
		return (begin() + _Off);
		}

	void clear() throw ()
		{	
		erase(begin(), end());
		}

	void flip() throw ()
		{	
		for (typename _Vectype::iterator _Next = this->_Myvec.begin();
			_Next != this->_Myvec.end(); ++_Next)
			*_Next = (_Vbase)~*_Next;
		_Trim(this->_Mysize);
		}

	void swap(_Myt& _Right)
		{	
		if (this == &_Right)
			;	
		else if (this->get_allocator() == _Right.get_allocator())
			{	
			this->_Swap_all(_Right);
			this->_Myvec.swap(_Right._Myvec);
			::std:: swap(this->_Mysize, _Right._Mysize);
			}

		else if (_Alty::propagate_on_container_swap::value)
			{	
			this->_Swap_alloc(_Right);
			this->_Myvec.swap(_Right._Myvec);
			::std:: swap(this->_Mysize, _Right._Mysize);
			}

		else
			{	
 
			_Debug_message(L"vector<bool> containers incompatible for swap", L"d:\\programs overflow\\vc\\include\\vector", 2884);

 

#line 2889 "d:\\programs overflow\\vc\\include\\vector"
			}
		}

	static void swap(reference _Left, reference _Right) throw ()
		{	
		bool _Val = _Left;	

		_Left = _Right;
		_Right = _Val;
		}

	size_t hash() const
		{	
		return (_Hash_seq((const unsigned char *)this->_Myvec.data(),
			this->_Myvec.size() * sizeof (_Vbase)));
		}

	iterator _Insert_n(const_iterator _Where,
		size_type _Count, const bool& _Val)
		{	
		size_type _Off = _Insert_x(_Where, _Count);
		::std:: fill(begin() + _Off, begin() + (_Off + _Count), _Val);
		return (begin() + _Off);
		}

	size_type _Insert_x(const_iterator _Where, size_type _Count)
		{	
		size_type _Off = _Where - begin();

 
		if (end() < _Where)
			_Debug_message(L"vector<bool> insert iterator outside range", L"d:\\programs overflow\\vc\\include\\vector", 2920);
		bool _Realloc = capacity() - size() < _Count;
 #line 2923 "d:\\programs overflow\\vc\\include\\vector"

		if (_Count == 0)
			;
		else if (max_size() - size() < _Count)
			_Xlen();	
		else
			{	
			this->_Myvec.resize(this->_Nw(size() + _Count), 0);
			if (empty())
				this->_Mysize += _Count;
			else
				{	
				iterator _Oldend = end();
				this->_Mysize += _Count;
				::std:: copy_backward(begin() + _Off, _Oldend, end());
				}

 
			_Orphan_range(_Realloc ? 0 : _Off, this->_Mysize);
 #line 2943 "d:\\programs overflow\\vc\\include\\vector"
			}
		return (_Off);
		}

 
	void _Orphan_range(size_type _Offlo, size_type _Offhi) const
		{	
		typedef _Vb_iter_base<_Alty> _Myiterbase;

		_Lockit _Lock(3);
		_Vbase *_Base = (_Vbase *)this->_Myvec._Myfirst;

		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();
		if (_Pnext != 0)
			while (*_Pnext != 0)
				{	
				size_type _Off = _VBITS * ((*_Pnext)->_Myptr - _Base)
					+ (*_Pnext)->_Myoff;
				if (_Off < _Offlo || _Offhi < _Off)
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
				else
					{	
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
				}
		}

 



#line 2976 "d:\\programs overflow\\vc\\include\\vector"

	void _Trim(size_type _Size)
		{	
		if (max_size() < _Size)
			_Xlen();	
		size_type _Words = this->_Nw(_Size);

		if (_Words < this->_Myvec.size())
			this->_Myvec.erase(this->_Myvec.begin() + _Words,
				this->_Myvec.end());
		this->_Mysize = _Size;
		_Size %= _VBITS;
		if (0 < _Size)
			this->_Myvec[_Words - 1] &= (_Vbase)((1 << _Size) - 1);
		}

	__declspec(noreturn) void _Xlen() const
		{	
		_Xlength_error("vector<bool> too long");
		}

	__declspec(noreturn) void _Xran() const
		{	
		_Xout_of_range("invalid vector<bool> subscript");
		}
	};

template<class _Alloc> inline
	bool operator==(const vector<bool, _Alloc>& _Left,
		const vector<bool, _Alloc>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& equal(_Left._Myvec.begin(), _Left._Myvec.end(),
			_Right._Myvec.begin()));
	}

template<class _Alloc> inline
	bool operator!=(const vector<bool, _Alloc>& _Left,
		const vector<bool, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

	
template<class _Alloc>
	struct hash<vector<_Bool, _Alloc> >
		: public unary_function<vector<_Bool, _Alloc>, size_t>
	{	
	typedef vector<_Bool, _Alloc> _Kty;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Keyval.hash());
		}
	};
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3037 "d:\\programs overflow\\vc\\include\\vector"
#line 3038 "d:\\programs overflow\\vc\\include\\vector"























#line 10 "d:\\my documents\\programs\\jotunengine2\\stdafx.h"


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




















































































#line 86 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


#line 89 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


#line 92 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


#line 95 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


#line 98 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


#line 101 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"























#line 125 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



#line 129 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
#line 130 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



#line 134 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
#line 135 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





#line 141 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



#line 145 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
#line 146 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




#line 151 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




#line 156 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"







#line 164 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 173 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




#line 178 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

#line 180 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
#line 181 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



#line 185 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



#line 189 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 203 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
#line 204 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"























































#line 260 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


extern "C" {
#line 264 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef unsigned int GLenum;
typedef unsigned int GLbitfield;
typedef unsigned int GLuint;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLboolean;
typedef signed char GLbyte;
typedef short GLshort;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned long GLulong;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;



#line 290 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
typedef signed long long GLint64EXT;
typedef unsigned long long GLuint64EXT;






#line 299 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
typedef GLint64EXT  GLint64;
typedef GLuint64EXT GLuint64;
typedef struct __GLsync *GLsync;

typedef char GLchar;
























































































































































































































































































































































































































































































































































__declspec(dllimport) void __stdcall glAccum (GLenum op, GLfloat value);
__declspec(dllimport) void __stdcall glAlphaFunc (GLenum func, GLclampf ref);
__declspec(dllimport) GLboolean __stdcall glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
__declspec(dllimport) void __stdcall glArrayElement (GLint i);
__declspec(dllimport) void __stdcall glBegin (GLenum mode);
__declspec(dllimport) void __stdcall glBindTexture (GLenum target, GLuint texture);
__declspec(dllimport) void __stdcall glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
__declspec(dllimport) void __stdcall glBlendFunc (GLenum sfactor, GLenum dfactor);
__declspec(dllimport) void __stdcall glCallList (GLuint list);
__declspec(dllimport) void __stdcall glCallLists (GLsizei n, GLenum type, const GLvoid *lists);
__declspec(dllimport) void __stdcall glClear (GLbitfield mask);
__declspec(dllimport) void __stdcall glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
__declspec(dllimport) void __stdcall glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
__declspec(dllimport) void __stdcall glClearDepth (GLclampd depth);
__declspec(dllimport) void __stdcall glClearIndex (GLfloat c);
__declspec(dllimport) void __stdcall glClearStencil (GLint s);
__declspec(dllimport) void __stdcall glClipPlane (GLenum plane, const GLdouble *equation);
__declspec(dllimport) void __stdcall glColor3b (GLbyte red, GLbyte green, GLbyte blue);
__declspec(dllimport) void __stdcall glColor3bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glColor3d (GLdouble red, GLdouble green, GLdouble blue);
__declspec(dllimport) void __stdcall glColor3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glColor3f (GLfloat red, GLfloat green, GLfloat blue);
__declspec(dllimport) void __stdcall glColor3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glColor3i (GLint red, GLint green, GLint blue);
__declspec(dllimport) void __stdcall glColor3iv (const GLint *v);
__declspec(dllimport) void __stdcall glColor3s (GLshort red, GLshort green, GLshort blue);
__declspec(dllimport) void __stdcall glColor3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
__declspec(dllimport) void __stdcall glColor3ubv (const GLubyte *v);
__declspec(dllimport) void __stdcall glColor3ui (GLuint red, GLuint green, GLuint blue);
__declspec(dllimport) void __stdcall glColor3uiv (const GLuint *v);
__declspec(dllimport) void __stdcall glColor3us (GLushort red, GLushort green, GLushort blue);
__declspec(dllimport) void __stdcall glColor3usv (const GLushort *v);
__declspec(dllimport) void __stdcall glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
__declspec(dllimport) void __stdcall glColor4bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
__declspec(dllimport) void __stdcall glColor4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
__declspec(dllimport) void __stdcall glColor4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
__declspec(dllimport) void __stdcall glColor4iv (const GLint *v);
__declspec(dllimport) void __stdcall glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
__declspec(dllimport) void __stdcall glColor4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
__declspec(dllimport) void __stdcall glColor4ubv (const GLubyte *v);
__declspec(dllimport) void __stdcall glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
__declspec(dllimport) void __stdcall glColor4uiv (const GLuint *v);
__declspec(dllimport) void __stdcall glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
__declspec(dllimport) void __stdcall glColor4usv (const GLushort *v);
__declspec(dllimport) void __stdcall glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
__declspec(dllimport) void __stdcall glColorMaterial (GLenum face, GLenum mode);
__declspec(dllimport) void __stdcall glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
__declspec(dllimport) void __stdcall glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
__declspec(dllimport) void __stdcall glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
__declspec(dllimport) void __stdcall glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
__declspec(dllimport) void __stdcall glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
__declspec(dllimport) void __stdcall glCullFace (GLenum mode);
__declspec(dllimport) void __stdcall glDeleteLists (GLuint list, GLsizei range);
__declspec(dllimport) void __stdcall glDeleteTextures (GLsizei n, const GLuint *textures);
__declspec(dllimport) void __stdcall glDepthFunc (GLenum func);
__declspec(dllimport) void __stdcall glDepthMask (GLboolean flag);
__declspec(dllimport) void __stdcall glDepthRange (GLclampd zNear, GLclampd zFar);
__declspec(dllimport) void __stdcall glDisable (GLenum cap);
__declspec(dllimport) void __stdcall glDisableClientState (GLenum array);
__declspec(dllimport) void __stdcall glDrawArrays (GLenum mode, GLint first, GLsizei count);
__declspec(dllimport) void __stdcall glDrawBuffer (GLenum mode);
__declspec(dllimport) void __stdcall glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
__declspec(dllimport) void __stdcall glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glEdgeFlag (GLboolean flag);
__declspec(dllimport) void __stdcall glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glEdgeFlagv (const GLboolean *flag);
__declspec(dllimport) void __stdcall glEnable (GLenum cap);
__declspec(dllimport) void __stdcall glEnableClientState (GLenum array);
__declspec(dllimport) void __stdcall glEnd (void);
__declspec(dllimport) void __stdcall glEndList (void);
__declspec(dllimport) void __stdcall glEvalCoord1d (GLdouble u);
__declspec(dllimport) void __stdcall glEvalCoord1dv (const GLdouble *u);
__declspec(dllimport) void __stdcall glEvalCoord1f (GLfloat u);
__declspec(dllimport) void __stdcall glEvalCoord1fv (const GLfloat *u);
__declspec(dllimport) void __stdcall glEvalCoord2d (GLdouble u, GLdouble v);
__declspec(dllimport) void __stdcall glEvalCoord2dv (const GLdouble *u);
__declspec(dllimport) void __stdcall glEvalCoord2f (GLfloat u, GLfloat v);
__declspec(dllimport) void __stdcall glEvalCoord2fv (const GLfloat *u);
__declspec(dllimport) void __stdcall glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
__declspec(dllimport) void __stdcall glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
__declspec(dllimport) void __stdcall glEvalPoint1 (GLint i);
__declspec(dllimport) void __stdcall glEvalPoint2 (GLint i, GLint j);
__declspec(dllimport) void __stdcall glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
__declspec(dllimport) void __stdcall glFinish (void);
__declspec(dllimport) void __stdcall glFlush (void);
__declspec(dllimport) void __stdcall glFogf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glFogfv (GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glFogi (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glFogiv (GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glFrontFace (GLenum mode);
__declspec(dllimport) void __stdcall glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
__declspec(dllimport) GLuint __stdcall glGenLists (GLsizei range);
__declspec(dllimport) void __stdcall glGenTextures (GLsizei n, GLuint *textures);
__declspec(dllimport) void __stdcall glGetBooleanv (GLenum pname, GLboolean *params);
__declspec(dllimport) void __stdcall glGetClipPlane (GLenum plane, GLdouble *equation);
__declspec(dllimport) void __stdcall glGetDoublev (GLenum pname, GLdouble *params);
__declspec(dllimport) GLenum __stdcall glGetError (void);
__declspec(dllimport) void __stdcall glGetFloatv (GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetIntegerv (GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetLightiv (GLenum light, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetMapdv (GLenum target, GLenum query, GLdouble *v);
__declspec(dllimport) void __stdcall glGetMapfv (GLenum target, GLenum query, GLfloat *v);
__declspec(dllimport) void __stdcall glGetMapiv (GLenum target, GLenum query, GLint *v);
__declspec(dllimport) void __stdcall glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetPixelMapfv (GLenum map, GLfloat *values);
__declspec(dllimport) void __stdcall glGetPixelMapuiv (GLenum map, GLuint *values);
__declspec(dllimport) void __stdcall glGetPixelMapusv (GLenum map, GLushort *values);
__declspec(dllimport) void __stdcall glGetPointerv (GLenum pname, GLvoid* *params);
__declspec(dllimport) void __stdcall glGetPolygonStipple (GLubyte *mask);
__declspec(dllimport) const GLubyte * __stdcall glGetString (GLenum name);
__declspec(dllimport) void __stdcall glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
__declspec(dllimport) void __stdcall glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
__declspec(dllimport) void __stdcall glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glHint (GLenum target, GLenum mode);
__declspec(dllimport) void __stdcall glIndexMask (GLuint mask);
__declspec(dllimport) void __stdcall glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glIndexd (GLdouble c);
__declspec(dllimport) void __stdcall glIndexdv (const GLdouble *c);
__declspec(dllimport) void __stdcall glIndexf (GLfloat c);
__declspec(dllimport) void __stdcall glIndexfv (const GLfloat *c);
__declspec(dllimport) void __stdcall glIndexi (GLint c);
__declspec(dllimport) void __stdcall glIndexiv (const GLint *c);
__declspec(dllimport) void __stdcall glIndexs (GLshort c);
__declspec(dllimport) void __stdcall glIndexsv (const GLshort *c);
__declspec(dllimport) void __stdcall glIndexub (GLubyte c);
__declspec(dllimport) void __stdcall glIndexubv (const GLubyte *c);
__declspec(dllimport) void __stdcall glInitNames (void);
__declspec(dllimport) void __stdcall glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) GLboolean __stdcall glIsEnabled (GLenum cap);
__declspec(dllimport) GLboolean __stdcall glIsList (GLuint list);
__declspec(dllimport) GLboolean __stdcall glIsTexture (GLuint texture);
__declspec(dllimport) void __stdcall glLightModelf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glLightModelfv (GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glLightModeli (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glLightModeliv (GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glLightf (GLenum light, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glLightfv (GLenum light, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glLighti (GLenum light, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glLightiv (GLenum light, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glLineStipple (GLint factor, GLushort pattern);
__declspec(dllimport) void __stdcall glLineWidth (GLfloat width);
__declspec(dllimport) void __stdcall glListBase (GLuint base);
__declspec(dllimport) void __stdcall glLoadIdentity (void);
__declspec(dllimport) void __stdcall glLoadMatrixd (const GLdouble *m);
__declspec(dllimport) void __stdcall glLoadMatrixf (const GLfloat *m);
__declspec(dllimport) void __stdcall glLoadName (GLuint name);
__declspec(dllimport) void __stdcall glLogicOp (GLenum opcode);
__declspec(dllimport) void __stdcall glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
__declspec(dllimport) void __stdcall glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
__declspec(dllimport) void __stdcall glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
__declspec(dllimport) void __stdcall glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
__declspec(dllimport) void __stdcall glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
__declspec(dllimport) void __stdcall glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
__declspec(dllimport) void __stdcall glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
__declspec(dllimport) void __stdcall glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
__declspec(dllimport) void __stdcall glMaterialf (GLenum face, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glMateriali (GLenum face, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glMaterialiv (GLenum face, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glMatrixMode (GLenum mode);
__declspec(dllimport) void __stdcall glMultMatrixd (const GLdouble *m);
__declspec(dllimport) void __stdcall glMultMatrixf (const GLfloat *m);
__declspec(dllimport) void __stdcall glNewList (GLuint list, GLenum mode);
__declspec(dllimport) void __stdcall glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
__declspec(dllimport) void __stdcall glNormal3bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
__declspec(dllimport) void __stdcall glNormal3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
__declspec(dllimport) void __stdcall glNormal3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glNormal3i (GLint nx, GLint ny, GLint nz);
__declspec(dllimport) void __stdcall glNormal3iv (const GLint *v);
__declspec(dllimport) void __stdcall glNormal3s (GLshort nx, GLshort ny, GLshort nz);
__declspec(dllimport) void __stdcall glNormal3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
__declspec(dllimport) void __stdcall glPassThrough (GLfloat token);
__declspec(dllimport) void __stdcall glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values);
__declspec(dllimport) void __stdcall glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values);
__declspec(dllimport) void __stdcall glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values);
__declspec(dllimport) void __stdcall glPixelStoref (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glPixelStorei (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glPixelTransferf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glPixelTransferi (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glPixelZoom (GLfloat xfactor, GLfloat yfactor);
__declspec(dllimport) void __stdcall glPointSize (GLfloat size);
__declspec(dllimport) void __stdcall glPolygonMode (GLenum face, GLenum mode);
__declspec(dllimport) void __stdcall glPolygonOffset (GLfloat factor, GLfloat units);
__declspec(dllimport) void __stdcall glPolygonStipple (const GLubyte *mask);
__declspec(dllimport) void __stdcall glPopAttrib (void);
__declspec(dllimport) void __stdcall glPopClientAttrib (void);
__declspec(dllimport) void __stdcall glPopMatrix (void);
__declspec(dllimport) void __stdcall glPopName (void);
__declspec(dllimport) void __stdcall glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
__declspec(dllimport) void __stdcall glPushAttrib (GLbitfield mask);
__declspec(dllimport) void __stdcall glPushClientAttrib (GLbitfield mask);
__declspec(dllimport) void __stdcall glPushMatrix (void);
__declspec(dllimport) void __stdcall glPushName (GLuint name);
__declspec(dllimport) void __stdcall glRasterPos2d (GLdouble x, GLdouble y);
__declspec(dllimport) void __stdcall glRasterPos2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos2f (GLfloat x, GLfloat y);
__declspec(dllimport) void __stdcall glRasterPos2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos2i (GLint x, GLint y);
__declspec(dllimport) void __stdcall glRasterPos2iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos2s (GLshort x, GLshort y);
__declspec(dllimport) void __stdcall glRasterPos2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glRasterPos3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glRasterPos3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos3i (GLint x, GLint y, GLint z);
__declspec(dllimport) void __stdcall glRasterPos3iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos3s (GLshort x, GLshort y, GLshort z);
__declspec(dllimport) void __stdcall glRasterPos3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
__declspec(dllimport) void __stdcall glRasterPos4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
__declspec(dllimport) void __stdcall glRasterPos4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
__declspec(dllimport) void __stdcall glRasterPos4iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
__declspec(dllimport) void __stdcall glRasterPos4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glReadBuffer (GLenum mode);
__declspec(dllimport) void __stdcall glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
__declspec(dllimport) void __stdcall glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
__declspec(dllimport) void __stdcall glRectdv (const GLdouble *v1, const GLdouble *v2);
__declspec(dllimport) void __stdcall glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
__declspec(dllimport) void __stdcall glRectfv (const GLfloat *v1, const GLfloat *v2);
__declspec(dllimport) void __stdcall glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
__declspec(dllimport) void __stdcall glRectiv (const GLint *v1, const GLint *v2);
__declspec(dllimport) void __stdcall glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
__declspec(dllimport) void __stdcall glRectsv (const GLshort *v1, const GLshort *v2);
__declspec(dllimport) GLint __stdcall glRenderMode (GLenum mode);
__declspec(dllimport) void __stdcall glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glScaled (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glScalef (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
__declspec(dllimport) void __stdcall glSelectBuffer (GLsizei size, GLuint *buffer);
__declspec(dllimport) void __stdcall glShadeModel (GLenum mode);
__declspec(dllimport) void __stdcall glStencilFunc (GLenum func, GLint ref, GLuint mask);
__declspec(dllimport) void __stdcall glStencilMask (GLuint mask);
__declspec(dllimport) void __stdcall glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
__declspec(dllimport) void __stdcall glTexCoord1d (GLdouble s);
__declspec(dllimport) void __stdcall glTexCoord1dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord1f (GLfloat s);
__declspec(dllimport) void __stdcall glTexCoord1fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord1i (GLint s);
__declspec(dllimport) void __stdcall glTexCoord1iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord1s (GLshort s);
__declspec(dllimport) void __stdcall glTexCoord1sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord2d (GLdouble s, GLdouble t);
__declspec(dllimport) void __stdcall glTexCoord2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord2f (GLfloat s, GLfloat t);
__declspec(dllimport) void __stdcall glTexCoord2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord2i (GLint s, GLint t);
__declspec(dllimport) void __stdcall glTexCoord2iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord2s (GLshort s, GLshort t);
__declspec(dllimport) void __stdcall glTexCoord2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
__declspec(dllimport) void __stdcall glTexCoord3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
__declspec(dllimport) void __stdcall glTexCoord3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord3i (GLint s, GLint t, GLint r);
__declspec(dllimport) void __stdcall glTexCoord3iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord3s (GLshort s, GLshort t, GLshort r);
__declspec(dllimport) void __stdcall glTexCoord3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
__declspec(dllimport) void __stdcall glTexCoord4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
__declspec(dllimport) void __stdcall glTexCoord4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
__declspec(dllimport) void __stdcall glTexCoord4iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
__declspec(dllimport) void __stdcall glTexCoord4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glTexEnvf (GLenum target, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexEnvi (GLenum target, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexEnviv (GLenum target, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexGend (GLenum coord, GLenum pname, GLdouble param);
__declspec(dllimport) void __stdcall glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
__declspec(dllimport) void __stdcall glTexGenf (GLenum coord, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexGeni (GLenum coord, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTexParameterf (GLenum target, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexParameteri (GLenum target, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
__declspec(dllimport) void __stdcall glTranslated (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glTranslatef (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glVertex2d (GLdouble x, GLdouble y);
__declspec(dllimport) void __stdcall glVertex2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex2f (GLfloat x, GLfloat y);
__declspec(dllimport) void __stdcall glVertex2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex2i (GLint x, GLint y);
__declspec(dllimport) void __stdcall glVertex2iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex2s (GLshort x, GLshort y);
__declspec(dllimport) void __stdcall glVertex2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertex3d (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glVertex3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex3f (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glVertex3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex3i (GLint x, GLint y, GLint z);
__declspec(dllimport) void __stdcall glVertex3iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex3s (GLshort x, GLshort y, GLshort z);
__declspec(dllimport) void __stdcall glVertex3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
__declspec(dllimport) void __stdcall glVertex4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
__declspec(dllimport) void __stdcall glVertex4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex4i (GLint x, GLint y, GLint z, GLint w);
__declspec(dllimport) void __stdcall glVertex4iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
__declspec(dllimport) void __stdcall glVertex4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
__declspec(dllimport) void __stdcall glViewport (GLint x, GLint y, GLsizei width, GLsizei height);



#line 1180 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"







#line 1188 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"





















#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winapifamily.h"


















#pragma once
#line 21 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winapifamily.h"





































#line 59 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winapifamily.h"


























































#line 118 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winapifamily.h"










































 

















#line 179 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winapifamily.h"

#line 181 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winapifamily.h"
#line 23 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\gl.h"































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 24 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"


extern "C" {
#line 28 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"


















#pragma region Desktop Family















#line 63 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"

const GLubyte* __stdcall gluErrorString (
    GLenum   errCode);

const wchar_t* __stdcall gluErrorUnicodeStringEXT (
    GLenum   errCode);

const GLubyte* __stdcall gluGetString (
    GLenum   name);

void __stdcall gluOrtho2D (
    GLdouble left, 
    GLdouble right, 
    GLdouble bottom, 
    GLdouble top);

void __stdcall gluPerspective (
    GLdouble fovy, 
    GLdouble aspect, 
    GLdouble zNear, 
    GLdouble zFar);

void __stdcall gluPickMatrix (
    GLdouble x, 
    GLdouble y, 
    GLdouble width, 
    GLdouble height, 
    GLint    viewport[4]);

void __stdcall gluLookAt (
    GLdouble eyex, 
    GLdouble eyey, 
    GLdouble eyez, 
    GLdouble centerx, 
    GLdouble centery, 
    GLdouble centerz, 
    GLdouble upx, 
    GLdouble upy, 
    GLdouble upz);

int __stdcall gluProject (
    GLdouble        objx, 
    GLdouble        objy, 
    GLdouble        objz,  
    const GLdouble  modelMatrix[16], 
    const GLdouble  projMatrix[16], 
    const GLint     viewport[4], 
    GLdouble        *winx, 
    GLdouble        *winy, 
    GLdouble        *winz);

int __stdcall gluUnProject (
    GLdouble       winx, 
    GLdouble       winy, 
    GLdouble       winz, 
    const GLdouble modelMatrix[16], 
    const GLdouble projMatrix[16], 
    const GLint    viewport[4], 
    GLdouble       *objx, 
    GLdouble       *objy, 
    GLdouble       *objz);


int __stdcall gluScaleImage (
    GLenum      format, 
    GLint       widthin, 
    GLint       heightin, 
    GLenum      typein, 
    const void  *datain, 
    GLint       widthout, 
    GLint       heightout, 
    GLenum      typeout, 
    void        *dataout);


int __stdcall gluBuild1DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);

int __stdcall gluBuild2DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLint       height, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);



class GLUnurbs;
class GLUquadric;
class GLUtesselator;


typedef class GLUnurbs GLUnurbsObj;
typedef class GLUquadric GLUquadricObj;
typedef class GLUtesselator GLUtesselatorObj;
typedef class GLUtesselator GLUtriangulatorObj;













#line 180 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"


GLUquadric* __stdcall gluNewQuadric (void);
void __stdcall gluDeleteQuadric (
    GLUquadric          *state);

void __stdcall gluQuadricNormals (
    GLUquadric          *quadObject, 
    GLenum              normals);

void __stdcall gluQuadricTexture (
    GLUquadric          *quadObject, 
    GLboolean           textureCoords);

void __stdcall gluQuadricOrientation (
    GLUquadric          *quadObject, 
    GLenum              orientation);

void __stdcall gluQuadricDrawStyle (
    GLUquadric          *quadObject, 
    GLenum              drawStyle);

void __stdcall gluCylinder (
    GLUquadric          *qobj, 
    GLdouble            baseRadius, 
    GLdouble            topRadius, 
    GLdouble            height, 
    GLint               slices, 
    GLint               stacks);

void __stdcall gluDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops);

void __stdcall gluPartialDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops, 
    GLdouble            startAngle, 
    GLdouble            sweepAngle);

void __stdcall gluSphere (
    GLUquadric          *qobj, 
    GLdouble            radius, 
    GLint               slices, 
    GLint               stacks);

void __stdcall gluQuadricCallback (
    GLUquadric          *qobj, 
    GLenum              which, 
    void                (__stdcall* fn)());

GLUtesselator* __stdcall  gluNewTess(          
    void );

void __stdcall  gluDeleteTess(       
    GLUtesselator       *tess );

void __stdcall  gluTessBeginPolygon( 
    GLUtesselator       *tess,
    void                *polygon_data );

void __stdcall  gluTessBeginContour( 
    GLUtesselator       *tess );

void __stdcall  gluTessVertex(       
    GLUtesselator       *tess,
    GLdouble            coords[3], 
    void                *data );

void __stdcall  gluTessEndContour(   
    GLUtesselator       *tess );

void __stdcall  gluTessEndPolygon(   
    GLUtesselator       *tess );

void __stdcall  gluTessProperty(     
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            value );
 
void __stdcall  gluTessNormal(       
    GLUtesselator       *tess, 
    GLdouble            x,
    GLdouble            y, 
    GLdouble            z );

void __stdcall  gluTessCallback(     
    GLUtesselator       *tess,
    GLenum              which, 
    void                (__stdcall *fn)());

void __stdcall  gluGetTessProperty(  
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            *value );
 
GLUnurbs* __stdcall gluNewNurbsRenderer (void);

void __stdcall gluDeleteNurbsRenderer (
    GLUnurbs            *nobj);

void __stdcall gluBeginSurface (
    GLUnurbs            *nobj);

void __stdcall gluBeginCurve (
    GLUnurbs            *nobj);

void __stdcall gluEndCurve (
    GLUnurbs            *nobj);

void __stdcall gluEndSurface (
    GLUnurbs            *nobj);

void __stdcall gluBeginTrim (
    GLUnurbs            *nobj);

void __stdcall gluEndTrim (
    GLUnurbs            *nobj);

void __stdcall gluPwlCurve (
    GLUnurbs            *nobj, 
    GLint               count, 
    GLfloat             *array, 
    GLint               stride, 
    GLenum              type);

void __stdcall gluNurbsCurve (
    GLUnurbs            *nobj, 
    GLint               nknots, 
    GLfloat             *knot, 
    GLint               stride, 
    GLfloat             *ctlarray, 
    GLint               order, 
    GLenum              type);

void __stdcall 
gluNurbsSurface(     
    GLUnurbs            *nobj, 
    GLint               sknot_count, 
    float               *sknot, 
    GLint               tknot_count, 
    GLfloat             *tknot, 
    GLint               s_stride, 
    GLint               t_stride, 
    GLfloat             *ctlarray, 
    GLint               sorder, 
    GLint               torder, 
    GLenum              type);

void __stdcall 
gluLoadSamplingMatrices (
    GLUnurbs            *nobj, 
    const GLfloat       modelMatrix[16], 
    const GLfloat       projMatrix[16], 
    const GLint         viewport[4] );

void __stdcall 
gluNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             value );

void __stdcall 
gluGetNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             *value );

void __stdcall 
gluNurbsCallback (
    GLUnurbs            *nobj, 
    GLenum              which, 
    void                (__stdcall* fn)() );





typedef void (__stdcall* GLUquadricErrorProc) (GLenum);


typedef void (__stdcall* GLUtessBeginProc)        (GLenum);
typedef void (__stdcall* GLUtessEdgeFlagProc)     (GLboolean);
typedef void (__stdcall* GLUtessVertexProc)       (void *);
typedef void (__stdcall* GLUtessEndProc)          (void);
typedef void (__stdcall* GLUtessErrorProc)        (GLenum);
typedef void (__stdcall* GLUtessCombineProc)      (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void** );
typedef void (__stdcall* GLUtessBeginDataProc)    (GLenum, void *);
typedef void (__stdcall* GLUtessEdgeFlagDataProc) (GLboolean, void *);
typedef void (__stdcall* GLUtessVertexDataProc)   (void *, void *);
typedef void (__stdcall* GLUtessEndDataProc)      (void *);
typedef void (__stdcall* GLUtessErrorDataProc)    (GLenum, void *);
typedef void (__stdcall* GLUtessCombineDataProc)  (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void**,
                                                  void* );


typedef void (__stdcall* GLUnurbsErrorProc)   (GLenum);













































































































































































void __stdcall   gluBeginPolygon( GLUtesselator *tess );

void __stdcall   gluNextContour(  GLUtesselator *tess, 
                                 GLenum        type );

void __stdcall   gluEndPolygon(   GLUtesselator *tess );















#line 584 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"
#pragma endregion


}
#line 589 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"

#line 591 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"
#line 592 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"
#line 1189 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
#line 1190 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
#line 1191 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















































typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
typedef void (__stdcall * PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);








#line 1251 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 1260 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"







































































































typedef void (__stdcall * PFNGLACTIVETEXTUREPROC) (GLenum texture);
typedef void (__stdcall * PFNGLCLIENTACTIVETEXTUREPROC) (GLenum texture);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint lod, GLvoid *img);
typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DPROC) (GLenum target, GLdouble s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FPROC) (GLenum target, GLfloat s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IPROC) (GLenum target, GLint s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SPROC) (GLenum target, GLshort s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IPROC) (GLenum target, GLint s, GLint t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SPROC) (GLenum target, GLshort s, GLshort t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLSAMPLECOVERAGEPROC) (GLclampf value, GLboolean invert);


















































#line 1460 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














































typedef void (__stdcall * PFNGLBLENDCOLORPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
typedef void (__stdcall * PFNGLBLENDEQUATIONPROC) (GLenum mode);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void (__stdcall * PFNGLFOGCOORDPOINTERPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (__stdcall * PFNGLFOGCOORDDPROC) (GLdouble coord);
typedef void (__stdcall * PFNGLFOGCOORDDVPROC) (const GLdouble *coord);
typedef void (__stdcall * PFNGLFOGCOORDFPROC) (GLfloat coord);
typedef void (__stdcall * PFNGLFOGCOORDFVPROC) (const GLfloat *coord);
typedef void (__stdcall * PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei drawcount);
typedef void (__stdcall * PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat *params);
typedef void (__stdcall * PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLPOINTPARAMETERIVPROC) (GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3BPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3BVPROC) (const GLbyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DVPROC) (const GLdouble *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FVPROC) (const GLfloat *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IPROC) (GLint red, GLint green, GLint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IVPROC) (const GLint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SPROC) (GLshort red, GLshort green, GLshort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SVPROC) (const GLshort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBVPROC) (const GLubyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIPROC) (GLuint red, GLuint green, GLuint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIVPROC) (const GLuint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USPROC) (GLushort red, GLushort green, GLushort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USVPROC) (const GLushort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLORPOINTERPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (__stdcall * PFNGLWINDOWPOS2DPROC) (GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLWINDOWPOS2DVPROC) (const GLdouble *p);
typedef void (__stdcall * PFNGLWINDOWPOS2FPROC) (GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLWINDOWPOS2FVPROC) (const GLfloat *p);
typedef void (__stdcall * PFNGLWINDOWPOS2IPROC) (GLint x, GLint y);
typedef void (__stdcall * PFNGLWINDOWPOS2IVPROC) (const GLint *p);
typedef void (__stdcall * PFNGLWINDOWPOS2SPROC) (GLshort x, GLshort y);
typedef void (__stdcall * PFNGLWINDOWPOS2SVPROC) (const GLshort *p);
typedef void (__stdcall * PFNGLWINDOWPOS3DPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLWINDOWPOS3DVPROC) (const GLdouble *p);
typedef void (__stdcall * PFNGLWINDOWPOS3FPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLWINDOWPOS3FVPROC) (const GLfloat *p);
typedef void (__stdcall * PFNGLWINDOWPOS3IPROC) (GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLWINDOWPOS3IVPROC) (const GLint *p);
typedef void (__stdcall * PFNGLWINDOWPOS3SPROC) (GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLWINDOWPOS3SVPROC) (const GLshort *p);



















































#line 1605 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

























































typedef ptrdiff_t GLintptr;
typedef ptrdiff_t GLsizeiptr;

typedef void (__stdcall * PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
typedef void (__stdcall * PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage);
typedef void (__stdcall * PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data);
typedef void (__stdcall * PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint* buffers);
typedef void (__stdcall * PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDQUERYPROC) (GLenum target);
typedef void (__stdcall * PFNGLGENBUFFERSPROC) (GLsizei n, GLuint* buffers);
typedef void (__stdcall * PFNGLGENQUERIESPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, GLvoid** params);
typedef void (__stdcall * PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid* data);
typedef void (__stdcall * PFNGLGETQUERYOBJECTIVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISBUFFERPROC) (GLuint buffer);
typedef GLboolean (__stdcall * PFNGLISQUERYPROC) (GLuint id);
typedef GLvoid* (__stdcall * PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
typedef GLboolean (__stdcall * PFNGLUNMAPBUFFERPROC) (GLenum target);























#line 1708 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



























































































typedef void (__stdcall * PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
typedef void (__stdcall * PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar* name);
typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum, GLenum);
typedef void (__stdcall * PFNGLCOMPILESHADERPROC) (GLuint shader);
typedef GLuint (__stdcall * PFNGLCREATEPROGRAMPROC) (void);
typedef GLuint (__stdcall * PFNGLCREATESHADERPROC) (GLenum type);
typedef void (__stdcall * PFNGLDELETEPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLDELETESHADERPROC) (GLuint shader);
typedef void (__stdcall * PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
typedef void (__stdcall * PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint);
typedef void (__stdcall * PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum* bufs);
typedef void (__stdcall * PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint);
typedef void (__stdcall * PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void (__stdcall * PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders);
typedef GLint (__stdcall * PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void (__stdcall * PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void (__stdcall * PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void (__stdcall * PFNGLGETSHADERSOURCEPROC) (GLuint obj, GLsizei maxLength, GLsizei* length, GLchar* source);
typedef void (__stdcall * PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint* param);
typedef GLint (__stdcall * PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void (__stdcall * PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat* params);
typedef void (__stdcall * PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint, GLenum, GLvoid**);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBDVPROC) (GLuint, GLenum, GLdouble*);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBFVPROC) (GLuint, GLenum, GLfloat*);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIVPROC) (GLuint, GLenum, GLint*);
typedef GLboolean (__stdcall * PFNGLISPROGRAMPROC) (GLuint program);
typedef GLboolean (__stdcall * PFNGLISSHADERPROC) (GLuint shader);
typedef void (__stdcall * PFNGLLINKPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar** strings, const GLint* lengths);
typedef void (__stdcall * PFNGLSTENCILFUNCSEPARATEPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILMASKSEPARATEPROC) (GLenum, GLuint);
typedef void (__stdcall * PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void (__stdcall * PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
typedef void (__stdcall * PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
typedef void (__stdcall * PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall * PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
typedef void (__stdcall * PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall * PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall * PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall * PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall * PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUSEPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLVALIDATEPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SPROC) (GLuint index, GLshort x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SPROC) (GLuint index, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NBVPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NIVPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NSVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBVPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUIVPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUSVPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4BVPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4IVPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBVPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UIVPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4USVPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* pointer);

































































































#line 1990 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






























typedef void (__stdcall * PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);










#line 2037 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
















































































































typedef void (__stdcall * PFNGLBEGINCONDITIONALRENDERPROC) (GLuint, GLenum);
typedef void (__stdcall * PFNGLBEGINTRANSFORMFEEDBACKPROC) (GLenum);
typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONPROC) (GLuint, GLuint, const GLchar*);
typedef void (__stdcall * PFNGLCLAMPCOLORPROC) (GLenum, GLenum);
typedef void (__stdcall * PFNGLCLEARBUFFERFIPROC) (GLenum, GLint, GLfloat, GLint);
typedef void (__stdcall * PFNGLCLEARBUFFERFVPROC) (GLenum, GLint, const GLfloat*);
typedef void (__stdcall * PFNGLCLEARBUFFERIVPROC) (GLenum, GLint, const GLint*);
typedef void (__stdcall * PFNGLCLEARBUFFERUIVPROC) (GLenum, GLint, const GLuint*);
typedef void (__stdcall * PFNGLCOLORMASKIPROC) (GLuint, GLboolean, GLboolean, GLboolean, GLboolean);
typedef void (__stdcall * PFNGLDISABLEIPROC) (GLenum, GLuint);
typedef void (__stdcall * PFNGLENABLEIPROC) (GLenum, GLuint);
typedef void (__stdcall * PFNGLENDCONDITIONALRENDERPROC) (void);
typedef void (__stdcall * PFNGLENDTRANSFORMFEEDBACKPROC) (void);
typedef void (__stdcall * PFNGLGETBOOLEANI_VPROC) (GLenum, GLuint, GLboolean*);
typedef GLint (__stdcall * PFNGLGETFRAGDATALOCATIONPROC) (GLuint, const GLchar*);
typedef const GLubyte* (__stdcall * PFNGLGETSTRINGIPROC) (GLenum, GLuint);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIIVPROC) (GLenum, GLenum, GLint*);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIUIVPROC) (GLenum, GLenum, GLuint*);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint, GLuint, GLsizei, GLsizei *, GLsizei *, GLenum *, GLchar *);
typedef void (__stdcall * PFNGLGETUNIFORMUIVPROC) (GLuint, GLint, GLuint*);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIIVPROC) (GLuint, GLenum, GLint*);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint, GLenum, GLuint*);
typedef GLboolean (__stdcall * PFNGLISENABLEDIPROC) (GLenum, GLuint);
typedef void (__stdcall * PFNGLTEXPARAMETERIIVPROC) (GLenum, GLenum, const GLint*);
typedef void (__stdcall * PFNGLTEXPARAMETERIUIVPROC) (GLenum, GLenum, const GLuint*);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKVARYINGSPROC) (GLuint, GLsizei, const GLchar **, GLenum);
typedef void (__stdcall * PFNGLUNIFORM1UIPROC) (GLint, GLuint);
typedef void (__stdcall * PFNGLUNIFORM1UIVPROC) (GLint, GLsizei, const GLuint*);
typedef void (__stdcall * PFNGLUNIFORM2UIPROC) (GLint, GLuint, GLuint);
typedef void (__stdcall * PFNGLUNIFORM2UIVPROC) (GLint, GLsizei, const GLuint*);
typedef void (__stdcall * PFNGLUNIFORM3UIPROC) (GLint, GLuint, GLuint, GLuint);
typedef void (__stdcall * PFNGLUNIFORM3UIVPROC) (GLint, GLsizei, const GLuint*);
typedef void (__stdcall * PFNGLUNIFORM4UIPROC) (GLint, GLuint, GLuint, GLuint, GLuint);
typedef void (__stdcall * PFNGLUNIFORM4UIVPROC) (GLint, GLsizei, const GLuint*);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IPROC) (GLuint, GLint);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IVPROC) (GLuint, const GLint*);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIPROC) (GLuint, GLuint);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIVPROC) (GLuint, const GLuint*);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IPROC) (GLuint, GLint, GLint);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IVPROC) (GLuint, const GLint*);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIPROC) (GLuint, GLuint, GLuint);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIVPROC) (GLuint, const GLuint*);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IPROC) (GLuint, GLint, GLint, GLint);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IVPROC) (GLuint, const GLint*);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIPROC) (GLuint, GLuint, GLuint, GLuint);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIVPROC) (GLuint, const GLuint*);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4BVPROC) (GLuint, const GLbyte*);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IPROC) (GLuint, GLint, GLint, GLint, GLint);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IVPROC) (GLuint, const GLint*);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4SVPROC) (GLuint, const GLshort*);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UBVPROC) (GLuint, const GLubyte*);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIPROC) (GLuint, GLuint, GLuint, GLuint, GLuint);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIVPROC) (GLuint, const GLuint*);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4USVPROC) (GLuint, const GLushort*);
typedef void (__stdcall * PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint, GLint, GLenum, GLsizei, const GLvoid*);



























































#line 2264 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









































typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum, GLint, GLsizei, GLsizei);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum, GLsizei, GLenum, const GLvoid*, GLsizei);
typedef void (__stdcall * PFNGLPRIMITIVERESTARTINDEXPROC) (GLuint);
typedef void (__stdcall * PFNGLTEXBUFFERPROC) (GLenum, GLenum, GLuint);








#line 2318 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





























typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREPROC) (GLenum, GLenum, GLuint, GLint);
typedef void (__stdcall * PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum, GLenum, GLint64 *);
typedef void (__stdcall * PFNGLGETINTEGER64I_VPROC) (GLenum, GLuint, GLint64 *);







#line 2358 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISORPROC) (GLuint index, GLuint divisor);





#line 2374 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



















typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEIPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLBLENDEQUATIONIPROC) (GLuint buf, GLenum mode);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEIPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (__stdcall * PFNGLBLENDFUNCIPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void (__stdcall * PFNGLMINSAMPLESHADINGPROC) (GLclampf value);









#line 2408 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 2417 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 2431 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 2443 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 2454 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 2468 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTBUFFERMASK3DFXPROC) (GLuint mask);





#line 2481 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 2493 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 2505 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 2514 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





















typedef void (__stdcall *GLDEBUGPROCAMD)(GLuint id, GLenum category, GLenum severity, GLsizei length, const GLchar* message, GLvoid* userParam);

typedef void (__stdcall * PFNGLDEBUGMESSAGECALLBACKAMDPROC) (GLDEBUGPROCAMD callback, GLvoid *userParam);
typedef void (__stdcall * PFNGLDEBUGMESSAGEENABLEAMDPROC) (GLenum category, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void (__stdcall * PFNGLDEBUGMESSAGEINSERTAMDPROC) (GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar* buf);
typedef GLuint (__stdcall * PFNGLGETDEBUGMESSAGELOGAMDPROC) (GLuint count, GLsizei bufsize, GLenum* categories, GLuint* severities, GLuint* ids, GLsizei* lengths, GLchar* message);








#line 2550 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 2562 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBLENDEQUATIONINDEXEDAMDPROC) (GLuint buf, GLenum mode);
typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLBLENDFUNCINDEXEDAMDPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);








#line 2581 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLVERTEXATTRIBPARAMETERIAMDPROC) (GLuint index, GLenum pname, GLint param);





#line 2604 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC) (GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC) (GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride);






#line 2619 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLDELETENAMESAMDPROC) (GLenum identifier, GLuint num, const GLuint* names);
typedef void (__stdcall * PFNGLGENNAMESAMDPROC) (GLenum identifier, GLuint num, GLuint* names);
typedef GLboolean (__stdcall * PFNGLISNAMEAMDPROC) (GLenum identifier, GLuint name);







#line 2642 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLBEGINPERFMONITORAMDPROC) (GLuint monitor);
typedef void (__stdcall * PFNGLDELETEPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void (__stdcall * PFNGLENDPERFMONITORAMDPROC) (GLuint monitor);
typedef void (__stdcall * PFNGLGENPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERDATAAMDPROC) (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint *bytesWritten);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERINFOAMDPROC) (GLuint group, GLuint counter, GLenum pname, GLvoid *data);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC) (GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar *counterString);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERSAMDPROC) (GLuint group, GLint* numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters);
typedef void (__stdcall * PFNGLGETPERFMONITORGROUPSTRINGAMDPROC) (GLuint group, GLsizei bufSize, GLsizei* length, GLchar *groupString);
typedef void (__stdcall * PFNGLGETPERFMONITORGROUPSAMDPROC) (GLint* numGroups, GLsizei groupsSize, GLuint *groups);
typedef void (__stdcall * PFNGLSELECTPERFMONITORCOUNTERSAMDPROC) (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList);















#line 2683 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 2694 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 2707 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLSETMULTISAMPLEFVAMDPROC) (GLenum pname, GLuint index, const GLfloat* val);





#line 2722 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 2733 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 2742 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 2751 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLTEXSTORAGESPARSEAMDPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
typedef void (__stdcall * PFNGLTEXTURESTORAGESPARSEAMDPROC) (GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);






#line 2776 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLSTENCILOPVALUEAMDPROC) (GLenum face, GLuint value);





#line 2794 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 2803 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 2812 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 2821 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLTESSELLATIONFACTORAMDPROC) (GLfloat factor);
typedef void (__stdcall * PFNGLTESSELLATIONMODEAMDPROC) (GLenum mode);






#line 2844 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 2853 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 2862 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBLITFRAMEBUFFERANGLEPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);





#line 2880 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);





#line 2897 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDANGLEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDANGLEPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISORANGLEPROC) (GLuint index, GLuint divisor);







#line 2916 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 2927 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 2938 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 2952 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 2966 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 2980 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 2992 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLBEGINQUERYANGLEPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETEQUERIESANGLEPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDQUERYANGLEPROC) (GLenum target);
typedef void (__stdcall * PFNGLGENQUERIESANGLEPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETQUERYOBJECTI64VANGLEPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTIVANGLEPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUI64VANGLEPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUIVANGLEPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETQUERYIVANGLEPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISQUERYANGLEPROC) (GLuint id);
typedef void (__stdcall * PFNGLQUERYCOUNTERANGLEPROC) (GLuint id, GLenum target);















#line 3032 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC) (GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source);





#line 3047 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 3058 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 3069 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
typedef void (__stdcall * PFNGLELEMENTPOINTERAPPLEPROC) (GLenum type, const GLvoid *pointer);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void (__stdcall * PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, const GLint* first, const GLsizei *count, GLsizei primcount);









#line 3094 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLDELETEFENCESAPPLEPROC) (GLsizei n, const GLuint* fences);
typedef void (__stdcall * PFNGLFINISHFENCEAPPLEPROC) (GLuint fence);
typedef void (__stdcall * PFNGLFINISHOBJECTAPPLEPROC) (GLenum object, GLint name);
typedef void (__stdcall * PFNGLGENFENCESAPPLEPROC) (GLsizei n, GLuint* fences);
typedef GLboolean (__stdcall * PFNGLISFENCEAPPLEPROC) (GLuint fence);
typedef void (__stdcall * PFNGLSETFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean (__stdcall * PFNGLTESTFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean (__stdcall * PFNGLTESTOBJECTAPPLEPROC) (GLenum object, GLuint name);












#line 3124 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"























#line 3148 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLBUFFERPARAMETERIAPPLEPROC) (GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC) (GLenum target, GLintptr offset, GLsizeiptr size);






#line 3166 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLGETOBJECTPARAMETERIVAPPLEPROC) (GLenum objectType, GLuint name, GLenum pname, GLint* params);
typedef GLenum (__stdcall * PFNGLOBJECTPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
typedef GLenum (__stdcall * PFNGLOBJECTUNPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);







#line 3190 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 3201 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 3214 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 3226 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 3237 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC) (GLenum target, GLenum pname, GLvoid **params);
typedef void (__stdcall * PFNGLTEXTURERANGEAPPLEPROC) (GLenum target, GLsizei length, GLvoid *pointer);






#line 3259 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 3270 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLBINDVERTEXARRAYAPPLEPROC) (GLuint array);
typedef void (__stdcall * PFNGLDELETEVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef void (__stdcall * PFNGLGENVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef GLboolean (__stdcall * PFNGLISVERTEXARRAYAPPLEPROC) (GLuint array);








#line 3291 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, GLvoid *pointer);
typedef void (__stdcall * PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, GLvoid *pointer);







#line 3317 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

















typedef void (__stdcall * PFNGLDISABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef void (__stdcall * PFNGLENABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef GLboolean (__stdcall * PFNGLISVERTEXATTRIBENABLEDAPPLEPROC) (GLuint index, GLenum pname);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB1DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB1FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB2DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB2FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points);











#line 3353 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 3364 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"























typedef int GLfixed;

typedef void (__stdcall * PFNGLCLEARDEPTHFPROC) (GLclampf d);
typedef void (__stdcall * PFNGLDEPTHRANGEFPROC) (GLclampf n, GLclampf f);
typedef void (__stdcall * PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint* range, GLint *precision);
typedef void (__stdcall * PFNGLRELEASESHADERCOMPILERPROC) (void);
typedef void (__stdcall * PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint* shaders, GLenum binaryformat, const GLvoid*binary, GLsizei length);









#line 3404 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"























#line 3428 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 3437 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLuint baseinstance);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance);







#line 3454 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef GLuint64 (__stdcall * PFNGLGETIMAGEHANDLEARBPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 (__stdcall * PFNGLGETTEXTUREHANDLEARBPROC) (GLuint texture);
typedef GLuint64 (__stdcall * PFNGLGETTEXTURESAMPLERHANDLEARBPROC) (GLuint texture, GLuint sampler);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBLUI64VARBPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef GLboolean (__stdcall * PFNGLISIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef GLboolean (__stdcall * PFNGLISTEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle, GLenum access);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC) (GLuint program, GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64ARBPROC) (GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64ARBPROC) (GLuint index, GLuint64EXT x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64VARBPROC) (GLuint index, const GLuint64EXT* v);




















#line 3499 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef GLint (__stdcall * PFNGLGETFRAGDATAINDEXPROC) (GLuint program, const GLchar * name);






#line 3519 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLBUFFERSTORAGEPROC) (GLenum target, GLsizeiptr size, const GLvoid* data, GLbitfield flags);
typedef void (__stdcall * PFNGLNAMEDBUFFERSTORAGEEXTPROC) (GLuint buffer, GLsizeiptr size, const GLvoid* data, GLbitfield flags);






#line 3544 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef struct _cl_context *cl_context;
typedef struct _cl_event *cl_event;

typedef GLsync (__stdcall * PFNGLCREATESYNCFROMCLEVENTARBPROC) (cl_context context, cl_event event, GLbitfield flags);





#line 3563 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCLEARBUFFERDATAPROC) (GLenum target, GLenum internalformat, GLenum format, GLenum type, const GLvoid* data);
typedef void (__stdcall * PFNGLCLEARBUFFERSUBDATAPROC) (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid* data);
typedef void (__stdcall * PFNGLCLEARNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const GLvoid* data);
typedef void (__stdcall * PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid* data);








#line 3582 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLCLEARTEXIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, const GLvoid* data);
typedef void (__stdcall * PFNGLCLEARTEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* data);






#line 3599 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLCLAMPCOLORARBPROC) (GLenum target, GLenum clamp);





#line 3618 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 3627 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

















#line 3645 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

























typedef void (__stdcall * PFNGLDISPATCHCOMPUTEPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
typedef void (__stdcall * PFNGLDISPATCHCOMPUTEINDIRECTPROC) (GLintptr indirect);






#line 3679 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);





#line 3697 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 3706 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);





#line 3722 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOPYIMAGESUBDATAPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);





#line 3735 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





























typedef void (__stdcall *GLDEBUGPROCARB)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, GLvoid* userParam);

typedef void (__stdcall * PFNGLDEBUGMESSAGECALLBACKARBPROC) (GLDEBUGPROCARB callback, const GLvoid *userParam);
typedef void (__stdcall * PFNGLDEBUGMESSAGECONTROLARBPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void (__stdcall * PFNGLDEBUGMESSAGEINSERTARBPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint (__stdcall * PFNGLGETDEBUGMESSAGELOGARBPROC) (GLuint count, GLsizei bufsize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);








#line 3779 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 3792 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 3803 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














#line 3818 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
























typedef void (__stdcall * PFNGLDRAWBUFFERSARBPROC) (GLsizei n, const GLenum* bufs);





#line 3849 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEIARBPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLBLENDEQUATIONIARBPROC) (GLuint buf, GLenum mode);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEIARBPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (__stdcall * PFNGLBLENDFUNCIARBPROC) (GLuint buf, GLenum src, GLenum dst);








#line 3868 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, const GLsizei* count, GLenum type, const GLvoid* const *indices, GLsizei primcount, const GLint *basevertex);








#line 3887 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLDRAWARRAYSINDIRECTPROC) (GLenum mode, const GLvoid *indirect);
typedef void (__stdcall * PFNGLDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const GLvoid *indirect);






#line 3905 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 3914 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 3927 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 3936 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 3947 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 3956 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 3965 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
























#line 3990 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 3999 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 4012 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLFRAMEBUFFERPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC) (GLuint framebuffer, GLenum pname, GLint param);








#line 4041 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

















































































typedef void (__stdcall * PFNGLBINDFRAMEBUFFERPROC) (GLenum target, GLuint framebuffer);
typedef void (__stdcall * PFNGLBINDRENDERBUFFERPROC) (GLenum target, GLuint renderbuffer);
typedef void (__stdcall * PFNGLBLITFRAMEBUFFERPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef GLenum (__stdcall * PFNGLCHECKFRAMEBUFFERSTATUSPROC) (GLenum target);
typedef void (__stdcall * PFNGLDELETEFRAMEBUFFERSPROC) (GLsizei n, const GLuint* framebuffers);
typedef void (__stdcall * PFNGLDELETERENDERBUFFERSPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void (__stdcall * PFNGLFRAMEBUFFERRENDERBUFFERPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE1DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE2DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE3DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURELAYERPROC) (GLenum target,GLenum attachment, GLuint texture,GLint level,GLint layer);
typedef void (__stdcall * PFNGLGENFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
typedef void (__stdcall * PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
typedef void (__stdcall * PFNGLGENERATEMIPMAPPROC) (GLenum target);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETRENDERBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISFRAMEBUFFERPROC) (GLuint framebuffer);
typedef GLboolean (__stdcall * PFNGLISRENDERBUFFERPROC) (GLuint renderbuffer);
typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
























#line 4167 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 4178 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


























typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREFACEARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURELAYERARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERIARBPROC) (GLuint program, GLenum pname, GLint value);








#line 4217 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLenum *binaryFormat, GLvoid*binary);
typedef void (__stdcall * PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);







#line 4239 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















#line 4255 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



















typedef void (__stdcall * PFNGLGETUNIFORMDVPROC) (GLuint program, GLint location, GLdouble* params);
typedef void (__stdcall * PFNGLUNIFORM1DPROC) (GLint location, GLdouble x);
typedef void (__stdcall * PFNGLUNIFORM1DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORM2DPROC) (GLint location, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLUNIFORM2DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORM3DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLUNIFORM3DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORM4DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLUNIFORM4DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);






















#line 4315 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 4326 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 4337 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




















































































typedef void (__stdcall * PFNGLCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
typedef void (__stdcall * PFNGLCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
typedef void (__stdcall * PFNGLCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIPROC) (GLenum target, GLenum pname, GLint params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLCOPYCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLGETCOLORTABLEPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETCONVOLUTIONFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETHISTOGRAMPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETMINMAXPROC) (GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETSEPARABLEFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
typedef void (__stdcall * PFNGLHISTOGRAMPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLMINMAXPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLRESETHISTOGRAMPROC) (GLenum target);
typedef void (__stdcall * PFNGLRESETMINMAXPROC) (GLenum target);
typedef void (__stdcall * PFNGLSEPARABLEFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);




































#line 4490 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC) (GLenum mode, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC) (GLenum mode, GLenum type, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);






#line 4508 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDARBPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDARBPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISORARBPROC) (GLuint index, GLuint divisor);







#line 4527 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params);





#line 4542 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










































































































typedef void (__stdcall * PFNGLGETINTERNALFORMATI64VPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64* params);





#line 4655 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLINVALIDATEBUFFERDATAPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLINVALIDATEBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (__stdcall * PFNGLINVALIDATEFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments);
typedef void (__stdcall * PFNGLINVALIDATESUBFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLINVALIDATETEXIMAGEPROC) (GLuint texture, GLint level);
typedef void (__stdcall * PFNGLINVALIDATETEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);










#line 4678 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 4689 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLFLUSHMAPPEDBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
typedef GLvoid * (__stdcall * PFNGLMAPBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);






#line 4711 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

















typedef void (__stdcall * PFNGLCURRENTPALETTEMATRIXARBPROC) (GLint index);
typedef void (__stdcall * PFNGLMATRIXINDEXPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
typedef void (__stdcall * PFNGLMATRIXINDEXUBVARBPROC) (GLint size, GLubyte *indices);
typedef void (__stdcall * PFNGLMATRIXINDEXUIVARBPROC) (GLint size, GLuint *indices);
typedef void (__stdcall * PFNGLMATRIXINDEXUSVARBPROC) (GLint size, GLushort *indices);









#line 4743 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBINDBUFFERSBASEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers);
typedef void (__stdcall * PFNGLBINDBUFFERSRANGEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizeiptr *sizes);
typedef void (__stdcall * PFNGLBINDIMAGETEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void (__stdcall * PFNGLBINDSAMPLERSPROC) (GLuint first, GLsizei count, const GLuint* samplers);
typedef void (__stdcall * PFNGLBINDTEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void (__stdcall * PFNGLBINDVERTEXBUFFERSPROC) (GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizei *strides);










#line 4766 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTPROC) (GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride);






#line 4781 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLSAMPLECOVERAGEARBPROC) (GLclampf value, GLboolean invert);





#line 4804 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










































typedef void (__stdcall * PFNGLACTIVETEXTUREARBPROC) (GLenum texture);
typedef void (__stdcall * PFNGLCLIENTACTIVETEXTUREARBPROC) (GLenum texture);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DARBPROC) (GLenum target, GLdouble s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FARBPROC) (GLenum target, GLfloat s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IARBPROC) (GLenum target, GLint s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SARBPROC) (GLenum target, GLshort s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SVARBPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DARBPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FARBPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IARBPROC) (GLenum target, GLint s, GLint t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SARBPROC) (GLenum target, GLshort s, GLshort t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SVARBPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IARBPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SVARBPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IARBPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SVARBPROC) (GLenum target, const GLshort *v);






































#line 4919 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLBEGINQUERYARBPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETEQUERIESARBPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDQUERYARBPROC) (GLenum target);
typedef void (__stdcall * PFNGLGENQUERIESARBPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETQUERYOBJECTIVARBPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUIVARBPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETQUERYIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISQUERYARBPROC) (GLuint id);












#line 4952 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 4963 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 4977 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLPOINTPARAMETERFARBPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPOINTPARAMETERFVARBPROC) (GLenum pname, const GLfloat* params);






#line 4997 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 5009 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






















































typedef void (__stdcall * PFNGLGETPROGRAMINTERFACEIVPROC) (GLuint program, GLenum programInterface, GLenum pname, GLint* params);
typedef GLuint (__stdcall * PFNGLGETPROGRAMRESOURCEINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint (__stdcall * PFNGLGETPROGRAMRESOURCELOCATIONPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint (__stdcall * PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef void (__stdcall * PFNGLGETPROGRAMRESOURCENAMEPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar *name);
typedef void (__stdcall * PFNGLGETPROGRAMRESOURCEIVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei *length, GLint *params);










#line 5080 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLPROVOKINGVERTEXPROC) (GLenum mode);





#line 5098 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 5112 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 5121 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














typedef GLenum (__stdcall * PFNGLGETGRAPHICSRESETSTATUSARBPROC) (void);
typedef void (__stdcall * PFNGLGETNCOLORTABLEARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* table);
typedef void (__stdcall * PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLsizei bufSize, void* img);
typedef void (__stdcall * PFNGLGETNCONVOLUTIONFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* image);
typedef void (__stdcall * PFNGLGETNHISTOGRAMARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void (__stdcall * PFNGLGETNMAPDVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLdouble* v);
typedef void (__stdcall * PFNGLGETNMAPFVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLfloat* v);
typedef void (__stdcall * PFNGLGETNMAPIVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLint* v);
typedef void (__stdcall * PFNGLGETNMINMAXARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void (__stdcall * PFNGLGETNPIXELMAPFVARBPROC) (GLenum map, GLsizei bufSize, GLfloat* values);
typedef void (__stdcall * PFNGLGETNPIXELMAPUIVARBPROC) (GLenum map, GLsizei bufSize, GLuint* values);
typedef void (__stdcall * PFNGLGETNPIXELMAPUSVARBPROC) (GLenum map, GLsizei bufSize, GLushort* values);
typedef void (__stdcall * PFNGLGETNPOLYGONSTIPPLEARBPROC) (GLsizei bufSize, GLubyte* pattern);
typedef void (__stdcall * PFNGLGETNSEPARABLEFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void* row, GLsizei columnBufSize, GLvoid*column, GLvoid*span);
typedef void (__stdcall * PFNGLGETNTEXIMAGEARBPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* img);
typedef void (__stdcall * PFNGLGETNUNIFORMDVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble* params);
typedef void (__stdcall * PFNGLGETNUNIFORMFVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void (__stdcall * PFNGLGETNUNIFORMIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void (__stdcall * PFNGLGETNUNIFORMUIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
typedef void (__stdcall * PFNGLREADNPIXELSARBPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data);
























#line 5180 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 5189 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 5198 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLMINSAMPLESHADINGARBPROC) (GLclampf value);





#line 5214 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLBINDSAMPLERPROC) (GLuint unit, GLuint sampler);
typedef void (__stdcall * PFNGLDELETESAMPLERSPROC) (GLsizei count, const GLuint * samplers);
typedef void (__stdcall * PFNGLGENSAMPLERSPROC) (GLsizei count, GLuint* samplers);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISSAMPLERPROC) (GLuint sampler);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERFPROC) (GLuint sampler, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIPROC) (GLuint sampler, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, const GLint* params);


















#line 5255 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 5266 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 5277 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLACTIVESHADERPROGRAMPROC) (GLuint pipeline, GLuint program);
typedef void (__stdcall * PFNGLBINDPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef GLuint (__stdcall * PFNGLCREATESHADERPROGRAMVPROC) (GLenum type, GLsizei count, const GLchar ** strings);
typedef void (__stdcall * PFNGLDELETEPROGRAMPIPELINESPROC) (GLsizei n, const GLuint* pipelines);
typedef void (__stdcall * PFNGLGENPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
typedef void (__stdcall * PFNGLGETPROGRAMPIPELINEINFOLOGPROC) (GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar *infoLog);
typedef void (__stdcall * PFNGLGETPROGRAMPIPELINEIVPROC) (GLuint pipeline, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1DPROC) (GLuint program, GLint location, GLdouble x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FPROC) (GLuint program, GLint location, GLfloat x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IPROC) (GLuint program, GLint location, GLint x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIPROC) (GLuint program, GLint location, GLuint x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IPROC) (GLuint program, GLint location, GLint x, GLint y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIPROC) (GLuint program, GLint location, GLuint x, GLuint y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUSEPROGRAMSTAGESPROC) (GLuint pipeline, GLbitfield stages, GLuint program);
typedef void (__stdcall * PFNGLVALIDATEPROGRAMPIPELINEPROC) (GLuint pipeline);
































































#line 5418 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




































typedef void (__stdcall * PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) (GLuint program, GLuint bufferIndex, GLenum pname, GLint* params);





#line 5461 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 5470 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 5479 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 5488 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"







































































typedef void (__stdcall * PFNGLBINDIMAGETEXTUREPROC) (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
typedef void (__stdcall * PFNGLMEMORYBARRIERPROC) (GLbitfield barriers);






#line 5568 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 5577 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









































typedef char GLcharARB;
typedef unsigned int GLhandleARB;

typedef void (__stdcall * PFNGLATTACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB obj);
typedef void (__stdcall * PFNGLCOMPILESHADERARBPROC) (GLhandleARB shaderObj);
typedef GLhandleARB (__stdcall * PFNGLCREATEPROGRAMOBJECTARBPROC) (void);
typedef GLhandleARB (__stdcall * PFNGLCREATESHADEROBJECTARBPROC) (GLenum shaderType);
typedef void (__stdcall * PFNGLDELETEOBJECTARBPROC) (GLhandleARB obj);
typedef void (__stdcall * PFNGLDETACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB attachedObj);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef void (__stdcall * PFNGLGETATTACHEDOBJECTSARBPROC) (GLhandleARB containerObj, GLsizei maxCount, GLsizei* count, GLhandleARB *obj);
typedef GLhandleARB (__stdcall * PFNGLGETHANDLEARBPROC) (GLenum pname);
typedef void (__stdcall * PFNGLGETINFOLOGARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *infoLog);
typedef void (__stdcall * PFNGLGETOBJECTPARAMETERFVARBPROC) (GLhandleARB obj, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETOBJECTPARAMETERIVARBPROC) (GLhandleARB obj, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETSHADERSOURCEARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *source);
typedef GLint (__stdcall * PFNGLGETUNIFORMLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);
typedef void (__stdcall * PFNGLGETUNIFORMFVARBPROC) (GLhandleARB programObj, GLint location, GLfloat* params);
typedef void (__stdcall * PFNGLGETUNIFORMIVARBPROC) (GLhandleARB programObj, GLint location, GLint* params);
typedef void (__stdcall * PFNGLLINKPROGRAMARBPROC) (GLhandleARB programObj);
typedef void (__stdcall * PFNGLSHADERSOURCEARBPROC) (GLhandleARB shaderObj, GLsizei count, const GLcharARB ** string, const GLint *length);
typedef void (__stdcall * PFNGLUNIFORM1FARBPROC) (GLint location, GLfloat v0);
typedef void (__stdcall * PFNGLUNIFORM1FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM1IARBPROC) (GLint location, GLint v0);
typedef void (__stdcall * PFNGLUNIFORM1IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM2FARBPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall * PFNGLUNIFORM2FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM2IARBPROC) (GLint location, GLint v0, GLint v1);
typedef void (__stdcall * PFNGLUNIFORM2IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM3FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall * PFNGLUNIFORM3FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM3IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall * PFNGLUNIFORM3IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM4FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall * PFNGLUNIFORM4FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM4IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall * PFNGLUNIFORM4IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUSEPROGRAMOBJECTARBPROC) (GLhandleARB programObj);
typedef void (__stdcall * PFNGLVALIDATEPROGRAMARBPROC) (GLhandleARB programObj);











































#line 5704 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 5713 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 5722 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"























typedef void (__stdcall * PFNGLSHADERSTORAGEBLOCKBINDINGPROC) (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);





#line 5752 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLGETACTIVESUBROUTINENAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void (__stdcall * PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void (__stdcall * PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values);
typedef void (__stdcall * PFNGLGETPROGRAMSTAGEIVPROC) (GLuint program, GLenum shadertype, GLenum pname, GLint* values);
typedef GLuint (__stdcall * PFNGLGETSUBROUTINEINDEXPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef GLint (__stdcall * PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef void (__stdcall * PFNGLGETUNIFORMSUBROUTINEUIVPROC) (GLenum shadertype, GLint location, GLuint* params);
typedef void (__stdcall * PFNGLUNIFORMSUBROUTINESUIVPROC) (GLenum shadertype, GLsizei count, const GLuint* indices);












#line 5789 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 5798 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 5809 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 5818 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLCOMPILESHADERINCLUDEARBPROC) (GLuint shader, GLsizei count, const GLchar* const *path, const GLint *length);
typedef void (__stdcall * PFNGLDELETENAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void (__stdcall * PFNGLGETNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name, GLsizei bufSize, GLint *stringlen, GLchar *string);
typedef void (__stdcall * PFNGLGETNAMEDSTRINGIVARBPROC) (GLint namelen, const GLchar* name, GLenum pname, GLint *params);
typedef GLboolean (__stdcall * PFNGLISNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void (__stdcall * PFNGLNAMEDSTRINGARBPROC) (GLenum type, GLint namelen, const GLchar* name, GLint stringlen, const GLchar *string);










#line 5845 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 5854 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 5867 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 5878 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


















typedef void (__stdcall * PFNGLTEXPAGECOMMITMENTARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
typedef void (__stdcall * PFNGLTEXTUREPAGECOMMITMENTEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);






#line 5905 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 5916 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






















typedef GLenum (__stdcall * PFNGLCLIENTWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);
typedef void (__stdcall * PFNGLDELETESYNCPROC) (GLsync GLsync);
typedef GLsync (__stdcall * PFNGLFENCESYNCPROC) (GLenum condition,GLbitfield flags);
typedef void (__stdcall * PFNGLGETINTEGER64VPROC) (GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETSYNCIVPROC) (GLsync GLsync,GLenum pname,GLsizei bufSize,GLsizei* length, GLint *values);
typedef GLboolean (__stdcall * PFNGLISSYNCPROC) (GLsync GLsync);
typedef void (__stdcall * PFNGLWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);











#line 5957 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"







































typedef void (__stdcall * PFNGLPATCHPARAMETERFVPROC) (GLenum pname, const GLfloat* values);
typedef void (__stdcall * PFNGLPATCHPARAMETERIPROC) (GLenum pname, GLint value);






#line 6005 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 6016 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLTEXBUFFERARBPROC) (GLenum target, GLenum internalformat, GLuint buffer);





#line 6035 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 6044 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLTEXBUFFERRANGEPROC) (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLTEXTUREBUFFERRANGEEXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);






#line 6063 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


















typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLvoid *img);











#line 6100 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 6114 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 6128 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





















#line 6150 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
















#line 6167 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 6176 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"































#line 6208 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 6217 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 6229 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





























#line 6259 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 6272 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 6283 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 6294 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




























typedef void (__stdcall * PFNGLGETMULTISAMPLEFVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void (__stdcall * PFNGLSAMPLEMASKIPROC) (GLuint index, GLbitfield mask);
typedef void (__stdcall * PFNGLTEXIMAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXIMAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);








#line 6335 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 6344 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 6353 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 6362 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















#line 6378 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

































#line 6412 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 6423 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 6435 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLTEXSTORAGE1DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall * PFNGLTEXSTORAGE2DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXSTORAGE3DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (__stdcall * PFNGLTEXTURESTORAGE1DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall * PFNGLTEXTURESTORAGE2DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXTURESTORAGE3DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);










#line 6460 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXSTORAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXSTORAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);








#line 6479 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














#line 6494 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLTEXTUREVIEWPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);





#line 6513 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLGETQUERYOBJECTI64VPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUI64VPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void (__stdcall * PFNGLQUERYCOUNTERPROC) (GLuint id, GLenum target);







#line 6533 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBINDTRANSFORMFEEDBACKPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETETRANSFORMFEEDBACKSPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKPROC) (GLenum mode, GLuint id);
typedef void (__stdcall * PFNGLGENTRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
typedef GLboolean (__stdcall * PFNGLISTRANSFORMFEEDBACKPROC) (GLuint id);
typedef void (__stdcall * PFNGLPAUSETRANSFORMFEEDBACKPROC) (void);
typedef void (__stdcall * PFNGLRESUMETRANSFORMFEEDBACKPROC) (void);











#line 6563 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLBEGINQUERYINDEXEDPROC) (GLenum target, GLuint index, GLuint id);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) (GLenum mode, GLuint id, GLuint stream);
typedef void (__stdcall * PFNGLENDQUERYINDEXEDPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLGETQUERYINDEXEDIVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);








#line 6585 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) (GLenum mode, GLuint id, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) (GLenum mode, GLuint id, GLuint stream, GLsizei primcount);






#line 6600 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);








#line 6624 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








































typedef void (__stdcall * PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void (__stdcall * PFNGLBINDBUFFERRANGEPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMBLOCKIVPROC) (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMNAMEPROC) (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMSIVPROC) (GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETINTEGERI_VPROC) (GLenum target, GLuint index, GLint* data);
typedef GLuint (__stdcall * PFNGLGETUNIFORMBLOCKINDEXPROC) (GLuint program, const GLchar* uniformBlockName);
typedef void (__stdcall * PFNGLGETUNIFORMINDICESPROC) (GLuint program, GLsizei uniformCount, const GLchar** uniformNames, GLuint* uniformIndices);
typedef void (__stdcall * PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);














#line 6689 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 6700 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLBINDVERTEXARRAYPROC) (GLuint array);
typedef void (__stdcall * PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint* arrays);
typedef void (__stdcall * PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
typedef GLboolean (__stdcall * PFNGLISVERTEXARRAYPROC) (GLuint array);








#line 6721 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETVERTEXATTRIBLDVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBLPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);














#line 6752 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLBINDVERTEXBUFFERPROC) (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXATTRIBBINDINGPROC) (GLuint attribindex, GLuint bindingindex);
typedef void (__stdcall * PFNGLVERTEXATTRIBFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXATTRIBIFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXATTRIBLFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXBINDINGDIVISORPROC) (GLuint bindingindex, GLuint divisor);










#line 6783 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

















































typedef void (__stdcall * PFNGLVERTEXBLENDARBPROC) (GLint count);
typedef void (__stdcall * PFNGLWEIGHTPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
typedef void (__stdcall * PFNGLWEIGHTBVARBPROC) (GLint size, GLbyte *weights);
typedef void (__stdcall * PFNGLWEIGHTDVARBPROC) (GLint size, GLdouble *weights);
typedef void (__stdcall * PFNGLWEIGHTFVARBPROC) (GLint size, GLfloat *weights);
typedef void (__stdcall * PFNGLWEIGHTIVARBPROC) (GLint size, GLint *weights);
typedef void (__stdcall * PFNGLWEIGHTSVARBPROC) (GLint size, GLshort *weights);
typedef void (__stdcall * PFNGLWEIGHTUBVARBPROC) (GLint size, GLubyte *weights);
typedef void (__stdcall * PFNGLWEIGHTUIVARBPROC) (GLint size, GLuint *weights);
typedef void (__stdcall * PFNGLWEIGHTUSVARBPROC) (GLint size, GLushort *weights);














#line 6857 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






































typedef ptrdiff_t GLintptrARB;
typedef ptrdiff_t GLsizeiptrARB;

typedef void (__stdcall * PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
typedef void (__stdcall * PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
typedef void (__stdcall * PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
typedef void (__stdcall * PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint* buffers);
typedef void (__stdcall * PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint* buffers);
typedef void (__stdcall * PFNGLGETBUFFERPARAMETERIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, GLvoid** params);
typedef void (__stdcall * PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
typedef GLboolean (__stdcall * PFNGLISBUFFERARBPROC) (GLuint buffer);
typedef GLvoid * (__stdcall * PFNGLMAPBUFFERARBPROC) (GLenum target, GLenum access);
typedef GLboolean (__stdcall * PFNGLUNMAPBUFFERARBPROC) (GLenum target);















#line 6925 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






















































































typedef void (__stdcall * PFNGLBINDPROGRAMARBPROC) (GLenum target, GLuint program);
typedef void (__stdcall * PFNGLDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint* programs);
typedef void (__stdcall * PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void (__stdcall * PFNGLENABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void (__stdcall * PFNGLGENPROGRAMSARBPROC) (GLsizei n, GLuint* programs);
typedef void (__stdcall * PFNGLGETPROGRAMENVPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETPROGRAMENVPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, GLvoid *string);
typedef void (__stdcall * PFNGLGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, GLvoid** pointer);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISPROGRAMARBPROC) (GLuint program);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const GLvoid *string);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DARBPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FARBPROC) (GLuint index, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SARBPROC) (GLuint index, GLshort x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DARBPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FARBPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SARBPROC) (GLuint index, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NBVARBPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NIVARBPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NSVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBARBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBVARBPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUIVARBPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUSVARBPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4BVARBPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4IVARBPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UIVARBPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4USVARBPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);


































































#line 7140 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLBINDATTRIBLOCATIONARBPROC) (GLhandleARB programObj, GLuint index, const GLcharARB* name);
typedef void (__stdcall * PFNGLGETACTIVEATTRIBARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef GLint (__stdcall * PFNGLGETATTRIBLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);







#line 7165 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 7176 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void (__stdcall * PFNGLCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void (__stdcall * PFNGLCOLORP4UIPROC) (GLenum type, GLuint color);
typedef void (__stdcall * PFNGLCOLORP4UIVPROC) (GLenum type, const GLuint* color);
typedef void (__stdcall * PFNGLMULTITEXCOORDP1UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP1UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP2UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP2UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP3UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP3UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP4UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP4UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLNORMALP3UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLNORMALP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLSECONDARYCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void (__stdcall * PFNGLSECONDARYCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void (__stdcall * PFNGLTEXCOORDP1UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP1UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLTEXCOORDP2UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP2UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLTEXCOORDP3UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLTEXCOORDP4UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP4UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLVERTEXATTRIBP1UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP1UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP2UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP2UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP3UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP3UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP4UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP4UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXP2UIPROC) (GLenum type, GLuint value);
typedef void (__stdcall * PFNGLVERTEXP2UIVPROC) (GLenum type, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXP3UIPROC) (GLenum type, GLuint value);
typedef void (__stdcall * PFNGLVERTEXP3UIVPROC) (GLenum type, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXP4UIPROC) (GLenum type, GLuint value);
typedef void (__stdcall * PFNGLVERTEXP4UIVPROC) (GLenum type, const GLuint* value);










































#line 7266 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




















typedef void (__stdcall * PFNGLDEPTHRANGEARRAYVPROC) (GLuint first, GLsizei count, const GLclampd * v);
typedef void (__stdcall * PFNGLDEPTHRANGEINDEXEDPROC) (GLuint index, GLclampd n, GLclampd f);
typedef void (__stdcall * PFNGLGETDOUBLEI_VPROC) (GLenum target, GLuint index, GLdouble* data);
typedef void (__stdcall * PFNGLGETFLOATI_VPROC) (GLenum target, GLuint index, GLfloat* data);
typedef void (__stdcall * PFNGLSCISSORARRAYVPROC) (GLuint first, GLsizei count, const GLint * v);
typedef void (__stdcall * PFNGLSCISSORINDEXEDPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLSCISSORINDEXEDVPROC) (GLuint index, const GLint * v);
typedef void (__stdcall * PFNGLVIEWPORTARRAYVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void (__stdcall * PFNGLVIEWPORTINDEXEDFPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void (__stdcall * PFNGLVIEWPORTINDEXEDFVPROC) (GLuint index, const GLfloat * v);














#line 7311 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLWINDOWPOS2DARBPROC) (GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLWINDOWPOS2DVARBPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS2FARBPROC) (GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLWINDOWPOS2FVARBPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS2IARBPROC) (GLint x, GLint y);
typedef void (__stdcall * PFNGLWINDOWPOS2IVARBPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS2SARBPROC) (GLshort x, GLshort y);
typedef void (__stdcall * PFNGLWINDOWPOS2SVARBPROC) (const GLshort* p);
typedef void (__stdcall * PFNGLWINDOWPOS3DARBPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLWINDOWPOS3DVARBPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS3FARBPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLWINDOWPOS3FVARBPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS3IARBPROC) (GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLWINDOWPOS3IVARBPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS3SARBPROC) (GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLWINDOWPOS3SVARBPROC) (const GLshort* p);




















#line 7354 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















#line 7370 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 7383 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 7396 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 7407 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
























typedef void (__stdcall * PFNGLDRAWBUFFERSATIPROC) (GLsizei n, const GLenum* bufs);





#line 7438 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLDRAWELEMENTARRAYATIPROC) (GLenum mode, GLsizei count);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTARRAYATIPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count);
typedef void (__stdcall * PFNGLELEMENTPOINTERATIPROC) (GLenum type, const GLvoid *pointer);







#line 7459 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLGETTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void (__stdcall * PFNGLGETTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
typedef void (__stdcall * PFNGLTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void (__stdcall * PFNGLTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);








#line 7487 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





























































typedef void (__stdcall * PFNGLALPHAFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void (__stdcall * PFNGLALPHAFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void (__stdcall * PFNGLALPHAFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void (__stdcall * PFNGLBEGINFRAGMENTSHADERATIPROC) (void);
typedef void (__stdcall * PFNGLBINDFRAGMENTSHADERATIPROC) (GLuint id);
typedef void (__stdcall * PFNGLCOLORFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void (__stdcall * PFNGLCOLORFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void (__stdcall * PFNGLCOLORFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void (__stdcall * PFNGLDELETEFRAGMENTSHADERATIPROC) (GLuint id);
typedef void (__stdcall * PFNGLENDFRAGMENTSHADERATIPROC) (void);
typedef GLuint (__stdcall * PFNGLGENFRAGMENTSHADERSATIPROC) (GLuint range);
typedef void (__stdcall * PFNGLPASSTEXCOORDATIPROC) (GLuint dst, GLuint coord, GLenum swizzle);
typedef void (__stdcall * PFNGLSAMPLEMAPATIPROC) (GLuint dst, GLuint interp, GLenum swizzle);
typedef void (__stdcall * PFNGLSETFRAGMENTSHADERCONSTANTATIPROC) (GLuint dst, const GLfloat* value);


















#line 7581 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef GLvoid * (__stdcall * PFNGLMAPOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLUNMAPOBJECTBUFFERATIPROC) (GLuint buffer);






#line 7596 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 7609 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLPNTRIANGLESFATIPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPNTRIANGLESIATIPROC) (GLenum pname, GLint param);






#line 7634 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLSTENCILFUNCSEPARATEATIPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILOPSEPARATEATIPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);






#line 7654 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 7663 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 7674 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 7685 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 7698 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





















#line 7720 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 7732 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLARRAYOBJECTATIPROC) (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void (__stdcall * PFNGLFREEOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLGETARRAYOBJECTFVATIPROC) (GLenum array, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETARRAYOBJECTIVATIPROC) (GLenum array, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETOBJECTBUFFERFVATIPROC) (GLuint buffer, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETOBJECTBUFFERIVATIPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVARIANTARRAYOBJECTFVATIPROC) (GLuint id, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVARIANTARRAYOBJECTIVATIPROC) (GLuint id, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISOBJECTBUFFERATIPROC) (GLuint buffer);
typedef GLuint (__stdcall * PFNGLNEWOBJECTBUFFERATIPROC) (GLsizei size, const GLvoid *pointer, GLenum usage);
typedef void (__stdcall * PFNGLUPDATEOBJECTBUFFERATIPROC) (GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve);
typedef void (__stdcall * PFNGLVARIANTARRAYOBJECTATIPROC) (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
















#line 7776 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC) (GLuint index, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLVERTEXATTRIBARRAYOBJECTATIPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);







#line 7793 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

















typedef void (__stdcall * PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC) (GLenum stream);
typedef void (__stdcall * PFNGLNORMALSTREAM3BATIPROC) (GLenum stream, GLbyte x, GLbyte y, GLbyte z);
typedef void (__stdcall * PFNGLNORMALSTREAM3BVATIPROC) (GLenum stream, const GLbyte *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLNORMALSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLNORMALSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLNORMALSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLNORMALSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXBLENDENVFATIPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLVERTEXBLENDENVIATIPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLVERTEXSTREAM1DATIPROC) (GLenum stream, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM1FATIPROC) (GLenum stream, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM1IATIPROC) (GLenum stream, GLint x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM1SATIPROC) (GLenum stream, GLshort x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2DATIPROC) (GLenum stream, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2FATIPROC) (GLenum stream, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2IATIPROC) (GLenum stream, GLint x, GLint y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2SATIPROC) (GLenum stream, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4IATIPROC) (GLenum stream, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4SVATIPROC) (GLenum stream, const GLshort *coords);

















































#line 7905 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 7919 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 7931 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 7942 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 7954 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













typedef GLint (__stdcall * PFNGLGETUNIFORMBUFFERSIZEEXTPROC) (GLuint program, GLint location);
typedef GLintptr (__stdcall * PFNGLGETUNIFORMOFFSETEXTPROC) (GLuint program, GLint location);
typedef void (__stdcall * PFNGLUNIFORMBUFFEREXTPROC) (GLuint program, GLint location, GLuint buffer);







#line 7978 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLBLENDCOLOREXTPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);





#line 7997 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEEXTPROC) (GLenum modeRGB, GLenum modeAlpha);





#line 8013 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEEXTPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);





#line 8031 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 8040 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBLENDEQUATIONEXTPROC) (GLenum mode);





#line 8058 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 8070 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 8081 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 8095 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
typedef void (__stdcall * PFNGLCOPYCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);






#line 8110 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLLOCKARRAYSEXTPROC) (GLint first, GLsizei count);
typedef void (__stdcall * PFNGLUNLOCKARRAYSEXTPROC) (void);






#line 8128 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



























typedef void (__stdcall * PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
typedef void (__stdcall * PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
typedef void (__stdcall * PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);

















#line 8186 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





















typedef void (__stdcall * PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLvoid *pointer);
typedef void (__stdcall * PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, GLvoid *pointer);






#line 8216 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOPYTEXIMAGE1DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXIMAGE2DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);









#line 8237 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLCULLPARAMETERDVEXTPROC) (GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLCULLPARAMETERFVEXTPROC) (GLenum pname, GLfloat* params);






#line 8256 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLINSERTEVENTMARKEREXTPROC) (GLsizei length, const GLchar* marker);
typedef void (__stdcall * PFNGLPOPGROUPMARKEREXTPROC) (void);
typedef void (__stdcall * PFNGLPUSHGROUPMARKEREXTPROC) (GLsizei length, const GLchar* marker);







#line 8273 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLDEPTHBOUNDSEXTPROC) (GLclampd zmin, GLclampd zmax);





#line 8289 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLBINDMULTITEXTUREEXTPROC) (GLenum texunit, GLenum target, GLuint texture);
typedef GLenum (__stdcall * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC) (GLuint framebuffer, GLenum target);
typedef void (__stdcall * PFNGLCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (__stdcall * PFNGLCOPYMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall * PFNGLCOPYMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall * PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLDISABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void (__stdcall * PFNGLDISABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void (__stdcall * PFNGLENABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLENABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLENABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void (__stdcall * PFNGLENABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void (__stdcall * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (__stdcall * PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void (__stdcall * PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
typedef void (__stdcall * PFNGLFRAMEBUFFERREADBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void (__stdcall * PFNGLGENERATEMULTITEXMIPMAPEXTPROC) (GLenum texunit, GLenum target);
typedef void (__stdcall * PFNGLGENERATETEXTUREMIPMAPEXTPROC) (GLuint texture, GLenum target);
typedef void (__stdcall * PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, GLvoid *img);
typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, GLvoid *img);
typedef void (__stdcall * PFNGLGETDOUBLEINDEXEDVEXTPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETDOUBLEI_VEXTPROC) (GLenum pname, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETFLOATINDEXEDVEXTPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETFLOATI_VEXTPROC) (GLenum pname, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
typedef void (__stdcall * PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPOINTERVEXTPROC) (GLuint buffer, GLenum pname, void** params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum pname, GLvoid *string);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMIVEXTPROC) (GLuint program, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETPOINTERINDEXEDVEXTPROC) (GLenum target, GLuint index, GLvoid** params);
typedef void (__stdcall * PFNGLGETPOINTERI_VEXTPROC) (GLenum pname, GLuint index, GLvoid** params);
typedef void (__stdcall * PFNGLGETTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
typedef void (__stdcall * PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYINTEGERVEXTPROC) (GLuint vaobj, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, GLvoid** param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYPOINTERVEXTPROC) (GLuint vaobj, GLenum pname, GLvoid** param);
typedef GLvoid * (__stdcall * PFNGLMAPNAMEDBUFFEREXTPROC) (GLuint buffer, GLenum access);
typedef GLvoid * (__stdcall * PFNGLMAPNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void (__stdcall * PFNGLMATRIXFRUSTUMEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void (__stdcall * PFNGLMATRIXLOADIDENTITYEXTPROC) (GLenum matrixMode);
typedef void (__stdcall * PFNGLMATRIXLOADTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXLOADTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXLOADDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXLOADFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXMULTTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXMULTTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXMULTDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXMULTFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXORTHOEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void (__stdcall * PFNGLMATRIXPOPEXTPROC) (GLenum matrixMode);
typedef void (__stdcall * PFNGLMATRIXPUSHEXTPROC) (GLenum matrixMode);
typedef void (__stdcall * PFNGLMATRIXROTATEDEXTPROC) (GLenum matrixMode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLMATRIXROTATEFEXTPROC) (GLenum matrixMode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLMATRIXSCALEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLMATRIXSCALEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLMATRIXTRANSLATEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLMATRIXTRANSLATEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLMULTITEXBUFFEREXTPROC) (GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
typedef void (__stdcall * PFNGLMULTITEXCOORDPOINTEREXTPROC) (GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (__stdcall * PFNGLMULTITEXENVFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLMULTITEXENVIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLMULTITEXGENDEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
typedef void (__stdcall * PFNGLMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLdouble* params);
typedef void (__stdcall * PFNGLMULTITEXGENFEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLMULTITEXGENIEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (__stdcall * PFNGLMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (__stdcall * PFNGLMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* param);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* param);
typedef void (__stdcall * PFNGLMULTITEXRENDERBUFFEREXTPROC) (GLenum texunit, GLenum target, GLuint renderbuffer);
typedef void (__stdcall * PFNGLMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (__stdcall * PFNGLMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (__stdcall * PFNGLMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (__stdcall * PFNGLNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage);
typedef void (__stdcall * PFNGLNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data);
typedef void (__stdcall * PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC) (GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLuint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *string);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC) (GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FEXTPROC) (GLuint program, GLint location, GLfloat v0);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IEXTPROC) (GLuint program, GLint location, GLint v0);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIEXTPROC) (GLuint program, GLint location, GLuint v0);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void (__stdcall * PFNGLTEXTUREBUFFEREXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
typedef void (__stdcall * PFNGLTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (__stdcall * PFNGLTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (__stdcall * PFNGLTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERFEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLfloat* param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* param);
typedef void (__stdcall * PFNGLTEXTURERENDERBUFFEREXTPROC) (GLuint texture, GLenum target, GLuint renderbuffer);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
typedef GLboolean (__stdcall * PFNGLUNMAPNAMEDBUFFEREXTPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLVERTEXARRAYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYINDEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYNORMALOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);

























































































































































































































#line 8730 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOLORMASKINDEXEDEXTPROC) (GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void (__stdcall * PFNGLDISABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLENABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLGETBOOLEANINDEXEDVEXTPROC) (GLenum value, GLuint index, GLboolean* data);
typedef void (__stdcall * PFNGLGETINTEGERINDEXEDVEXTPROC) (GLenum value, GLuint index, GLint* data);
typedef GLboolean (__stdcall * PFNGLISENABLEDINDEXEDEXTPROC) (GLenum target, GLuint index);










#line 8753 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);






#line 8768 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);





#line 8784 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (__stdcall * PFNGLFOGCOORDDEXTPROC) (GLdouble coord);
typedef void (__stdcall * PFNGLFOGCOORDDVEXTPROC) (const GLdouble *coord);
typedef void (__stdcall * PFNGLFOGCOORDFEXTPROC) (GLfloat coord);
typedef void (__stdcall * PFNGLFOGCOORDFVEXTPROC) (const GLfloat *coord);









#line 8814 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





















typedef void (__stdcall * PFNGLFRAGMENTCOLORMATERIALEXTPROC) (GLenum face, GLenum mode);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFEXTPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFVEXTPROC) (GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELIEXTPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELIVEXTPROC) (GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFEXTPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTIEXTPROC) (GLenum light, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFEXTPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALIEXTPROC) (GLenum face, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLLIGHTENVIEXTPROC) (GLenum pname, GLint param);






















#line 8876 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBLITFRAMEBUFFEREXTPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);





#line 8894 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);





#line 8911 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 8923 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


























































typedef void (__stdcall * PFNGLBINDFRAMEBUFFEREXTPROC) (GLenum target, GLuint framebuffer);
typedef void (__stdcall * PFNGLBINDRENDERBUFFEREXTPROC) (GLenum target, GLuint renderbuffer);
typedef GLenum (__stdcall * PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC) (GLenum target);
typedef void (__stdcall * PFNGLDELETEFRAMEBUFFERSEXTPROC) (GLsizei n, const GLuint* framebuffers);
typedef void (__stdcall * PFNGLDELETERENDERBUFFERSEXTPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void (__stdcall * PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE1DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE2DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE3DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (__stdcall * PFNGLGENFRAMEBUFFERSEXTPROC) (GLsizei n, GLuint* framebuffers);
typedef void (__stdcall * PFNGLGENRENDERBUFFERSEXTPROC) (GLsizei n, GLuint* renderbuffers);
typedef void (__stdcall * PFNGLGENERATEMIPMAPEXTPROC) (GLenum target);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISFRAMEBUFFEREXTPROC) (GLuint framebuffer);
typedef GLboolean (__stdcall * PFNGLISRENDERBUFFEREXTPROC) (GLuint renderbuffer);
typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);





















#line 9020 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 9032 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



























typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERIEXTPROC) (GLuint program, GLenum pname, GLint value);







#line 9070 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);






#line 9085 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

































typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONEXTPROC) (GLuint program, GLuint color, const GLchar *name);
typedef GLint (__stdcall * PFNGLGETFRAGDATALOCATIONEXTPROC) (GLuint program, const GLchar *name);
typedef void (__stdcall * PFNGLGETUNIFORMUIVEXTPROC) (GLuint program, GLint location, GLuint *params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIIVEXTPROC) (GLuint index, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIUIVEXTPROC) (GLuint index, GLenum pname, GLuint *params);
typedef void (__stdcall * PFNGLUNIFORM1UIEXTPROC) (GLint location, GLuint v0);
typedef void (__stdcall * PFNGLUNIFORM1UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLUNIFORM2UIEXTPROC) (GLint location, GLuint v0, GLuint v1);
typedef void (__stdcall * PFNGLUNIFORM2UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLUNIFORM3UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall * PFNGLUNIFORM3UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLUNIFORM4UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall * PFNGLUNIFORM4UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IEXTPROC) (GLuint index, GLint x);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIEXTPROC) (GLuint index, GLuint x);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IEXTPROC) (GLuint index, GLint x, GLint y);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIEXTPROC) (GLuint index, GLuint x, GLuint y);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IEXTPROC) (GLuint index, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4BVEXTPROC) (GLuint index, const GLbyte *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IEXTPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4SVEXTPROC) (GLuint index, const GLshort *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UBVEXTPROC) (GLuint index, const GLubyte *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4USVEXTPROC) (GLuint index, const GLushort *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBIPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);






































#line 9191 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




















typedef void (__stdcall * PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLHISTOGRAMEXTPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLMINMAXEXTPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLRESETHISTOGRAMEXTPROC) (GLenum target);
typedef void (__stdcall * PFNGLRESETMINMAXEXTPROC) (GLenum target);














#line 9236 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 9245 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLINDEXFUNCEXTPROC) (GLenum func, GLfloat ref);





#line 9258 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLINDEXMATERIALEXTPROC) (GLenum face, GLenum mode);





#line 9271 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 9280 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLAPPLYTEXTUREEXTPROC) (GLenum mode);
typedef void (__stdcall * PFNGLTEXTURELIGHTEXTPROC) (GLenum pname);
typedef void (__stdcall * PFNGLTEXTUREMATERIALEXTPROC) (GLenum face, GLenum mode);







#line 9307 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 9316 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIDRAWARRAYSEXTPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, GLsizei* count, GLenum type, const GLvoid * const *indices, GLsizei primcount);






#line 9331 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
























typedef void (__stdcall * PFNGLSAMPLEMASKEXTPROC) (GLclampf value, GLboolean invert);
typedef void (__stdcall * PFNGLSAMPLEPATTERNEXTPROC) (GLenum pattern);






#line 9364 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 9378 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 9391 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














#line 9406 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




























typedef void (__stdcall * PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *data);
typedef void (__stdcall * PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *data);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);








#line 9447 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 9461 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) (GLenum target, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);










#line 9494 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 9503 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLPOINTPARAMETERFEXTPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPOINTPARAMETERFVEXTPROC) (GLenum pname, const GLfloat* params);






#line 9523 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLPOLYGONOFFSETEXTPROC) (GLfloat factor, GLfloat bias);





#line 9540 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLPROVOKINGVERTEXEXTPROC) (GLenum mode);





#line 9558 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 9569 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBEGINSCENEEXTPROC) (void);
typedef void (__stdcall * PFNGLENDSCENEEXTPROC) (void);






#line 9584 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLSECONDARYCOLOR3BEXTPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3BVEXTPROC) (const GLbyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DEXTPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DVEXTPROC) (const GLdouble *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FEXTPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FVEXTPROC) (const GLfloat *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IEXTPROC) (GLint red, GLint green, GLint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IVEXTPROC) (const GLint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SEXTPROC) (GLshort red, GLshort green, GLshort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SVEXTPROC) (const GLshort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBEXTPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBVEXTPROC) (const GLubyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIEXTPROC) (GLuint red, GLuint green, GLuint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIVEXTPROC) (const GLuint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USEXTPROC) (GLushort red, GLushort green, GLushort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USVEXTPROC) (const GLushort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);





















#line 9637 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLACTIVEPROGRAMEXTPROC) (GLuint program);
typedef GLuint (__stdcall * PFNGLCREATESHADERPROGRAMEXTPROC) (GLenum type, const GLchar* string);
typedef void (__stdcall * PFNGLUSESHADERPROGRAMEXTPROC) (GLenum type, GLuint program);







#line 9656 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 9669 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






























































typedef void (__stdcall * PFNGLBINDIMAGETEXTUREEXTPROC) (GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
typedef void (__stdcall * PFNGLMEMORYBARRIEREXTPROC) (GLbitfield barriers);






#line 9740 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 9749 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 9760 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 9772 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLACTIVESTENCILFACEEXTPROC) (GLenum face);





#line 9788 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 9800 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);







#line 9817 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



















































#line 9869 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);





#line 9892 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);





#line 9914 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLTEXBUFFEREXTPROC) (GLenum target, GLenum internalformat, GLuint buffer);





#line 9933 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 9942 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 9956 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 9970 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 9984 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





















#line 10006 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 10017 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 10026 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 10035 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






























#line 10066 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 10078 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 10090 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






















































typedef void (__stdcall * PFNGLCLEARCOLORIIEXTPROC) (GLint red, GLint green, GLint blue, GLint alpha);
typedef void (__stdcall * PFNGLCLEARCOLORIUIEXTPROC) (GLuint red, GLuint green, GLuint blue, GLuint alpha);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, GLuint *params);
typedef void (__stdcall * PFNGLTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, const GLuint *params);










#line 10161 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 10174 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 10187 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












typedef GLboolean (__stdcall * PFNGLARETEXTURESRESIDENTEXTPROC) (GLsizei n, const GLuint* textures, GLboolean* residences);
typedef void (__stdcall * PFNGLBINDTEXTUREEXTPROC) (GLenum target, GLuint texture);
typedef void (__stdcall * PFNGLDELETETEXTURESEXTPROC) (GLsizei n, const GLuint* textures);
typedef void (__stdcall * PFNGLGENTEXTURESEXTPROC) (GLsizei n, GLuint* textures);
typedef GLboolean (__stdcall * PFNGLISTEXTUREEXTPROC) (GLuint texture);
typedef void (__stdcall * PFNGLPRIORITIZETEXTURESEXTPROC) (GLsizei n, const GLuint* textures, const GLclampf* priorities);










#line 10216 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLTEXTURENORMALEXTPROC) (GLenum mode);





#line 10232 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 10246 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

























#line 10272 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 10285 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 10298 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


































#line 10333 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














#line 10348 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLGETQUERYOBJECTI64VEXTPROC) (GLuint id, GLenum pname, GLint64EXT *params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUI64VEXTPROC) (GLuint id, GLenum pname, GLuint64EXT *params);






#line 10365 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






















typedef void (__stdcall * PFNGLBEGINTRANSFORMFEEDBACKEXTPROC) (GLenum primitiveMode);
typedef void (__stdcall * PFNGLBINDBUFFERBASEEXTPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void (__stdcall * PFNGLBINDBUFFEROFFSETEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void (__stdcall * PFNGLBINDBUFFERRANGEEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLENDTRANSFORMFEEDBACKEXTPROC) (void);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei *size, GLenum *type, GLchar *name);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC) (GLuint program, GLsizei count, const GLchar * const* varyings, GLenum bufferMode);











#line 10406 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








































typedef void (__stdcall * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void (__stdcall * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (__stdcall * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean* pointer);
typedef void (__stdcall * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (__stdcall * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);












#line 10467 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 10478 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



















typedef void (__stdcall * PFNGLGETVERTEXATTRIBLDVEXTPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DEXTPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DEXTPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBLPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);















#line 10524 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





















































































































typedef void (__stdcall * PFNGLBEGINVERTEXSHADEREXTPROC) (void);
typedef GLuint (__stdcall * PFNGLBINDLIGHTPARAMETEREXTPROC) (GLenum light, GLenum value);
typedef GLuint (__stdcall * PFNGLBINDMATERIALPARAMETEREXTPROC) (GLenum face, GLenum value);
typedef GLuint (__stdcall * PFNGLBINDPARAMETEREXTPROC) (GLenum value);
typedef GLuint (__stdcall * PFNGLBINDTEXGENPARAMETEREXTPROC) (GLenum unit, GLenum coord, GLenum value);
typedef GLuint (__stdcall * PFNGLBINDTEXTUREUNITPARAMETEREXTPROC) (GLenum unit, GLenum value);
typedef void (__stdcall * PFNGLBINDVERTEXSHADEREXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLDELETEVERTEXSHADEREXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLENDVERTEXSHADEREXTPROC) (void);
typedef void (__stdcall * PFNGLEXTRACTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLuint (__stdcall * PFNGLGENSYMBOLSEXTPROC) (GLenum dataType, GLenum storageType, GLenum range, GLuint components);
typedef GLuint (__stdcall * PFNGLGENVERTEXSHADERSEXTPROC) (GLuint range);
typedef void (__stdcall * PFNGLGETINVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void (__stdcall * PFNGLGETINVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void (__stdcall * PFNGLGETINVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void (__stdcall * PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void (__stdcall * PFNGLGETLOCALCONSTANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void (__stdcall * PFNGLGETLOCALCONSTANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void (__stdcall * PFNGLGETVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void (__stdcall * PFNGLGETVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void (__stdcall * PFNGLGETVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void (__stdcall * PFNGLGETVARIANTPOINTERVEXTPROC) (GLuint id, GLenum value, GLvoid **data);
typedef void (__stdcall * PFNGLINSERTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLboolean (__stdcall * PFNGLISVARIANTENABLEDEXTPROC) (GLuint id, GLenum cap);
typedef void (__stdcall * PFNGLSETINVARIANTEXTPROC) (GLuint id, GLenum type, GLvoid *addr);
typedef void (__stdcall * PFNGLSETLOCALCONSTANTEXTPROC) (GLuint id, GLenum type, GLvoid *addr);
typedef void (__stdcall * PFNGLSHADEROP1EXTPROC) (GLenum op, GLuint res, GLuint arg1);
typedef void (__stdcall * PFNGLSHADEROP2EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2);
typedef void (__stdcall * PFNGLSHADEROP3EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
typedef void (__stdcall * PFNGLSWIZZLEEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void (__stdcall * PFNGLVARIANTPOINTEREXTPROC) (GLuint id, GLenum type, GLuint stride, GLvoid *addr);
typedef void (__stdcall * PFNGLVARIANTBVEXTPROC) (GLuint id, GLbyte *addr);
typedef void (__stdcall * PFNGLVARIANTDVEXTPROC) (GLuint id, GLdouble *addr);
typedef void (__stdcall * PFNGLVARIANTFVEXTPROC) (GLuint id, GLfloat *addr);
typedef void (__stdcall * PFNGLVARIANTIVEXTPROC) (GLuint id, GLint *addr);
typedef void (__stdcall * PFNGLVARIANTSVEXTPROC) (GLuint id, GLshort *addr);
typedef void (__stdcall * PFNGLVARIANTUBVEXTPROC) (GLuint id, GLubyte *addr);
typedef void (__stdcall * PFNGLVARIANTUIVEXTPROC) (GLuint id, GLuint *addr);
typedef void (__stdcall * PFNGLVARIANTUSVEXTPROC) (GLuint id, GLushort *addr);
typedef void (__stdcall * PFNGLWRITEMASKEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);














































#line 10730 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




















typedef void (__stdcall * PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
typedef void (__stdcall * PFNGLVERTEXWEIGHTFEXTPROC) (GLfloat weight);
typedef void (__stdcall * PFNGLVERTEXWEIGHTFVEXTPROC) (GLfloat* weight);







#line 10761 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef GLsync (__stdcall * PFNGLIMPORTSYNCEXTPROC) (GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);





#line 10776 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFRAMETERMINATORGREMEDYPROC) (void);





#line 10789 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLSTRINGMARKERGREMEDYPROC) (GLsizei len, const GLvoid *string);





#line 10802 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 10811 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERFHPPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERIHPPROC) (GLenum target, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);










#line 10834 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 10843 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 10852 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 10863 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIMODEDRAWARRAYSIBMPROC) (const GLenum* mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
typedef void (__stdcall * PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum* mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, GLint modestride);






#line 10878 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 10889 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 10901 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 10912 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"























typedef void (__stdcall * PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLEDGEFLAGPOINTERLISTIBMPROC) (GLint stride, const GLboolean ** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);












#line 10956 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

















#line 10974 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 10985 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef GLvoid * (__stdcall * PFNGLMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level, GLbitfield access, GLint* stride, GLenum *layout);
typedef void (__stdcall * PFNGLSYNCTEXTUREINTELPROC) (GLuint texture);
typedef void (__stdcall * PFNGLUNMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level);







#line 11007 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void (__stdcall * PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const void** pointer);
typedef void (__stdcall * PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void (__stdcall * PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);








#line 11032 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXSCISSORFUNCINTELPROC) (GLenum target, GLenum lfunc, GLenum hfunc);
typedef void (__stdcall * PFNGLTEXSCISSORINTELPROC) (GLenum target, GLclampf tlow, GLclampf thigh);






#line 11047 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















































typedef void (__stdcall *GLDEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, GLvoid* userParam);

typedef void (__stdcall * PFNGLDEBUGMESSAGECALLBACKPROC) (GLDEBUGPROC callback, const GLvoid *userParam);
typedef void (__stdcall * PFNGLDEBUGMESSAGECONTROLPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void (__stdcall * PFNGLDEBUGMESSAGEINSERTPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint (__stdcall * PFNGLGETDEBUGMESSAGELOGPROC) (GLuint count, GLsizei bufsize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
typedef void (__stdcall * PFNGLGETOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void (__stdcall * PFNGLGETOBJECTPTRLABELPROC) (void* ptr, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void (__stdcall * PFNGLOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei length, const GLchar* label);
typedef void (__stdcall * PFNGLOBJECTPTRLABELPROC) (void* ptr, GLsizei length, const GLchar* label);
typedef void (__stdcall * PFNGLPOPDEBUGGROUPPROC) (void);
typedef void (__stdcall * PFNGLPUSHDEBUGGROUPPROC) (GLenum source, GLuint id, GLsizei length, const GLchar * message);














#line 11121 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





































#line 11159 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef GLuint (__stdcall * PFNGLBUFFERREGIONENABLEDPROC) (void);
typedef void (__stdcall * PFNGLDELETEBUFFERREGIONPROC) (GLenum region);
typedef void (__stdcall * PFNGLDRAWBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest);
typedef GLuint (__stdcall * PFNGLNEWBUFFERREGIONPROC) (GLenum region);
typedef void (__stdcall * PFNGLREADBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height);









#line 11185 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















#line 11201 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 11212 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLRESIZEBUFFERSMESAPROC) (void);





#line 11225 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLWINDOWPOS2DMESAPROC) (GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLWINDOWPOS2DVMESAPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS2FMESAPROC) (GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLWINDOWPOS2FVMESAPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS2IMESAPROC) (GLint x, GLint y);
typedef void (__stdcall * PFNGLWINDOWPOS2IVMESAPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS2SMESAPROC) (GLshort x, GLshort y);
typedef void (__stdcall * PFNGLWINDOWPOS2SVMESAPROC) (const GLshort* p);
typedef void (__stdcall * PFNGLWINDOWPOS3DMESAPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLWINDOWPOS3DVMESAPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS3FMESAPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLWINDOWPOS3FVMESAPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS3IMESAPROC) (GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLWINDOWPOS3IVMESAPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS3SMESAPROC) (GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLWINDOWPOS3SVMESAPROC) (const GLshort* p);
typedef void (__stdcall * PFNGLWINDOWPOS4DMESAPROC) (GLdouble x, GLdouble y, GLdouble z, GLdouble);
typedef void (__stdcall * PFNGLWINDOWPOS4DVMESAPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS4FMESAPROC) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLWINDOWPOS4FVMESAPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS4IMESAPROC) (GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLWINDOWPOS4IVMESAPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS4SMESAPROC) (GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLWINDOWPOS4SVMESAPROC) (const GLshort* p);




























#line 11284 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 11297 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBEGINCONDITIONALRENDERNVXPROC) (GLuint id);
typedef void (__stdcall * PFNGLENDCONDITIONALRENDERNVXPROC) (void);






#line 11312 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














#line 11327 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC) (GLenum mode, const GLvoid *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC) (GLenum mode, GLenum type, const GLvoid *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);






#line 11342 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef GLuint64 (__stdcall * PFNGLGETIMAGEHANDLENVPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 (__stdcall * PFNGLGETTEXTUREHANDLENVPROC) (GLuint texture);
typedef GLuint64 (__stdcall * PFNGLGETTEXTURESAMPLERHANDLENVPROC) (GLuint texture, GLuint sampler);
typedef GLboolean (__stdcall * PFNGLISIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef GLboolean (__stdcall * PFNGLISTEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle, GLenum access);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC) (GLuint program, GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64NVPROC) (GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64VNVPROC) (GLint location, GLsizei count, const GLuint64* value);

















#line 11379 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





















































typedef void (__stdcall * PFNGLBLENDBARRIERNVPROC) (void);
typedef void (__stdcall * PFNGLBLENDPARAMETERINVPROC) (GLenum pname, GLint value);






#line 11441 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 11450 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 11459 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 11471 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBEGINCONDITIONALRENDERNVPROC) (GLuint id, GLenum mode);
typedef void (__stdcall * PFNGLENDCONDITIONALRENDERNVPROC) (void);






#line 11491 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 11503 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOPYIMAGESUBDATANVPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);





#line 11516 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 11528 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLCLEARDEPTHDNVPROC) (GLdouble depth);
typedef void (__stdcall * PFNGLDEPTHBOUNDSDNVPROC) (GLdouble zmin, GLdouble zmax);
typedef void (__stdcall * PFNGLDEPTHRANGEDNVPROC) (GLdouble zNear, GLdouble zFar);







#line 11550 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 11561 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














#line 11576 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWTEXTURENVPROC) (GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);





#line 11589 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"































typedef void (__stdcall * PFNGLEVALMAPSNVPROC) (GLenum target, GLenum mode);
typedef void (__stdcall * PFNGLGETMAPATTRIBPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMAPATTRIBPARAMETERIVNVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points);
typedef void (__stdcall * PFNGLGETMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points);
typedef void (__stdcall * PFNGLMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, const GLint* params);













#line 11643 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

















typedef void (__stdcall * PFNGLGETMULTISAMPLEFVNVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void (__stdcall * PFNGLSAMPLEMASKINDEXEDNVPROC) (GLuint index, GLbitfield mask);
typedef void (__stdcall * PFNGLTEXRENDERBUFFERNVPROC) (GLenum target, GLuint renderbuffer);







#line 11671 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLDELETEFENCESNVPROC) (GLsizei n, const GLuint* fences);
typedef void (__stdcall * PFNGLFINISHFENCENVPROC) (GLuint fence);
typedef void (__stdcall * PFNGLGENFENCESNVPROC) (GLsizei n, GLuint* fences);
typedef void (__stdcall * PFNGLGETFENCEIVNVPROC) (GLuint fence, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISFENCENVPROC) (GLuint fence);
typedef void (__stdcall * PFNGLSETFENCENVPROC) (GLuint fence, GLenum condition);
typedef GLboolean (__stdcall * PFNGLTESTFENCENVPROC) (GLuint fence);











#line 11700 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
























#line 11725 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 11738 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble *params);
typedef void (__stdcall * PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat *params);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4DNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLdouble v[]);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4FNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLfloat v[]);










#line 11768 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














#line 11783 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 11792 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 11801 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);





#line 11819 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLPROGRAMVERTEXLIMITNVPROC) (GLenum target, GLint limit);





#line 11836 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 11845 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
















#line 11889 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















#line 11905 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 11914 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 11923 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



































typedef void (__stdcall * PFNGLGETUNIFORMI64VNVPROC) (GLuint program, GLint location, GLint64EXT* params);
typedef void (__stdcall * PFNGLGETUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLuint64EXT* params);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1I64NVPROC) (GLuint program, GLint location, GLint64EXT x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM1I64NVPROC) (GLint location, GLint64EXT x);
typedef void (__stdcall * PFNGLUNIFORM1I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM1UI64NVPROC) (GLint location, GLuint64EXT x);
typedef void (__stdcall * PFNGLUNIFORM1UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM2I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y);
typedef void (__stdcall * PFNGLUNIFORM2I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM2UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void (__stdcall * PFNGLUNIFORM2UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM3I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (__stdcall * PFNGLUNIFORM3I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM3UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (__stdcall * PFNGLUNIFORM3UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM4I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (__stdcall * PFNGLUNIFORM4I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM4UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (__stdcall * PFNGLUNIFORM4UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);






































#line 12031 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef unsigned short GLhalf;

typedef void (__stdcall * PFNGLCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void (__stdcall * PFNGLCOLOR3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLCOLOR4HNVPROC) (GLhalf red, GLhalf green, GLhalf blue, GLhalf alpha);
typedef void (__stdcall * PFNGLCOLOR4HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLFOGCOORDHNVPROC) (GLhalf fog);
typedef void (__stdcall * PFNGLFOGCOORDHVNVPROC) (const GLhalf* fog);
typedef void (__stdcall * PFNGLMULTITEXCOORD1HNVPROC) (GLenum target, GLhalf s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2HNVPROC) (GLenum target, GLhalf s, GLhalf t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLNORMAL3HNVPROC) (GLhalf nx, GLhalf ny, GLhalf nz);
typedef void (__stdcall * PFNGLNORMAL3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD1HNVPROC) (GLhalf s);
typedef void (__stdcall * PFNGLTEXCOORD1HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD2HNVPROC) (GLhalf s, GLhalf t);
typedef void (__stdcall * PFNGLTEXCOORD2HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD3HNVPROC) (GLhalf s, GLhalf t, GLhalf r);
typedef void (__stdcall * PFNGLTEXCOORD3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD4HNVPROC) (GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void (__stdcall * PFNGLTEXCOORD4HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEX2HNVPROC) (GLhalf x, GLhalf y);
typedef void (__stdcall * PFNGLVERTEX2HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEX3HNVPROC) (GLhalf x, GLhalf y, GLhalf z);
typedef void (__stdcall * PFNGLVERTEX3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEX4HNVPROC) (GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void (__stdcall * PFNGLVERTEX4HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1HNVPROC) (GLuint index, GLhalf x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2HNVPROC) (GLuint index, GLhalf x, GLhalf y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXWEIGHTHNVPROC) (GLhalf weight);
typedef void (__stdcall * PFNGLVERTEXWEIGHTHVNVPROC) (const GLhalf* weight);


















































#line 12138 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 12150 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 12161 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 12172 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBEGINOCCLUSIONQUERYNVPROC) (GLuint id);
typedef void (__stdcall * PFNGLDELETEOCCLUSIONQUERIESNVPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDOCCLUSIONQUERYNVPROC) (void);
typedef void (__stdcall * PFNGLGENOCCLUSIONQUERIESNVPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETOCCLUSIONQUERYIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETOCCLUSIONQUERYUIVNVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef GLboolean (__stdcall * PFNGLISOCCLUSIONQUERYNVPROC) (GLuint id);











#line 12202 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 12214 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);







#line 12237 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 12246 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"







































































































































typedef void (__stdcall * PFNGLCOPYPATHNVPROC) (GLuint resultPath, GLuint srcPath);
typedef void (__stdcall * PFNGLCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLCOVERFILLPATHNVPROC) (GLuint path, GLenum coverMode);
typedef void (__stdcall * PFNGLCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLCOVERSTROKEPATHNVPROC) (GLuint name, GLenum coverMode);
typedef void (__stdcall * PFNGLDELETEPATHSNVPROC) (GLuint path, GLsizei range);
typedef GLuint (__stdcall * PFNGLGENPATHSNVPROC) (GLsizei range);
typedef void (__stdcall * PFNGLGETPATHCOLORGENFVNVPROC) (GLenum color, GLenum pname, GLfloat* value);
typedef void (__stdcall * PFNGLGETPATHCOLORGENIVNVPROC) (GLenum color, GLenum pname, GLint* value);
typedef void (__stdcall * PFNGLGETPATHCOMMANDSNVPROC) (GLuint name, GLubyte* commands);
typedef void (__stdcall * PFNGLGETPATHCOORDSNVPROC) (GLuint name, GLfloat* coords);
typedef void (__stdcall * PFNGLGETPATHDASHARRAYNVPROC) (GLuint name, GLfloat* dashArray);
typedef GLfloat (__stdcall * PFNGLGETPATHLENGTHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments);
typedef void (__stdcall * PFNGLGETPATHMETRICRANGENVPROC) (GLbitfield metricQueryMask, GLuint fistPathName, GLsizei numPaths, GLsizei stride, GLfloat* metrics);
typedef void (__stdcall * PFNGLGETPATHMETRICSNVPROC) (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
typedef void (__stdcall * PFNGLGETPATHPARAMETERFVNVPROC) (GLuint name, GLenum param, GLfloat* value);
typedef void (__stdcall * PFNGLGETPATHPARAMETERIVNVPROC) (GLuint name, GLenum param, GLint* value);
typedef void (__stdcall * PFNGLGETPATHSPACINGNVPROC) (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
typedef void (__stdcall * PFNGLGETPATHTEXGENFVNVPROC) (GLenum texCoordSet, GLenum pname, GLfloat* value);
typedef void (__stdcall * PFNGLGETPATHTEXGENIVNVPROC) (GLenum texCoordSet, GLenum pname, GLint* value);
typedef void (__stdcall * PFNGLINTERPOLATEPATHSNVPROC) (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
typedef GLboolean (__stdcall * PFNGLISPATHNVPROC) (GLuint path);
typedef GLboolean (__stdcall * PFNGLISPOINTINFILLPATHNVPROC) (GLuint path, GLuint mask, GLfloat x, GLfloat y);
typedef GLboolean (__stdcall * PFNGLISPOINTINSTROKEPATHNVPROC) (GLuint path, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLPATHCOLORGENNVPROC) (GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat* coeffs);
typedef void (__stdcall * PFNGLPATHCOMMANDSNVPROC) (GLuint path, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const GLvoid*coords);
typedef void (__stdcall * PFNGLPATHCOORDSNVPROC) (GLuint path, GLsizei numCoords, GLenum coordType, const void* coords);
typedef void (__stdcall * PFNGLPATHCOVERDEPTHFUNCNVPROC) (GLenum zfunc);
typedef void (__stdcall * PFNGLPATHDASHARRAYNVPROC) (GLuint path, GLsizei dashCount, const GLfloat* dashArray);
typedef void (__stdcall * PFNGLPATHFOGGENNVPROC) (GLenum genMode);
typedef void (__stdcall * PFNGLPATHGLYPHRANGENVPROC) (GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void (__stdcall * PFNGLPATHGLYPHSNVPROC) (GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid*charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void (__stdcall * PFNGLPATHPARAMETERFNVPROC) (GLuint path, GLenum pname, GLfloat value);
typedef void (__stdcall * PFNGLPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, const GLfloat* value);
typedef void (__stdcall * PFNGLPATHPARAMETERINVPROC) (GLuint path, GLenum pname, GLint value);
typedef void (__stdcall * PFNGLPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, const GLint* value);
typedef void (__stdcall * PFNGLPATHSTENCILDEPTHOFFSETNVPROC) (GLfloat factor, GLfloat units);
typedef void (__stdcall * PFNGLPATHSTENCILFUNCNVPROC) (GLenum func, GLint ref, GLuint mask);
typedef void (__stdcall * PFNGLPATHSTRINGNVPROC) (GLuint path, GLenum format, GLsizei length, const void* pathString);
typedef void (__stdcall * PFNGLPATHSUBCOMMANDSNVPROC) (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const GLvoid*coords);
typedef void (__stdcall * PFNGLPATHSUBCOORDSNVPROC) (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void* coords);
typedef void (__stdcall * PFNGLPATHTEXGENNVPROC) (GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat* coeffs);
typedef GLboolean (__stdcall * PFNGLPOINTALONGPATHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY);
typedef void (__stdcall * PFNGLSTENCILFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLSTENCILFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLSTENCILSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask);
typedef void (__stdcall * PFNGLTRANSFORMPATHNVPROC) (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat* transformValues);
typedef void (__stdcall * PFNGLWEIGHTPATHSNVPROC) (GLuint resultPath, GLsizei numPaths, const GLuint paths[], const GLfloat weights[]);





















































#line 12484 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLFLUSHPIXELDATARANGENVPROC) (GLenum target);
typedef void (__stdcall * PFNGLPIXELDATARANGENVPROC) (GLenum target, GLsizei length, GLvoid *pointer);






#line 12506 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLPOINTPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLPOINTPARAMETERIVNVPROC) (GLenum pname, const GLint* params);






#line 12525 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLGETVIDEOI64VNVPROC) (GLuint video_slot, GLenum pname, GLint64EXT* params);
typedef void (__stdcall * PFNGLGETVIDEOIVNVPROC) (GLuint video_slot, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVIDEOUI64VNVPROC) (GLuint video_slot, GLenum pname, GLuint64EXT* params);
typedef void (__stdcall * PFNGLGETVIDEOUIVNVPROC) (GLuint video_slot, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLPRESENTFRAMEDUALFILLNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
typedef void (__stdcall * PFNGLPRESENTFRAMEKEYEDNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);










#line 12555 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLPRIMITIVERESTARTINDEXNVPROC) (GLuint index);
typedef void (__stdcall * PFNGLPRIMITIVERESTARTNVPROC) (void);






#line 12573 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


























































typedef void (__stdcall * PFNGLCOMBINERINPUTNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void (__stdcall * PFNGLCOMBINEROUTPUTNVPROC) (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERFVNVPROC) (GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERIVNVPROC) (GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLFINALCOMBINERINPUTNVPROC) (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void (__stdcall * PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) (GLenum variable, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) (GLenum variable, GLenum pname, GLint* params);

















#line 12662 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, GLfloat* params);






#line 12679 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 12688 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 12697 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLGETBUFFERPARAMETERUI64VNVPROC) (GLenum target, GLenum pname, GLuint64EXT* params);
typedef void (__stdcall * PFNGLGETINTEGERUI64VNVPROC) (GLenum value, GLuint64EXT* result);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC) (GLuint buffer, GLenum pname, GLuint64EXT* params);
typedef GLboolean (__stdcall * PFNGLISBUFFERRESIDENTNVPROC) (GLenum target);
typedef GLboolean (__stdcall * PFNGLISNAMEDBUFFERRESIDENTNVPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLMAKEBUFFERNONRESIDENTNVPROC) (GLenum target);
typedef void (__stdcall * PFNGLMAKEBUFFERRESIDENTNVPROC) (GLenum target, GLenum access);
typedef void (__stdcall * PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLMAKENAMEDBUFFERRESIDENTNVPROC) (GLuint buffer, GLenum access);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMUI64NVPROC) (GLuint program, GLint location, GLuint64EXT value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORMUI64NVPROC) (GLint location, GLuint64EXT value);
typedef void (__stdcall * PFNGLUNIFORMUI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);

















#line 12738 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 12747 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














#line 12762 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 12775 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 12787 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXTUREBARRIERNVPROC) (void);





#line 12800 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 12809 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














#line 12824 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 12835 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);










#line 12861 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 12875 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


















































































#line 12958 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





































#line 12996 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


























#line 13023 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
































typedef void (__stdcall * PFNGLACTIVEVARYINGNVPROC) (GLuint program, const GLchar *name);
typedef void (__stdcall * PFNGLBEGINTRANSFORMFEEDBACKNVPROC) (GLenum primitiveMode);
typedef void (__stdcall * PFNGLBINDBUFFERBASENVPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void (__stdcall * PFNGLBINDBUFFEROFFSETNVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void (__stdcall * PFNGLBINDBUFFERRANGENVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLENDTRANSFORMFEEDBACKNVPROC) (void);
typedef void (__stdcall * PFNGLGETACTIVEVARYINGNVPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC) (GLuint program, GLuint index, GLint *location);
typedef GLint (__stdcall * PFNGLGETVARYINGLOCATIONNVPROC) (GLuint program, const GLchar *name);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC) (GLuint count, const GLint *attribs, GLenum bufferMode);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC) (GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);















#line 13082 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBINDTRANSFORMFEEDBACKNVPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETETRANSFORMFEEDBACKSNVPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKNVPROC) (GLenum mode, GLuint id);
typedef void (__stdcall * PFNGLGENTRANSFORMFEEDBACKSNVPROC) (GLsizei n, GLuint* ids);
typedef GLboolean (__stdcall * PFNGLISTRANSFORMFEEDBACKNVPROC) (GLuint id);
typedef void (__stdcall * PFNGLPAUSETRANSFORMFEEDBACKNVPROC) (void);
typedef void (__stdcall * PFNGLRESUMETRANSFORMFEEDBACKNVPROC) (void);











#line 13112 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











typedef GLintptr GLvdpauSurfaceNV;

typedef void (__stdcall * PFNGLVDPAUFININVPROC) (void);
typedef void (__stdcall * PFNGLVDPAUGETSURFACEIVNVPROC) (GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei* length, GLint *values);
typedef void (__stdcall * PFNGLVDPAUINITNVPROC) (const void* vdpDevice, const GLvoid*getProcAddress);
typedef void (__stdcall * PFNGLVDPAUISSURFACENVPROC) (GLvdpauSurfaceNV surface);
typedef void (__stdcall * PFNGLVDPAUMAPSURFACESNVPROC) (GLsizei numSurfaces, const GLvdpauSurfaceNV* surfaces);
typedef GLvdpauSurfaceNV (__stdcall * PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef GLvdpauSurfaceNV (__stdcall * PFNGLVDPAUREGISTERVIDEOSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef void (__stdcall * PFNGLVDPAUSURFACEACCESSNVPROC) (GLvdpauSurfaceNV surface, GLenum access);
typedef void (__stdcall * PFNGLVDPAUUNMAPSURFACESNVPROC) (GLsizei numSurface, const GLvdpauSurfaceNV* surfaces);
typedef void (__stdcall * PFNGLVDPAUUNREGISTERSURFACENVPROC) (GLvdpauSurfaceNV surface);














#line 13150 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLFLUSHVERTEXARRAYRANGENVPROC) (void);
typedef void (__stdcall * PFNGLVERTEXARRAYRANGENVPROC) (GLsizei length, GLvoid *pointer);






#line 13171 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 13182 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLGETVERTEXATTRIBLI64VNVPROC) (GLuint index, GLenum pname, GLint64EXT* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBLUI64VNVPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1I64NVPROC) (GLuint index, GLint64EXT x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64NVPROC) (GLuint index, GLuint64EXT x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBLFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);























#line 13234 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
































typedef void (__stdcall * PFNGLBUFFERADDRESSRANGENVPROC) (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
typedef void (__stdcall * PFNGLCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLEDGEFLAGFORMATNVPROC) (GLsizei stride);
typedef void (__stdcall * PFNGLFOGCOORDFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLGETINTEGERUI64I_VNVPROC) (GLenum value, GLuint index, GLuint64EXT result[]);
typedef void (__stdcall * PFNGLINDEXFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLNORMALFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLSECONDARYCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLTEXCOORDFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXATTRIBFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXATTRIBIFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
















#line 13295 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


























































































typedef GLboolean (__stdcall * PFNGLAREPROGRAMSRESIDENTNVPROC) (GLsizei n, const GLuint* ids, GLboolean *residences);
typedef void (__stdcall * PFNGLBINDPROGRAMNVPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETEPROGRAMSNVPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLEXECUTEPROGRAMNVPROC) (GLenum target, GLuint id, const GLfloat* params);
typedef void (__stdcall * PFNGLGENPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETPROGRAMPARAMETERDVNVPROC) (GLenum target, GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETPROGRAMPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETPROGRAMSTRINGNVPROC) (GLuint id, GLenum pname, GLubyte* program);
typedef void (__stdcall * PFNGLGETPROGRAMIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTRACKMATRIXIVNVPROC) (GLenum target, GLuint address, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, GLvoid** pointer);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBDVNVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBFVNVPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIVNVPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISPROGRAMNVPROC) (GLuint id);
typedef void (__stdcall * PFNGLLOADPROGRAMNVPROC) (GLenum target, GLuint id, GLsizei len, const GLubyte* program);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4DNVPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4DVNVPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4FNVPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4FVNVPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERS4DVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERS4FVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLfloat* params);
typedef void (__stdcall * PFNGLREQUESTRESIDENTPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DNVPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FNVPROC) (GLuint index, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SNVPROC) (GLuint index, GLshort x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DNVPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FNVPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SNVPROC) (GLuint index, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBNVPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBVNVPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4UBVNVPROC) (GLuint index, GLsizei n, const GLubyte* v);




































































#line 13518 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 13527 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 13536 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 13548 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 13559 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 13570 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




































typedef void (__stdcall * PFNGLBEGINVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void (__stdcall * PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
typedef void (__stdcall * PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
typedef void (__stdcall * PFNGLENDVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void (__stdcall * PFNGLGETVIDEOCAPTURESTREAMDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETVIDEOCAPTURESTREAMFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVIDEOCAPTURESTREAMIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVIDEOCAPTUREIVNVPROC) (GLuint video_capture_slot, GLenum pname, GLint* params);
typedef GLenum (__stdcall * PFNGLVIDEOCAPTURENVPROC) (GLuint video_capture_slot, GLuint* sequence_num, GLuint64EXT *capture_time);
typedef void (__stdcall * PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble* params);
typedef void (__stdcall * PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint* params);
















#line 13635 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 13644 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



















#line 13664 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 13676 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCLEARDEPTHFOESPROC) (GLclampd depth);
typedef void (__stdcall * PFNGLCLIPPLANEFOESPROC) (GLenum plane, const GLfloat* equation);
typedef void (__stdcall * PFNGLDEPTHRANGEFOESPROC) (GLclampf n, GLclampf f);
typedef void (__stdcall * PFNGLFRUSTUMFOESPROC) (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
typedef void (__stdcall * PFNGLGETCLIPPLANEFOESPROC) (GLenum plane, GLfloat* equation);
typedef void (__stdcall * PFNGLORTHOFOESPROC) (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);










#line 13699 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 13711 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















#line 13727 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 13739 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





























#line 13769 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"































#line 13801 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef int GLclampx;

typedef void (__stdcall * PFNGLALPHAFUNCXPROC) (GLenum func, GLclampx ref);
typedef void (__stdcall * PFNGLCLEARCOLORXPROC) (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
typedef void (__stdcall * PFNGLCLEARDEPTHXPROC) (GLclampx depth);
typedef void (__stdcall * PFNGLCOLOR4XPROC) (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
typedef void (__stdcall * PFNGLDEPTHRANGEXPROC) (GLclampx zNear, GLclampx zFar);
typedef void (__stdcall * PFNGLFOGXPROC) (GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLFOGXVPROC) (GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLFRUSTUMFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void (__stdcall * PFNGLFRUSTUMXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void (__stdcall * PFNGLLIGHTMODELXPROC) (GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLLIGHTMODELXVPROC) (GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLLIGHTXPROC) (GLenum light, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLLIGHTXVPROC) (GLenum light, GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLLINEWIDTHXPROC) (GLfixed width);
typedef void (__stdcall * PFNGLLOADMATRIXXPROC) (const GLfixed* m);
typedef void (__stdcall * PFNGLMATERIALXPROC) (GLenum face, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLMATERIALXVPROC) (GLenum face, GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLMULTMATRIXXPROC) (const GLfixed* m);
typedef void (__stdcall * PFNGLMULTITEXCOORD4XPROC) (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
typedef void (__stdcall * PFNGLNORMAL3XPROC) (GLfixed nx, GLfixed ny, GLfixed nz);
typedef void (__stdcall * PFNGLORTHOFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void (__stdcall * PFNGLORTHOXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void (__stdcall * PFNGLPOINTSIZEXPROC) (GLfixed size);
typedef void (__stdcall * PFNGLPOLYGONOFFSETXPROC) (GLfixed factor, GLfixed units);
typedef void (__stdcall * PFNGLROTATEXPROC) (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
typedef void (__stdcall * PFNGLSAMPLECOVERAGEXPROC) (GLclampx value, GLboolean invert);
typedef void (__stdcall * PFNGLSCALEXPROC) (GLfixed x, GLfixed y, GLfixed z);
typedef void (__stdcall * PFNGLTEXENVXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLTEXENVXVPROC) (GLenum target, GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLTEXPARAMETERXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLTRANSLATEXPROC) (GLfixed x, GLfixed y, GLfixed z);



































#line 13876 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCLIPPLANEFPROC) (GLenum plane, const GLfloat* equation);
typedef void (__stdcall * PFNGLCLIPPLANEXPROC) (GLenum plane, const GLfixed* equation);
typedef void (__stdcall * PFNGLGETCLIPPLANEFPROC) (GLenum pname, GLfloat eqn[4]);
typedef void (__stdcall * PFNGLGETCLIPPLANEXPROC) (GLenum pname, GLfixed eqn[4]);
typedef void (__stdcall * PFNGLGETFIXEDVPROC) (GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETLIGHTXVPROC) (GLenum light, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETMATERIALXVPROC) (GLenum face, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETTEXENVXVPROC) (GLenum env, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETTEXPARAMETERXVPROC) (GLenum target, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLPOINTPARAMETERXPROC) (GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLPOINTPARAMETERXVPROC) (GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLPOINTSIZEPOINTEROESPROC) (GLenum type, GLsizei stride, const GLvoid* pointer);
typedef void (__stdcall * PFNGLTEXPARAMETERXVPROC) (GLenum target, GLenum pname, const GLfixed* params);

















#line 13913 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



















#line 13933 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef const GLchar* (__stdcall * PFNGLERRORSTRINGREGALPROC) (GLenum error);





#line 13946 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef GLboolean (__stdcall * PFNGLGETEXTENSIONREGALPROC) (const GLchar* ext);
typedef GLboolean (__stdcall * PFNGLISSUPPORTEDREGALPROC) (const GLchar* ext);






#line 13961 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
















typedef void (__stdcall *GLLOGPROCREGAL)(GLenum stream, GLsizei length, const GLchar *message, GLvoid *context);

typedef void (__stdcall * PFNGLLOGMESSAGECALLBACKREGALPROC) (GLLOGPROCREGAL callback);





#line 13986 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 13998 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















#line 14014 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"


















#line 14033 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDETAILTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);
typedef void (__stdcall * PFNGLGETDETAILTEXFUNCSGISPROC) (GLenum target, GLfloat* points);






#line 14048 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFOGFUNCSGISPROC) (GLsizei n, const GLfloat* points);
typedef void (__stdcall * PFNGLGETFOGFUNCSGISPROC) (GLfloat* points);






#line 14063 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 14075 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"























typedef void (__stdcall * PFNGLSAMPLEMASKSGISPROC) (GLclampf value, GLboolean invert);
typedef void (__stdcall * PFNGLSAMPLEPATTERNSGISPROC) (GLenum pattern);






#line 14107 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 14116 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

















#line 14134 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETSHARPENTEXFUNCSGISPROC) (GLenum target, GLfloat* points);
typedef void (__stdcall * PFNGLSHARPENTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);






#line 14149 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLenum format, GLenum type, const GLvoid *pixels);






#line 14164 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 14175 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 14186 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLfloat* weights);
typedef void (__stdcall * PFNGLTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLsizei n, const GLfloat* weights);






#line 14201 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 14215 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 14224 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLASYNCMARKERSGIXPROC) (GLuint marker);
typedef void (__stdcall * PFNGLDELETEASYNCMARKERSSGIXPROC) (GLuint marker, GLsizei range);
typedef GLint (__stdcall * PFNGLFINISHASYNCSGIXPROC) (GLuint* markerp);
typedef GLuint (__stdcall * PFNGLGENASYNCMARKERSSGIXPROC) (GLsizei range);
typedef GLboolean (__stdcall * PFNGLISASYNCMARKERSGIXPROC) (GLuint marker);
typedef GLint (__stdcall * PFNGLPOLLASYNCSGIXPROC) (GLuint* markerp);










#line 14249 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 14261 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"















#line 14277 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 14289 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 14298 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 14309 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 14322 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFLUSHRASTERSGIXPROC) (void);





#line 14335 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 14347 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLTEXTUREFOGSGIXPROC) (GLenum pname);





#line 14364 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFRAGMENTCOLORMATERIALSGIXPROC) (GLenum face, GLenum mode);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFSGIXPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELISGIXPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELIVSGIXPROC) (GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFSGIXPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTISGIXPROC) (GLenum light, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFSGIXPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALISGIXPROC) (GLenum face, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum value, GLfloat* data);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum value, GLint* data);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* data);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* data);





















#line 14409 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFRAMEZOOMSGIXPROC) (GLint factor);





#line 14422 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 14433 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 14442 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 14451 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLPIXELTEXGENSGIXPROC) (GLenum mode);





#line 14464 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 14473 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLREFERENCEPLANESGIXPROC) (const GLdouble* equation);





#line 14486 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"














#line 14501 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 14515 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 14526 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLSPRITEPARAMETERFSGIXPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLSPRITEPARAMETERFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLSPRITEPARAMETERISGIXPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLSPRITEPARAMETERIVSGIXPROC) (GLenum pname, GLint* params);








#line 14545 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTAGSAMPLEBUFFERSGIXPROC) (void);





#line 14558 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 14567 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"












#line 14580 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 14589 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 14600 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





































#line 14638 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"













#line 14652 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 14664 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 14676 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"








#line 14685 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




















#line 14706 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"























typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void (__stdcall * PFNGLCOPYCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);











#line 14748 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 14760 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLFINISHTEXTURESUNXPROC) (void);





#line 14776 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 14787 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLGLOBALALPHAFACTORBSUNPROC) (GLbyte factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORDSUNPROC) (GLdouble factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORFSUNPROC) (GLfloat factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORISUNPROC) (GLint factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORSSUNPROC) (GLshort factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORUBSUNPROC) (GLubyte factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORUISUNPROC) (GLuint factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORUSSUNPROC) (GLushort factor);












#line 14817 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 14829 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLREADVIDEOPIXELSSUNPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels);





#line 14842 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 14853 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"
























typedef void (__stdcall * PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUBSUNPROC) (GLubyte code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUBVSUNPROC) (const GLubyte* code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUISUNPROC) (GLuint code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUIVSUNPROC) (const GLuint* code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUSSUNPROC) (GLushort code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUSVSUNPROC) (const GLushort* code);











#line 14896 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOLOR3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *v);
typedef void (__stdcall * PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX2FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX2FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX3FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX3FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void (__stdcall * PFNGLNORMAL3FVERTEX3FSUNPROC) (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC) (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC) (const GLuint* rc, const GLubyte *c, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC) (GLuint rc, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC) (const GLfloat* tc, const GLubyte *c, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD4FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLTEXCOORD4FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *v);












































#line 14987 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"











#line 14999 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"










#line 15010 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLADDSWAPHINTRECTWINPROC) (GLint x, GLint y, GLsizei width, GLsizei height);





#line 15023 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"





#line 15029 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

#line 15031 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"



#line 15035 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

#line 15037 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




#line 15042 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

extern __declspec(dllimport) PFNGLCOPYTEXSUBIMAGE3DPROC __glewCopyTexSubImage3D;
extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTSPROC __glewDrawRangeElements;
extern __declspec(dllimport) PFNGLTEXIMAGE3DPROC __glewTexImage3D;
extern __declspec(dllimport) PFNGLTEXSUBIMAGE3DPROC __glewTexSubImage3D;

extern __declspec(dllimport) PFNGLACTIVETEXTUREPROC __glewActiveTexture;
extern __declspec(dllimport) PFNGLCLIENTACTIVETEXTUREPROC __glewClientActiveTexture;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE1DPROC __glewCompressedTexImage1D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE2DPROC __glewCompressedTexImage2D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE3DPROC __glewCompressedTexImage3D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC __glewCompressedTexSubImage1D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC __glewCompressedTexSubImage2D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC __glewCompressedTexSubImage3D;
extern __declspec(dllimport) PFNGLGETCOMPRESSEDTEXIMAGEPROC __glewGetCompressedTexImage;
extern __declspec(dllimport) PFNGLLOADTRANSPOSEMATRIXDPROC __glewLoadTransposeMatrixd;
extern __declspec(dllimport) PFNGLLOADTRANSPOSEMATRIXFPROC __glewLoadTransposeMatrixf;
extern __declspec(dllimport) PFNGLMULTTRANSPOSEMATRIXDPROC __glewMultTransposeMatrixd;
extern __declspec(dllimport) PFNGLMULTTRANSPOSEMATRIXFPROC __glewMultTransposeMatrixf;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1DPROC __glewMultiTexCoord1d;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1DVPROC __glewMultiTexCoord1dv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1FPROC __glewMultiTexCoord1f;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1FVPROC __glewMultiTexCoord1fv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1IPROC __glewMultiTexCoord1i;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1IVPROC __glewMultiTexCoord1iv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1SPROC __glewMultiTexCoord1s;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1SVPROC __glewMultiTexCoord1sv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2DPROC __glewMultiTexCoord2d;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2DVPROC __glewMultiTexCoord2dv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2FPROC __glewMultiTexCoord2f;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2FVPROC __glewMultiTexCoord2fv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2IPROC __glewMultiTexCoord2i;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2IVPROC __glewMultiTexCoord2iv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2SPROC __glewMultiTexCoord2s;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2SVPROC __glewMultiTexCoord2sv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3DPROC __glewMultiTexCoord3d;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3DVPROC __glewMultiTexCoord3dv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3FPROC __glewMultiTexCoord3f;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3FVPROC __glewMultiTexCoord3fv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3IPROC __glewMultiTexCoord3i;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3IVPROC __glewMultiTexCoord3iv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3SPROC __glewMultiTexCoord3s;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3SVPROC __glewMultiTexCoord3sv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4DPROC __glewMultiTexCoord4d;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4DVPROC __glewMultiTexCoord4dv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4FPROC __glewMultiTexCoord4f;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4FVPROC __glewMultiTexCoord4fv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4IPROC __glewMultiTexCoord4i;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4IVPROC __glewMultiTexCoord4iv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4SPROC __glewMultiTexCoord4s;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4SVPROC __glewMultiTexCoord4sv;
extern __declspec(dllimport) PFNGLSAMPLECOVERAGEPROC __glewSampleCoverage;

extern __declspec(dllimport) PFNGLBLENDCOLORPROC __glewBlendColor;
extern __declspec(dllimport) PFNGLBLENDEQUATIONPROC __glewBlendEquation;
extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEPROC __glewBlendFuncSeparate;
extern __declspec(dllimport) PFNGLFOGCOORDPOINTERPROC __glewFogCoordPointer;
extern __declspec(dllimport) PFNGLFOGCOORDDPROC __glewFogCoordd;
extern __declspec(dllimport) PFNGLFOGCOORDDVPROC __glewFogCoorddv;
extern __declspec(dllimport) PFNGLFOGCOORDFPROC __glewFogCoordf;
extern __declspec(dllimport) PFNGLFOGCOORDFVPROC __glewFogCoordfv;
extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSPROC __glewMultiDrawArrays;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSPROC __glewMultiDrawElements;
extern __declspec(dllimport) PFNGLPOINTPARAMETERFPROC __glewPointParameterf;
extern __declspec(dllimport) PFNGLPOINTPARAMETERFVPROC __glewPointParameterfv;
extern __declspec(dllimport) PFNGLPOINTPARAMETERIPROC __glewPointParameteri;
extern __declspec(dllimport) PFNGLPOINTPARAMETERIVPROC __glewPointParameteriv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3BPROC __glewSecondaryColor3b;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3BVPROC __glewSecondaryColor3bv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3DPROC __glewSecondaryColor3d;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3DVPROC __glewSecondaryColor3dv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3FPROC __glewSecondaryColor3f;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3FVPROC __glewSecondaryColor3fv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3IPROC __glewSecondaryColor3i;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3IVPROC __glewSecondaryColor3iv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3SPROC __glewSecondaryColor3s;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3SVPROC __glewSecondaryColor3sv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UBPROC __glewSecondaryColor3ub;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UBVPROC __glewSecondaryColor3ubv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UIPROC __glewSecondaryColor3ui;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UIVPROC __glewSecondaryColor3uiv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3USPROC __glewSecondaryColor3us;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3USVPROC __glewSecondaryColor3usv;
extern __declspec(dllimport) PFNGLSECONDARYCOLORPOINTERPROC __glewSecondaryColorPointer;
extern __declspec(dllimport) PFNGLWINDOWPOS2DPROC __glewWindowPos2d;
extern __declspec(dllimport) PFNGLWINDOWPOS2DVPROC __glewWindowPos2dv;
extern __declspec(dllimport) PFNGLWINDOWPOS2FPROC __glewWindowPos2f;
extern __declspec(dllimport) PFNGLWINDOWPOS2FVPROC __glewWindowPos2fv;
extern __declspec(dllimport) PFNGLWINDOWPOS2IPROC __glewWindowPos2i;
extern __declspec(dllimport) PFNGLWINDOWPOS2IVPROC __glewWindowPos2iv;
extern __declspec(dllimport) PFNGLWINDOWPOS2SPROC __glewWindowPos2s;
extern __declspec(dllimport) PFNGLWINDOWPOS2SVPROC __glewWindowPos2sv;
extern __declspec(dllimport) PFNGLWINDOWPOS3DPROC __glewWindowPos3d;
extern __declspec(dllimport) PFNGLWINDOWPOS3DVPROC __glewWindowPos3dv;
extern __declspec(dllimport) PFNGLWINDOWPOS3FPROC __glewWindowPos3f;
extern __declspec(dllimport) PFNGLWINDOWPOS3FVPROC __glewWindowPos3fv;
extern __declspec(dllimport) PFNGLWINDOWPOS3IPROC __glewWindowPos3i;
extern __declspec(dllimport) PFNGLWINDOWPOS3IVPROC __glewWindowPos3iv;
extern __declspec(dllimport) PFNGLWINDOWPOS3SPROC __glewWindowPos3s;
extern __declspec(dllimport) PFNGLWINDOWPOS3SVPROC __glewWindowPos3sv;

extern __declspec(dllimport) PFNGLBEGINQUERYPROC __glewBeginQuery;
extern __declspec(dllimport) PFNGLBINDBUFFERPROC __glewBindBuffer;
extern __declspec(dllimport) PFNGLBUFFERDATAPROC __glewBufferData;
extern __declspec(dllimport) PFNGLBUFFERSUBDATAPROC __glewBufferSubData;
extern __declspec(dllimport) PFNGLDELETEBUFFERSPROC __glewDeleteBuffers;
extern __declspec(dllimport) PFNGLDELETEQUERIESPROC __glewDeleteQueries;
extern __declspec(dllimport) PFNGLENDQUERYPROC __glewEndQuery;
extern __declspec(dllimport) PFNGLGENBUFFERSPROC __glewGenBuffers;
extern __declspec(dllimport) PFNGLGENQUERIESPROC __glewGenQueries;
extern __declspec(dllimport) PFNGLGETBUFFERPARAMETERIVPROC __glewGetBufferParameteriv;
extern __declspec(dllimport) PFNGLGETBUFFERPOINTERVPROC __glewGetBufferPointerv;
extern __declspec(dllimport) PFNGLGETBUFFERSUBDATAPROC __glewGetBufferSubData;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTIVPROC __glewGetQueryObjectiv;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUIVPROC __glewGetQueryObjectuiv;
extern __declspec(dllimport) PFNGLGETQUERYIVPROC __glewGetQueryiv;
extern __declspec(dllimport) PFNGLISBUFFERPROC __glewIsBuffer;
extern __declspec(dllimport) PFNGLISQUERYPROC __glewIsQuery;
extern __declspec(dllimport) PFNGLMAPBUFFERPROC __glewMapBuffer;
extern __declspec(dllimport) PFNGLUNMAPBUFFERPROC __glewUnmapBuffer;

extern __declspec(dllimport) PFNGLATTACHSHADERPROC __glewAttachShader;
extern __declspec(dllimport) PFNGLBINDATTRIBLOCATIONPROC __glewBindAttribLocation;
extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEPROC __glewBlendEquationSeparate;
extern __declspec(dllimport) PFNGLCOMPILESHADERPROC __glewCompileShader;
extern __declspec(dllimport) PFNGLCREATEPROGRAMPROC __glewCreateProgram;
extern __declspec(dllimport) PFNGLCREATESHADERPROC __glewCreateShader;
extern __declspec(dllimport) PFNGLDELETEPROGRAMPROC __glewDeleteProgram;
extern __declspec(dllimport) PFNGLDELETESHADERPROC __glewDeleteShader;
extern __declspec(dllimport) PFNGLDETACHSHADERPROC __glewDetachShader;
extern __declspec(dllimport) PFNGLDISABLEVERTEXATTRIBARRAYPROC __glewDisableVertexAttribArray;
extern __declspec(dllimport) PFNGLDRAWBUFFERSPROC __glewDrawBuffers;
extern __declspec(dllimport) PFNGLENABLEVERTEXATTRIBARRAYPROC __glewEnableVertexAttribArray;
extern __declspec(dllimport) PFNGLGETACTIVEATTRIBPROC __glewGetActiveAttrib;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMPROC __glewGetActiveUniform;
extern __declspec(dllimport) PFNGLGETATTACHEDSHADERSPROC __glewGetAttachedShaders;
extern __declspec(dllimport) PFNGLGETATTRIBLOCATIONPROC __glewGetAttribLocation;
extern __declspec(dllimport) PFNGLGETPROGRAMINFOLOGPROC __glewGetProgramInfoLog;
extern __declspec(dllimport) PFNGLGETPROGRAMIVPROC __glewGetProgramiv;
extern __declspec(dllimport) PFNGLGETSHADERINFOLOGPROC __glewGetShaderInfoLog;
extern __declspec(dllimport) PFNGLGETSHADERSOURCEPROC __glewGetShaderSource;
extern __declspec(dllimport) PFNGLGETSHADERIVPROC __glewGetShaderiv;
extern __declspec(dllimport) PFNGLGETUNIFORMLOCATIONPROC __glewGetUniformLocation;
extern __declspec(dllimport) PFNGLGETUNIFORMFVPROC __glewGetUniformfv;
extern __declspec(dllimport) PFNGLGETUNIFORMIVPROC __glewGetUniformiv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBPOINTERVPROC __glewGetVertexAttribPointerv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBDVPROC __glewGetVertexAttribdv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBFVPROC __glewGetVertexAttribfv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIVPROC __glewGetVertexAttribiv;
extern __declspec(dllimport) PFNGLISPROGRAMPROC __glewIsProgram;
extern __declspec(dllimport) PFNGLISSHADERPROC __glewIsShader;
extern __declspec(dllimport) PFNGLLINKPROGRAMPROC __glewLinkProgram;
extern __declspec(dllimport) PFNGLSHADERSOURCEPROC __glewShaderSource;
extern __declspec(dllimport) PFNGLSTENCILFUNCSEPARATEPROC __glewStencilFuncSeparate;
extern __declspec(dllimport) PFNGLSTENCILMASKSEPARATEPROC __glewStencilMaskSeparate;
extern __declspec(dllimport) PFNGLSTENCILOPSEPARATEPROC __glewStencilOpSeparate;
extern __declspec(dllimport) PFNGLUNIFORM1FPROC __glewUniform1f;
extern __declspec(dllimport) PFNGLUNIFORM1FVPROC __glewUniform1fv;
extern __declspec(dllimport) PFNGLUNIFORM1IPROC __glewUniform1i;
extern __declspec(dllimport) PFNGLUNIFORM1IVPROC __glewUniform1iv;
extern __declspec(dllimport) PFNGLUNIFORM2FPROC __glewUniform2f;
extern __declspec(dllimport) PFNGLUNIFORM2FVPROC __glewUniform2fv;
extern __declspec(dllimport) PFNGLUNIFORM2IPROC __glewUniform2i;
extern __declspec(dllimport) PFNGLUNIFORM2IVPROC __glewUniform2iv;
extern __declspec(dllimport) PFNGLUNIFORM3FPROC __glewUniform3f;
extern __declspec(dllimport) PFNGLUNIFORM3FVPROC __glewUniform3fv;
extern __declspec(dllimport) PFNGLUNIFORM3IPROC __glewUniform3i;
extern __declspec(dllimport) PFNGLUNIFORM3IVPROC __glewUniform3iv;
extern __declspec(dllimport) PFNGLUNIFORM4FPROC __glewUniform4f;
extern __declspec(dllimport) PFNGLUNIFORM4FVPROC __glewUniform4fv;
extern __declspec(dllimport) PFNGLUNIFORM4IPROC __glewUniform4i;
extern __declspec(dllimport) PFNGLUNIFORM4IVPROC __glewUniform4iv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2FVPROC __glewUniformMatrix2fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3FVPROC __glewUniformMatrix3fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4FVPROC __glewUniformMatrix4fv;
extern __declspec(dllimport) PFNGLUSEPROGRAMPROC __glewUseProgram;
extern __declspec(dllimport) PFNGLVALIDATEPROGRAMPROC __glewValidateProgram;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DPROC __glewVertexAttrib1d;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DVPROC __glewVertexAttrib1dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FPROC __glewVertexAttrib1f;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FVPROC __glewVertexAttrib1fv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SPROC __glewVertexAttrib1s;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SVPROC __glewVertexAttrib1sv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DPROC __glewVertexAttrib2d;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DVPROC __glewVertexAttrib2dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FPROC __glewVertexAttrib2f;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FVPROC __glewVertexAttrib2fv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SPROC __glewVertexAttrib2s;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SVPROC __glewVertexAttrib2sv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DPROC __glewVertexAttrib3d;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DVPROC __glewVertexAttrib3dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FPROC __glewVertexAttrib3f;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FVPROC __glewVertexAttrib3fv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SPROC __glewVertexAttrib3s;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SVPROC __glewVertexAttrib3sv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NBVPROC __glewVertexAttrib4Nbv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NIVPROC __glewVertexAttrib4Niv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NSVPROC __glewVertexAttrib4Nsv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUBPROC __glewVertexAttrib4Nub;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUBVPROC __glewVertexAttrib4Nubv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUIVPROC __glewVertexAttrib4Nuiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUSVPROC __glewVertexAttrib4Nusv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4BVPROC __glewVertexAttrib4bv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DPROC __glewVertexAttrib4d;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DVPROC __glewVertexAttrib4dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FPROC __glewVertexAttrib4f;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FVPROC __glewVertexAttrib4fv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4IVPROC __glewVertexAttrib4iv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SPROC __glewVertexAttrib4s;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SVPROC __glewVertexAttrib4sv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UBVPROC __glewVertexAttrib4ubv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UIVPROC __glewVertexAttrib4uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4USVPROC __glewVertexAttrib4usv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBPOINTERPROC __glewVertexAttribPointer;

extern __declspec(dllimport) PFNGLUNIFORMMATRIX2X3FVPROC __glewUniformMatrix2x3fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2X4FVPROC __glewUniformMatrix2x4fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3X2FVPROC __glewUniformMatrix3x2fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3X4FVPROC __glewUniformMatrix3x4fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4X2FVPROC __glewUniformMatrix4x2fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4X3FVPROC __glewUniformMatrix4x3fv;

extern __declspec(dllimport) PFNGLBEGINCONDITIONALRENDERPROC __glewBeginConditionalRender;
extern __declspec(dllimport) PFNGLBEGINTRANSFORMFEEDBACKPROC __glewBeginTransformFeedback;
extern __declspec(dllimport) PFNGLBINDFRAGDATALOCATIONPROC __glewBindFragDataLocation;
extern __declspec(dllimport) PFNGLCLAMPCOLORPROC __glewClampColor;
extern __declspec(dllimport) PFNGLCLEARBUFFERFIPROC __glewClearBufferfi;
extern __declspec(dllimport) PFNGLCLEARBUFFERFVPROC __glewClearBufferfv;
extern __declspec(dllimport) PFNGLCLEARBUFFERIVPROC __glewClearBufferiv;
extern __declspec(dllimport) PFNGLCLEARBUFFERUIVPROC __glewClearBufferuiv;
extern __declspec(dllimport) PFNGLCOLORMASKIPROC __glewColorMaski;
extern __declspec(dllimport) PFNGLDISABLEIPROC __glewDisablei;
extern __declspec(dllimport) PFNGLENABLEIPROC __glewEnablei;
extern __declspec(dllimport) PFNGLENDCONDITIONALRENDERPROC __glewEndConditionalRender;
extern __declspec(dllimport) PFNGLENDTRANSFORMFEEDBACKPROC __glewEndTransformFeedback;
extern __declspec(dllimport) PFNGLGETBOOLEANI_VPROC __glewGetBooleani_v;
extern __declspec(dllimport) PFNGLGETFRAGDATALOCATIONPROC __glewGetFragDataLocation;
extern __declspec(dllimport) PFNGLGETSTRINGIPROC __glewGetStringi;
extern __declspec(dllimport) PFNGLGETTEXPARAMETERIIVPROC __glewGetTexParameterIiv;
extern __declspec(dllimport) PFNGLGETTEXPARAMETERIUIVPROC __glewGetTexParameterIuiv;
extern __declspec(dllimport) PFNGLGETTRANSFORMFEEDBACKVARYINGPROC __glewGetTransformFeedbackVarying;
extern __declspec(dllimport) PFNGLGETUNIFORMUIVPROC __glewGetUniformuiv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIIVPROC __glewGetVertexAttribIiv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIUIVPROC __glewGetVertexAttribIuiv;
extern __declspec(dllimport) PFNGLISENABLEDIPROC __glewIsEnabledi;
extern __declspec(dllimport) PFNGLTEXPARAMETERIIVPROC __glewTexParameterIiv;
extern __declspec(dllimport) PFNGLTEXPARAMETERIUIVPROC __glewTexParameterIuiv;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKVARYINGSPROC __glewTransformFeedbackVaryings;
extern __declspec(dllimport) PFNGLUNIFORM1UIPROC __glewUniform1ui;
extern __declspec(dllimport) PFNGLUNIFORM1UIVPROC __glewUniform1uiv;
extern __declspec(dllimport) PFNGLUNIFORM2UIPROC __glewUniform2ui;
extern __declspec(dllimport) PFNGLUNIFORM2UIVPROC __glewUniform2uiv;
extern __declspec(dllimport) PFNGLUNIFORM3UIPROC __glewUniform3ui;
extern __declspec(dllimport) PFNGLUNIFORM3UIVPROC __glewUniform3uiv;
extern __declspec(dllimport) PFNGLUNIFORM4UIPROC __glewUniform4ui;
extern __declspec(dllimport) PFNGLUNIFORM4UIVPROC __glewUniform4uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1IPROC __glewVertexAttribI1i;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1IVPROC __glewVertexAttribI1iv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1UIPROC __glewVertexAttribI1ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1UIVPROC __glewVertexAttribI1uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2IPROC __glewVertexAttribI2i;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2IVPROC __glewVertexAttribI2iv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2UIPROC __glewVertexAttribI2ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2UIVPROC __glewVertexAttribI2uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3IPROC __glewVertexAttribI3i;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3IVPROC __glewVertexAttribI3iv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3UIPROC __glewVertexAttribI3ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3UIVPROC __glewVertexAttribI3uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4BVPROC __glewVertexAttribI4bv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4IPROC __glewVertexAttribI4i;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4IVPROC __glewVertexAttribI4iv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4SVPROC __glewVertexAttribI4sv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UBVPROC __glewVertexAttribI4ubv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UIPROC __glewVertexAttribI4ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UIVPROC __glewVertexAttribI4uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4USVPROC __glewVertexAttribI4usv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBIPOINTERPROC __glewVertexAttribIPointer;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDPROC __glewDrawArraysInstanced;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDPROC __glewDrawElementsInstanced;
extern __declspec(dllimport) PFNGLPRIMITIVERESTARTINDEXPROC __glewPrimitiveRestartIndex;
extern __declspec(dllimport) PFNGLTEXBUFFERPROC __glewTexBuffer;

extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREPROC __glewFramebufferTexture;
extern __declspec(dllimport) PFNGLGETBUFFERPARAMETERI64VPROC __glewGetBufferParameteri64v;
extern __declspec(dllimport) PFNGLGETINTEGER64I_VPROC __glewGetInteger64i_v;

extern __declspec(dllimport) PFNGLVERTEXATTRIBDIVISORPROC __glewVertexAttribDivisor;

extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEIPROC __glewBlendEquationSeparatei;
extern __declspec(dllimport) PFNGLBLENDEQUATIONIPROC __glewBlendEquationi;
extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEIPROC __glewBlendFuncSeparatei;
extern __declspec(dllimport) PFNGLBLENDFUNCIPROC __glewBlendFunci;
extern __declspec(dllimport) PFNGLMINSAMPLESHADINGPROC __glewMinSampleShading;

extern __declspec(dllimport) PFNGLTBUFFERMASK3DFXPROC __glewTbufferMask3DFX;

extern __declspec(dllimport) PFNGLDEBUGMESSAGECALLBACKAMDPROC __glewDebugMessageCallbackAMD;
extern __declspec(dllimport) PFNGLDEBUGMESSAGEENABLEAMDPROC __glewDebugMessageEnableAMD;
extern __declspec(dllimport) PFNGLDEBUGMESSAGEINSERTAMDPROC __glewDebugMessageInsertAMD;
extern __declspec(dllimport) PFNGLGETDEBUGMESSAGELOGAMDPROC __glewGetDebugMessageLogAMD;

extern __declspec(dllimport) PFNGLBLENDEQUATIONINDEXEDAMDPROC __glewBlendEquationIndexedAMD;
extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC __glewBlendEquationSeparateIndexedAMD;
extern __declspec(dllimport) PFNGLBLENDFUNCINDEXEDAMDPROC __glewBlendFuncIndexedAMD;
extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC __glewBlendFuncSeparateIndexedAMD;

extern __declspec(dllimport) PFNGLVERTEXATTRIBPARAMETERIAMDPROC __glewVertexAttribParameteriAMD;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC __glewMultiDrawArraysIndirectAMD;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC __glewMultiDrawElementsIndirectAMD;

extern __declspec(dllimport) PFNGLDELETENAMESAMDPROC __glewDeleteNamesAMD;
extern __declspec(dllimport) PFNGLGENNAMESAMDPROC __glewGenNamesAMD;
extern __declspec(dllimport) PFNGLISNAMEAMDPROC __glewIsNameAMD;

extern __declspec(dllimport) PFNGLBEGINPERFMONITORAMDPROC __glewBeginPerfMonitorAMD;
extern __declspec(dllimport) PFNGLDELETEPERFMONITORSAMDPROC __glewDeletePerfMonitorsAMD;
extern __declspec(dllimport) PFNGLENDPERFMONITORAMDPROC __glewEndPerfMonitorAMD;
extern __declspec(dllimport) PFNGLGENPERFMONITORSAMDPROC __glewGenPerfMonitorsAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORCOUNTERDATAAMDPROC __glewGetPerfMonitorCounterDataAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORCOUNTERINFOAMDPROC __glewGetPerfMonitorCounterInfoAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC __glewGetPerfMonitorCounterStringAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORCOUNTERSAMDPROC __glewGetPerfMonitorCountersAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORGROUPSTRINGAMDPROC __glewGetPerfMonitorGroupStringAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORGROUPSAMDPROC __glewGetPerfMonitorGroupsAMD;
extern __declspec(dllimport) PFNGLSELECTPERFMONITORCOUNTERSAMDPROC __glewSelectPerfMonitorCountersAMD;

extern __declspec(dllimport) PFNGLSETMULTISAMPLEFVAMDPROC __glewSetMultisamplefvAMD;

extern __declspec(dllimport) PFNGLTEXSTORAGESPARSEAMDPROC __glewTexStorageSparseAMD;
extern __declspec(dllimport) PFNGLTEXTURESTORAGESPARSEAMDPROC __glewTextureStorageSparseAMD;

extern __declspec(dllimport) PFNGLSTENCILOPVALUEAMDPROC __glewStencilOpValueAMD;

extern __declspec(dllimport) PFNGLTESSELLATIONFACTORAMDPROC __glewTessellationFactorAMD;
extern __declspec(dllimport) PFNGLTESSELLATIONMODEAMDPROC __glewTessellationModeAMD;

extern __declspec(dllimport) PFNGLBLITFRAMEBUFFERANGLEPROC __glewBlitFramebufferANGLE;

extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC __glewRenderbufferStorageMultisampleANGLE;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDANGLEPROC __glewDrawArraysInstancedANGLE;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDANGLEPROC __glewDrawElementsInstancedANGLE;
extern __declspec(dllimport) PFNGLVERTEXATTRIBDIVISORANGLEPROC __glewVertexAttribDivisorANGLE;

extern __declspec(dllimport) PFNGLBEGINQUERYANGLEPROC __glewBeginQueryANGLE;
extern __declspec(dllimport) PFNGLDELETEQUERIESANGLEPROC __glewDeleteQueriesANGLE;
extern __declspec(dllimport) PFNGLENDQUERYANGLEPROC __glewEndQueryANGLE;
extern __declspec(dllimport) PFNGLGENQUERIESANGLEPROC __glewGenQueriesANGLE;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTI64VANGLEPROC __glewGetQueryObjecti64vANGLE;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTIVANGLEPROC __glewGetQueryObjectivANGLE;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUI64VANGLEPROC __glewGetQueryObjectui64vANGLE;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUIVANGLEPROC __glewGetQueryObjectuivANGLE;
extern __declspec(dllimport) PFNGLGETQUERYIVANGLEPROC __glewGetQueryivANGLE;
extern __declspec(dllimport) PFNGLISQUERYANGLEPROC __glewIsQueryANGLE;
extern __declspec(dllimport) PFNGLQUERYCOUNTERANGLEPROC __glewQueryCounterANGLE;

extern __declspec(dllimport) PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC __glewGetTranslatedShaderSourceANGLE;

extern __declspec(dllimport) PFNGLDRAWELEMENTARRAYAPPLEPROC __glewDrawElementArrayAPPLE;
extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC __glewDrawRangeElementArrayAPPLE;
extern __declspec(dllimport) PFNGLELEMENTPOINTERAPPLEPROC __glewElementPointerAPPLE;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC __glewMultiDrawElementArrayAPPLE;
extern __declspec(dllimport) PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC __glewMultiDrawRangeElementArrayAPPLE;

extern __declspec(dllimport) PFNGLDELETEFENCESAPPLEPROC __glewDeleteFencesAPPLE;
extern __declspec(dllimport) PFNGLFINISHFENCEAPPLEPROC __glewFinishFenceAPPLE;
extern __declspec(dllimport) PFNGLFINISHOBJECTAPPLEPROC __glewFinishObjectAPPLE;
extern __declspec(dllimport) PFNGLGENFENCESAPPLEPROC __glewGenFencesAPPLE;
extern __declspec(dllimport) PFNGLISFENCEAPPLEPROC __glewIsFenceAPPLE;
extern __declspec(dllimport) PFNGLSETFENCEAPPLEPROC __glewSetFenceAPPLE;
extern __declspec(dllimport) PFNGLTESTFENCEAPPLEPROC __glewTestFenceAPPLE;
extern __declspec(dllimport) PFNGLTESTOBJECTAPPLEPROC __glewTestObjectAPPLE;

extern __declspec(dllimport) PFNGLBUFFERPARAMETERIAPPLEPROC __glewBufferParameteriAPPLE;
extern __declspec(dllimport) PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC __glewFlushMappedBufferRangeAPPLE;

extern __declspec(dllimport) PFNGLGETOBJECTPARAMETERIVAPPLEPROC __glewGetObjectParameterivAPPLE;
extern __declspec(dllimport) PFNGLOBJECTPURGEABLEAPPLEPROC __glewObjectPurgeableAPPLE;
extern __declspec(dllimport) PFNGLOBJECTUNPURGEABLEAPPLEPROC __glewObjectUnpurgeableAPPLE;

extern __declspec(dllimport) PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC __glewGetTexParameterPointervAPPLE;
extern __declspec(dllimport) PFNGLTEXTURERANGEAPPLEPROC __glewTextureRangeAPPLE;

extern __declspec(dllimport) PFNGLBINDVERTEXARRAYAPPLEPROC __glewBindVertexArrayAPPLE;
extern __declspec(dllimport) PFNGLDELETEVERTEXARRAYSAPPLEPROC __glewDeleteVertexArraysAPPLE;
extern __declspec(dllimport) PFNGLGENVERTEXARRAYSAPPLEPROC __glewGenVertexArraysAPPLE;
extern __declspec(dllimport) PFNGLISVERTEXARRAYAPPLEPROC __glewIsVertexArrayAPPLE;

extern __declspec(dllimport) PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC __glewFlushVertexArrayRangeAPPLE;
extern __declspec(dllimport) PFNGLVERTEXARRAYPARAMETERIAPPLEPROC __glewVertexArrayParameteriAPPLE;
extern __declspec(dllimport) PFNGLVERTEXARRAYRANGEAPPLEPROC __glewVertexArrayRangeAPPLE;

extern __declspec(dllimport) PFNGLDISABLEVERTEXATTRIBAPPLEPROC __glewDisableVertexAttribAPPLE;
extern __declspec(dllimport) PFNGLENABLEVERTEXATTRIBAPPLEPROC __glewEnableVertexAttribAPPLE;
extern __declspec(dllimport) PFNGLISVERTEXATTRIBENABLEDAPPLEPROC __glewIsVertexAttribEnabledAPPLE;
extern __declspec(dllimport) PFNGLMAPVERTEXATTRIB1DAPPLEPROC __glewMapVertexAttrib1dAPPLE;
extern __declspec(dllimport) PFNGLMAPVERTEXATTRIB1FAPPLEPROC __glewMapVertexAttrib1fAPPLE;
extern __declspec(dllimport) PFNGLMAPVERTEXATTRIB2DAPPLEPROC __glewMapVertexAttrib2dAPPLE;
extern __declspec(dllimport) PFNGLMAPVERTEXATTRIB2FAPPLEPROC __glewMapVertexAttrib2fAPPLE;

extern __declspec(dllimport) PFNGLCLEARDEPTHFPROC __glewClearDepthf;
extern __declspec(dllimport) PFNGLDEPTHRANGEFPROC __glewDepthRangef;
extern __declspec(dllimport) PFNGLGETSHADERPRECISIONFORMATPROC __glewGetShaderPrecisionFormat;
extern __declspec(dllimport) PFNGLRELEASESHADERCOMPILERPROC __glewReleaseShaderCompiler;
extern __declspec(dllimport) PFNGLSHADERBINARYPROC __glewShaderBinary;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC __glewDrawArraysInstancedBaseInstance;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC __glewDrawElementsInstancedBaseInstance;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC __glewDrawElementsInstancedBaseVertexBaseInstance;

extern __declspec(dllimport) PFNGLGETIMAGEHANDLEARBPROC __glewGetImageHandleARB;
extern __declspec(dllimport) PFNGLGETTEXTUREHANDLEARBPROC __glewGetTextureHandleARB;
extern __declspec(dllimport) PFNGLGETTEXTURESAMPLERHANDLEARBPROC __glewGetTextureSamplerHandleARB;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBLUI64VARBPROC __glewGetVertexAttribLui64vARB;
extern __declspec(dllimport) PFNGLISIMAGEHANDLERESIDENTARBPROC __glewIsImageHandleResidentARB;
extern __declspec(dllimport) PFNGLISTEXTUREHANDLERESIDENTARBPROC __glewIsTextureHandleResidentARB;
extern __declspec(dllimport) PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC __glewMakeImageHandleNonResidentARB;
extern __declspec(dllimport) PFNGLMAKEIMAGEHANDLERESIDENTARBPROC __glewMakeImageHandleResidentARB;
extern __declspec(dllimport) PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC __glewMakeTextureHandleNonResidentARB;
extern __declspec(dllimport) PFNGLMAKETEXTUREHANDLERESIDENTARBPROC __glewMakeTextureHandleResidentARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC __glewProgramUniformHandleui64ARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC __glewProgramUniformHandleui64vARB;
extern __declspec(dllimport) PFNGLUNIFORMHANDLEUI64ARBPROC __glewUniformHandleui64ARB;
extern __declspec(dllimport) PFNGLUNIFORMHANDLEUI64VARBPROC __glewUniformHandleui64vARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1UI64ARBPROC __glewVertexAttribL1ui64ARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1UI64VARBPROC __glewVertexAttribL1ui64vARB;

extern __declspec(dllimport) PFNGLBINDFRAGDATALOCATIONINDEXEDPROC __glewBindFragDataLocationIndexed;
extern __declspec(dllimport) PFNGLGETFRAGDATAINDEXPROC __glewGetFragDataIndex;

extern __declspec(dllimport) PFNGLBUFFERSTORAGEPROC __glewBufferStorage;
extern __declspec(dllimport) PFNGLNAMEDBUFFERSTORAGEEXTPROC __glewNamedBufferStorageEXT;

extern __declspec(dllimport) PFNGLCREATESYNCFROMCLEVENTARBPROC __glewCreateSyncFromCLeventARB;

extern __declspec(dllimport) PFNGLCLEARBUFFERDATAPROC __glewClearBufferData;
extern __declspec(dllimport) PFNGLCLEARBUFFERSUBDATAPROC __glewClearBufferSubData;
extern __declspec(dllimport) PFNGLCLEARNAMEDBUFFERDATAEXTPROC __glewClearNamedBufferDataEXT;
extern __declspec(dllimport) PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC __glewClearNamedBufferSubDataEXT;

extern __declspec(dllimport) PFNGLCLEARTEXIMAGEPROC __glewClearTexImage;
extern __declspec(dllimport) PFNGLCLEARTEXSUBIMAGEPROC __glewClearTexSubImage;

extern __declspec(dllimport) PFNGLCLAMPCOLORARBPROC __glewClampColorARB;

extern __declspec(dllimport) PFNGLDISPATCHCOMPUTEPROC __glewDispatchCompute;
extern __declspec(dllimport) PFNGLDISPATCHCOMPUTEINDIRECTPROC __glewDispatchComputeIndirect;

extern __declspec(dllimport) PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC __glewDispatchComputeGroupSizeARB;

extern __declspec(dllimport) PFNGLCOPYBUFFERSUBDATAPROC __glewCopyBufferSubData;

extern __declspec(dllimport) PFNGLCOPYIMAGESUBDATAPROC __glewCopyImageSubData;

extern __declspec(dllimport) PFNGLDEBUGMESSAGECALLBACKARBPROC __glewDebugMessageCallbackARB;
extern __declspec(dllimport) PFNGLDEBUGMESSAGECONTROLARBPROC __glewDebugMessageControlARB;
extern __declspec(dllimport) PFNGLDEBUGMESSAGEINSERTARBPROC __glewDebugMessageInsertARB;
extern __declspec(dllimport) PFNGLGETDEBUGMESSAGELOGARBPROC __glewGetDebugMessageLogARB;

extern __declspec(dllimport) PFNGLDRAWBUFFERSARBPROC __glewDrawBuffersARB;

extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEIARBPROC __glewBlendEquationSeparateiARB;
extern __declspec(dllimport) PFNGLBLENDEQUATIONIARBPROC __glewBlendEquationiARB;
extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEIARBPROC __glewBlendFuncSeparateiARB;
extern __declspec(dllimport) PFNGLBLENDFUNCIARBPROC __glewBlendFunciARB;

extern __declspec(dllimport) PFNGLDRAWELEMENTSBASEVERTEXPROC __glewDrawElementsBaseVertex;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC __glewDrawElementsInstancedBaseVertex;
extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC __glewDrawRangeElementsBaseVertex;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC __glewMultiDrawElementsBaseVertex;

extern __declspec(dllimport) PFNGLDRAWARRAYSINDIRECTPROC __glewDrawArraysIndirect;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINDIRECTPROC __glewDrawElementsIndirect;

extern __declspec(dllimport) PFNGLFRAMEBUFFERPARAMETERIPROC __glewFramebufferParameteri;
extern __declspec(dllimport) PFNGLGETFRAMEBUFFERPARAMETERIVPROC __glewGetFramebufferParameteriv;
extern __declspec(dllimport) PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC __glewGetNamedFramebufferParameterivEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC __glewNamedFramebufferParameteriEXT;

extern __declspec(dllimport) PFNGLBINDFRAMEBUFFERPROC __glewBindFramebuffer;
extern __declspec(dllimport) PFNGLBINDRENDERBUFFERPROC __glewBindRenderbuffer;
extern __declspec(dllimport) PFNGLBLITFRAMEBUFFERPROC __glewBlitFramebuffer;
extern __declspec(dllimport) PFNGLCHECKFRAMEBUFFERSTATUSPROC __glewCheckFramebufferStatus;
extern __declspec(dllimport) PFNGLDELETEFRAMEBUFFERSPROC __glewDeleteFramebuffers;
extern __declspec(dllimport) PFNGLDELETERENDERBUFFERSPROC __glewDeleteRenderbuffers;
extern __declspec(dllimport) PFNGLFRAMEBUFFERRENDERBUFFERPROC __glewFramebufferRenderbuffer;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE1DPROC __glewFramebufferTexture1D;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE2DPROC __glewFramebufferTexture2D;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE3DPROC __glewFramebufferTexture3D;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURELAYERPROC __glewFramebufferTextureLayer;
extern __declspec(dllimport) PFNGLGENFRAMEBUFFERSPROC __glewGenFramebuffers;
extern __declspec(dllimport) PFNGLGENRENDERBUFFERSPROC __glewGenRenderbuffers;
extern __declspec(dllimport) PFNGLGENERATEMIPMAPPROC __glewGenerateMipmap;
extern __declspec(dllimport) PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetFramebufferAttachmentParameteriv;
extern __declspec(dllimport) PFNGLGETRENDERBUFFERPARAMETERIVPROC __glewGetRenderbufferParameteriv;
extern __declspec(dllimport) PFNGLISFRAMEBUFFERPROC __glewIsFramebuffer;
extern __declspec(dllimport) PFNGLISRENDERBUFFERPROC __glewIsRenderbuffer;
extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEPROC __glewRenderbufferStorage;
extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewRenderbufferStorageMultisample;

extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREARBPROC __glewFramebufferTextureARB;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREFACEARBPROC __glewFramebufferTextureFaceARB;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURELAYERARBPROC __glewFramebufferTextureLayerARB;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETERIARBPROC __glewProgramParameteriARB;

extern __declspec(dllimport) PFNGLGETPROGRAMBINARYPROC __glewGetProgramBinary;
extern __declspec(dllimport) PFNGLPROGRAMBINARYPROC __glewProgramBinary;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETERIPROC __glewProgramParameteri;

extern __declspec(dllimport) PFNGLGETUNIFORMDVPROC __glewGetUniformdv;
extern __declspec(dllimport) PFNGLUNIFORM1DPROC __glewUniform1d;
extern __declspec(dllimport) PFNGLUNIFORM1DVPROC __glewUniform1dv;
extern __declspec(dllimport) PFNGLUNIFORM2DPROC __glewUniform2d;
extern __declspec(dllimport) PFNGLUNIFORM2DVPROC __glewUniform2dv;
extern __declspec(dllimport) PFNGLUNIFORM3DPROC __glewUniform3d;
extern __declspec(dllimport) PFNGLUNIFORM3DVPROC __glewUniform3dv;
extern __declspec(dllimport) PFNGLUNIFORM4DPROC __glewUniform4d;
extern __declspec(dllimport) PFNGLUNIFORM4DVPROC __glewUniform4dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2DVPROC __glewUniformMatrix2dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2X3DVPROC __glewUniformMatrix2x3dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2X4DVPROC __glewUniformMatrix2x4dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3DVPROC __glewUniformMatrix3dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3X2DVPROC __glewUniformMatrix3x2dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3X4DVPROC __glewUniformMatrix3x4dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4DVPROC __glewUniformMatrix4dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4X2DVPROC __glewUniformMatrix4x2dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4X3DVPROC __glewUniformMatrix4x3dv;

extern __declspec(dllimport) PFNGLCOLORSUBTABLEPROC __glewColorSubTable;
extern __declspec(dllimport) PFNGLCOLORTABLEPROC __glewColorTable;
extern __declspec(dllimport) PFNGLCOLORTABLEPARAMETERFVPROC __glewColorTableParameterfv;
extern __declspec(dllimport) PFNGLCOLORTABLEPARAMETERIVPROC __glewColorTableParameteriv;
extern __declspec(dllimport) PFNGLCONVOLUTIONFILTER1DPROC __glewConvolutionFilter1D;
extern __declspec(dllimport) PFNGLCONVOLUTIONFILTER2DPROC __glewConvolutionFilter2D;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERFPROC __glewConvolutionParameterf;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERFVPROC __glewConvolutionParameterfv;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERIPROC __glewConvolutionParameteri;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERIVPROC __glewConvolutionParameteriv;
extern __declspec(dllimport) PFNGLCOPYCOLORSUBTABLEPROC __glewCopyColorSubTable;
extern __declspec(dllimport) PFNGLCOPYCOLORTABLEPROC __glewCopyColorTable;
extern __declspec(dllimport) PFNGLCOPYCONVOLUTIONFILTER1DPROC __glewCopyConvolutionFilter1D;
extern __declspec(dllimport) PFNGLCOPYCONVOLUTIONFILTER2DPROC __glewCopyConvolutionFilter2D;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPROC __glewGetColorTable;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERFVPROC __glewGetColorTableParameterfv;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERIVPROC __glewGetColorTableParameteriv;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONFILTERPROC __glewGetConvolutionFilter;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONPARAMETERFVPROC __glewGetConvolutionParameterfv;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONPARAMETERIVPROC __glewGetConvolutionParameteriv;
extern __declspec(dllimport) PFNGLGETHISTOGRAMPROC __glewGetHistogram;
extern __declspec(dllimport) PFNGLGETHISTOGRAMPARAMETERFVPROC __glewGetHistogramParameterfv;
extern __declspec(dllimport) PFNGLGETHISTOGRAMPARAMETERIVPROC __glewGetHistogramParameteriv;
extern __declspec(dllimport) PFNGLGETMINMAXPROC __glewGetMinmax;
extern __declspec(dllimport) PFNGLGETMINMAXPARAMETERFVPROC __glewGetMinmaxParameterfv;
extern __declspec(dllimport) PFNGLGETMINMAXPARAMETERIVPROC __glewGetMinmaxParameteriv;
extern __declspec(dllimport) PFNGLGETSEPARABLEFILTERPROC __glewGetSeparableFilter;
extern __declspec(dllimport) PFNGLHISTOGRAMPROC __glewHistogram;
extern __declspec(dllimport) PFNGLMINMAXPROC __glewMinmax;
extern __declspec(dllimport) PFNGLRESETHISTOGRAMPROC __glewResetHistogram;
extern __declspec(dllimport) PFNGLRESETMINMAXPROC __glewResetMinmax;
extern __declspec(dllimport) PFNGLSEPARABLEFILTER2DPROC __glewSeparableFilter2D;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC __glewMultiDrawArraysIndirectCountARB;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC __glewMultiDrawElementsIndirectCountARB;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDARBPROC __glewDrawArraysInstancedARB;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDARBPROC __glewDrawElementsInstancedARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIBDIVISORARBPROC __glewVertexAttribDivisorARB;

extern __declspec(dllimport) PFNGLGETINTERNALFORMATIVPROC __glewGetInternalformativ;

extern __declspec(dllimport) PFNGLGETINTERNALFORMATI64VPROC __glewGetInternalformati64v;

extern __declspec(dllimport) PFNGLINVALIDATEBUFFERDATAPROC __glewInvalidateBufferData;
extern __declspec(dllimport) PFNGLINVALIDATEBUFFERSUBDATAPROC __glewInvalidateBufferSubData;
extern __declspec(dllimport) PFNGLINVALIDATEFRAMEBUFFERPROC __glewInvalidateFramebuffer;
extern __declspec(dllimport) PFNGLINVALIDATESUBFRAMEBUFFERPROC __glewInvalidateSubFramebuffer;
extern __declspec(dllimport) PFNGLINVALIDATETEXIMAGEPROC __glewInvalidateTexImage;
extern __declspec(dllimport) PFNGLINVALIDATETEXSUBIMAGEPROC __glewInvalidateTexSubImage;

extern __declspec(dllimport) PFNGLFLUSHMAPPEDBUFFERRANGEPROC __glewFlushMappedBufferRange;
extern __declspec(dllimport) PFNGLMAPBUFFERRANGEPROC __glewMapBufferRange;

extern __declspec(dllimport) PFNGLCURRENTPALETTEMATRIXARBPROC __glewCurrentPaletteMatrixARB;
extern __declspec(dllimport) PFNGLMATRIXINDEXPOINTERARBPROC __glewMatrixIndexPointerARB;
extern __declspec(dllimport) PFNGLMATRIXINDEXUBVARBPROC __glewMatrixIndexubvARB;
extern __declspec(dllimport) PFNGLMATRIXINDEXUIVARBPROC __glewMatrixIndexuivARB;
extern __declspec(dllimport) PFNGLMATRIXINDEXUSVARBPROC __glewMatrixIndexusvARB;

extern __declspec(dllimport) PFNGLBINDBUFFERSBASEPROC __glewBindBuffersBase;
extern __declspec(dllimport) PFNGLBINDBUFFERSRANGEPROC __glewBindBuffersRange;
extern __declspec(dllimport) PFNGLBINDIMAGETEXTURESPROC __glewBindImageTextures;
extern __declspec(dllimport) PFNGLBINDSAMPLERSPROC __glewBindSamplers;
extern __declspec(dllimport) PFNGLBINDTEXTURESPROC __glewBindTextures;
extern __declspec(dllimport) PFNGLBINDVERTEXBUFFERSPROC __glewBindVertexBuffers;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTPROC __glewMultiDrawArraysIndirect;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTPROC __glewMultiDrawElementsIndirect;

extern __declspec(dllimport) PFNGLSAMPLECOVERAGEARBPROC __glewSampleCoverageARB;

extern __declspec(dllimport) PFNGLACTIVETEXTUREARBPROC __glewActiveTextureARB;
extern __declspec(dllimport) PFNGLCLIENTACTIVETEXTUREARBPROC __glewClientActiveTextureARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1DARBPROC __glewMultiTexCoord1dARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1DVARBPROC __glewMultiTexCoord1dvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1FARBPROC __glewMultiTexCoord1fARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1FVARBPROC __glewMultiTexCoord1fvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1IARBPROC __glewMultiTexCoord1iARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1IVARBPROC __glewMultiTexCoord1ivARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1SARBPROC __glewMultiTexCoord1sARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1SVARBPROC __glewMultiTexCoord1svARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2DARBPROC __glewMultiTexCoord2dARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2DVARBPROC __glewMultiTexCoord2dvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2FARBPROC __glewMultiTexCoord2fARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2FVARBPROC __glewMultiTexCoord2fvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2IARBPROC __glewMultiTexCoord2iARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2IVARBPROC __glewMultiTexCoord2ivARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2SARBPROC __glewMultiTexCoord2sARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2SVARBPROC __glewMultiTexCoord2svARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3DARBPROC __glewMultiTexCoord3dARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3DVARBPROC __glewMultiTexCoord3dvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3FARBPROC __glewMultiTexCoord3fARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3FVARBPROC __glewMultiTexCoord3fvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3IARBPROC __glewMultiTexCoord3iARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3IVARBPROC __glewMultiTexCoord3ivARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3SARBPROC __glewMultiTexCoord3sARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3SVARBPROC __glewMultiTexCoord3svARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4DARBPROC __glewMultiTexCoord4dARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4DVARBPROC __glewMultiTexCoord4dvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4FARBPROC __glewMultiTexCoord4fARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4FVARBPROC __glewMultiTexCoord4fvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4IARBPROC __glewMultiTexCoord4iARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4IVARBPROC __glewMultiTexCoord4ivARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4SARBPROC __glewMultiTexCoord4sARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4SVARBPROC __glewMultiTexCoord4svARB;

extern __declspec(dllimport) PFNGLBEGINQUERYARBPROC __glewBeginQueryARB;
extern __declspec(dllimport) PFNGLDELETEQUERIESARBPROC __glewDeleteQueriesARB;
extern __declspec(dllimport) PFNGLENDQUERYARBPROC __glewEndQueryARB;
extern __declspec(dllimport) PFNGLGENQUERIESARBPROC __glewGenQueriesARB;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTIVARBPROC __glewGetQueryObjectivARB;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUIVARBPROC __glewGetQueryObjectuivARB;
extern __declspec(dllimport) PFNGLGETQUERYIVARBPROC __glewGetQueryivARB;
extern __declspec(dllimport) PFNGLISQUERYARBPROC __glewIsQueryARB;

extern __declspec(dllimport) PFNGLPOINTPARAMETERFARBPROC __glewPointParameterfARB;
extern __declspec(dllimport) PFNGLPOINTPARAMETERFVARBPROC __glewPointParameterfvARB;

extern __declspec(dllimport) PFNGLGETPROGRAMINTERFACEIVPROC __glewGetProgramInterfaceiv;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCEINDEXPROC __glewGetProgramResourceIndex;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCELOCATIONPROC __glewGetProgramResourceLocation;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC __glewGetProgramResourceLocationIndex;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCENAMEPROC __glewGetProgramResourceName;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCEIVPROC __glewGetProgramResourceiv;

extern __declspec(dllimport) PFNGLPROVOKINGVERTEXPROC __glewProvokingVertex;

extern __declspec(dllimport) PFNGLGETGRAPHICSRESETSTATUSARBPROC __glewGetGraphicsResetStatusARB;
extern __declspec(dllimport) PFNGLGETNCOLORTABLEARBPROC __glewGetnColorTableARB;
extern __declspec(dllimport) PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC __glewGetnCompressedTexImageARB;
extern __declspec(dllimport) PFNGLGETNCONVOLUTIONFILTERARBPROC __glewGetnConvolutionFilterARB;
extern __declspec(dllimport) PFNGLGETNHISTOGRAMARBPROC __glewGetnHistogramARB;
extern __declspec(dllimport) PFNGLGETNMAPDVARBPROC __glewGetnMapdvARB;
extern __declspec(dllimport) PFNGLGETNMAPFVARBPROC __glewGetnMapfvARB;
extern __declspec(dllimport) PFNGLGETNMAPIVARBPROC __glewGetnMapivARB;
extern __declspec(dllimport) PFNGLGETNMINMAXARBPROC __glewGetnMinmaxARB;
extern __declspec(dllimport) PFNGLGETNPIXELMAPFVARBPROC __glewGetnPixelMapfvARB;
extern __declspec(dllimport) PFNGLGETNPIXELMAPUIVARBPROC __glewGetnPixelMapuivARB;
extern __declspec(dllimport) PFNGLGETNPIXELMAPUSVARBPROC __glewGetnPixelMapusvARB;
extern __declspec(dllimport) PFNGLGETNPOLYGONSTIPPLEARBPROC __glewGetnPolygonStippleARB;
extern __declspec(dllimport) PFNGLGETNSEPARABLEFILTERARBPROC __glewGetnSeparableFilterARB;
extern __declspec(dllimport) PFNGLGETNTEXIMAGEARBPROC __glewGetnTexImageARB;
extern __declspec(dllimport) PFNGLGETNUNIFORMDVARBPROC __glewGetnUniformdvARB;
extern __declspec(dllimport) PFNGLGETNUNIFORMFVARBPROC __glewGetnUniformfvARB;
extern __declspec(dllimport) PFNGLGETNUNIFORMIVARBPROC __glewGetnUniformivARB;
extern __declspec(dllimport) PFNGLGETNUNIFORMUIVARBPROC __glewGetnUniformuivARB;
extern __declspec(dllimport) PFNGLREADNPIXELSARBPROC __glewReadnPixelsARB;

extern __declspec(dllimport) PFNGLMINSAMPLESHADINGARBPROC __glewMinSampleShadingARB;

extern __declspec(dllimport) PFNGLBINDSAMPLERPROC __glewBindSampler;
extern __declspec(dllimport) PFNGLDELETESAMPLERSPROC __glewDeleteSamplers;
extern __declspec(dllimport) PFNGLGENSAMPLERSPROC __glewGenSamplers;
extern __declspec(dllimport) PFNGLGETSAMPLERPARAMETERIIVPROC __glewGetSamplerParameterIiv;
extern __declspec(dllimport) PFNGLGETSAMPLERPARAMETERIUIVPROC __glewGetSamplerParameterIuiv;
extern __declspec(dllimport) PFNGLGETSAMPLERPARAMETERFVPROC __glewGetSamplerParameterfv;
extern __declspec(dllimport) PFNGLGETSAMPLERPARAMETERIVPROC __glewGetSamplerParameteriv;
extern __declspec(dllimport) PFNGLISSAMPLERPROC __glewIsSampler;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERIIVPROC __glewSamplerParameterIiv;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERIUIVPROC __glewSamplerParameterIuiv;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERFPROC __glewSamplerParameterf;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERFVPROC __glewSamplerParameterfv;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERIPROC __glewSamplerParameteri;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERIVPROC __glewSamplerParameteriv;

extern __declspec(dllimport) PFNGLACTIVESHADERPROGRAMPROC __glewActiveShaderProgram;
extern __declspec(dllimport) PFNGLBINDPROGRAMPIPELINEPROC __glewBindProgramPipeline;
extern __declspec(dllimport) PFNGLCREATESHADERPROGRAMVPROC __glewCreateShaderProgramv;
extern __declspec(dllimport) PFNGLDELETEPROGRAMPIPELINESPROC __glewDeleteProgramPipelines;
extern __declspec(dllimport) PFNGLGENPROGRAMPIPELINESPROC __glewGenProgramPipelines;
extern __declspec(dllimport) PFNGLGETPROGRAMPIPELINEINFOLOGPROC __glewGetProgramPipelineInfoLog;
extern __declspec(dllimport) PFNGLGETPROGRAMPIPELINEIVPROC __glewGetProgramPipelineiv;
extern __declspec(dllimport) PFNGLISPROGRAMPIPELINEPROC __glewIsProgramPipeline;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1DPROC __glewProgramUniform1d;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1DVPROC __glewProgramUniform1dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1FPROC __glewProgramUniform1f;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1FVPROC __glewProgramUniform1fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1IPROC __glewProgramUniform1i;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1IVPROC __glewProgramUniform1iv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UIPROC __glewProgramUniform1ui;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UIVPROC __glewProgramUniform1uiv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2DPROC __glewProgramUniform2d;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2DVPROC __glewProgramUniform2dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2FPROC __glewProgramUniform2f;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2FVPROC __glewProgramUniform2fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2IPROC __glewProgramUniform2i;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2IVPROC __glewProgramUniform2iv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UIPROC __glewProgramUniform2ui;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UIVPROC __glewProgramUniform2uiv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3DPROC __glewProgramUniform3d;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3DVPROC __glewProgramUniform3dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3FPROC __glewProgramUniform3f;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3FVPROC __glewProgramUniform3fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3IPROC __glewProgramUniform3i;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3IVPROC __glewProgramUniform3iv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UIPROC __glewProgramUniform3ui;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UIVPROC __glewProgramUniform3uiv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4DPROC __glewProgramUniform4d;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4DVPROC __glewProgramUniform4dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4FPROC __glewProgramUniform4f;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4FVPROC __glewProgramUniform4fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4IPROC __glewProgramUniform4i;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4IVPROC __glewProgramUniform4iv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UIPROC __glewProgramUniform4ui;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UIVPROC __glewProgramUniform4uiv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2DVPROC __glewProgramUniformMatrix2dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2FVPROC __glewProgramUniformMatrix2fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC __glewProgramUniformMatrix2x3dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC __glewProgramUniformMatrix2x3fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC __glewProgramUniformMatrix2x4dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC __glewProgramUniformMatrix2x4fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3DVPROC __glewProgramUniformMatrix3dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3FVPROC __glewProgramUniformMatrix3fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC __glewProgramUniformMatrix3x2dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC __glewProgramUniformMatrix3x2fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC __glewProgramUniformMatrix3x4dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC __glewProgramUniformMatrix3x4fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4DVPROC __glewProgramUniformMatrix4dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4FVPROC __glewProgramUniformMatrix4fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC __glewProgramUniformMatrix4x2dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC __glewProgramUniformMatrix4x2fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC __glewProgramUniformMatrix4x3dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC __glewProgramUniformMatrix4x3fv;
extern __declspec(dllimport) PFNGLUSEPROGRAMSTAGESPROC __glewUseProgramStages;
extern __declspec(dllimport) PFNGLVALIDATEPROGRAMPIPELINEPROC __glewValidateProgramPipeline;

extern __declspec(dllimport) PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC __glewGetActiveAtomicCounterBufferiv;

extern __declspec(dllimport) PFNGLBINDIMAGETEXTUREPROC __glewBindImageTexture;
extern __declspec(dllimport) PFNGLMEMORYBARRIERPROC __glewMemoryBarrier;

extern __declspec(dllimport) PFNGLATTACHOBJECTARBPROC __glewAttachObjectARB;
extern __declspec(dllimport) PFNGLCOMPILESHADERARBPROC __glewCompileShaderARB;
extern __declspec(dllimport) PFNGLCREATEPROGRAMOBJECTARBPROC __glewCreateProgramObjectARB;
extern __declspec(dllimport) PFNGLCREATESHADEROBJECTARBPROC __glewCreateShaderObjectARB;
extern __declspec(dllimport) PFNGLDELETEOBJECTARBPROC __glewDeleteObjectARB;
extern __declspec(dllimport) PFNGLDETACHOBJECTARBPROC __glewDetachObjectARB;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMARBPROC __glewGetActiveUniformARB;
extern __declspec(dllimport) PFNGLGETATTACHEDOBJECTSARBPROC __glewGetAttachedObjectsARB;
extern __declspec(dllimport) PFNGLGETHANDLEARBPROC __glewGetHandleARB;
extern __declspec(dllimport) PFNGLGETINFOLOGARBPROC __glewGetInfoLogARB;
extern __declspec(dllimport) PFNGLGETOBJECTPARAMETERFVARBPROC __glewGetObjectParameterfvARB;
extern __declspec(dllimport) PFNGLGETOBJECTPARAMETERIVARBPROC __glewGetObjectParameterivARB;
extern __declspec(dllimport) PFNGLGETSHADERSOURCEARBPROC __glewGetShaderSourceARB;
extern __declspec(dllimport) PFNGLGETUNIFORMLOCATIONARBPROC __glewGetUniformLocationARB;
extern __declspec(dllimport) PFNGLGETUNIFORMFVARBPROC __glewGetUniformfvARB;
extern __declspec(dllimport) PFNGLGETUNIFORMIVARBPROC __glewGetUniformivARB;
extern __declspec(dllimport) PFNGLLINKPROGRAMARBPROC __glewLinkProgramARB;
extern __declspec(dllimport) PFNGLSHADERSOURCEARBPROC __glewShaderSourceARB;
extern __declspec(dllimport) PFNGLUNIFORM1FARBPROC __glewUniform1fARB;
extern __declspec(dllimport) PFNGLUNIFORM1FVARBPROC __glewUniform1fvARB;
extern __declspec(dllimport) PFNGLUNIFORM1IARBPROC __glewUniform1iARB;
extern __declspec(dllimport) PFNGLUNIFORM1IVARBPROC __glewUniform1ivARB;
extern __declspec(dllimport) PFNGLUNIFORM2FARBPROC __glewUniform2fARB;
extern __declspec(dllimport) PFNGLUNIFORM2FVARBPROC __glewUniform2fvARB;
extern __declspec(dllimport) PFNGLUNIFORM2IARBPROC __glewUniform2iARB;
extern __declspec(dllimport) PFNGLUNIFORM2IVARBPROC __glewUniform2ivARB;
extern __declspec(dllimport) PFNGLUNIFORM3FARBPROC __glewUniform3fARB;
extern __declspec(dllimport) PFNGLUNIFORM3FVARBPROC __glewUniform3fvARB;
extern __declspec(dllimport) PFNGLUNIFORM3IARBPROC __glewUniform3iARB;
extern __declspec(dllimport) PFNGLUNIFORM3IVARBPROC __glewUniform3ivARB;
extern __declspec(dllimport) PFNGLUNIFORM4FARBPROC __glewUniform4fARB;
extern __declspec(dllimport) PFNGLUNIFORM4FVARBPROC __glewUniform4fvARB;
extern __declspec(dllimport) PFNGLUNIFORM4IARBPROC __glewUniform4iARB;
extern __declspec(dllimport) PFNGLUNIFORM4IVARBPROC __glewUniform4ivARB;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2FVARBPROC __glewUniformMatrix2fvARB;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3FVARBPROC __glewUniformMatrix3fvARB;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4FVARBPROC __glewUniformMatrix4fvARB;
extern __declspec(dllimport) PFNGLUSEPROGRAMOBJECTARBPROC __glewUseProgramObjectARB;
extern __declspec(dllimport) PFNGLVALIDATEPROGRAMARBPROC __glewValidateProgramARB;

extern __declspec(dllimport) PFNGLSHADERSTORAGEBLOCKBINDINGPROC __glewShaderStorageBlockBinding;

extern __declspec(dllimport) PFNGLGETACTIVESUBROUTINENAMEPROC __glewGetActiveSubroutineName;
extern __declspec(dllimport) PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC __glewGetActiveSubroutineUniformName;
extern __declspec(dllimport) PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC __glewGetActiveSubroutineUniformiv;
extern __declspec(dllimport) PFNGLGETPROGRAMSTAGEIVPROC __glewGetProgramStageiv;
extern __declspec(dllimport) PFNGLGETSUBROUTINEINDEXPROC __glewGetSubroutineIndex;
extern __declspec(dllimport) PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC __glewGetSubroutineUniformLocation;
extern __declspec(dllimport) PFNGLGETUNIFORMSUBROUTINEUIVPROC __glewGetUniformSubroutineuiv;
extern __declspec(dllimport) PFNGLUNIFORMSUBROUTINESUIVPROC __glewUniformSubroutinesuiv;

extern __declspec(dllimport) PFNGLCOMPILESHADERINCLUDEARBPROC __glewCompileShaderIncludeARB;
extern __declspec(dllimport) PFNGLDELETENAMEDSTRINGARBPROC __glewDeleteNamedStringARB;
extern __declspec(dllimport) PFNGLGETNAMEDSTRINGARBPROC __glewGetNamedStringARB;
extern __declspec(dllimport) PFNGLGETNAMEDSTRINGIVARBPROC __glewGetNamedStringivARB;
extern __declspec(dllimport) PFNGLISNAMEDSTRINGARBPROC __glewIsNamedStringARB;
extern __declspec(dllimport) PFNGLNAMEDSTRINGARBPROC __glewNamedStringARB;

extern __declspec(dllimport) PFNGLTEXPAGECOMMITMENTARBPROC __glewTexPageCommitmentARB;
extern __declspec(dllimport) PFNGLTEXTUREPAGECOMMITMENTEXTPROC __glewTexturePageCommitmentEXT;

extern __declspec(dllimport) PFNGLCLIENTWAITSYNCPROC __glewClientWaitSync;
extern __declspec(dllimport) PFNGLDELETESYNCPROC __glewDeleteSync;
extern __declspec(dllimport) PFNGLFENCESYNCPROC __glewFenceSync;
extern __declspec(dllimport) PFNGLGETINTEGER64VPROC __glewGetInteger64v;
extern __declspec(dllimport) PFNGLGETSYNCIVPROC __glewGetSynciv;
extern __declspec(dllimport) PFNGLISSYNCPROC __glewIsSync;
extern __declspec(dllimport) PFNGLWAITSYNCPROC __glewWaitSync;

extern __declspec(dllimport) PFNGLPATCHPARAMETERFVPROC __glewPatchParameterfv;
extern __declspec(dllimport) PFNGLPATCHPARAMETERIPROC __glewPatchParameteri;

extern __declspec(dllimport) PFNGLTEXBUFFERARBPROC __glewTexBufferARB;

extern __declspec(dllimport) PFNGLTEXBUFFERRANGEPROC __glewTexBufferRange;
extern __declspec(dllimport) PFNGLTEXTUREBUFFERRANGEEXTPROC __glewTextureBufferRangeEXT;

extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE1DARBPROC __glewCompressedTexImage1DARB;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE2DARBPROC __glewCompressedTexImage2DARB;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE3DARBPROC __glewCompressedTexImage3DARB;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC __glewCompressedTexSubImage1DARB;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC __glewCompressedTexSubImage2DARB;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC __glewCompressedTexSubImage3DARB;
extern __declspec(dllimport) PFNGLGETCOMPRESSEDTEXIMAGEARBPROC __glewGetCompressedTexImageARB;

extern __declspec(dllimport) PFNGLGETMULTISAMPLEFVPROC __glewGetMultisamplefv;
extern __declspec(dllimport) PFNGLSAMPLEMASKIPROC __glewSampleMaski;
extern __declspec(dllimport) PFNGLTEXIMAGE2DMULTISAMPLEPROC __glewTexImage2DMultisample;
extern __declspec(dllimport) PFNGLTEXIMAGE3DMULTISAMPLEPROC __glewTexImage3DMultisample;

extern __declspec(dllimport) PFNGLTEXSTORAGE1DPROC __glewTexStorage1D;
extern __declspec(dllimport) PFNGLTEXSTORAGE2DPROC __glewTexStorage2D;
extern __declspec(dllimport) PFNGLTEXSTORAGE3DPROC __glewTexStorage3D;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE1DEXTPROC __glewTextureStorage1DEXT;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE2DEXTPROC __glewTextureStorage2DEXT;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE3DEXTPROC __glewTextureStorage3DEXT;

extern __declspec(dllimport) PFNGLTEXSTORAGE2DMULTISAMPLEPROC __glewTexStorage2DMultisample;
extern __declspec(dllimport) PFNGLTEXSTORAGE3DMULTISAMPLEPROC __glewTexStorage3DMultisample;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC __glewTextureStorage2DMultisampleEXT;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC __glewTextureStorage3DMultisampleEXT;

extern __declspec(dllimport) PFNGLTEXTUREVIEWPROC __glewTextureView;

extern __declspec(dllimport) PFNGLGETQUERYOBJECTI64VPROC __glewGetQueryObjecti64v;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUI64VPROC __glewGetQueryObjectui64v;
extern __declspec(dllimport) PFNGLQUERYCOUNTERPROC __glewQueryCounter;

extern __declspec(dllimport) PFNGLBINDTRANSFORMFEEDBACKPROC __glewBindTransformFeedback;
extern __declspec(dllimport) PFNGLDELETETRANSFORMFEEDBACKSPROC __glewDeleteTransformFeedbacks;
extern __declspec(dllimport) PFNGLDRAWTRANSFORMFEEDBACKPROC __glewDrawTransformFeedback;
extern __declspec(dllimport) PFNGLGENTRANSFORMFEEDBACKSPROC __glewGenTransformFeedbacks;
extern __declspec(dllimport) PFNGLISTRANSFORMFEEDBACKPROC __glewIsTransformFeedback;
extern __declspec(dllimport) PFNGLPAUSETRANSFORMFEEDBACKPROC __glewPauseTransformFeedback;
extern __declspec(dllimport) PFNGLRESUMETRANSFORMFEEDBACKPROC __glewResumeTransformFeedback;

extern __declspec(dllimport) PFNGLBEGINQUERYINDEXEDPROC __glewBeginQueryIndexed;
extern __declspec(dllimport) PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC __glewDrawTransformFeedbackStream;
extern __declspec(dllimport) PFNGLENDQUERYINDEXEDPROC __glewEndQueryIndexed;
extern __declspec(dllimport) PFNGLGETQUERYINDEXEDIVPROC __glewGetQueryIndexediv;

extern __declspec(dllimport) PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC __glewDrawTransformFeedbackInstanced;
extern __declspec(dllimport) PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC __glewDrawTransformFeedbackStreamInstanced;

extern __declspec(dllimport) PFNGLLOADTRANSPOSEMATRIXDARBPROC __glewLoadTransposeMatrixdARB;
extern __declspec(dllimport) PFNGLLOADTRANSPOSEMATRIXFARBPROC __glewLoadTransposeMatrixfARB;
extern __declspec(dllimport) PFNGLMULTTRANSPOSEMATRIXDARBPROC __glewMultTransposeMatrixdARB;
extern __declspec(dllimport) PFNGLMULTTRANSPOSEMATRIXFARBPROC __glewMultTransposeMatrixfARB;

extern __declspec(dllimport) PFNGLBINDBUFFERBASEPROC __glewBindBufferBase;
extern __declspec(dllimport) PFNGLBINDBUFFERRANGEPROC __glewBindBufferRange;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC __glewGetActiveUniformBlockName;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMBLOCKIVPROC __glewGetActiveUniformBlockiv;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMNAMEPROC __glewGetActiveUniformName;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMSIVPROC __glewGetActiveUniformsiv;
extern __declspec(dllimport) PFNGLGETINTEGERI_VPROC __glewGetIntegeri_v;
extern __declspec(dllimport) PFNGLGETUNIFORMBLOCKINDEXPROC __glewGetUniformBlockIndex;
extern __declspec(dllimport) PFNGLGETUNIFORMINDICESPROC __glewGetUniformIndices;
extern __declspec(dllimport) PFNGLUNIFORMBLOCKBINDINGPROC __glewUniformBlockBinding;

extern __declspec(dllimport) PFNGLBINDVERTEXARRAYPROC __glewBindVertexArray;
extern __declspec(dllimport) PFNGLDELETEVERTEXARRAYSPROC __glewDeleteVertexArrays;
extern __declspec(dllimport) PFNGLGENVERTEXARRAYSPROC __glewGenVertexArrays;
extern __declspec(dllimport) PFNGLISVERTEXARRAYPROC __glewIsVertexArray;

extern __declspec(dllimport) PFNGLGETVERTEXATTRIBLDVPROC __glewGetVertexAttribLdv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1DPROC __glewVertexAttribL1d;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1DVPROC __glewVertexAttribL1dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2DPROC __glewVertexAttribL2d;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2DVPROC __glewVertexAttribL2dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3DPROC __glewVertexAttribL3d;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3DVPROC __glewVertexAttribL3dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4DPROC __glewVertexAttribL4d;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4DVPROC __glewVertexAttribL4dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBLPOINTERPROC __glewVertexAttribLPointer;

extern __declspec(dllimport) PFNGLBINDVERTEXBUFFERPROC __glewBindVertexBuffer;
extern __declspec(dllimport) PFNGLVERTEXATTRIBBINDINGPROC __glewVertexAttribBinding;
extern __declspec(dllimport) PFNGLVERTEXATTRIBFORMATPROC __glewVertexAttribFormat;
extern __declspec(dllimport) PFNGLVERTEXATTRIBIFORMATPROC __glewVertexAttribIFormat;
extern __declspec(dllimport) PFNGLVERTEXATTRIBLFORMATPROC __glewVertexAttribLFormat;
extern __declspec(dllimport) PFNGLVERTEXBINDINGDIVISORPROC __glewVertexBindingDivisor;

extern __declspec(dllimport) PFNGLVERTEXBLENDARBPROC __glewVertexBlendARB;
extern __declspec(dllimport) PFNGLWEIGHTPOINTERARBPROC __glewWeightPointerARB;
extern __declspec(dllimport) PFNGLWEIGHTBVARBPROC __glewWeightbvARB;
extern __declspec(dllimport) PFNGLWEIGHTDVARBPROC __glewWeightdvARB;
extern __declspec(dllimport) PFNGLWEIGHTFVARBPROC __glewWeightfvARB;
extern __declspec(dllimport) PFNGLWEIGHTIVARBPROC __glewWeightivARB;
extern __declspec(dllimport) PFNGLWEIGHTSVARBPROC __glewWeightsvARB;
extern __declspec(dllimport) PFNGLWEIGHTUBVARBPROC __glewWeightubvARB;
extern __declspec(dllimport) PFNGLWEIGHTUIVARBPROC __glewWeightuivARB;
extern __declspec(dllimport) PFNGLWEIGHTUSVARBPROC __glewWeightusvARB;

extern __declspec(dllimport) PFNGLBINDBUFFERARBPROC __glewBindBufferARB;
extern __declspec(dllimport) PFNGLBUFFERDATAARBPROC __glewBufferDataARB;
extern __declspec(dllimport) PFNGLBUFFERSUBDATAARBPROC __glewBufferSubDataARB;
extern __declspec(dllimport) PFNGLDELETEBUFFERSARBPROC __glewDeleteBuffersARB;
extern __declspec(dllimport) PFNGLGENBUFFERSARBPROC __glewGenBuffersARB;
extern __declspec(dllimport) PFNGLGETBUFFERPARAMETERIVARBPROC __glewGetBufferParameterivARB;
extern __declspec(dllimport) PFNGLGETBUFFERPOINTERVARBPROC __glewGetBufferPointervARB;
extern __declspec(dllimport) PFNGLGETBUFFERSUBDATAARBPROC __glewGetBufferSubDataARB;
extern __declspec(dllimport) PFNGLISBUFFERARBPROC __glewIsBufferARB;
extern __declspec(dllimport) PFNGLMAPBUFFERARBPROC __glewMapBufferARB;
extern __declspec(dllimport) PFNGLUNMAPBUFFERARBPROC __glewUnmapBufferARB;

extern __declspec(dllimport) PFNGLBINDPROGRAMARBPROC __glewBindProgramARB;
extern __declspec(dllimport) PFNGLDELETEPROGRAMSARBPROC __glewDeleteProgramsARB;
extern __declspec(dllimport) PFNGLDISABLEVERTEXATTRIBARRAYARBPROC __glewDisableVertexAttribArrayARB;
extern __declspec(dllimport) PFNGLENABLEVERTEXATTRIBARRAYARBPROC __glewEnableVertexAttribArrayARB;
extern __declspec(dllimport) PFNGLGENPROGRAMSARBPROC __glewGenProgramsARB;
extern __declspec(dllimport) PFNGLGETPROGRAMENVPARAMETERDVARBPROC __glewGetProgramEnvParameterdvARB;
extern __declspec(dllimport) PFNGLGETPROGRAMENVPARAMETERFVARBPROC __glewGetProgramEnvParameterfvARB;
extern __declspec(dllimport) PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC __glewGetProgramLocalParameterdvARB;
extern __declspec(dllimport) PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC __glewGetProgramLocalParameterfvARB;
extern __declspec(dllimport) PFNGLGETPROGRAMSTRINGARBPROC __glewGetProgramStringARB;
extern __declspec(dllimport) PFNGLGETPROGRAMIVARBPROC __glewGetProgramivARB;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBPOINTERVARBPROC __glewGetVertexAttribPointervARB;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBDVARBPROC __glewGetVertexAttribdvARB;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBFVARBPROC __glewGetVertexAttribfvARB;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIVARBPROC __glewGetVertexAttribivARB;
extern __declspec(dllimport) PFNGLISPROGRAMARBPROC __glewIsProgramARB;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETER4DARBPROC __glewProgramEnvParameter4dARB;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETER4DVARBPROC __glewProgramEnvParameter4dvARB;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETER4FARBPROC __glewProgramEnvParameter4fARB;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETER4FVARBPROC __glewProgramEnvParameter4fvARB;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETER4DARBPROC __glewProgramLocalParameter4dARB;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETER4DVARBPROC __glewProgramLocalParameter4dvARB;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETER4FARBPROC __glewProgramLocalParameter4fARB;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETER4FVARBPROC __glewProgramLocalParameter4fvARB;
extern __declspec(dllimport) PFNGLPROGRAMSTRINGARBPROC __glewProgramStringARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DARBPROC __glewVertexAttrib1dARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DVARBPROC __glewVertexAttrib1dvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FARBPROC __glewVertexAttrib1fARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FVARBPROC __glewVertexAttrib1fvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SARBPROC __glewVertexAttrib1sARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SVARBPROC __glewVertexAttrib1svARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DARBPROC __glewVertexAttrib2dARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DVARBPROC __glewVertexAttrib2dvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FARBPROC __glewVertexAttrib2fARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FVARBPROC __glewVertexAttrib2fvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SARBPROC __glewVertexAttrib2sARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SVARBPROC __glewVertexAttrib2svARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DARBPROC __glewVertexAttrib3dARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DVARBPROC __glewVertexAttrib3dvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FARBPROC __glewVertexAttrib3fARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FVARBPROC __glewVertexAttrib3fvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SARBPROC __glewVertexAttrib3sARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SVARBPROC __glewVertexAttrib3svARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NBVARBPROC __glewVertexAttrib4NbvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NIVARBPROC __glewVertexAttrib4NivARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NSVARBPROC __glewVertexAttrib4NsvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUBARBPROC __glewVertexAttrib4NubARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUBVARBPROC __glewVertexAttrib4NubvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUIVARBPROC __glewVertexAttrib4NuivARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUSVARBPROC __glewVertexAttrib4NusvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4BVARBPROC __glewVertexAttrib4bvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DARBPROC __glewVertexAttrib4dARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DVARBPROC __glewVertexAttrib4dvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FARBPROC __glewVertexAttrib4fARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FVARBPROC __glewVertexAttrib4fvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4IVARBPROC __glewVertexAttrib4ivARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SARBPROC __glewVertexAttrib4sARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SVARBPROC __glewVertexAttrib4svARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UBVARBPROC __glewVertexAttrib4ubvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UIVARBPROC __glewVertexAttrib4uivARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4USVARBPROC __glewVertexAttrib4usvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIBPOINTERARBPROC __glewVertexAttribPointerARB;

extern __declspec(dllimport) PFNGLBINDATTRIBLOCATIONARBPROC __glewBindAttribLocationARB;
extern __declspec(dllimport) PFNGLGETACTIVEATTRIBARBPROC __glewGetActiveAttribARB;
extern __declspec(dllimport) PFNGLGETATTRIBLOCATIONARBPROC __glewGetAttribLocationARB;

extern __declspec(dllimport) PFNGLCOLORP3UIPROC __glewColorP3ui;
extern __declspec(dllimport) PFNGLCOLORP3UIVPROC __glewColorP3uiv;
extern __declspec(dllimport) PFNGLCOLORP4UIPROC __glewColorP4ui;
extern __declspec(dllimport) PFNGLCOLORP4UIVPROC __glewColorP4uiv;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP1UIPROC __glewMultiTexCoordP1ui;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP1UIVPROC __glewMultiTexCoordP1uiv;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP2UIPROC __glewMultiTexCoordP2ui;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP2UIVPROC __glewMultiTexCoordP2uiv;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP3UIPROC __glewMultiTexCoordP3ui;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP3UIVPROC __glewMultiTexCoordP3uiv;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP4UIPROC __glewMultiTexCoordP4ui;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP4UIVPROC __glewMultiTexCoordP4uiv;
extern __declspec(dllimport) PFNGLNORMALP3UIPROC __glewNormalP3ui;
extern __declspec(dllimport) PFNGLNORMALP3UIVPROC __glewNormalP3uiv;
extern __declspec(dllimport) PFNGLSECONDARYCOLORP3UIPROC __glewSecondaryColorP3ui;
extern __declspec(dllimport) PFNGLSECONDARYCOLORP3UIVPROC __glewSecondaryColorP3uiv;
extern __declspec(dllimport) PFNGLTEXCOORDP1UIPROC __glewTexCoordP1ui;
extern __declspec(dllimport) PFNGLTEXCOORDP1UIVPROC __glewTexCoordP1uiv;
extern __declspec(dllimport) PFNGLTEXCOORDP2UIPROC __glewTexCoordP2ui;
extern __declspec(dllimport) PFNGLTEXCOORDP2UIVPROC __glewTexCoordP2uiv;
extern __declspec(dllimport) PFNGLTEXCOORDP3UIPROC __glewTexCoordP3ui;
extern __declspec(dllimport) PFNGLTEXCOORDP3UIVPROC __glewTexCoordP3uiv;
extern __declspec(dllimport) PFNGLTEXCOORDP4UIPROC __glewTexCoordP4ui;
extern __declspec(dllimport) PFNGLTEXCOORDP4UIVPROC __glewTexCoordP4uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP1UIPROC __glewVertexAttribP1ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP1UIVPROC __glewVertexAttribP1uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP2UIPROC __glewVertexAttribP2ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP2UIVPROC __glewVertexAttribP2uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP3UIPROC __glewVertexAttribP3ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP3UIVPROC __glewVertexAttribP3uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP4UIPROC __glewVertexAttribP4ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP4UIVPROC __glewVertexAttribP4uiv;
extern __declspec(dllimport) PFNGLVERTEXP2UIPROC __glewVertexP2ui;
extern __declspec(dllimport) PFNGLVERTEXP2UIVPROC __glewVertexP2uiv;
extern __declspec(dllimport) PFNGLVERTEXP3UIPROC __glewVertexP3ui;
extern __declspec(dllimport) PFNGLVERTEXP3UIVPROC __glewVertexP3uiv;
extern __declspec(dllimport) PFNGLVERTEXP4UIPROC __glewVertexP4ui;
extern __declspec(dllimport) PFNGLVERTEXP4UIVPROC __glewVertexP4uiv;

extern __declspec(dllimport) PFNGLDEPTHRANGEARRAYVPROC __glewDepthRangeArrayv;
extern __declspec(dllimport) PFNGLDEPTHRANGEINDEXEDPROC __glewDepthRangeIndexed;
extern __declspec(dllimport) PFNGLGETDOUBLEI_VPROC __glewGetDoublei_v;
extern __declspec(dllimport) PFNGLGETFLOATI_VPROC __glewGetFloati_v;
extern __declspec(dllimport) PFNGLSCISSORARRAYVPROC __glewScissorArrayv;
extern __declspec(dllimport) PFNGLSCISSORINDEXEDPROC __glewScissorIndexed;
extern __declspec(dllimport) PFNGLSCISSORINDEXEDVPROC __glewScissorIndexedv;
extern __declspec(dllimport) PFNGLVIEWPORTARRAYVPROC __glewViewportArrayv;
extern __declspec(dllimport) PFNGLVIEWPORTINDEXEDFPROC __glewViewportIndexedf;
extern __declspec(dllimport) PFNGLVIEWPORTINDEXEDFVPROC __glewViewportIndexedfv;

extern __declspec(dllimport) PFNGLWINDOWPOS2DARBPROC __glewWindowPos2dARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2DVARBPROC __glewWindowPos2dvARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2FARBPROC __glewWindowPos2fARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2FVARBPROC __glewWindowPos2fvARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2IARBPROC __glewWindowPos2iARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2IVARBPROC __glewWindowPos2ivARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2SARBPROC __glewWindowPos2sARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2SVARBPROC __glewWindowPos2svARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3DARBPROC __glewWindowPos3dARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3DVARBPROC __glewWindowPos3dvARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3FARBPROC __glewWindowPos3fARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3FVARBPROC __glewWindowPos3fvARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3IARBPROC __glewWindowPos3iARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3IVARBPROC __glewWindowPos3ivARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3SARBPROC __glewWindowPos3sARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3SVARBPROC __glewWindowPos3svARB;

extern __declspec(dllimport) PFNGLDRAWBUFFERSATIPROC __glewDrawBuffersATI;

extern __declspec(dllimport) PFNGLDRAWELEMENTARRAYATIPROC __glewDrawElementArrayATI;
extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTARRAYATIPROC __glewDrawRangeElementArrayATI;
extern __declspec(dllimport) PFNGLELEMENTPOINTERATIPROC __glewElementPointerATI;

extern __declspec(dllimport) PFNGLGETTEXBUMPPARAMETERFVATIPROC __glewGetTexBumpParameterfvATI;
extern __declspec(dllimport) PFNGLGETTEXBUMPPARAMETERIVATIPROC __glewGetTexBumpParameterivATI;
extern __declspec(dllimport) PFNGLTEXBUMPPARAMETERFVATIPROC __glewTexBumpParameterfvATI;
extern __declspec(dllimport) PFNGLTEXBUMPPARAMETERIVATIPROC __glewTexBumpParameterivATI;

extern __declspec(dllimport) PFNGLALPHAFRAGMENTOP1ATIPROC __glewAlphaFragmentOp1ATI;
extern __declspec(dllimport) PFNGLALPHAFRAGMENTOP2ATIPROC __glewAlphaFragmentOp2ATI;
extern __declspec(dllimport) PFNGLALPHAFRAGMENTOP3ATIPROC __glewAlphaFragmentOp3ATI;
extern __declspec(dllimport) PFNGLBEGINFRAGMENTSHADERATIPROC __glewBeginFragmentShaderATI;
extern __declspec(dllimport) PFNGLBINDFRAGMENTSHADERATIPROC __glewBindFragmentShaderATI;
extern __declspec(dllimport) PFNGLCOLORFRAGMENTOP1ATIPROC __glewColorFragmentOp1ATI;
extern __declspec(dllimport) PFNGLCOLORFRAGMENTOP2ATIPROC __glewColorFragmentOp2ATI;
extern __declspec(dllimport) PFNGLCOLORFRAGMENTOP3ATIPROC __glewColorFragmentOp3ATI;
extern __declspec(dllimport) PFNGLDELETEFRAGMENTSHADERATIPROC __glewDeleteFragmentShaderATI;
extern __declspec(dllimport) PFNGLENDFRAGMENTSHADERATIPROC __glewEndFragmentShaderATI;
extern __declspec(dllimport) PFNGLGENFRAGMENTSHADERSATIPROC __glewGenFragmentShadersATI;
extern __declspec(dllimport) PFNGLPASSTEXCOORDATIPROC __glewPassTexCoordATI;
extern __declspec(dllimport) PFNGLSAMPLEMAPATIPROC __glewSampleMapATI;
extern __declspec(dllimport) PFNGLSETFRAGMENTSHADERCONSTANTATIPROC __glewSetFragmentShaderConstantATI;

extern __declspec(dllimport) PFNGLMAPOBJECTBUFFERATIPROC __glewMapObjectBufferATI;
extern __declspec(dllimport) PFNGLUNMAPOBJECTBUFFERATIPROC __glewUnmapObjectBufferATI;

extern __declspec(dllimport) PFNGLPNTRIANGLESFATIPROC __glewPNTrianglesfATI;
extern __declspec(dllimport) PFNGLPNTRIANGLESIATIPROC __glewPNTrianglesiATI;

extern __declspec(dllimport) PFNGLSTENCILFUNCSEPARATEATIPROC __glewStencilFuncSeparateATI;
extern __declspec(dllimport) PFNGLSTENCILOPSEPARATEATIPROC __glewStencilOpSeparateATI;

extern __declspec(dllimport) PFNGLARRAYOBJECTATIPROC __glewArrayObjectATI;
extern __declspec(dllimport) PFNGLFREEOBJECTBUFFERATIPROC __glewFreeObjectBufferATI;
extern __declspec(dllimport) PFNGLGETARRAYOBJECTFVATIPROC __glewGetArrayObjectfvATI;
extern __declspec(dllimport) PFNGLGETARRAYOBJECTIVATIPROC __glewGetArrayObjectivATI;
extern __declspec(dllimport) PFNGLGETOBJECTBUFFERFVATIPROC __glewGetObjectBufferfvATI;
extern __declspec(dllimport) PFNGLGETOBJECTBUFFERIVATIPROC __glewGetObjectBufferivATI;
extern __declspec(dllimport) PFNGLGETVARIANTARRAYOBJECTFVATIPROC __glewGetVariantArrayObjectfvATI;
extern __declspec(dllimport) PFNGLGETVARIANTARRAYOBJECTIVATIPROC __glewGetVariantArrayObjectivATI;
extern __declspec(dllimport) PFNGLISOBJECTBUFFERATIPROC __glewIsObjectBufferATI;
extern __declspec(dllimport) PFNGLNEWOBJECTBUFFERATIPROC __glewNewObjectBufferATI;
extern __declspec(dllimport) PFNGLUPDATEOBJECTBUFFERATIPROC __glewUpdateObjectBufferATI;
extern __declspec(dllimport) PFNGLVARIANTARRAYOBJECTATIPROC __glewVariantArrayObjectATI;

extern __declspec(dllimport) PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC __glewGetVertexAttribArrayObjectfvATI;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC __glewGetVertexAttribArrayObjectivATI;
extern __declspec(dllimport) PFNGLVERTEXATTRIBARRAYOBJECTATIPROC __glewVertexAttribArrayObjectATI;

extern __declspec(dllimport) PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC __glewClientActiveVertexStreamATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3BATIPROC __glewNormalStream3bATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3BVATIPROC __glewNormalStream3bvATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3DATIPROC __glewNormalStream3dATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3DVATIPROC __glewNormalStream3dvATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3FATIPROC __glewNormalStream3fATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3FVATIPROC __glewNormalStream3fvATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3IATIPROC __glewNormalStream3iATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3IVATIPROC __glewNormalStream3ivATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3SATIPROC __glewNormalStream3sATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3SVATIPROC __glewNormalStream3svATI;
extern __declspec(dllimport) PFNGLVERTEXBLENDENVFATIPROC __glewVertexBlendEnvfATI;
extern __declspec(dllimport) PFNGLVERTEXBLENDENVIATIPROC __glewVertexBlendEnviATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1DATIPROC __glewVertexStream1dATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1DVATIPROC __glewVertexStream1dvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1FATIPROC __glewVertexStream1fATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1FVATIPROC __glewVertexStream1fvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1IATIPROC __glewVertexStream1iATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1IVATIPROC __glewVertexStream1ivATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1SATIPROC __glewVertexStream1sATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1SVATIPROC __glewVertexStream1svATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2DATIPROC __glewVertexStream2dATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2DVATIPROC __glewVertexStream2dvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2FATIPROC __glewVertexStream2fATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2FVATIPROC __glewVertexStream2fvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2IATIPROC __glewVertexStream2iATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2IVATIPROC __glewVertexStream2ivATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2SATIPROC __glewVertexStream2sATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2SVATIPROC __glewVertexStream2svATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3DATIPROC __glewVertexStream3dATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3DVATIPROC __glewVertexStream3dvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3FATIPROC __glewVertexStream3fATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3FVATIPROC __glewVertexStream3fvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3IATIPROC __glewVertexStream3iATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3IVATIPROC __glewVertexStream3ivATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3SATIPROC __glewVertexStream3sATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3SVATIPROC __glewVertexStream3svATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4DATIPROC __glewVertexStream4dATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4DVATIPROC __glewVertexStream4dvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4FATIPROC __glewVertexStream4fATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4FVATIPROC __glewVertexStream4fvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4IATIPROC __glewVertexStream4iATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4IVATIPROC __glewVertexStream4ivATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4SATIPROC __glewVertexStream4sATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4SVATIPROC __glewVertexStream4svATI;

extern __declspec(dllimport) PFNGLGETUNIFORMBUFFERSIZEEXTPROC __glewGetUniformBufferSizeEXT;
extern __declspec(dllimport) PFNGLGETUNIFORMOFFSETEXTPROC __glewGetUniformOffsetEXT;
extern __declspec(dllimport) PFNGLUNIFORMBUFFEREXTPROC __glewUniformBufferEXT;

extern __declspec(dllimport) PFNGLBLENDCOLOREXTPROC __glewBlendColorEXT;

extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEEXTPROC __glewBlendEquationSeparateEXT;

extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEEXTPROC __glewBlendFuncSeparateEXT;

extern __declspec(dllimport) PFNGLBLENDEQUATIONEXTPROC __glewBlendEquationEXT;

extern __declspec(dllimport) PFNGLCOLORSUBTABLEEXTPROC __glewColorSubTableEXT;
extern __declspec(dllimport) PFNGLCOPYCOLORSUBTABLEEXTPROC __glewCopyColorSubTableEXT;

extern __declspec(dllimport) PFNGLLOCKARRAYSEXTPROC __glewLockArraysEXT;
extern __declspec(dllimport) PFNGLUNLOCKARRAYSEXTPROC __glewUnlockArraysEXT;

extern __declspec(dllimport) PFNGLCONVOLUTIONFILTER1DEXTPROC __glewConvolutionFilter1DEXT;
extern __declspec(dllimport) PFNGLCONVOLUTIONFILTER2DEXTPROC __glewConvolutionFilter2DEXT;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERFEXTPROC __glewConvolutionParameterfEXT;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERFVEXTPROC __glewConvolutionParameterfvEXT;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERIEXTPROC __glewConvolutionParameteriEXT;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERIVEXTPROC __glewConvolutionParameterivEXT;
extern __declspec(dllimport) PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC __glewCopyConvolutionFilter1DEXT;
extern __declspec(dllimport) PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC __glewCopyConvolutionFilter2DEXT;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONFILTEREXTPROC __glewGetConvolutionFilterEXT;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC __glewGetConvolutionParameterfvEXT;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC __glewGetConvolutionParameterivEXT;
extern __declspec(dllimport) PFNGLGETSEPARABLEFILTEREXTPROC __glewGetSeparableFilterEXT;
extern __declspec(dllimport) PFNGLSEPARABLEFILTER2DEXTPROC __glewSeparableFilter2DEXT;

extern __declspec(dllimport) PFNGLBINORMALPOINTEREXTPROC __glewBinormalPointerEXT;
extern __declspec(dllimport) PFNGLTANGENTPOINTEREXTPROC __glewTangentPointerEXT;

extern __declspec(dllimport) PFNGLCOPYTEXIMAGE1DEXTPROC __glewCopyTexImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXIMAGE2DEXTPROC __glewCopyTexImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXSUBIMAGE1DEXTPROC __glewCopyTexSubImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXSUBIMAGE2DEXTPROC __glewCopyTexSubImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXSUBIMAGE3DEXTPROC __glewCopyTexSubImage3DEXT;

extern __declspec(dllimport) PFNGLCULLPARAMETERDVEXTPROC __glewCullParameterdvEXT;
extern __declspec(dllimport) PFNGLCULLPARAMETERFVEXTPROC __glewCullParameterfvEXT;

extern __declspec(dllimport) PFNGLINSERTEVENTMARKEREXTPROC __glewInsertEventMarkerEXT;
extern __declspec(dllimport) PFNGLPOPGROUPMARKEREXTPROC __glewPopGroupMarkerEXT;
extern __declspec(dllimport) PFNGLPUSHGROUPMARKEREXTPROC __glewPushGroupMarkerEXT;

extern __declspec(dllimport) PFNGLDEPTHBOUNDSEXTPROC __glewDepthBoundsEXT;

extern __declspec(dllimport) PFNGLBINDMULTITEXTUREEXTPROC __glewBindMultiTextureEXT;
extern __declspec(dllimport) PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC __glewCheckNamedFramebufferStatusEXT;
extern __declspec(dllimport) PFNGLCLIENTATTRIBDEFAULTEXTPROC __glewClientAttribDefaultEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC __glewCompressedMultiTexImage1DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC __glewCompressedMultiTexImage2DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC __glewCompressedMultiTexImage3DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC __glewCompressedMultiTexSubImage1DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC __glewCompressedMultiTexSubImage2DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC __glewCompressedMultiTexSubImage3DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC __glewCompressedTextureImage1DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC __glewCompressedTextureImage2DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC __glewCompressedTextureImage3DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC __glewCompressedTextureSubImage1DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC __glewCompressedTextureSubImage2DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC __glewCompressedTextureSubImage3DEXT;
extern __declspec(dllimport) PFNGLCOPYMULTITEXIMAGE1DEXTPROC __glewCopyMultiTexImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYMULTITEXIMAGE2DEXTPROC __glewCopyMultiTexImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC __glewCopyMultiTexSubImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC __glewCopyMultiTexSubImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC __glewCopyMultiTexSubImage3DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXTUREIMAGE1DEXTPROC __glewCopyTextureImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXTUREIMAGE2DEXTPROC __glewCopyTextureImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC __glewCopyTextureSubImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC __glewCopyTextureSubImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC __glewCopyTextureSubImage3DEXT;
extern __declspec(dllimport) PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC __glewDisableClientStateIndexedEXT;
extern __declspec(dllimport) PFNGLDISABLECLIENTSTATEIEXTPROC __glewDisableClientStateiEXT;
extern __declspec(dllimport) PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC __glewDisableVertexArrayAttribEXT;
extern __declspec(dllimport) PFNGLDISABLEVERTEXARRAYEXTPROC __glewDisableVertexArrayEXT;
extern __declspec(dllimport) PFNGLENABLECLIENTSTATEINDEXEDEXTPROC __glewEnableClientStateIndexedEXT;
extern __declspec(dllimport) PFNGLENABLECLIENTSTATEIEXTPROC __glewEnableClientStateiEXT;
extern __declspec(dllimport) PFNGLENABLEVERTEXARRAYATTRIBEXTPROC __glewEnableVertexArrayAttribEXT;
extern __declspec(dllimport) PFNGLENABLEVERTEXARRAYEXTPROC __glewEnableVertexArrayEXT;
extern __declspec(dllimport) PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC __glewFlushMappedNamedBufferRangeEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC __glewFramebufferDrawBufferEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC __glewFramebufferDrawBuffersEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERREADBUFFEREXTPROC __glewFramebufferReadBufferEXT;
extern __declspec(dllimport) PFNGLGENERATEMULTITEXMIPMAPEXTPROC __glewGenerateMultiTexMipmapEXT;
extern __declspec(dllimport) PFNGLGENERATETEXTUREMIPMAPEXTPROC __glewGenerateTextureMipmapEXT;
extern __declspec(dllimport) PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC __glewGetCompressedMultiTexImageEXT;
extern __declspec(dllimport) PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC __glewGetCompressedTextureImageEXT;
extern __declspec(dllimport) PFNGLGETDOUBLEINDEXEDVEXTPROC __glewGetDoubleIndexedvEXT;
extern __declspec(dllimport) PFNGLGETDOUBLEI_VEXTPROC __glewGetDoublei_vEXT;
extern __declspec(dllimport) PFNGLGETFLOATINDEXEDVEXTPROC __glewGetFloatIndexedvEXT;
extern __declspec(dllimport) PFNGLGETFLOATI_VEXTPROC __glewGetFloati_vEXT;
extern __declspec(dllimport) PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC __glewGetFramebufferParameterivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXENVFVEXTPROC __glewGetMultiTexEnvfvEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXENVIVEXTPROC __glewGetMultiTexEnvivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXGENDVEXTPROC __glewGetMultiTexGendvEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXGENFVEXTPROC __glewGetMultiTexGenfvEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXGENIVEXTPROC __glewGetMultiTexGenivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXIMAGEEXTPROC __glewGetMultiTexImageEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC __glewGetMultiTexLevelParameterfvEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC __glewGetMultiTexLevelParameterivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXPARAMETERIIVEXTPROC __glewGetMultiTexParameterIivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXPARAMETERIUIVEXTPROC __glewGetMultiTexParameterIuivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXPARAMETERFVEXTPROC __glewGetMultiTexParameterfvEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXPARAMETERIVEXTPROC __glewGetMultiTexParameterivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC __glewGetNamedBufferParameterivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERPOINTERVEXTPROC __glewGetNamedBufferPointervEXT;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERSUBDATAEXTPROC __glewGetNamedBufferSubDataEXT;
extern __declspec(dllimport) PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetNamedFramebufferAttachmentParameterivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC __glewGetNamedProgramLocalParameterIivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC __glewGetNamedProgramLocalParameterIuivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC __glewGetNamedProgramLocalParameterdvEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC __glewGetNamedProgramLocalParameterfvEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMSTRINGEXTPROC __glewGetNamedProgramStringEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMIVEXTPROC __glewGetNamedProgramivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC __glewGetNamedRenderbufferParameterivEXT;
extern __declspec(dllimport) PFNGLGETPOINTERINDEXEDVEXTPROC __glewGetPointerIndexedvEXT;
extern __declspec(dllimport) PFNGLGETPOINTERI_VEXTPROC __glewGetPointeri_vEXT;
extern __declspec(dllimport) PFNGLGETTEXTUREIMAGEEXTPROC __glewGetTextureImageEXT;
extern __declspec(dllimport) PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC __glewGetTextureLevelParameterfvEXT;
extern __declspec(dllimport) PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC __glewGetTextureLevelParameterivEXT;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERIIVEXTPROC __glewGetTextureParameterIivEXT;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERIUIVEXTPROC __glewGetTextureParameterIuivEXT;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERFVEXTPROC __glewGetTextureParameterfvEXT;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERIVEXTPROC __glewGetTextureParameterivEXT;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC __glewGetVertexArrayIntegeri_vEXT;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYINTEGERVEXTPROC __glewGetVertexArrayIntegervEXT;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC __glewGetVertexArrayPointeri_vEXT;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYPOINTERVEXTPROC __glewGetVertexArrayPointervEXT;
extern __declspec(dllimport) PFNGLMAPNAMEDBUFFEREXTPROC __glewMapNamedBufferEXT;
extern __declspec(dllimport) PFNGLMAPNAMEDBUFFERRANGEEXTPROC __glewMapNamedBufferRangeEXT;
extern __declspec(dllimport) PFNGLMATRIXFRUSTUMEXTPROC __glewMatrixFrustumEXT;
extern __declspec(dllimport) PFNGLMATRIXLOADIDENTITYEXTPROC __glewMatrixLoadIdentityEXT;
extern __declspec(dllimport) PFNGLMATRIXLOADTRANSPOSEDEXTPROC __glewMatrixLoadTransposedEXT;
extern __declspec(dllimport) PFNGLMATRIXLOADTRANSPOSEFEXTPROC __glewMatrixLoadTransposefEXT;
extern __declspec(dllimport) PFNGLMATRIXLOADDEXTPROC __glewMatrixLoaddEXT;
extern __declspec(dllimport) PFNGLMATRIXLOADFEXTPROC __glewMatrixLoadfEXT;
extern __declspec(dllimport) PFNGLMATRIXMULTTRANSPOSEDEXTPROC __glewMatrixMultTransposedEXT;
extern __declspec(dllimport) PFNGLMATRIXMULTTRANSPOSEFEXTPROC __glewMatrixMultTransposefEXT;
extern __declspec(dllimport) PFNGLMATRIXMULTDEXTPROC __glewMatrixMultdEXT;
extern __declspec(dllimport) PFNGLMATRIXMULTFEXTPROC __glewMatrixMultfEXT;
extern __declspec(dllimport) PFNGLMATRIXORTHOEXTPROC __glewMatrixOrthoEXT;
extern __declspec(dllimport) PFNGLMATRIXPOPEXTPROC __glewMatrixPopEXT;
extern __declspec(dllimport) PFNGLMATRIXPUSHEXTPROC __glewMatrixPushEXT;
extern __declspec(dllimport) PFNGLMATRIXROTATEDEXTPROC __glewMatrixRotatedEXT;
extern __declspec(dllimport) PFNGLMATRIXROTATEFEXTPROC __glewMatrixRotatefEXT;
extern __declspec(dllimport) PFNGLMATRIXSCALEDEXTPROC __glewMatrixScaledEXT;
extern __declspec(dllimport) PFNGLMATRIXSCALEFEXTPROC __glewMatrixScalefEXT;
extern __declspec(dllimport) PFNGLMATRIXTRANSLATEDEXTPROC __glewMatrixTranslatedEXT;
extern __declspec(dllimport) PFNGLMATRIXTRANSLATEFEXTPROC __glewMatrixTranslatefEXT;
extern __declspec(dllimport) PFNGLMULTITEXBUFFEREXTPROC __glewMultiTexBufferEXT;
extern __declspec(dllimport) PFNGLMULTITEXCOORDPOINTEREXTPROC __glewMultiTexCoordPointerEXT;
extern __declspec(dllimport) PFNGLMULTITEXENVFEXTPROC __glewMultiTexEnvfEXT;
extern __declspec(dllimport) PFNGLMULTITEXENVFVEXTPROC __glewMultiTexEnvfvEXT;
extern __declspec(dllimport) PFNGLMULTITEXENVIEXTPROC __glewMultiTexEnviEXT;
extern __declspec(dllimport) PFNGLMULTITEXENVIVEXTPROC __glewMultiTexEnvivEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENDEXTPROC __glewMultiTexGendEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENDVEXTPROC __glewMultiTexGendvEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENFEXTPROC __glewMultiTexGenfEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENFVEXTPROC __glewMultiTexGenfvEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENIEXTPROC __glewMultiTexGeniEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENIVEXTPROC __glewMultiTexGenivEXT;
extern __declspec(dllimport) PFNGLMULTITEXIMAGE1DEXTPROC __glewMultiTexImage1DEXT;
extern __declspec(dllimport) PFNGLMULTITEXIMAGE2DEXTPROC __glewMultiTexImage2DEXT;
extern __declspec(dllimport) PFNGLMULTITEXIMAGE3DEXTPROC __glewMultiTexImage3DEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERIIVEXTPROC __glewMultiTexParameterIivEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERIUIVEXTPROC __glewMultiTexParameterIuivEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERFEXTPROC __glewMultiTexParameterfEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERFVEXTPROC __glewMultiTexParameterfvEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERIEXTPROC __glewMultiTexParameteriEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERIVEXTPROC __glewMultiTexParameterivEXT;
extern __declspec(dllimport) PFNGLMULTITEXRENDERBUFFEREXTPROC __glewMultiTexRenderbufferEXT;
extern __declspec(dllimport) PFNGLMULTITEXSUBIMAGE1DEXTPROC __glewMultiTexSubImage1DEXT;
extern __declspec(dllimport) PFNGLMULTITEXSUBIMAGE2DEXTPROC __glewMultiTexSubImage2DEXT;
extern __declspec(dllimport) PFNGLMULTITEXSUBIMAGE3DEXTPROC __glewMultiTexSubImage3DEXT;
extern __declspec(dllimport) PFNGLNAMEDBUFFERDATAEXTPROC __glewNamedBufferDataEXT;
extern __declspec(dllimport) PFNGLNAMEDBUFFERSUBDATAEXTPROC __glewNamedBufferSubDataEXT;
extern __declspec(dllimport) PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC __glewNamedCopyBufferSubDataEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC __glewNamedFramebufferRenderbufferEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC __glewNamedFramebufferTexture1DEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC __glewNamedFramebufferTexture2DEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC __glewNamedFramebufferTexture3DEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC __glewNamedFramebufferTextureEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC __glewNamedFramebufferTextureFaceEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC __glewNamedFramebufferTextureLayerEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC __glewNamedProgramLocalParameter4dEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC __glewNamedProgramLocalParameter4dvEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC __glewNamedProgramLocalParameter4fEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC __glewNamedProgramLocalParameter4fvEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC __glewNamedProgramLocalParameterI4iEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC __glewNamedProgramLocalParameterI4ivEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC __glewNamedProgramLocalParameterI4uiEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC __glewNamedProgramLocalParameterI4uivEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC __glewNamedProgramLocalParameters4fvEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC __glewNamedProgramLocalParametersI4ivEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC __glewNamedProgramLocalParametersI4uivEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMSTRINGEXTPROC __glewNamedProgramStringEXT;
extern __declspec(dllimport) PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC __glewNamedRenderbufferStorageEXT;
extern __declspec(dllimport) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC __glewNamedRenderbufferStorageMultisampleCoverageEXT;
extern __declspec(dllimport) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewNamedRenderbufferStorageMultisampleEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1FEXTPROC __glewProgramUniform1fEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1FVEXTPROC __glewProgramUniform1fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1IEXTPROC __glewProgramUniform1iEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1IVEXTPROC __glewProgramUniform1ivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UIEXTPROC __glewProgramUniform1uiEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UIVEXTPROC __glewProgramUniform1uivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2FEXTPROC __glewProgramUniform2fEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2FVEXTPROC __glewProgramUniform2fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2IEXTPROC __glewProgramUniform2iEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2IVEXTPROC __glewProgramUniform2ivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UIEXTPROC __glewProgramUniform2uiEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UIVEXTPROC __glewProgramUniform2uivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3FEXTPROC __glewProgramUniform3fEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3FVEXTPROC __glewProgramUniform3fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3IEXTPROC __glewProgramUniform3iEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3IVEXTPROC __glewProgramUniform3ivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UIEXTPROC __glewProgramUniform3uiEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UIVEXTPROC __glewProgramUniform3uivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4FEXTPROC __glewProgramUniform4fEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4FVEXTPROC __glewProgramUniform4fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4IEXTPROC __glewProgramUniform4iEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4IVEXTPROC __glewProgramUniform4ivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UIEXTPROC __glewProgramUniform4uiEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UIVEXTPROC __glewProgramUniform4uivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC __glewProgramUniformMatrix2fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC __glewProgramUniformMatrix2x3fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC __glewProgramUniformMatrix2x4fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC __glewProgramUniformMatrix3fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC __glewProgramUniformMatrix3x2fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC __glewProgramUniformMatrix3x4fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC __glewProgramUniformMatrix4fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC __glewProgramUniformMatrix4x2fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC __glewProgramUniformMatrix4x3fvEXT;
extern __declspec(dllimport) PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC __glewPushClientAttribDefaultEXT;
extern __declspec(dllimport) PFNGLTEXTUREBUFFEREXTPROC __glewTextureBufferEXT;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE1DEXTPROC __glewTextureImage1DEXT;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE2DEXTPROC __glewTextureImage2DEXT;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE3DEXTPROC __glewTextureImage3DEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIIVEXTPROC __glewTextureParameterIivEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIUIVEXTPROC __glewTextureParameterIuivEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERFEXTPROC __glewTextureParameterfEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERFVEXTPROC __glewTextureParameterfvEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIEXTPROC __glewTextureParameteriEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIVEXTPROC __glewTextureParameterivEXT;
extern __declspec(dllimport) PFNGLTEXTURERENDERBUFFEREXTPROC __glewTextureRenderbufferEXT;
extern __declspec(dllimport) PFNGLTEXTURESUBIMAGE1DEXTPROC __glewTextureSubImage1DEXT;
extern __declspec(dllimport) PFNGLTEXTURESUBIMAGE2DEXTPROC __glewTextureSubImage2DEXT;
extern __declspec(dllimport) PFNGLTEXTURESUBIMAGE3DEXTPROC __glewTextureSubImage3DEXT;
extern __declspec(dllimport) PFNGLUNMAPNAMEDBUFFEREXTPROC __glewUnmapNamedBufferEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYCOLOROFFSETEXTPROC __glewVertexArrayColorOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC __glewVertexArrayEdgeFlagOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC __glewVertexArrayFogCoordOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYINDEXOFFSETEXTPROC __glewVertexArrayIndexOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC __glewVertexArrayMultiTexCoordOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYNORMALOFFSETEXTPROC __glewVertexArrayNormalOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC __glewVertexArraySecondaryColorOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC __glewVertexArrayTexCoordOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC __glewVertexArrayVertexAttribIOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC __glewVertexArrayVertexAttribOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC __glewVertexArrayVertexOffsetEXT;

extern __declspec(dllimport) PFNGLCOLORMASKINDEXEDEXTPROC __glewColorMaskIndexedEXT;
extern __declspec(dllimport) PFNGLDISABLEINDEXEDEXTPROC __glewDisableIndexedEXT;
extern __declspec(dllimport) PFNGLENABLEINDEXEDEXTPROC __glewEnableIndexedEXT;
extern __declspec(dllimport) PFNGLGETBOOLEANINDEXEDVEXTPROC __glewGetBooleanIndexedvEXT;
extern __declspec(dllimport) PFNGLGETINTEGERINDEXEDVEXTPROC __glewGetIntegerIndexedvEXT;
extern __declspec(dllimport) PFNGLISENABLEDINDEXEDEXTPROC __glewIsEnabledIndexedEXT;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDEXTPROC __glewDrawArraysInstancedEXT;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDEXTPROC __glewDrawElementsInstancedEXT;

extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTSEXTPROC __glewDrawRangeElementsEXT;

extern __declspec(dllimport) PFNGLFOGCOORDPOINTEREXTPROC __glewFogCoordPointerEXT;
extern __declspec(dllimport) PFNGLFOGCOORDDEXTPROC __glewFogCoorddEXT;
extern __declspec(dllimport) PFNGLFOGCOORDDVEXTPROC __glewFogCoorddvEXT;
extern __declspec(dllimport) PFNGLFOGCOORDFEXTPROC __glewFogCoordfEXT;
extern __declspec(dllimport) PFNGLFOGCOORDFVEXTPROC __glewFogCoordfvEXT;

extern __declspec(dllimport) PFNGLFRAGMENTCOLORMATERIALEXTPROC __glewFragmentColorMaterialEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELFEXTPROC __glewFragmentLightModelfEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELFVEXTPROC __glewFragmentLightModelfvEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELIEXTPROC __glewFragmentLightModeliEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELIVEXTPROC __glewFragmentLightModelivEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTFEXTPROC __glewFragmentLightfEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTFVEXTPROC __glewFragmentLightfvEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTIEXTPROC __glewFragmentLightiEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTIVEXTPROC __glewFragmentLightivEXT;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALFEXTPROC __glewFragmentMaterialfEXT;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALFVEXTPROC __glewFragmentMaterialfvEXT;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALIEXTPROC __glewFragmentMaterialiEXT;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALIVEXTPROC __glewFragmentMaterialivEXT;
extern __declspec(dllimport) PFNGLGETFRAGMENTLIGHTFVEXTPROC __glewGetFragmentLightfvEXT;
extern __declspec(dllimport) PFNGLGETFRAGMENTLIGHTIVEXTPROC __glewGetFragmentLightivEXT;
extern __declspec(dllimport) PFNGLGETFRAGMENTMATERIALFVEXTPROC __glewGetFragmentMaterialfvEXT;
extern __declspec(dllimport) PFNGLGETFRAGMENTMATERIALIVEXTPROC __glewGetFragmentMaterialivEXT;
extern __declspec(dllimport) PFNGLLIGHTENVIEXTPROC __glewLightEnviEXT;

extern __declspec(dllimport) PFNGLBLITFRAMEBUFFEREXTPROC __glewBlitFramebufferEXT;

extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewRenderbufferStorageMultisampleEXT;

extern __declspec(dllimport) PFNGLBINDFRAMEBUFFEREXTPROC __glewBindFramebufferEXT;
extern __declspec(dllimport) PFNGLBINDRENDERBUFFEREXTPROC __glewBindRenderbufferEXT;
extern __declspec(dllimport) PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC __glewCheckFramebufferStatusEXT;
extern __declspec(dllimport) PFNGLDELETEFRAMEBUFFERSEXTPROC __glewDeleteFramebuffersEXT;
extern __declspec(dllimport) PFNGLDELETERENDERBUFFERSEXTPROC __glewDeleteRenderbuffersEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC __glewFramebufferRenderbufferEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE1DEXTPROC __glewFramebufferTexture1DEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE2DEXTPROC __glewFramebufferTexture2DEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE3DEXTPROC __glewFramebufferTexture3DEXT;
extern __declspec(dllimport) PFNGLGENFRAMEBUFFERSEXTPROC __glewGenFramebuffersEXT;
extern __declspec(dllimport) PFNGLGENRENDERBUFFERSEXTPROC __glewGenRenderbuffersEXT;
extern __declspec(dllimport) PFNGLGENERATEMIPMAPEXTPROC __glewGenerateMipmapEXT;
extern __declspec(dllimport) PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetFramebufferAttachmentParameterivEXT;
extern __declspec(dllimport) PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC __glewGetRenderbufferParameterivEXT;
extern __declspec(dllimport) PFNGLISFRAMEBUFFEREXTPROC __glewIsFramebufferEXT;
extern __declspec(dllimport) PFNGLISRENDERBUFFEREXTPROC __glewIsRenderbufferEXT;
extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEEXTPROC __glewRenderbufferStorageEXT;

extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREEXTPROC __glewFramebufferTextureEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC __glewFramebufferTextureFaceEXT;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETERIEXTPROC __glewProgramParameteriEXT;

extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERS4FVEXTPROC __glewProgramEnvParameters4fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC __glewProgramLocalParameters4fvEXT;

extern __declspec(dllimport) PFNGLBINDFRAGDATALOCATIONEXTPROC __glewBindFragDataLocationEXT;
extern __declspec(dllimport) PFNGLGETFRAGDATALOCATIONEXTPROC __glewGetFragDataLocationEXT;
extern __declspec(dllimport) PFNGLGETUNIFORMUIVEXTPROC __glewGetUniformuivEXT;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIIVEXTPROC __glewGetVertexAttribIivEXT;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIUIVEXTPROC __glewGetVertexAttribIuivEXT;
extern __declspec(dllimport) PFNGLUNIFORM1UIEXTPROC __glewUniform1uiEXT;
extern __declspec(dllimport) PFNGLUNIFORM1UIVEXTPROC __glewUniform1uivEXT;
extern __declspec(dllimport) PFNGLUNIFORM2UIEXTPROC __glewUniform2uiEXT;
extern __declspec(dllimport) PFNGLUNIFORM2UIVEXTPROC __glewUniform2uivEXT;
extern __declspec(dllimport) PFNGLUNIFORM3UIEXTPROC __glewUniform3uiEXT;
extern __declspec(dllimport) PFNGLUNIFORM3UIVEXTPROC __glewUniform3uivEXT;
extern __declspec(dllimport) PFNGLUNIFORM4UIEXTPROC __glewUniform4uiEXT;
extern __declspec(dllimport) PFNGLUNIFORM4UIVEXTPROC __glewUniform4uivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1IEXTPROC __glewVertexAttribI1iEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1IVEXTPROC __glewVertexAttribI1ivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1UIEXTPROC __glewVertexAttribI1uiEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1UIVEXTPROC __glewVertexAttribI1uivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2IEXTPROC __glewVertexAttribI2iEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2IVEXTPROC __glewVertexAttribI2ivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2UIEXTPROC __glewVertexAttribI2uiEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2UIVEXTPROC __glewVertexAttribI2uivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3IEXTPROC __glewVertexAttribI3iEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3IVEXTPROC __glewVertexAttribI3ivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3UIEXTPROC __glewVertexAttribI3uiEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3UIVEXTPROC __glewVertexAttribI3uivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4BVEXTPROC __glewVertexAttribI4bvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4IEXTPROC __glewVertexAttribI4iEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4IVEXTPROC __glewVertexAttribI4ivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4SVEXTPROC __glewVertexAttribI4svEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UBVEXTPROC __glewVertexAttribI4ubvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UIEXTPROC __glewVertexAttribI4uiEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UIVEXTPROC __glewVertexAttribI4uivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4USVEXTPROC __glewVertexAttribI4usvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBIPOINTEREXTPROC __glewVertexAttribIPointerEXT;

extern __declspec(dllimport) PFNGLGETHISTOGRAMEXTPROC __glewGetHistogramEXT;
extern __declspec(dllimport) PFNGLGETHISTOGRAMPARAMETERFVEXTPROC __glewGetHistogramParameterfvEXT;
extern __declspec(dllimport) PFNGLGETHISTOGRAMPARAMETERIVEXTPROC __glewGetHistogramParameterivEXT;
extern __declspec(dllimport) PFNGLGETMINMAXEXTPROC __glewGetMinmaxEXT;
extern __declspec(dllimport) PFNGLGETMINMAXPARAMETERFVEXTPROC __glewGetMinmaxParameterfvEXT;
extern __declspec(dllimport) PFNGLGETMINMAXPARAMETERIVEXTPROC __glewGetMinmaxParameterivEXT;
extern __declspec(dllimport) PFNGLHISTOGRAMEXTPROC __glewHistogramEXT;
extern __declspec(dllimport) PFNGLMINMAXEXTPROC __glewMinmaxEXT;
extern __declspec(dllimport) PFNGLRESETHISTOGRAMEXTPROC __glewResetHistogramEXT;
extern __declspec(dllimport) PFNGLRESETMINMAXEXTPROC __glewResetMinmaxEXT;

extern __declspec(dllimport) PFNGLINDEXFUNCEXTPROC __glewIndexFuncEXT;

extern __declspec(dllimport) PFNGLINDEXMATERIALEXTPROC __glewIndexMaterialEXT;

extern __declspec(dllimport) PFNGLAPPLYTEXTUREEXTPROC __glewApplyTextureEXT;
extern __declspec(dllimport) PFNGLTEXTURELIGHTEXTPROC __glewTextureLightEXT;
extern __declspec(dllimport) PFNGLTEXTUREMATERIALEXTPROC __glewTextureMaterialEXT;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSEXTPROC __glewMultiDrawArraysEXT;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSEXTPROC __glewMultiDrawElementsEXT;

extern __declspec(dllimport) PFNGLSAMPLEMASKEXTPROC __glewSampleMaskEXT;
extern __declspec(dllimport) PFNGLSAMPLEPATTERNEXTPROC __glewSamplePatternEXT;

extern __declspec(dllimport) PFNGLCOLORTABLEEXTPROC __glewColorTableEXT;
extern __declspec(dllimport) PFNGLGETCOLORTABLEEXTPROC __glewGetColorTableEXT;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERFVEXTPROC __glewGetColorTableParameterfvEXT;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERIVEXTPROC __glewGetColorTableParameterivEXT;

extern __declspec(dllimport) PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC __glewGetPixelTransformParameterfvEXT;
extern __declspec(dllimport) PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC __glewGetPixelTransformParameterivEXT;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERFEXTPROC __glewPixelTransformParameterfEXT;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC __glewPixelTransformParameterfvEXT;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERIEXTPROC __glewPixelTransformParameteriEXT;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC __glewPixelTransformParameterivEXT;

extern __declspec(dllimport) PFNGLPOINTPARAMETERFEXTPROC __glewPointParameterfEXT;
extern __declspec(dllimport) PFNGLPOINTPARAMETERFVEXTPROC __glewPointParameterfvEXT;

extern __declspec(dllimport) PFNGLPOLYGONOFFSETEXTPROC __glewPolygonOffsetEXT;

extern __declspec(dllimport) PFNGLPROVOKINGVERTEXEXTPROC __glewProvokingVertexEXT;

extern __declspec(dllimport) PFNGLBEGINSCENEEXTPROC __glewBeginSceneEXT;
extern __declspec(dllimport) PFNGLENDSCENEEXTPROC __glewEndSceneEXT;

extern __declspec(dllimport) PFNGLSECONDARYCOLOR3BEXTPROC __glewSecondaryColor3bEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3BVEXTPROC __glewSecondaryColor3bvEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3DEXTPROC __glewSecondaryColor3dEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3DVEXTPROC __glewSecondaryColor3dvEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3FEXTPROC __glewSecondaryColor3fEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3FVEXTPROC __glewSecondaryColor3fvEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3IEXTPROC __glewSecondaryColor3iEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3IVEXTPROC __glewSecondaryColor3ivEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3SEXTPROC __glewSecondaryColor3sEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3SVEXTPROC __glewSecondaryColor3svEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UBEXTPROC __glewSecondaryColor3ubEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UBVEXTPROC __glewSecondaryColor3ubvEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UIEXTPROC __glewSecondaryColor3uiEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UIVEXTPROC __glewSecondaryColor3uivEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3USEXTPROC __glewSecondaryColor3usEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3USVEXTPROC __glewSecondaryColor3usvEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLORPOINTEREXTPROC __glewSecondaryColorPointerEXT;

extern __declspec(dllimport) PFNGLACTIVEPROGRAMEXTPROC __glewActiveProgramEXT;
extern __declspec(dllimport) PFNGLCREATESHADERPROGRAMEXTPROC __glewCreateShaderProgramEXT;
extern __declspec(dllimport) PFNGLUSESHADERPROGRAMEXTPROC __glewUseShaderProgramEXT;

extern __declspec(dllimport) PFNGLBINDIMAGETEXTUREEXTPROC __glewBindImageTextureEXT;
extern __declspec(dllimport) PFNGLMEMORYBARRIEREXTPROC __glewMemoryBarrierEXT;

extern __declspec(dllimport) PFNGLACTIVESTENCILFACEEXTPROC __glewActiveStencilFaceEXT;

extern __declspec(dllimport) PFNGLTEXSUBIMAGE1DEXTPROC __glewTexSubImage1DEXT;
extern __declspec(dllimport) PFNGLTEXSUBIMAGE2DEXTPROC __glewTexSubImage2DEXT;
extern __declspec(dllimport) PFNGLTEXSUBIMAGE3DEXTPROC __glewTexSubImage3DEXT;

extern __declspec(dllimport) PFNGLTEXIMAGE3DEXTPROC __glewTexImage3DEXT;

extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC __glewFramebufferTextureLayerEXT;

extern __declspec(dllimport) PFNGLTEXBUFFEREXTPROC __glewTexBufferEXT;

extern __declspec(dllimport) PFNGLCLEARCOLORIIEXTPROC __glewClearColorIiEXT;
extern __declspec(dllimport) PFNGLCLEARCOLORIUIEXTPROC __glewClearColorIuiEXT;
extern __declspec(dllimport) PFNGLGETTEXPARAMETERIIVEXTPROC __glewGetTexParameterIivEXT;
extern __declspec(dllimport) PFNGLGETTEXPARAMETERIUIVEXTPROC __glewGetTexParameterIuivEXT;
extern __declspec(dllimport) PFNGLTEXPARAMETERIIVEXTPROC __glewTexParameterIivEXT;
extern __declspec(dllimport) PFNGLTEXPARAMETERIUIVEXTPROC __glewTexParameterIuivEXT;

extern __declspec(dllimport) PFNGLARETEXTURESRESIDENTEXTPROC __glewAreTexturesResidentEXT;
extern __declspec(dllimport) PFNGLBINDTEXTUREEXTPROC __glewBindTextureEXT;
extern __declspec(dllimport) PFNGLDELETETEXTURESEXTPROC __glewDeleteTexturesEXT;
extern __declspec(dllimport) PFNGLGENTEXTURESEXTPROC __glewGenTexturesEXT;
extern __declspec(dllimport) PFNGLISTEXTUREEXTPROC __glewIsTextureEXT;
extern __declspec(dllimport) PFNGLPRIORITIZETEXTURESEXTPROC __glewPrioritizeTexturesEXT;

extern __declspec(dllimport) PFNGLTEXTURENORMALEXTPROC __glewTextureNormalEXT;

extern __declspec(dllimport) PFNGLGETQUERYOBJECTI64VEXTPROC __glewGetQueryObjecti64vEXT;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUI64VEXTPROC __glewGetQueryObjectui64vEXT;

extern __declspec(dllimport) PFNGLBEGINTRANSFORMFEEDBACKEXTPROC __glewBeginTransformFeedbackEXT;
extern __declspec(dllimport) PFNGLBINDBUFFERBASEEXTPROC __glewBindBufferBaseEXT;
extern __declspec(dllimport) PFNGLBINDBUFFEROFFSETEXTPROC __glewBindBufferOffsetEXT;
extern __declspec(dllimport) PFNGLBINDBUFFERRANGEEXTPROC __glewBindBufferRangeEXT;
extern __declspec(dllimport) PFNGLENDTRANSFORMFEEDBACKEXTPROC __glewEndTransformFeedbackEXT;
extern __declspec(dllimport) PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC __glewGetTransformFeedbackVaryingEXT;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC __glewTransformFeedbackVaryingsEXT;

extern __declspec(dllimport) PFNGLARRAYELEMENTEXTPROC __glewArrayElementEXT;
extern __declspec(dllimport) PFNGLCOLORPOINTEREXTPROC __glewColorPointerEXT;
extern __declspec(dllimport) PFNGLDRAWARRAYSEXTPROC __glewDrawArraysEXT;
extern __declspec(dllimport) PFNGLEDGEFLAGPOINTEREXTPROC __glewEdgeFlagPointerEXT;
extern __declspec(dllimport) PFNGLINDEXPOINTEREXTPROC __glewIndexPointerEXT;
extern __declspec(dllimport) PFNGLNORMALPOINTEREXTPROC __glewNormalPointerEXT;
extern __declspec(dllimport) PFNGLTEXCOORDPOINTEREXTPROC __glewTexCoordPointerEXT;
extern __declspec(dllimport) PFNGLVERTEXPOINTEREXTPROC __glewVertexPointerEXT;

extern __declspec(dllimport) PFNGLGETVERTEXATTRIBLDVEXTPROC __glewGetVertexAttribLdvEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC __glewVertexArrayVertexAttribLOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1DEXTPROC __glewVertexAttribL1dEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1DVEXTPROC __glewVertexAttribL1dvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2DEXTPROC __glewVertexAttribL2dEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2DVEXTPROC __glewVertexAttribL2dvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3DEXTPROC __glewVertexAttribL3dEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3DVEXTPROC __glewVertexAttribL3dvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4DEXTPROC __glewVertexAttribL4dEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4DVEXTPROC __glewVertexAttribL4dvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBLPOINTEREXTPROC __glewVertexAttribLPointerEXT;

extern __declspec(dllimport) PFNGLBEGINVERTEXSHADEREXTPROC __glewBeginVertexShaderEXT;
extern __declspec(dllimport) PFNGLBINDLIGHTPARAMETEREXTPROC __glewBindLightParameterEXT;
extern __declspec(dllimport) PFNGLBINDMATERIALPARAMETEREXTPROC __glewBindMaterialParameterEXT;
extern __declspec(dllimport) PFNGLBINDPARAMETEREXTPROC __glewBindParameterEXT;
extern __declspec(dllimport) PFNGLBINDTEXGENPARAMETEREXTPROC __glewBindTexGenParameterEXT;
extern __declspec(dllimport) PFNGLBINDTEXTUREUNITPARAMETEREXTPROC __glewBindTextureUnitParameterEXT;
extern __declspec(dllimport) PFNGLBINDVERTEXSHADEREXTPROC __glewBindVertexShaderEXT;
extern __declspec(dllimport) PFNGLDELETEVERTEXSHADEREXTPROC __glewDeleteVertexShaderEXT;
extern __declspec(dllimport) PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC __glewDisableVariantClientStateEXT;
extern __declspec(dllimport) PFNGLENABLEVARIANTCLIENTSTATEEXTPROC __glewEnableVariantClientStateEXT;
extern __declspec(dllimport) PFNGLENDVERTEXSHADEREXTPROC __glewEndVertexShaderEXT;
extern __declspec(dllimport) PFNGLEXTRACTCOMPONENTEXTPROC __glewExtractComponentEXT;
extern __declspec(dllimport) PFNGLGENSYMBOLSEXTPROC __glewGenSymbolsEXT;
extern __declspec(dllimport) PFNGLGENVERTEXSHADERSEXTPROC __glewGenVertexShadersEXT;
extern __declspec(dllimport) PFNGLGETINVARIANTBOOLEANVEXTPROC __glewGetInvariantBooleanvEXT;
extern __declspec(dllimport) PFNGLGETINVARIANTFLOATVEXTPROC __glewGetInvariantFloatvEXT;
extern __declspec(dllimport) PFNGLGETINVARIANTINTEGERVEXTPROC __glewGetInvariantIntegervEXT;
extern __declspec(dllimport) PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC __glewGetLocalConstantBooleanvEXT;
extern __declspec(dllimport) PFNGLGETLOCALCONSTANTFLOATVEXTPROC __glewGetLocalConstantFloatvEXT;
extern __declspec(dllimport) PFNGLGETLOCALCONSTANTINTEGERVEXTPROC __glewGetLocalConstantIntegervEXT;
extern __declspec(dllimport) PFNGLGETVARIANTBOOLEANVEXTPROC __glewGetVariantBooleanvEXT;
extern __declspec(dllimport) PFNGLGETVARIANTFLOATVEXTPROC __glewGetVariantFloatvEXT;
extern __declspec(dllimport) PFNGLGETVARIANTINTEGERVEXTPROC __glewGetVariantIntegervEXT;
extern __declspec(dllimport) PFNGLGETVARIANTPOINTERVEXTPROC __glewGetVariantPointervEXT;
extern __declspec(dllimport) PFNGLINSERTCOMPONENTEXTPROC __glewInsertComponentEXT;
extern __declspec(dllimport) PFNGLISVARIANTENABLEDEXTPROC __glewIsVariantEnabledEXT;
extern __declspec(dllimport) PFNGLSETINVARIANTEXTPROC __glewSetInvariantEXT;
extern __declspec(dllimport) PFNGLSETLOCALCONSTANTEXTPROC __glewSetLocalConstantEXT;
extern __declspec(dllimport) PFNGLSHADEROP1EXTPROC __glewShaderOp1EXT;
extern __declspec(dllimport) PFNGLSHADEROP2EXTPROC __glewShaderOp2EXT;
extern __declspec(dllimport) PFNGLSHADEROP3EXTPROC __glewShaderOp3EXT;
extern __declspec(dllimport) PFNGLSWIZZLEEXTPROC __glewSwizzleEXT;
extern __declspec(dllimport) PFNGLVARIANTPOINTEREXTPROC __glewVariantPointerEXT;
extern __declspec(dllimport) PFNGLVARIANTBVEXTPROC __glewVariantbvEXT;
extern __declspec(dllimport) PFNGLVARIANTDVEXTPROC __glewVariantdvEXT;
extern __declspec(dllimport) PFNGLVARIANTFVEXTPROC __glewVariantfvEXT;
extern __declspec(dllimport) PFNGLVARIANTIVEXTPROC __glewVariantivEXT;
extern __declspec(dllimport) PFNGLVARIANTSVEXTPROC __glewVariantsvEXT;
extern __declspec(dllimport) PFNGLVARIANTUBVEXTPROC __glewVariantubvEXT;
extern __declspec(dllimport) PFNGLVARIANTUIVEXTPROC __glewVariantuivEXT;
extern __declspec(dllimport) PFNGLVARIANTUSVEXTPROC __glewVariantusvEXT;
extern __declspec(dllimport) PFNGLWRITEMASKEXTPROC __glewWriteMaskEXT;

extern __declspec(dllimport) PFNGLVERTEXWEIGHTPOINTEREXTPROC __glewVertexWeightPointerEXT;
extern __declspec(dllimport) PFNGLVERTEXWEIGHTFEXTPROC __glewVertexWeightfEXT;
extern __declspec(dllimport) PFNGLVERTEXWEIGHTFVEXTPROC __glewVertexWeightfvEXT;

extern __declspec(dllimport) PFNGLIMPORTSYNCEXTPROC __glewImportSyncEXT;

extern __declspec(dllimport) PFNGLFRAMETERMINATORGREMEDYPROC __glewFrameTerminatorGREMEDY;

extern __declspec(dllimport) PFNGLSTRINGMARKERGREMEDYPROC __glewStringMarkerGREMEDY;

extern __declspec(dllimport) PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC __glewGetImageTransformParameterfvHP;
extern __declspec(dllimport) PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC __glewGetImageTransformParameterivHP;
extern __declspec(dllimport) PFNGLIMAGETRANSFORMPARAMETERFHPPROC __glewImageTransformParameterfHP;
extern __declspec(dllimport) PFNGLIMAGETRANSFORMPARAMETERFVHPPROC __glewImageTransformParameterfvHP;
extern __declspec(dllimport) PFNGLIMAGETRANSFORMPARAMETERIHPPROC __glewImageTransformParameteriHP;
extern __declspec(dllimport) PFNGLIMAGETRANSFORMPARAMETERIVHPPROC __glewImageTransformParameterivHP;

extern __declspec(dllimport) PFNGLMULTIMODEDRAWARRAYSIBMPROC __glewMultiModeDrawArraysIBM;
extern __declspec(dllimport) PFNGLMULTIMODEDRAWELEMENTSIBMPROC __glewMultiModeDrawElementsIBM;

extern __declspec(dllimport) PFNGLCOLORPOINTERLISTIBMPROC __glewColorPointerListIBM;
extern __declspec(dllimport) PFNGLEDGEFLAGPOINTERLISTIBMPROC __glewEdgeFlagPointerListIBM;
extern __declspec(dllimport) PFNGLFOGCOORDPOINTERLISTIBMPROC __glewFogCoordPointerListIBM;
extern __declspec(dllimport) PFNGLINDEXPOINTERLISTIBMPROC __glewIndexPointerListIBM;
extern __declspec(dllimport) PFNGLNORMALPOINTERLISTIBMPROC __glewNormalPointerListIBM;
extern __declspec(dllimport) PFNGLSECONDARYCOLORPOINTERLISTIBMPROC __glewSecondaryColorPointerListIBM;
extern __declspec(dllimport) PFNGLTEXCOORDPOINTERLISTIBMPROC __glewTexCoordPointerListIBM;
extern __declspec(dllimport) PFNGLVERTEXPOINTERLISTIBMPROC __glewVertexPointerListIBM;

extern __declspec(dllimport) PFNGLMAPTEXTURE2DINTELPROC __glewMapTexture2DINTEL;
extern __declspec(dllimport) PFNGLSYNCTEXTUREINTELPROC __glewSyncTextureINTEL;
extern __declspec(dllimport) PFNGLUNMAPTEXTURE2DINTELPROC __glewUnmapTexture2DINTEL;

extern __declspec(dllimport) PFNGLCOLORPOINTERVINTELPROC __glewColorPointervINTEL;
extern __declspec(dllimport) PFNGLNORMALPOINTERVINTELPROC __glewNormalPointervINTEL;
extern __declspec(dllimport) PFNGLTEXCOORDPOINTERVINTELPROC __glewTexCoordPointervINTEL;
extern __declspec(dllimport) PFNGLVERTEXPOINTERVINTELPROC __glewVertexPointervINTEL;

extern __declspec(dllimport) PFNGLTEXSCISSORFUNCINTELPROC __glewTexScissorFuncINTEL;
extern __declspec(dllimport) PFNGLTEXSCISSORINTELPROC __glewTexScissorINTEL;

extern __declspec(dllimport) PFNGLDEBUGMESSAGECALLBACKPROC __glewDebugMessageCallback;
extern __declspec(dllimport) PFNGLDEBUGMESSAGECONTROLPROC __glewDebugMessageControl;
extern __declspec(dllimport) PFNGLDEBUGMESSAGEINSERTPROC __glewDebugMessageInsert;
extern __declspec(dllimport) PFNGLGETDEBUGMESSAGELOGPROC __glewGetDebugMessageLog;
extern __declspec(dllimport) PFNGLGETOBJECTLABELPROC __glewGetObjectLabel;
extern __declspec(dllimport) PFNGLGETOBJECTPTRLABELPROC __glewGetObjectPtrLabel;
extern __declspec(dllimport) PFNGLOBJECTLABELPROC __glewObjectLabel;
extern __declspec(dllimport) PFNGLOBJECTPTRLABELPROC __glewObjectPtrLabel;
extern __declspec(dllimport) PFNGLPOPDEBUGGROUPPROC __glewPopDebugGroup;
extern __declspec(dllimport) PFNGLPUSHDEBUGGROUPPROC __glewPushDebugGroup;

extern __declspec(dllimport) PFNGLBUFFERREGIONENABLEDPROC __glewBufferRegionEnabled;
extern __declspec(dllimport) PFNGLDELETEBUFFERREGIONPROC __glewDeleteBufferRegion;
extern __declspec(dllimport) PFNGLDRAWBUFFERREGIONPROC __glewDrawBufferRegion;
extern __declspec(dllimport) PFNGLNEWBUFFERREGIONPROC __glewNewBufferRegion;
extern __declspec(dllimport) PFNGLREADBUFFERREGIONPROC __glewReadBufferRegion;

extern __declspec(dllimport) PFNGLRESIZEBUFFERSMESAPROC __glewResizeBuffersMESA;

extern __declspec(dllimport) PFNGLWINDOWPOS2DMESAPROC __glewWindowPos2dMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2DVMESAPROC __glewWindowPos2dvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2FMESAPROC __glewWindowPos2fMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2FVMESAPROC __glewWindowPos2fvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2IMESAPROC __glewWindowPos2iMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2IVMESAPROC __glewWindowPos2ivMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2SMESAPROC __glewWindowPos2sMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2SVMESAPROC __glewWindowPos2svMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3DMESAPROC __glewWindowPos3dMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3DVMESAPROC __glewWindowPos3dvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3FMESAPROC __glewWindowPos3fMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3FVMESAPROC __glewWindowPos3fvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3IMESAPROC __glewWindowPos3iMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3IVMESAPROC __glewWindowPos3ivMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3SMESAPROC __glewWindowPos3sMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3SVMESAPROC __glewWindowPos3svMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4DMESAPROC __glewWindowPos4dMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4DVMESAPROC __glewWindowPos4dvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4FMESAPROC __glewWindowPos4fMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4FVMESAPROC __glewWindowPos4fvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4IMESAPROC __glewWindowPos4iMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4IVMESAPROC __glewWindowPos4ivMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4SMESAPROC __glewWindowPos4sMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4SVMESAPROC __glewWindowPos4svMESA;

extern __declspec(dllimport) PFNGLBEGINCONDITIONALRENDERNVXPROC __glewBeginConditionalRenderNVX;
extern __declspec(dllimport) PFNGLENDCONDITIONALRENDERNVXPROC __glewEndConditionalRenderNVX;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC __glewMultiDrawArraysIndirectBindlessNV;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC __glewMultiDrawElementsIndirectBindlessNV;

extern __declspec(dllimport) PFNGLGETIMAGEHANDLENVPROC __glewGetImageHandleNV;
extern __declspec(dllimport) PFNGLGETTEXTUREHANDLENVPROC __glewGetTextureHandleNV;
extern __declspec(dllimport) PFNGLGETTEXTURESAMPLERHANDLENVPROC __glewGetTextureSamplerHandleNV;
extern __declspec(dllimport) PFNGLISIMAGEHANDLERESIDENTNVPROC __glewIsImageHandleResidentNV;
extern __declspec(dllimport) PFNGLISTEXTUREHANDLERESIDENTNVPROC __glewIsTextureHandleResidentNV;
extern __declspec(dllimport) PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC __glewMakeImageHandleNonResidentNV;
extern __declspec(dllimport) PFNGLMAKEIMAGEHANDLERESIDENTNVPROC __glewMakeImageHandleResidentNV;
extern __declspec(dllimport) PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC __glewMakeTextureHandleNonResidentNV;
extern __declspec(dllimport) PFNGLMAKETEXTUREHANDLERESIDENTNVPROC __glewMakeTextureHandleResidentNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC __glewProgramUniformHandleui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC __glewProgramUniformHandleui64vNV;
extern __declspec(dllimport) PFNGLUNIFORMHANDLEUI64NVPROC __glewUniformHandleui64NV;
extern __declspec(dllimport) PFNGLUNIFORMHANDLEUI64VNVPROC __glewUniformHandleui64vNV;

extern __declspec(dllimport) PFNGLBLENDBARRIERNVPROC __glewBlendBarrierNV;
extern __declspec(dllimport) PFNGLBLENDPARAMETERINVPROC __glewBlendParameteriNV;

extern __declspec(dllimport) PFNGLBEGINCONDITIONALRENDERNVPROC __glewBeginConditionalRenderNV;
extern __declspec(dllimport) PFNGLENDCONDITIONALRENDERNVPROC __glewEndConditionalRenderNV;

extern __declspec(dllimport) PFNGLCOPYIMAGESUBDATANVPROC __glewCopyImageSubDataNV;

extern __declspec(dllimport) PFNGLCLEARDEPTHDNVPROC __glewClearDepthdNV;
extern __declspec(dllimport) PFNGLDEPTHBOUNDSDNVPROC __glewDepthBoundsdNV;
extern __declspec(dllimport) PFNGLDEPTHRANGEDNVPROC __glewDepthRangedNV;

extern __declspec(dllimport) PFNGLDRAWTEXTURENVPROC __glewDrawTextureNV;

extern __declspec(dllimport) PFNGLEVALMAPSNVPROC __glewEvalMapsNV;
extern __declspec(dllimport) PFNGLGETMAPATTRIBPARAMETERFVNVPROC __glewGetMapAttribParameterfvNV;
extern __declspec(dllimport) PFNGLGETMAPATTRIBPARAMETERIVNVPROC __glewGetMapAttribParameterivNV;
extern __declspec(dllimport) PFNGLGETMAPCONTROLPOINTSNVPROC __glewGetMapControlPointsNV;
extern __declspec(dllimport) PFNGLGETMAPPARAMETERFVNVPROC __glewGetMapParameterfvNV;
extern __declspec(dllimport) PFNGLGETMAPPARAMETERIVNVPROC __glewGetMapParameterivNV;
extern __declspec(dllimport) PFNGLMAPCONTROLPOINTSNVPROC __glewMapControlPointsNV;
extern __declspec(dllimport) PFNGLMAPPARAMETERFVNVPROC __glewMapParameterfvNV;
extern __declspec(dllimport) PFNGLMAPPARAMETERIVNVPROC __glewMapParameterivNV;

extern __declspec(dllimport) PFNGLGETMULTISAMPLEFVNVPROC __glewGetMultisamplefvNV;
extern __declspec(dllimport) PFNGLSAMPLEMASKINDEXEDNVPROC __glewSampleMaskIndexedNV;
extern __declspec(dllimport) PFNGLTEXRENDERBUFFERNVPROC __glewTexRenderbufferNV;

extern __declspec(dllimport) PFNGLDELETEFENCESNVPROC __glewDeleteFencesNV;
extern __declspec(dllimport) PFNGLFINISHFENCENVPROC __glewFinishFenceNV;
extern __declspec(dllimport) PFNGLGENFENCESNVPROC __glewGenFencesNV;
extern __declspec(dllimport) PFNGLGETFENCEIVNVPROC __glewGetFenceivNV;
extern __declspec(dllimport) PFNGLISFENCENVPROC __glewIsFenceNV;
extern __declspec(dllimport) PFNGLSETFENCENVPROC __glewSetFenceNV;
extern __declspec(dllimport) PFNGLTESTFENCENVPROC __glewTestFenceNV;

extern __declspec(dllimport) PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC __glewGetProgramNamedParameterdvNV;
extern __declspec(dllimport) PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC __glewGetProgramNamedParameterfvNV;
extern __declspec(dllimport) PFNGLPROGRAMNAMEDPARAMETER4DNVPROC __glewProgramNamedParameter4dNV;
extern __declspec(dllimport) PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC __glewProgramNamedParameter4dvNV;
extern __declspec(dllimport) PFNGLPROGRAMNAMEDPARAMETER4FNVPROC __glewProgramNamedParameter4fNV;
extern __declspec(dllimport) PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC __glewProgramNamedParameter4fvNV;

extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC __glewRenderbufferStorageMultisampleCoverageNV;

extern __declspec(dllimport) PFNGLPROGRAMVERTEXLIMITNVPROC __glewProgramVertexLimitNV;

extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERI4INVPROC __glewProgramEnvParameterI4iNV;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERI4IVNVPROC __glewProgramEnvParameterI4ivNV;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERI4UINVPROC __glewProgramEnvParameterI4uiNV;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERI4UIVNVPROC __glewProgramEnvParameterI4uivNV;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERSI4IVNVPROC __glewProgramEnvParametersI4ivNV;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC __glewProgramEnvParametersI4uivNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERI4INVPROC __glewProgramLocalParameterI4iNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC __glewProgramLocalParameterI4ivNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERI4UINVPROC __glewProgramLocalParameterI4uiNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC __glewProgramLocalParameterI4uivNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC __glewProgramLocalParametersI4ivNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC __glewProgramLocalParametersI4uivNV;

extern __declspec(dllimport) PFNGLGETUNIFORMI64VNVPROC __glewGetUniformi64vNV;
extern __declspec(dllimport) PFNGLGETUNIFORMUI64VNVPROC __glewGetUniformui64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1I64NVPROC __glewProgramUniform1i64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1I64VNVPROC __glewProgramUniform1i64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UI64NVPROC __glewProgramUniform1ui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UI64VNVPROC __glewProgramUniform1ui64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2I64NVPROC __glewProgramUniform2i64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2I64VNVPROC __glewProgramUniform2i64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UI64NVPROC __glewProgramUniform2ui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UI64VNVPROC __glewProgramUniform2ui64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3I64NVPROC __glewProgramUniform3i64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3I64VNVPROC __glewProgramUniform3i64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UI64NVPROC __glewProgramUniform3ui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UI64VNVPROC __glewProgramUniform3ui64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4I64NVPROC __glewProgramUniform4i64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4I64VNVPROC __glewProgramUniform4i64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UI64NVPROC __glewProgramUniform4ui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UI64VNVPROC __glewProgramUniform4ui64vNV;
extern __declspec(dllimport) PFNGLUNIFORM1I64NVPROC __glewUniform1i64NV;
extern __declspec(dllimport) PFNGLUNIFORM1I64VNVPROC __glewUniform1i64vNV;
extern __declspec(dllimport) PFNGLUNIFORM1UI64NVPROC __glewUniform1ui64NV;
extern __declspec(dllimport) PFNGLUNIFORM1UI64VNVPROC __glewUniform1ui64vNV;
extern __declspec(dllimport) PFNGLUNIFORM2I64NVPROC __glewUniform2i64NV;
extern __declspec(dllimport) PFNGLUNIFORM2I64VNVPROC __glewUniform2i64vNV;
extern __declspec(dllimport) PFNGLUNIFORM2UI64NVPROC __glewUniform2ui64NV;
extern __declspec(dllimport) PFNGLUNIFORM2UI64VNVPROC __glewUniform2ui64vNV;
extern __declspec(dllimport) PFNGLUNIFORM3I64NVPROC __glewUniform3i64NV;
extern __declspec(dllimport) PFNGLUNIFORM3I64VNVPROC __glewUniform3i64vNV;
extern __declspec(dllimport) PFNGLUNIFORM3UI64NVPROC __glewUniform3ui64NV;
extern __declspec(dllimport) PFNGLUNIFORM3UI64VNVPROC __glewUniform3ui64vNV;
extern __declspec(dllimport) PFNGLUNIFORM4I64NVPROC __glewUniform4i64NV;
extern __declspec(dllimport) PFNGLUNIFORM4I64VNVPROC __glewUniform4i64vNV;
extern __declspec(dllimport) PFNGLUNIFORM4UI64NVPROC __glewUniform4ui64NV;
extern __declspec(dllimport) PFNGLUNIFORM4UI64VNVPROC __glewUniform4ui64vNV;

extern __declspec(dllimport) PFNGLCOLOR3HNVPROC __glewColor3hNV;
extern __declspec(dllimport) PFNGLCOLOR3HVNVPROC __glewColor3hvNV;
extern __declspec(dllimport) PFNGLCOLOR4HNVPROC __glewColor4hNV;
extern __declspec(dllimport) PFNGLCOLOR4HVNVPROC __glewColor4hvNV;
extern __declspec(dllimport) PFNGLFOGCOORDHNVPROC __glewFogCoordhNV;
extern __declspec(dllimport) PFNGLFOGCOORDHVNVPROC __glewFogCoordhvNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1HNVPROC __glewMultiTexCoord1hNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1HVNVPROC __glewMultiTexCoord1hvNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2HNVPROC __glewMultiTexCoord2hNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2HVNVPROC __glewMultiTexCoord2hvNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3HNVPROC __glewMultiTexCoord3hNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3HVNVPROC __glewMultiTexCoord3hvNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4HNVPROC __glewMultiTexCoord4hNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4HVNVPROC __glewMultiTexCoord4hvNV;
extern __declspec(dllimport) PFNGLNORMAL3HNVPROC __glewNormal3hNV;
extern __declspec(dllimport) PFNGLNORMAL3HVNVPROC __glewNormal3hvNV;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3HNVPROC __glewSecondaryColor3hNV;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3HVNVPROC __glewSecondaryColor3hvNV;
extern __declspec(dllimport) PFNGLTEXCOORD1HNVPROC __glewTexCoord1hNV;
extern __declspec(dllimport) PFNGLTEXCOORD1HVNVPROC __glewTexCoord1hvNV;
extern __declspec(dllimport) PFNGLTEXCOORD2HNVPROC __glewTexCoord2hNV;
extern __declspec(dllimport) PFNGLTEXCOORD2HVNVPROC __glewTexCoord2hvNV;
extern __declspec(dllimport) PFNGLTEXCOORD3HNVPROC __glewTexCoord3hNV;
extern __declspec(dllimport) PFNGLTEXCOORD3HVNVPROC __glewTexCoord3hvNV;
extern __declspec(dllimport) PFNGLTEXCOORD4HNVPROC __glewTexCoord4hNV;
extern __declspec(dllimport) PFNGLTEXCOORD4HVNVPROC __glewTexCoord4hvNV;
extern __declspec(dllimport) PFNGLVERTEX2HNVPROC __glewVertex2hNV;
extern __declspec(dllimport) PFNGLVERTEX2HVNVPROC __glewVertex2hvNV;
extern __declspec(dllimport) PFNGLVERTEX3HNVPROC __glewVertex3hNV;
extern __declspec(dllimport) PFNGLVERTEX3HVNVPROC __glewVertex3hvNV;
extern __declspec(dllimport) PFNGLVERTEX4HNVPROC __glewVertex4hNV;
extern __declspec(dllimport) PFNGLVERTEX4HVNVPROC __glewVertex4hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1HNVPROC __glewVertexAttrib1hNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1HVNVPROC __glewVertexAttrib1hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2HNVPROC __glewVertexAttrib2hNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2HVNVPROC __glewVertexAttrib2hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3HNVPROC __glewVertexAttrib3hNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3HVNVPROC __glewVertexAttrib3hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4HNVPROC __glewVertexAttrib4hNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4HVNVPROC __glewVertexAttrib4hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS1HVNVPROC __glewVertexAttribs1hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS2HVNVPROC __glewVertexAttribs2hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS3HVNVPROC __glewVertexAttribs3hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS4HVNVPROC __glewVertexAttribs4hvNV;
extern __declspec(dllimport) PFNGLVERTEXWEIGHTHNVPROC __glewVertexWeighthNV;
extern __declspec(dllimport) PFNGLVERTEXWEIGHTHVNVPROC __glewVertexWeighthvNV;

extern __declspec(dllimport) PFNGLBEGINOCCLUSIONQUERYNVPROC __glewBeginOcclusionQueryNV;
extern __declspec(dllimport) PFNGLDELETEOCCLUSIONQUERIESNVPROC __glewDeleteOcclusionQueriesNV;
extern __declspec(dllimport) PFNGLENDOCCLUSIONQUERYNVPROC __glewEndOcclusionQueryNV;
extern __declspec(dllimport) PFNGLGENOCCLUSIONQUERIESNVPROC __glewGenOcclusionQueriesNV;
extern __declspec(dllimport) PFNGLGETOCCLUSIONQUERYIVNVPROC __glewGetOcclusionQueryivNV;
extern __declspec(dllimport) PFNGLGETOCCLUSIONQUERYUIVNVPROC __glewGetOcclusionQueryuivNV;
extern __declspec(dllimport) PFNGLISOCCLUSIONQUERYNVPROC __glewIsOcclusionQueryNV;

extern __declspec(dllimport) PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC __glewProgramBufferParametersIivNV;
extern __declspec(dllimport) PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC __glewProgramBufferParametersIuivNV;
extern __declspec(dllimport) PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC __glewProgramBufferParametersfvNV;

extern __declspec(dllimport) PFNGLCOPYPATHNVPROC __glewCopyPathNV;
extern __declspec(dllimport) PFNGLCOVERFILLPATHINSTANCEDNVPROC __glewCoverFillPathInstancedNV;
extern __declspec(dllimport) PFNGLCOVERFILLPATHNVPROC __glewCoverFillPathNV;
extern __declspec(dllimport) PFNGLCOVERSTROKEPATHINSTANCEDNVPROC __glewCoverStrokePathInstancedNV;
extern __declspec(dllimport) PFNGLCOVERSTROKEPATHNVPROC __glewCoverStrokePathNV;
extern __declspec(dllimport) PFNGLDELETEPATHSNVPROC __glewDeletePathsNV;
extern __declspec(dllimport) PFNGLGENPATHSNVPROC __glewGenPathsNV;
extern __declspec(dllimport) PFNGLGETPATHCOLORGENFVNVPROC __glewGetPathColorGenfvNV;
extern __declspec(dllimport) PFNGLGETPATHCOLORGENIVNVPROC __glewGetPathColorGenivNV;
extern __declspec(dllimport) PFNGLGETPATHCOMMANDSNVPROC __glewGetPathCommandsNV;
extern __declspec(dllimport) PFNGLGETPATHCOORDSNVPROC __glewGetPathCoordsNV;
extern __declspec(dllimport) PFNGLGETPATHDASHARRAYNVPROC __glewGetPathDashArrayNV;
extern __declspec(dllimport) PFNGLGETPATHLENGTHNVPROC __glewGetPathLengthNV;
extern __declspec(dllimport) PFNGLGETPATHMETRICRANGENVPROC __glewGetPathMetricRangeNV;
extern __declspec(dllimport) PFNGLGETPATHMETRICSNVPROC __glewGetPathMetricsNV;
extern __declspec(dllimport) PFNGLGETPATHPARAMETERFVNVPROC __glewGetPathParameterfvNV;
extern __declspec(dllimport) PFNGLGETPATHPARAMETERIVNVPROC __glewGetPathParameterivNV;
extern __declspec(dllimport) PFNGLGETPATHSPACINGNVPROC __glewGetPathSpacingNV;
extern __declspec(dllimport) PFNGLGETPATHTEXGENFVNVPROC __glewGetPathTexGenfvNV;
extern __declspec(dllimport) PFNGLGETPATHTEXGENIVNVPROC __glewGetPathTexGenivNV;
extern __declspec(dllimport) PFNGLINTERPOLATEPATHSNVPROC __glewInterpolatePathsNV;
extern __declspec(dllimport) PFNGLISPATHNVPROC __glewIsPathNV;
extern __declspec(dllimport) PFNGLISPOINTINFILLPATHNVPROC __glewIsPointInFillPathNV;
extern __declspec(dllimport) PFNGLISPOINTINSTROKEPATHNVPROC __glewIsPointInStrokePathNV;
extern __declspec(dllimport) PFNGLPATHCOLORGENNVPROC __glewPathColorGenNV;
extern __declspec(dllimport) PFNGLPATHCOMMANDSNVPROC __glewPathCommandsNV;
extern __declspec(dllimport) PFNGLPATHCOORDSNVPROC __glewPathCoordsNV;
extern __declspec(dllimport) PFNGLPATHCOVERDEPTHFUNCNVPROC __glewPathCoverDepthFuncNV;
extern __declspec(dllimport) PFNGLPATHDASHARRAYNVPROC __glewPathDashArrayNV;
extern __declspec(dllimport) PFNGLPATHFOGGENNVPROC __glewPathFogGenNV;
extern __declspec(dllimport) PFNGLPATHGLYPHRANGENVPROC __glewPathGlyphRangeNV;
extern __declspec(dllimport) PFNGLPATHGLYPHSNVPROC __glewPathGlyphsNV;
extern __declspec(dllimport) PFNGLPATHPARAMETERFNVPROC __glewPathParameterfNV;
extern __declspec(dllimport) PFNGLPATHPARAMETERFVNVPROC __glewPathParameterfvNV;
extern __declspec(dllimport) PFNGLPATHPARAMETERINVPROC __glewPathParameteriNV;
extern __declspec(dllimport) PFNGLPATHPARAMETERIVNVPROC __glewPathParameterivNV;
extern __declspec(dllimport) PFNGLPATHSTENCILDEPTHOFFSETNVPROC __glewPathStencilDepthOffsetNV;
extern __declspec(dllimport) PFNGLPATHSTENCILFUNCNVPROC __glewPathStencilFuncNV;
extern __declspec(dllimport) PFNGLPATHSTRINGNVPROC __glewPathStringNV;
extern __declspec(dllimport) PFNGLPATHSUBCOMMANDSNVPROC __glewPathSubCommandsNV;
extern __declspec(dllimport) PFNGLPATHSUBCOORDSNVPROC __glewPathSubCoordsNV;
extern __declspec(dllimport) PFNGLPATHTEXGENNVPROC __glewPathTexGenNV;
extern __declspec(dllimport) PFNGLPOINTALONGPATHNVPROC __glewPointAlongPathNV;
extern __declspec(dllimport) PFNGLSTENCILFILLPATHINSTANCEDNVPROC __glewStencilFillPathInstancedNV;
extern __declspec(dllimport) PFNGLSTENCILFILLPATHNVPROC __glewStencilFillPathNV;
extern __declspec(dllimport) PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC __glewStencilStrokePathInstancedNV;
extern __declspec(dllimport) PFNGLSTENCILSTROKEPATHNVPROC __glewStencilStrokePathNV;
extern __declspec(dllimport) PFNGLTRANSFORMPATHNVPROC __glewTransformPathNV;
extern __declspec(dllimport) PFNGLWEIGHTPATHSNVPROC __glewWeightPathsNV;

extern __declspec(dllimport) PFNGLFLUSHPIXELDATARANGENVPROC __glewFlushPixelDataRangeNV;
extern __declspec(dllimport) PFNGLPIXELDATARANGENVPROC __glewPixelDataRangeNV;

extern __declspec(dllimport) PFNGLPOINTPARAMETERINVPROC __glewPointParameteriNV;
extern __declspec(dllimport) PFNGLPOINTPARAMETERIVNVPROC __glewPointParameterivNV;

extern __declspec(dllimport) PFNGLGETVIDEOI64VNVPROC __glewGetVideoi64vNV;
extern __declspec(dllimport) PFNGLGETVIDEOIVNVPROC __glewGetVideoivNV;
extern __declspec(dllimport) PFNGLGETVIDEOUI64VNVPROC __glewGetVideoui64vNV;
extern __declspec(dllimport) PFNGLGETVIDEOUIVNVPROC __glewGetVideouivNV;
extern __declspec(dllimport) PFNGLPRESENTFRAMEDUALFILLNVPROC __glewPresentFrameDualFillNV;
extern __declspec(dllimport) PFNGLPRESENTFRAMEKEYEDNVPROC __glewPresentFrameKeyedNV;

extern __declspec(dllimport) PFNGLPRIMITIVERESTARTINDEXNVPROC __glewPrimitiveRestartIndexNV;
extern __declspec(dllimport) PFNGLPRIMITIVERESTARTNVPROC __glewPrimitiveRestartNV;

extern __declspec(dllimport) PFNGLCOMBINERINPUTNVPROC __glewCombinerInputNV;
extern __declspec(dllimport) PFNGLCOMBINEROUTPUTNVPROC __glewCombinerOutputNV;
extern __declspec(dllimport) PFNGLCOMBINERPARAMETERFNVPROC __glewCombinerParameterfNV;
extern __declspec(dllimport) PFNGLCOMBINERPARAMETERFVNVPROC __glewCombinerParameterfvNV;
extern __declspec(dllimport) PFNGLCOMBINERPARAMETERINVPROC __glewCombinerParameteriNV;
extern __declspec(dllimport) PFNGLCOMBINERPARAMETERIVNVPROC __glewCombinerParameterivNV;
extern __declspec(dllimport) PFNGLFINALCOMBINERINPUTNVPROC __glewFinalCombinerInputNV;
extern __declspec(dllimport) PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC __glewGetCombinerInputParameterfvNV;
extern __declspec(dllimport) PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC __glewGetCombinerInputParameterivNV;
extern __declspec(dllimport) PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC __glewGetCombinerOutputParameterfvNV;
extern __declspec(dllimport) PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC __glewGetCombinerOutputParameterivNV;
extern __declspec(dllimport) PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC __glewGetFinalCombinerInputParameterfvNV;
extern __declspec(dllimport) PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC __glewGetFinalCombinerInputParameterivNV;

extern __declspec(dllimport) PFNGLCOMBINERSTAGEPARAMETERFVNVPROC __glewCombinerStageParameterfvNV;
extern __declspec(dllimport) PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC __glewGetCombinerStageParameterfvNV;

extern __declspec(dllimport) PFNGLGETBUFFERPARAMETERUI64VNVPROC __glewGetBufferParameterui64vNV;
extern __declspec(dllimport) PFNGLGETINTEGERUI64VNVPROC __glewGetIntegerui64vNV;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC __glewGetNamedBufferParameterui64vNV;
extern __declspec(dllimport) PFNGLISBUFFERRESIDENTNVPROC __glewIsBufferResidentNV;
extern __declspec(dllimport) PFNGLISNAMEDBUFFERRESIDENTNVPROC __glewIsNamedBufferResidentNV;
extern __declspec(dllimport) PFNGLMAKEBUFFERNONRESIDENTNVPROC __glewMakeBufferNonResidentNV;
extern __declspec(dllimport) PFNGLMAKEBUFFERRESIDENTNVPROC __glewMakeBufferResidentNV;
extern __declspec(dllimport) PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC __glewMakeNamedBufferNonResidentNV;
extern __declspec(dllimport) PFNGLMAKENAMEDBUFFERRESIDENTNVPROC __glewMakeNamedBufferResidentNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMUI64NVPROC __glewProgramUniformui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMUI64VNVPROC __glewProgramUniformui64vNV;
extern __declspec(dllimport) PFNGLUNIFORMUI64NVPROC __glewUniformui64NV;
extern __declspec(dllimport) PFNGLUNIFORMUI64VNVPROC __glewUniformui64vNV;

extern __declspec(dllimport) PFNGLTEXTUREBARRIERNVPROC __glewTextureBarrierNV;

extern __declspec(dllimport) PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTexImage2DMultisampleCoverageNV;
extern __declspec(dllimport) PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTexImage3DMultisampleCoverageNV;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTextureImage2DMultisampleCoverageNV;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC __glewTextureImage2DMultisampleNV;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTextureImage3DMultisampleCoverageNV;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC __glewTextureImage3DMultisampleNV;

extern __declspec(dllimport) PFNGLACTIVEVARYINGNVPROC __glewActiveVaryingNV;
extern __declspec(dllimport) PFNGLBEGINTRANSFORMFEEDBACKNVPROC __glewBeginTransformFeedbackNV;
extern __declspec(dllimport) PFNGLBINDBUFFERBASENVPROC __glewBindBufferBaseNV;
extern __declspec(dllimport) PFNGLBINDBUFFEROFFSETNVPROC __glewBindBufferOffsetNV;
extern __declspec(dllimport) PFNGLBINDBUFFERRANGENVPROC __glewBindBufferRangeNV;
extern __declspec(dllimport) PFNGLENDTRANSFORMFEEDBACKNVPROC __glewEndTransformFeedbackNV;
extern __declspec(dllimport) PFNGLGETACTIVEVARYINGNVPROC __glewGetActiveVaryingNV;
extern __declspec(dllimport) PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC __glewGetTransformFeedbackVaryingNV;
extern __declspec(dllimport) PFNGLGETVARYINGLOCATIONNVPROC __glewGetVaryingLocationNV;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC __glewTransformFeedbackAttribsNV;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC __glewTransformFeedbackVaryingsNV;

extern __declspec(dllimport) PFNGLBINDTRANSFORMFEEDBACKNVPROC __glewBindTransformFeedbackNV;
extern __declspec(dllimport) PFNGLDELETETRANSFORMFEEDBACKSNVPROC __glewDeleteTransformFeedbacksNV;
extern __declspec(dllimport) PFNGLDRAWTRANSFORMFEEDBACKNVPROC __glewDrawTransformFeedbackNV;
extern __declspec(dllimport) PFNGLGENTRANSFORMFEEDBACKSNVPROC __glewGenTransformFeedbacksNV;
extern __declspec(dllimport) PFNGLISTRANSFORMFEEDBACKNVPROC __glewIsTransformFeedbackNV;
extern __declspec(dllimport) PFNGLPAUSETRANSFORMFEEDBACKNVPROC __glewPauseTransformFeedbackNV;
extern __declspec(dllimport) PFNGLRESUMETRANSFORMFEEDBACKNVPROC __glewResumeTransformFeedbackNV;

extern __declspec(dllimport) PFNGLVDPAUFININVPROC __glewVDPAUFiniNV;
extern __declspec(dllimport) PFNGLVDPAUGETSURFACEIVNVPROC __glewVDPAUGetSurfaceivNV;
extern __declspec(dllimport) PFNGLVDPAUINITNVPROC __glewVDPAUInitNV;
extern __declspec(dllimport) PFNGLVDPAUISSURFACENVPROC __glewVDPAUIsSurfaceNV;
extern __declspec(dllimport) PFNGLVDPAUMAPSURFACESNVPROC __glewVDPAUMapSurfacesNV;
extern __declspec(dllimport) PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC __glewVDPAURegisterOutputSurfaceNV;
extern __declspec(dllimport) PFNGLVDPAUREGISTERVIDEOSURFACENVPROC __glewVDPAURegisterVideoSurfaceNV;
extern __declspec(dllimport) PFNGLVDPAUSURFACEACCESSNVPROC __glewVDPAUSurfaceAccessNV;
extern __declspec(dllimport) PFNGLVDPAUUNMAPSURFACESNVPROC __glewVDPAUUnmapSurfacesNV;
extern __declspec(dllimport) PFNGLVDPAUUNREGISTERSURFACENVPROC __glewVDPAUUnregisterSurfaceNV;

extern __declspec(dllimport) PFNGLFLUSHVERTEXARRAYRANGENVPROC __glewFlushVertexArrayRangeNV;
extern __declspec(dllimport) PFNGLVERTEXARRAYRANGENVPROC __glewVertexArrayRangeNV;

extern __declspec(dllimport) PFNGLGETVERTEXATTRIBLI64VNVPROC __glewGetVertexAttribLi64vNV;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBLUI64VNVPROC __glewGetVertexAttribLui64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1I64NVPROC __glewVertexAttribL1i64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1I64VNVPROC __glewVertexAttribL1i64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1UI64NVPROC __glewVertexAttribL1ui64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1UI64VNVPROC __glewVertexAttribL1ui64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2I64NVPROC __glewVertexAttribL2i64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2I64VNVPROC __glewVertexAttribL2i64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2UI64NVPROC __glewVertexAttribL2ui64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2UI64VNVPROC __glewVertexAttribL2ui64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3I64NVPROC __glewVertexAttribL3i64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3I64VNVPROC __glewVertexAttribL3i64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3UI64NVPROC __glewVertexAttribL3ui64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3UI64VNVPROC __glewVertexAttribL3ui64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4I64NVPROC __glewVertexAttribL4i64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4I64VNVPROC __glewVertexAttribL4i64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4UI64NVPROC __glewVertexAttribL4ui64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4UI64VNVPROC __glewVertexAttribL4ui64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBLFORMATNVPROC __glewVertexAttribLFormatNV;

extern __declspec(dllimport) PFNGLBUFFERADDRESSRANGENVPROC __glewBufferAddressRangeNV;
extern __declspec(dllimport) PFNGLCOLORFORMATNVPROC __glewColorFormatNV;
extern __declspec(dllimport) PFNGLEDGEFLAGFORMATNVPROC __glewEdgeFlagFormatNV;
extern __declspec(dllimport) PFNGLFOGCOORDFORMATNVPROC __glewFogCoordFormatNV;
extern __declspec(dllimport) PFNGLGETINTEGERUI64I_VNVPROC __glewGetIntegerui64i_vNV;
extern __declspec(dllimport) PFNGLINDEXFORMATNVPROC __glewIndexFormatNV;
extern __declspec(dllimport) PFNGLNORMALFORMATNVPROC __glewNormalFormatNV;
extern __declspec(dllimport) PFNGLSECONDARYCOLORFORMATNVPROC __glewSecondaryColorFormatNV;
extern __declspec(dllimport) PFNGLTEXCOORDFORMATNVPROC __glewTexCoordFormatNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBFORMATNVPROC __glewVertexAttribFormatNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBIFORMATNVPROC __glewVertexAttribIFormatNV;
extern __declspec(dllimport) PFNGLVERTEXFORMATNVPROC __glewVertexFormatNV;

extern __declspec(dllimport) PFNGLAREPROGRAMSRESIDENTNVPROC __glewAreProgramsResidentNV;
extern __declspec(dllimport) PFNGLBINDPROGRAMNVPROC __glewBindProgramNV;
extern __declspec(dllimport) PFNGLDELETEPROGRAMSNVPROC __glewDeleteProgramsNV;
extern __declspec(dllimport) PFNGLEXECUTEPROGRAMNVPROC __glewExecuteProgramNV;
extern __declspec(dllimport) PFNGLGENPROGRAMSNVPROC __glewGenProgramsNV;
extern __declspec(dllimport) PFNGLGETPROGRAMPARAMETERDVNVPROC __glewGetProgramParameterdvNV;
extern __declspec(dllimport) PFNGLGETPROGRAMPARAMETERFVNVPROC __glewGetProgramParameterfvNV;
extern __declspec(dllimport) PFNGLGETPROGRAMSTRINGNVPROC __glewGetProgramStringNV;
extern __declspec(dllimport) PFNGLGETPROGRAMIVNVPROC __glewGetProgramivNV;
extern __declspec(dllimport) PFNGLGETTRACKMATRIXIVNVPROC __glewGetTrackMatrixivNV;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBPOINTERVNVPROC __glewGetVertexAttribPointervNV;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBDVNVPROC __glewGetVertexAttribdvNV;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBFVNVPROC __glewGetVertexAttribfvNV;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIVNVPROC __glewGetVertexAttribivNV;
extern __declspec(dllimport) PFNGLISPROGRAMNVPROC __glewIsProgramNV;
extern __declspec(dllimport) PFNGLLOADPROGRAMNVPROC __glewLoadProgramNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETER4DNVPROC __glewProgramParameter4dNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETER4DVNVPROC __glewProgramParameter4dvNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETER4FNVPROC __glewProgramParameter4fNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETER4FVNVPROC __glewProgramParameter4fvNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETERS4DVNVPROC __glewProgramParameters4dvNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETERS4FVNVPROC __glewProgramParameters4fvNV;
extern __declspec(dllimport) PFNGLREQUESTRESIDENTPROGRAMSNVPROC __glewRequestResidentProgramsNV;
extern __declspec(dllimport) PFNGLTRACKMATRIXNVPROC __glewTrackMatrixNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DNVPROC __glewVertexAttrib1dNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DVNVPROC __glewVertexAttrib1dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FNVPROC __glewVertexAttrib1fNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FVNVPROC __glewVertexAttrib1fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SNVPROC __glewVertexAttrib1sNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SVNVPROC __glewVertexAttrib1svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DNVPROC __glewVertexAttrib2dNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DVNVPROC __glewVertexAttrib2dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FNVPROC __glewVertexAttrib2fNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FVNVPROC __glewVertexAttrib2fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SNVPROC __glewVertexAttrib2sNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SVNVPROC __glewVertexAttrib2svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DNVPROC __glewVertexAttrib3dNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DVNVPROC __glewVertexAttrib3dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FNVPROC __glewVertexAttrib3fNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FVNVPROC __glewVertexAttrib3fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SNVPROC __glewVertexAttrib3sNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SVNVPROC __glewVertexAttrib3svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DNVPROC __glewVertexAttrib4dNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DVNVPROC __glewVertexAttrib4dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FNVPROC __glewVertexAttrib4fNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FVNVPROC __glewVertexAttrib4fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SNVPROC __glewVertexAttrib4sNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SVNVPROC __glewVertexAttrib4svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UBNVPROC __glewVertexAttrib4ubNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UBVNVPROC __glewVertexAttrib4ubvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBPOINTERNVPROC __glewVertexAttribPointerNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS1DVNVPROC __glewVertexAttribs1dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS1FVNVPROC __glewVertexAttribs1fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS1SVNVPROC __glewVertexAttribs1svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS2DVNVPROC __glewVertexAttribs2dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS2FVNVPROC __glewVertexAttribs2fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS2SVNVPROC __glewVertexAttribs2svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS3DVNVPROC __glewVertexAttribs3dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS3FVNVPROC __glewVertexAttribs3fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS3SVNVPROC __glewVertexAttribs3svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS4DVNVPROC __glewVertexAttribs4dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS4FVNVPROC __glewVertexAttribs4fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS4SVNVPROC __glewVertexAttribs4svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS4UBVNVPROC __glewVertexAttribs4ubvNV;

extern __declspec(dllimport) PFNGLBEGINVIDEOCAPTURENVPROC __glewBeginVideoCaptureNV;
extern __declspec(dllimport) PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC __glewBindVideoCaptureStreamBufferNV;
extern __declspec(dllimport) PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC __glewBindVideoCaptureStreamTextureNV;
extern __declspec(dllimport) PFNGLENDVIDEOCAPTURENVPROC __glewEndVideoCaptureNV;
extern __declspec(dllimport) PFNGLGETVIDEOCAPTURESTREAMDVNVPROC __glewGetVideoCaptureStreamdvNV;
extern __declspec(dllimport) PFNGLGETVIDEOCAPTURESTREAMFVNVPROC __glewGetVideoCaptureStreamfvNV;
extern __declspec(dllimport) PFNGLGETVIDEOCAPTURESTREAMIVNVPROC __glewGetVideoCaptureStreamivNV;
extern __declspec(dllimport) PFNGLGETVIDEOCAPTUREIVNVPROC __glewGetVideoCaptureivNV;
extern __declspec(dllimport) PFNGLVIDEOCAPTURENVPROC __glewVideoCaptureNV;
extern __declspec(dllimport) PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC __glewVideoCaptureStreamParameterdvNV;
extern __declspec(dllimport) PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC __glewVideoCaptureStreamParameterfvNV;
extern __declspec(dllimport) PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC __glewVideoCaptureStreamParameterivNV;

extern __declspec(dllimport) PFNGLCLEARDEPTHFOESPROC __glewClearDepthfOES;
extern __declspec(dllimport) PFNGLCLIPPLANEFOESPROC __glewClipPlanefOES;
extern __declspec(dllimport) PFNGLDEPTHRANGEFOESPROC __glewDepthRangefOES;
extern __declspec(dllimport) PFNGLFRUSTUMFOESPROC __glewFrustumfOES;
extern __declspec(dllimport) PFNGLGETCLIPPLANEFOESPROC __glewGetClipPlanefOES;
extern __declspec(dllimport) PFNGLORTHOFOESPROC __glewOrthofOES;

extern __declspec(dllimport) PFNGLALPHAFUNCXPROC __glewAlphaFuncx;
extern __declspec(dllimport) PFNGLCLEARCOLORXPROC __glewClearColorx;
extern __declspec(dllimport) PFNGLCLEARDEPTHXPROC __glewClearDepthx;
extern __declspec(dllimport) PFNGLCOLOR4XPROC __glewColor4x;
extern __declspec(dllimport) PFNGLDEPTHRANGEXPROC __glewDepthRangex;
extern __declspec(dllimport) PFNGLFOGXPROC __glewFogx;
extern __declspec(dllimport) PFNGLFOGXVPROC __glewFogxv;
extern __declspec(dllimport) PFNGLFRUSTUMFPROC __glewFrustumf;
extern __declspec(dllimport) PFNGLFRUSTUMXPROC __glewFrustumx;
extern __declspec(dllimport) PFNGLLIGHTMODELXPROC __glewLightModelx;
extern __declspec(dllimport) PFNGLLIGHTMODELXVPROC __glewLightModelxv;
extern __declspec(dllimport) PFNGLLIGHTXPROC __glewLightx;
extern __declspec(dllimport) PFNGLLIGHTXVPROC __glewLightxv;
extern __declspec(dllimport) PFNGLLINEWIDTHXPROC __glewLineWidthx;
extern __declspec(dllimport) PFNGLLOADMATRIXXPROC __glewLoadMatrixx;
extern __declspec(dllimport) PFNGLMATERIALXPROC __glewMaterialx;
extern __declspec(dllimport) PFNGLMATERIALXVPROC __glewMaterialxv;
extern __declspec(dllimport) PFNGLMULTMATRIXXPROC __glewMultMatrixx;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4XPROC __glewMultiTexCoord4x;
extern __declspec(dllimport) PFNGLNORMAL3XPROC __glewNormal3x;
extern __declspec(dllimport) PFNGLORTHOFPROC __glewOrthof;
extern __declspec(dllimport) PFNGLORTHOXPROC __glewOrthox;
extern __declspec(dllimport) PFNGLPOINTSIZEXPROC __glewPointSizex;
extern __declspec(dllimport) PFNGLPOLYGONOFFSETXPROC __glewPolygonOffsetx;
extern __declspec(dllimport) PFNGLROTATEXPROC __glewRotatex;
extern __declspec(dllimport) PFNGLSAMPLECOVERAGEXPROC __glewSampleCoveragex;
extern __declspec(dllimport) PFNGLSCALEXPROC __glewScalex;
extern __declspec(dllimport) PFNGLTEXENVXPROC __glewTexEnvx;
extern __declspec(dllimport) PFNGLTEXENVXVPROC __glewTexEnvxv;
extern __declspec(dllimport) PFNGLTEXPARAMETERXPROC __glewTexParameterx;
extern __declspec(dllimport) PFNGLTRANSLATEXPROC __glewTranslatex;

extern __declspec(dllimport) PFNGLCLIPPLANEFPROC __glewClipPlanef;
extern __declspec(dllimport) PFNGLCLIPPLANEXPROC __glewClipPlanex;
extern __declspec(dllimport) PFNGLGETCLIPPLANEFPROC __glewGetClipPlanef;
extern __declspec(dllimport) PFNGLGETCLIPPLANEXPROC __glewGetClipPlanex;
extern __declspec(dllimport) PFNGLGETFIXEDVPROC __glewGetFixedv;
extern __declspec(dllimport) PFNGLGETLIGHTXVPROC __glewGetLightxv;
extern __declspec(dllimport) PFNGLGETMATERIALXVPROC __glewGetMaterialxv;
extern __declspec(dllimport) PFNGLGETTEXENVXVPROC __glewGetTexEnvxv;
extern __declspec(dllimport) PFNGLGETTEXPARAMETERXVPROC __glewGetTexParameterxv;
extern __declspec(dllimport) PFNGLPOINTPARAMETERXPROC __glewPointParameterx;
extern __declspec(dllimport) PFNGLPOINTPARAMETERXVPROC __glewPointParameterxv;
extern __declspec(dllimport) PFNGLPOINTSIZEPOINTEROESPROC __glewPointSizePointerOES;
extern __declspec(dllimport) PFNGLTEXPARAMETERXVPROC __glewTexParameterxv;

extern __declspec(dllimport) PFNGLERRORSTRINGREGALPROC __glewErrorStringREGAL;

extern __declspec(dllimport) PFNGLGETEXTENSIONREGALPROC __glewGetExtensionREGAL;
extern __declspec(dllimport) PFNGLISSUPPORTEDREGALPROC __glewIsSupportedREGAL;

extern __declspec(dllimport) PFNGLLOGMESSAGECALLBACKREGALPROC __glewLogMessageCallbackREGAL;

extern __declspec(dllimport) PFNGLDETAILTEXFUNCSGISPROC __glewDetailTexFuncSGIS;
extern __declspec(dllimport) PFNGLGETDETAILTEXFUNCSGISPROC __glewGetDetailTexFuncSGIS;

extern __declspec(dllimport) PFNGLFOGFUNCSGISPROC __glewFogFuncSGIS;
extern __declspec(dllimport) PFNGLGETFOGFUNCSGISPROC __glewGetFogFuncSGIS;

extern __declspec(dllimport) PFNGLSAMPLEMASKSGISPROC __glewSampleMaskSGIS;
extern __declspec(dllimport) PFNGLSAMPLEPATTERNSGISPROC __glewSamplePatternSGIS;

extern __declspec(dllimport) PFNGLGETSHARPENTEXFUNCSGISPROC __glewGetSharpenTexFuncSGIS;
extern __declspec(dllimport) PFNGLSHARPENTEXFUNCSGISPROC __glewSharpenTexFuncSGIS;

extern __declspec(dllimport) PFNGLTEXIMAGE4DSGISPROC __glewTexImage4DSGIS;
extern __declspec(dllimport) PFNGLTEXSUBIMAGE4DSGISPROC __glewTexSubImage4DSGIS;

extern __declspec(dllimport) PFNGLGETTEXFILTERFUNCSGISPROC __glewGetTexFilterFuncSGIS;
extern __declspec(dllimport) PFNGLTEXFILTERFUNCSGISPROC __glewTexFilterFuncSGIS;

extern __declspec(dllimport) PFNGLASYNCMARKERSGIXPROC __glewAsyncMarkerSGIX;
extern __declspec(dllimport) PFNGLDELETEASYNCMARKERSSGIXPROC __glewDeleteAsyncMarkersSGIX;
extern __declspec(dllimport) PFNGLFINISHASYNCSGIXPROC __glewFinishAsyncSGIX;
extern __declspec(dllimport) PFNGLGENASYNCMARKERSSGIXPROC __glewGenAsyncMarkersSGIX;
extern __declspec(dllimport) PFNGLISASYNCMARKERSGIXPROC __glewIsAsyncMarkerSGIX;
extern __declspec(dllimport) PFNGLPOLLASYNCSGIXPROC __glewPollAsyncSGIX;

extern __declspec(dllimport) PFNGLFLUSHRASTERSGIXPROC __glewFlushRasterSGIX;

extern __declspec(dllimport) PFNGLTEXTUREFOGSGIXPROC __glewTextureFogSGIX;

extern __declspec(dllimport) PFNGLFRAGMENTCOLORMATERIALSGIXPROC __glewFragmentColorMaterialSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELFSGIXPROC __glewFragmentLightModelfSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELFVSGIXPROC __glewFragmentLightModelfvSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELISGIXPROC __glewFragmentLightModeliSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELIVSGIXPROC __glewFragmentLightModelivSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTFSGIXPROC __glewFragmentLightfSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTFVSGIXPROC __glewFragmentLightfvSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTISGIXPROC __glewFragmentLightiSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTIVSGIXPROC __glewFragmentLightivSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALFSGIXPROC __glewFragmentMaterialfSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALFVSGIXPROC __glewFragmentMaterialfvSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALISGIXPROC __glewFragmentMaterialiSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALIVSGIXPROC __glewFragmentMaterialivSGIX;
extern __declspec(dllimport) PFNGLGETFRAGMENTLIGHTFVSGIXPROC __glewGetFragmentLightfvSGIX;
extern __declspec(dllimport) PFNGLGETFRAGMENTLIGHTIVSGIXPROC __glewGetFragmentLightivSGIX;
extern __declspec(dllimport) PFNGLGETFRAGMENTMATERIALFVSGIXPROC __glewGetFragmentMaterialfvSGIX;
extern __declspec(dllimport) PFNGLGETFRAGMENTMATERIALIVSGIXPROC __glewGetFragmentMaterialivSGIX;

extern __declspec(dllimport) PFNGLFRAMEZOOMSGIXPROC __glewFrameZoomSGIX;

extern __declspec(dllimport) PFNGLPIXELTEXGENSGIXPROC __glewPixelTexGenSGIX;

extern __declspec(dllimport) PFNGLREFERENCEPLANESGIXPROC __glewReferencePlaneSGIX;

extern __declspec(dllimport) PFNGLSPRITEPARAMETERFSGIXPROC __glewSpriteParameterfSGIX;
extern __declspec(dllimport) PFNGLSPRITEPARAMETERFVSGIXPROC __glewSpriteParameterfvSGIX;
extern __declspec(dllimport) PFNGLSPRITEPARAMETERISGIXPROC __glewSpriteParameteriSGIX;
extern __declspec(dllimport) PFNGLSPRITEPARAMETERIVSGIXPROC __glewSpriteParameterivSGIX;

extern __declspec(dllimport) PFNGLTAGSAMPLEBUFFERSGIXPROC __glewTagSampleBufferSGIX;

extern __declspec(dllimport) PFNGLCOLORTABLEPARAMETERFVSGIPROC __glewColorTableParameterfvSGI;
extern __declspec(dllimport) PFNGLCOLORTABLEPARAMETERIVSGIPROC __glewColorTableParameterivSGI;
extern __declspec(dllimport) PFNGLCOLORTABLESGIPROC __glewColorTableSGI;
extern __declspec(dllimport) PFNGLCOPYCOLORTABLESGIPROC __glewCopyColorTableSGI;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERFVSGIPROC __glewGetColorTableParameterfvSGI;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERIVSGIPROC __glewGetColorTableParameterivSGI;
extern __declspec(dllimport) PFNGLGETCOLORTABLESGIPROC __glewGetColorTableSGI;

extern __declspec(dllimport) PFNGLFINISHTEXTURESUNXPROC __glewFinishTextureSUNX;

extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORBSUNPROC __glewGlobalAlphaFactorbSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORDSUNPROC __glewGlobalAlphaFactordSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORFSUNPROC __glewGlobalAlphaFactorfSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORISUNPROC __glewGlobalAlphaFactoriSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORSSUNPROC __glewGlobalAlphaFactorsSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORUBSUNPROC __glewGlobalAlphaFactorubSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORUISUNPROC __glewGlobalAlphaFactoruiSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORUSSUNPROC __glewGlobalAlphaFactorusSUN;

extern __declspec(dllimport) PFNGLREADVIDEOPIXELSSUNPROC __glewReadVideoPixelsSUN;

extern __declspec(dllimport) PFNGLREPLACEMENTCODEPOINTERSUNPROC __glewReplacementCodePointerSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUBSUNPROC __glewReplacementCodeubSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUBVSUNPROC __glewReplacementCodeubvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUISUNPROC __glewReplacementCodeuiSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUIVSUNPROC __glewReplacementCodeuivSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUSSUNPROC __glewReplacementCodeusSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUSVSUNPROC __glewReplacementCodeusvSUN;

extern __declspec(dllimport) PFNGLCOLOR3FVERTEX3FSUNPROC __glewColor3fVertex3fSUN;
extern __declspec(dllimport) PFNGLCOLOR3FVERTEX3FVSUNPROC __glewColor3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewColor4fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewColor4fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLCOLOR4UBVERTEX2FSUNPROC __glewColor4ubVertex2fSUN;
extern __declspec(dllimport) PFNGLCOLOR4UBVERTEX2FVSUNPROC __glewColor4ubVertex2fvSUN;
extern __declspec(dllimport) PFNGLCOLOR4UBVERTEX3FSUNPROC __glewColor4ubVertex3fSUN;
extern __declspec(dllimport) PFNGLCOLOR4UBVERTEX3FVSUNPROC __glewColor4ubVertex3fvSUN;
extern __declspec(dllimport) PFNGLNORMAL3FVERTEX3FSUNPROC __glewNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLNORMAL3FVERTEX3FVSUNPROC __glewNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC __glewReplacementCodeuiColor3fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC __glewReplacementCodeuiColor4ubVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC __glewReplacementCodeuiColor4ubVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC __glewReplacementCodeuiVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC __glewReplacementCodeuiVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC __glewTexCoord2fColor3fVertex3fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC __glewTexCoord2fColor3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC __glewTexCoord2fColor4ubVertex3fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC __glewTexCoord2fColor4ubVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FVERTEX3FSUNPROC __glewTexCoord2fVertex3fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FVERTEX3FVSUNPROC __glewTexCoord2fVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD4FVERTEX4FSUNPROC __glewTexCoord4fVertex4fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD4FVERTEX4FVSUNPROC __glewTexCoord4fVertex4fvSUN;

extern __declspec(dllimport) PFNGLADDSWAPHINTRECTWINPROC __glewAddSwapHintRectWIN;




#line 17468 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_1;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_2;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_2_1;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_3;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_4;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_5;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_2_0;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_2_1;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_3_0;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_3_1;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_3_2;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_3_3;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_0;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_1;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_2;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_3;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_4;
extern __declspec(dllimport) GLboolean __GLEW_3DFX_multisample;
extern __declspec(dllimport) GLboolean __GLEW_3DFX_tbuffer;
extern __declspec(dllimport) GLboolean __GLEW_3DFX_texture_compression_FXT1;
extern __declspec(dllimport) GLboolean __GLEW_AMD_blend_minmax_factor;
extern __declspec(dllimport) GLboolean __GLEW_AMD_conservative_depth;
extern __declspec(dllimport) GLboolean __GLEW_AMD_debug_output;
extern __declspec(dllimport) GLboolean __GLEW_AMD_depth_clamp_separate;
extern __declspec(dllimport) GLboolean __GLEW_AMD_draw_buffers_blend;
extern __declspec(dllimport) GLboolean __GLEW_AMD_interleaved_elements;
extern __declspec(dllimport) GLboolean __GLEW_AMD_multi_draw_indirect;
extern __declspec(dllimport) GLboolean __GLEW_AMD_name_gen_delete;
extern __declspec(dllimport) GLboolean __GLEW_AMD_performance_monitor;
extern __declspec(dllimport) GLboolean __GLEW_AMD_pinned_memory;
extern __declspec(dllimport) GLboolean __GLEW_AMD_query_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_AMD_sample_positions;
extern __declspec(dllimport) GLboolean __GLEW_AMD_seamless_cubemap_per_texture;
extern __declspec(dllimport) GLboolean __GLEW_AMD_shader_stencil_export;
extern __declspec(dllimport) GLboolean __GLEW_AMD_shader_trinary_minmax;
extern __declspec(dllimport) GLboolean __GLEW_AMD_sparse_texture;
extern __declspec(dllimport) GLboolean __GLEW_AMD_stencil_operation_extended;
extern __declspec(dllimport) GLboolean __GLEW_AMD_texture_texture4;
extern __declspec(dllimport) GLboolean __GLEW_AMD_transform_feedback3_lines_triangles;
extern __declspec(dllimport) GLboolean __GLEW_AMD_vertex_shader_layer;
extern __declspec(dllimport) GLboolean __GLEW_AMD_vertex_shader_tessellator;
extern __declspec(dllimport) GLboolean __GLEW_AMD_vertex_shader_viewport_index;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_depth_texture;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_framebuffer_blit;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_framebuffer_multisample;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_instanced_arrays;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_pack_reverse_row_order;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_program_binary;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_texture_compression_dxt1;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_texture_compression_dxt3;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_texture_compression_dxt5;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_texture_usage;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_timer_query;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_translated_shader_source;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_aux_depth_stencil;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_client_storage;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_element_array;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_fence;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_float_pixels;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_flush_buffer_range;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_object_purgeable;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_pixel_buffer;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_rgb_422;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_row_bytes;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_specular_vector;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_texture_range;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_transform_hint;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_vertex_array_object;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_vertex_array_range;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_vertex_program_evaluators;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_ycbcr_422;
extern __declspec(dllimport) GLboolean __GLEW_ARB_ES2_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_ARB_ES3_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_ARB_arrays_of_arrays;
extern __declspec(dllimport) GLboolean __GLEW_ARB_base_instance;
extern __declspec(dllimport) GLboolean __GLEW_ARB_bindless_texture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_blend_func_extended;
extern __declspec(dllimport) GLboolean __GLEW_ARB_buffer_storage;
extern __declspec(dllimport) GLboolean __GLEW_ARB_cl_event;
extern __declspec(dllimport) GLboolean __GLEW_ARB_clear_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_clear_texture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_color_buffer_float;
extern __declspec(dllimport) GLboolean __GLEW_ARB_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_ARB_compressed_texture_pixel_storage;
extern __declspec(dllimport) GLboolean __GLEW_ARB_compute_shader;
extern __declspec(dllimport) GLboolean __GLEW_ARB_compute_variable_group_size;
extern __declspec(dllimport) GLboolean __GLEW_ARB_conservative_depth;
extern __declspec(dllimport) GLboolean __GLEW_ARB_copy_buffer;
extern __declspec(dllimport) GLboolean __GLEW_ARB_copy_image;
extern __declspec(dllimport) GLboolean __GLEW_ARB_debug_output;
extern __declspec(dllimport) GLboolean __GLEW_ARB_depth_buffer_float;
extern __declspec(dllimport) GLboolean __GLEW_ARB_depth_clamp;
extern __declspec(dllimport) GLboolean __GLEW_ARB_depth_texture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_draw_buffers;
extern __declspec(dllimport) GLboolean __GLEW_ARB_draw_buffers_blend;
extern __declspec(dllimport) GLboolean __GLEW_ARB_draw_elements_base_vertex;
extern __declspec(dllimport) GLboolean __GLEW_ARB_draw_indirect;
extern __declspec(dllimport) GLboolean __GLEW_ARB_draw_instanced;
extern __declspec(dllimport) GLboolean __GLEW_ARB_enhanced_layouts;
extern __declspec(dllimport) GLboolean __GLEW_ARB_explicit_attrib_location;
extern __declspec(dllimport) GLboolean __GLEW_ARB_explicit_uniform_location;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_coord_conventions;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_layer_viewport;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_program;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_program_shadow;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_shader;
extern __declspec(dllimport) GLboolean __GLEW_ARB_framebuffer_no_attachments;
extern __declspec(dllimport) GLboolean __GLEW_ARB_framebuffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_framebuffer_sRGB;
extern __declspec(dllimport) GLboolean __GLEW_ARB_geometry_shader4;
extern __declspec(dllimport) GLboolean __GLEW_ARB_get_program_binary;
extern __declspec(dllimport) GLboolean __GLEW_ARB_gpu_shader5;
extern __declspec(dllimport) GLboolean __GLEW_ARB_gpu_shader_fp64;
extern __declspec(dllimport) GLboolean __GLEW_ARB_half_float_pixel;
extern __declspec(dllimport) GLboolean __GLEW_ARB_half_float_vertex;
extern __declspec(dllimport) GLboolean __GLEW_ARB_imaging;
extern __declspec(dllimport) GLboolean __GLEW_ARB_indirect_parameters;
extern __declspec(dllimport) GLboolean __GLEW_ARB_instanced_arrays;
extern __declspec(dllimport) GLboolean __GLEW_ARB_internalformat_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_internalformat_query2;
extern __declspec(dllimport) GLboolean __GLEW_ARB_invalidate_subdata;
extern __declspec(dllimport) GLboolean __GLEW_ARB_map_buffer_alignment;
extern __declspec(dllimport) GLboolean __GLEW_ARB_map_buffer_range;
extern __declspec(dllimport) GLboolean __GLEW_ARB_matrix_palette;
extern __declspec(dllimport) GLboolean __GLEW_ARB_multi_bind;
extern __declspec(dllimport) GLboolean __GLEW_ARB_multi_draw_indirect;
extern __declspec(dllimport) GLboolean __GLEW_ARB_multisample;
extern __declspec(dllimport) GLboolean __GLEW_ARB_multitexture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_occlusion_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_occlusion_query2;
extern __declspec(dllimport) GLboolean __GLEW_ARB_pixel_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_point_parameters;
extern __declspec(dllimport) GLboolean __GLEW_ARB_point_sprite;
extern __declspec(dllimport) GLboolean __GLEW_ARB_program_interface_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_provoking_vertex;
extern __declspec(dllimport) GLboolean __GLEW_ARB_query_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_robust_buffer_access_behavior;
extern __declspec(dllimport) GLboolean __GLEW_ARB_robustness;
extern __declspec(dllimport) GLboolean __GLEW_ARB_robustness_application_isolation;
extern __declspec(dllimport) GLboolean __GLEW_ARB_robustness_share_group_isolation;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sample_shading;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sampler_objects;
extern __declspec(dllimport) GLboolean __GLEW_ARB_seamless_cube_map;
extern __declspec(dllimport) GLboolean __GLEW_ARB_seamless_cubemap_per_texture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_separate_shader_objects;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_atomic_counters;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_bit_encoding;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_draw_parameters;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_group_vote;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_image_load_store;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_image_size;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_objects;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_precision;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_stencil_export;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_storage_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_subroutine;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_texture_lod;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shading_language_100;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shading_language_420pack;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shading_language_include;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shading_language_packing;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shadow;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shadow_ambient;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sparse_texture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_stencil_texturing;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sync;
extern __declspec(dllimport) GLboolean __GLEW_ARB_tessellation_shader;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_border_clamp;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_buffer_object_rgb32;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_buffer_range;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_compression;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_compression_bptc;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_compression_rgtc;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_cube_map;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_cube_map_array;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_env_add;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_env_combine;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_env_crossbar;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_env_dot3;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_float;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_gather;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_mirror_clamp_to_edge;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_mirrored_repeat;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_multisample;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_non_power_of_two;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_query_levels;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_query_lod;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_rectangle;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_rg;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_rgb10_a2ui;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_stencil8;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_storage;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_storage_multisample;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_swizzle;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_view;
extern __declspec(dllimport) GLboolean __GLEW_ARB_timer_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_transform_feedback2;
extern __declspec(dllimport) GLboolean __GLEW_ARB_transform_feedback3;
extern __declspec(dllimport) GLboolean __GLEW_ARB_transform_feedback_instanced;
extern __declspec(dllimport) GLboolean __GLEW_ARB_transpose_matrix;
extern __declspec(dllimport) GLboolean __GLEW_ARB_uniform_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_array_bgra;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_array_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_attrib_64bit;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_attrib_binding;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_blend;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_program;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_shader;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_type_10f_11f_11f_rev;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_type_2_10_10_10_rev;
extern __declspec(dllimport) GLboolean __GLEW_ARB_viewport_array;
extern __declspec(dllimport) GLboolean __GLEW_ARB_window_pos;
extern __declspec(dllimport) GLboolean __GLEW_ATIX_point_sprites;
extern __declspec(dllimport) GLboolean __GLEW_ATIX_texture_env_combine3;
extern __declspec(dllimport) GLboolean __GLEW_ATIX_texture_env_route;
extern __declspec(dllimport) GLboolean __GLEW_ATIX_vertex_shader_output_point_size;
extern __declspec(dllimport) GLboolean __GLEW_ATI_draw_buffers;
extern __declspec(dllimport) GLboolean __GLEW_ATI_element_array;
extern __declspec(dllimport) GLboolean __GLEW_ATI_envmap_bumpmap;
extern __declspec(dllimport) GLboolean __GLEW_ATI_fragment_shader;
extern __declspec(dllimport) GLboolean __GLEW_ATI_map_object_buffer;
extern __declspec(dllimport) GLboolean __GLEW_ATI_meminfo;
extern __declspec(dllimport) GLboolean __GLEW_ATI_pn_triangles;
extern __declspec(dllimport) GLboolean __GLEW_ATI_separate_stencil;
extern __declspec(dllimport) GLboolean __GLEW_ATI_shader_texture_lod;
extern __declspec(dllimport) GLboolean __GLEW_ATI_text_fragment_shader;
extern __declspec(dllimport) GLboolean __GLEW_ATI_texture_compression_3dc;
extern __declspec(dllimport) GLboolean __GLEW_ATI_texture_env_combine3;
extern __declspec(dllimport) GLboolean __GLEW_ATI_texture_float;
extern __declspec(dllimport) GLboolean __GLEW_ATI_texture_mirror_once;
extern __declspec(dllimport) GLboolean __GLEW_ATI_vertex_array_object;
extern __declspec(dllimport) GLboolean __GLEW_ATI_vertex_attrib_array_object;
extern __declspec(dllimport) GLboolean __GLEW_ATI_vertex_streams;
extern __declspec(dllimport) GLboolean __GLEW_EXT_422_pixels;
extern __declspec(dllimport) GLboolean __GLEW_EXT_Cg_shader;
extern __declspec(dllimport) GLboolean __GLEW_EXT_abgr;
extern __declspec(dllimport) GLboolean __GLEW_EXT_bgra;
extern __declspec(dllimport) GLboolean __GLEW_EXT_bindable_uniform;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_color;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_equation_separate;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_func_separate;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_logic_op;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_minmax;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_subtract;
extern __declspec(dllimport) GLboolean __GLEW_EXT_clip_volume_hint;
extern __declspec(dllimport) GLboolean __GLEW_EXT_cmyka;
extern __declspec(dllimport) GLboolean __GLEW_EXT_color_subtable;
extern __declspec(dllimport) GLboolean __GLEW_EXT_compiled_vertex_array;
extern __declspec(dllimport) GLboolean __GLEW_EXT_convolution;
extern __declspec(dllimport) GLboolean __GLEW_EXT_coordinate_frame;
extern __declspec(dllimport) GLboolean __GLEW_EXT_copy_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_cull_vertex;
extern __declspec(dllimport) GLboolean __GLEW_EXT_debug_marker;
extern __declspec(dllimport) GLboolean __GLEW_EXT_depth_bounds_test;
extern __declspec(dllimport) GLboolean __GLEW_EXT_direct_state_access;
extern __declspec(dllimport) GLboolean __GLEW_EXT_draw_buffers2;
extern __declspec(dllimport) GLboolean __GLEW_EXT_draw_instanced;
extern __declspec(dllimport) GLboolean __GLEW_EXT_draw_range_elements;
extern __declspec(dllimport) GLboolean __GLEW_EXT_fog_coord;
extern __declspec(dllimport) GLboolean __GLEW_EXT_fragment_lighting;
extern __declspec(dllimport) GLboolean __GLEW_EXT_framebuffer_blit;
extern __declspec(dllimport) GLboolean __GLEW_EXT_framebuffer_multisample;
extern __declspec(dllimport) GLboolean __GLEW_EXT_framebuffer_multisample_blit_scaled;
extern __declspec(dllimport) GLboolean __GLEW_EXT_framebuffer_object;
extern __declspec(dllimport) GLboolean __GLEW_EXT_framebuffer_sRGB;
extern __declspec(dllimport) GLboolean __GLEW_EXT_geometry_shader4;
extern __declspec(dllimport) GLboolean __GLEW_EXT_gpu_program_parameters;
extern __declspec(dllimport) GLboolean __GLEW_EXT_gpu_shader4;
extern __declspec(dllimport) GLboolean __GLEW_EXT_histogram;
extern __declspec(dllimport) GLboolean __GLEW_EXT_index_array_formats;
extern __declspec(dllimport) GLboolean __GLEW_EXT_index_func;
extern __declspec(dllimport) GLboolean __GLEW_EXT_index_material;
extern __declspec(dllimport) GLboolean __GLEW_EXT_index_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_light_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_misc_attribute;
extern __declspec(dllimport) GLboolean __GLEW_EXT_multi_draw_arrays;
extern __declspec(dllimport) GLboolean __GLEW_EXT_multisample;
extern __declspec(dllimport) GLboolean __GLEW_EXT_packed_depth_stencil;
extern __declspec(dllimport) GLboolean __GLEW_EXT_packed_float;
extern __declspec(dllimport) GLboolean __GLEW_EXT_packed_pixels;
extern __declspec(dllimport) GLboolean __GLEW_EXT_paletted_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_pixel_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_EXT_pixel_transform;
extern __declspec(dllimport) GLboolean __GLEW_EXT_pixel_transform_color_table;
extern __declspec(dllimport) GLboolean __GLEW_EXT_point_parameters;
extern __declspec(dllimport) GLboolean __GLEW_EXT_polygon_offset;
extern __declspec(dllimport) GLboolean __GLEW_EXT_provoking_vertex;
extern __declspec(dllimport) GLboolean __GLEW_EXT_rescale_normal;
extern __declspec(dllimport) GLboolean __GLEW_EXT_scene_marker;
extern __declspec(dllimport) GLboolean __GLEW_EXT_secondary_color;
extern __declspec(dllimport) GLboolean __GLEW_EXT_separate_shader_objects;
extern __declspec(dllimport) GLboolean __GLEW_EXT_separate_specular_color;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shader_image_load_store;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shadow_funcs;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shared_texture_palette;
extern __declspec(dllimport) GLboolean __GLEW_EXT_stencil_clear_tag;
extern __declspec(dllimport) GLboolean __GLEW_EXT_stencil_two_side;
extern __declspec(dllimport) GLboolean __GLEW_EXT_stencil_wrap;
extern __declspec(dllimport) GLboolean __GLEW_EXT_subtexture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture3D;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_array;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_compression_dxt1;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_compression_latc;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_compression_rgtc;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_compression_s3tc;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_cube_map;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_edge_clamp;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_env;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_env_add;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_env_combine;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_env_dot3;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_filter_anisotropic;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_integer;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_lod_bias;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_mirror_clamp;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_object;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_perturb_normal;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_rectangle;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_sRGB;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_sRGB_decode;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_shared_exponent;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_snorm;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_swizzle;
extern __declspec(dllimport) GLboolean __GLEW_EXT_timer_query;
extern __declspec(dllimport) GLboolean __GLEW_EXT_transform_feedback;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_array;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_array_bgra;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_attrib_64bit;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_shader;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_weighting;
extern __declspec(dllimport) GLboolean __GLEW_EXT_x11_sync_object;
extern __declspec(dllimport) GLboolean __GLEW_GREMEDY_frame_terminator;
extern __declspec(dllimport) GLboolean __GLEW_GREMEDY_string_marker;
extern __declspec(dllimport) GLboolean __GLEW_HP_convolution_border_modes;
extern __declspec(dllimport) GLboolean __GLEW_HP_image_transform;
extern __declspec(dllimport) GLboolean __GLEW_HP_occlusion_test;
extern __declspec(dllimport) GLboolean __GLEW_HP_texture_lighting;
extern __declspec(dllimport) GLboolean __GLEW_IBM_cull_vertex;
extern __declspec(dllimport) GLboolean __GLEW_IBM_multimode_draw_arrays;
extern __declspec(dllimport) GLboolean __GLEW_IBM_rasterpos_clip;
extern __declspec(dllimport) GLboolean __GLEW_IBM_static_data;
extern __declspec(dllimport) GLboolean __GLEW_IBM_texture_mirrored_repeat;
extern __declspec(dllimport) GLboolean __GLEW_IBM_vertex_array_lists;
extern __declspec(dllimport) GLboolean __GLEW_INGR_color_clamp;
extern __declspec(dllimport) GLboolean __GLEW_INGR_interlace_read;
extern __declspec(dllimport) GLboolean __GLEW_INTEL_map_texture;
extern __declspec(dllimport) GLboolean __GLEW_INTEL_parallel_arrays;
extern __declspec(dllimport) GLboolean __GLEW_INTEL_texture_scissor;
extern __declspec(dllimport) GLboolean __GLEW_KHR_debug;
extern __declspec(dllimport) GLboolean __GLEW_KHR_texture_compression_astc_ldr;
extern __declspec(dllimport) GLboolean __GLEW_KTX_buffer_region;
extern __declspec(dllimport) GLboolean __GLEW_MESAX_texture_stack;
extern __declspec(dllimport) GLboolean __GLEW_MESA_pack_invert;
extern __declspec(dllimport) GLboolean __GLEW_MESA_resize_buffers;
extern __declspec(dllimport) GLboolean __GLEW_MESA_window_pos;
extern __declspec(dllimport) GLboolean __GLEW_MESA_ycbcr_texture;
extern __declspec(dllimport) GLboolean __GLEW_NVX_conditional_render;
extern __declspec(dllimport) GLboolean __GLEW_NVX_gpu_memory_info;
extern __declspec(dllimport) GLboolean __GLEW_NV_bindless_multi_draw_indirect;
extern __declspec(dllimport) GLboolean __GLEW_NV_bindless_texture;
extern __declspec(dllimport) GLboolean __GLEW_NV_blend_equation_advanced;
extern __declspec(dllimport) GLboolean __GLEW_NV_blend_equation_advanced_coherent;
extern __declspec(dllimport) GLboolean __GLEW_NV_blend_square;
extern __declspec(dllimport) GLboolean __GLEW_NV_compute_program5;
extern __declspec(dllimport) GLboolean __GLEW_NV_conditional_render;
extern __declspec(dllimport) GLboolean __GLEW_NV_copy_depth_to_color;
extern __declspec(dllimport) GLboolean __GLEW_NV_copy_image;
extern __declspec(dllimport) GLboolean __GLEW_NV_deep_texture3D;
extern __declspec(dllimport) GLboolean __GLEW_NV_depth_buffer_float;
extern __declspec(dllimport) GLboolean __GLEW_NV_depth_clamp;
extern __declspec(dllimport) GLboolean __GLEW_NV_depth_range_unclamped;
extern __declspec(dllimport) GLboolean __GLEW_NV_draw_texture;
extern __declspec(dllimport) GLboolean __GLEW_NV_evaluators;
extern __declspec(dllimport) GLboolean __GLEW_NV_explicit_multisample;
extern __declspec(dllimport) GLboolean __GLEW_NV_fence;
extern __declspec(dllimport) GLboolean __GLEW_NV_float_buffer;
extern __declspec(dllimport) GLboolean __GLEW_NV_fog_distance;
extern __declspec(dllimport) GLboolean __GLEW_NV_fragment_program;
extern __declspec(dllimport) GLboolean __GLEW_NV_fragment_program2;
extern __declspec(dllimport) GLboolean __GLEW_NV_fragment_program4;
extern __declspec(dllimport) GLboolean __GLEW_NV_fragment_program_option;
extern __declspec(dllimport) GLboolean __GLEW_NV_framebuffer_multisample_coverage;
extern __declspec(dllimport) GLboolean __GLEW_NV_geometry_program4;
extern __declspec(dllimport) GLboolean __GLEW_NV_geometry_shader4;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_program4;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_program5;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_program5_mem_extended;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_program_fp64;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_shader5;
extern __declspec(dllimport) GLboolean __GLEW_NV_half_float;
extern __declspec(dllimport) GLboolean __GLEW_NV_light_max_exponent;
extern __declspec(dllimport) GLboolean __GLEW_NV_multisample_coverage;
extern __declspec(dllimport) GLboolean __GLEW_NV_multisample_filter_hint;
extern __declspec(dllimport) GLboolean __GLEW_NV_occlusion_query;
extern __declspec(dllimport) GLboolean __GLEW_NV_packed_depth_stencil;
extern __declspec(dllimport) GLboolean __GLEW_NV_parameter_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_NV_parameter_buffer_object2;
extern __declspec(dllimport) GLboolean __GLEW_NV_path_rendering;
extern __declspec(dllimport) GLboolean __GLEW_NV_pixel_data_range;
extern __declspec(dllimport) GLboolean __GLEW_NV_point_sprite;
extern __declspec(dllimport) GLboolean __GLEW_NV_present_video;
extern __declspec(dllimport) GLboolean __GLEW_NV_primitive_restart;
extern __declspec(dllimport) GLboolean __GLEW_NV_register_combiners;
extern __declspec(dllimport) GLboolean __GLEW_NV_register_combiners2;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_atomic_counters;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_atomic_float;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_buffer_load;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_storage_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_NV_tessellation_program5;
extern __declspec(dllimport) GLboolean __GLEW_NV_texgen_emboss;
extern __declspec(dllimport) GLboolean __GLEW_NV_texgen_reflection;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_barrier;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_compression_vtc;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_env_combine4;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_expand_normal;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_multisample;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_rectangle;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_shader;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_shader2;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_shader3;
extern __declspec(dllimport) GLboolean __GLEW_NV_transform_feedback;
extern __declspec(dllimport) GLboolean __GLEW_NV_transform_feedback2;
extern __declspec(dllimport) GLboolean __GLEW_NV_vdpau_interop;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_array_range;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_array_range2;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_attrib_integer_64bit;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_buffer_unified_memory;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program1_1;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program2;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program2_option;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program3;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program4;
extern __declspec(dllimport) GLboolean __GLEW_NV_video_capture;
extern __declspec(dllimport) GLboolean __GLEW_OES_byte_coordinates;
extern __declspec(dllimport) GLboolean __GLEW_OES_compressed_paletted_texture;
extern __declspec(dllimport) GLboolean __GLEW_OES_read_format;
extern __declspec(dllimport) GLboolean __GLEW_OES_single_precision;
extern __declspec(dllimport) GLboolean __GLEW_OML_interlace;
extern __declspec(dllimport) GLboolean __GLEW_OML_resample;
extern __declspec(dllimport) GLboolean __GLEW_OML_subsample;
extern __declspec(dllimport) GLboolean __GLEW_PGI_misc_hints;
extern __declspec(dllimport) GLboolean __GLEW_PGI_vertex_hints;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_ES1_0_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_ES1_1_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_enable;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_error_string;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_extension_query;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_log;
extern __declspec(dllimport) GLboolean __GLEW_REND_screen_coordinates;
extern __declspec(dllimport) GLboolean __GLEW_S3_s3tc;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_color_range;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_detail_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_fog_function;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_generate_mipmap;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_multisample;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_pixel_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_point_line_texgen;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_sharpen_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture4D;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture_border_clamp;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture_edge_clamp;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture_filter4;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture_lod;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture_select;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_async;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_async_histogram;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_async_pixel;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_blend_alpha_minmax;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_clipmap;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_convolution_accuracy;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_depth_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_flush_raster;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fog_offset;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fog_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fragment_specular_lighting;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_framezoom;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_interlace;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_ir_instrument1;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_list_priority;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_pixel_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_pixel_texture_bits;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_reference_plane;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_resample;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_shadow;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_shadow_ambient;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_sprite;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_tag_sample_buffer;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_add_env;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_coordinate_clamp;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_lod_bias;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_multi_buffer;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_range;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_scale_bias;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_vertex_preclip;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_vertex_preclip_hint;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_ycrcb;
extern __declspec(dllimport) GLboolean __GLEW_SGI_color_matrix;
extern __declspec(dllimport) GLboolean __GLEW_SGI_color_table;
extern __declspec(dllimport) GLboolean __GLEW_SGI_texture_color_table;
extern __declspec(dllimport) GLboolean __GLEW_SUNX_constant_data;
extern __declspec(dllimport) GLboolean __GLEW_SUN_convolution_border_modes;
extern __declspec(dllimport) GLboolean __GLEW_SUN_global_alpha;
extern __declspec(dllimport) GLboolean __GLEW_SUN_mesh_array;
extern __declspec(dllimport) GLboolean __GLEW_SUN_read_video_pixels;
extern __declspec(dllimport) GLboolean __GLEW_SUN_slice_accum;
extern __declspec(dllimport) GLboolean __GLEW_SUN_triangle_list;
extern __declspec(dllimport) GLboolean __GLEW_SUN_vertex;
extern __declspec(dllimport) GLboolean __GLEW_WIN_phong_shading;
extern __declspec(dllimport) GLboolean __GLEW_WIN_specular_fog;
extern __declspec(dllimport) GLboolean __GLEW_WIN_swap_hint;








































extern __declspec(dllimport) GLenum __stdcall glewInit (void);
extern __declspec(dllimport) GLboolean __stdcall glewIsSupported (const char *name);





#line 18032 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

extern __declspec(dllimport) GLboolean glewExperimental;
extern __declspec(dllimport) GLboolean __stdcall glewGetExtension (const char *name);
extern __declspec(dllimport) const GLubyte * __stdcall glewGetErrorString (GLenum error);
extern __declspec(dllimport) const GLubyte * __stdcall glewGetString (GLenum name);


}
#line 18041 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"






#line 18048 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




#line 18053 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




#line 18058 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"




#line 18063 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glew.h"

#line 13 "d:\\my documents\\programs\\jotunengine2\\stdafx.h"


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"
































extern "C" {
#line 35 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"

















































#line 85 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"






 
  
 

#line 96 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"
#line 97 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"








 
  
  
 





#line 115 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"
 
#line 117 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"



 
  
  
   
  

#line 127 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"
 


#line 131 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"
 
#line 133 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"














#line 148 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"






#line 155 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"








#line 164 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"



#line 168 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"

 
 

#line 173 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"















#line 189 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"
  

#line 192 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"

#line 194 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"

#line 196 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"

#line 198 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"
    #line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\gl.h"































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 199 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"
  #line 200 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"
  

#line 203 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"
#line 204 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"



































































































































































































































































































































































typedef void (*GLFWglproc)(void);







typedef struct GLFWmonitor GLFWmonitor;







typedef struct GLFWwindow GLFWwindow;












typedef void (* GLFWerrorfun)(int,const char*);















typedef void (* GLFWwindowposfun)(GLFWwindow*,int,int);













typedef void (* GLFWwindowsizefun)(GLFWwindow*,int,int);











typedef void (* GLFWwindowclosefun)(GLFWwindow*);











typedef void (* GLFWwindowrefreshfun)(GLFWwindow*);













typedef void (* GLFWwindowfocusfun)(GLFWwindow*,int);














typedef void (* GLFWwindowiconifyfun)(GLFWwindow*,int);














typedef void (* GLFWframebuffersizefun)(GLFWwindow*,int,int);
















typedef void (* GLFWmousebuttonfun)(GLFWwindow*,int,int,int);













typedef void (* GLFWcursorposfun)(GLFWwindow*,double,double);













typedef void (* GLFWcursorenterfun)(GLFWwindow*,int);













typedef void (* GLFWscrollfun)(GLFWwindow*,double,double);
















typedef void (* GLFWkeyfun)(GLFWwindow*,int,int,int,int);












typedef void (* GLFWcharfun)(GLFWwindow*,unsigned int);












typedef void (* GLFWmonitorfun)(GLFWmonitor*,int);







typedef struct
{
    

    int width;
    

    int height;
    

    int redBits;
    

    int greenBits;
    

    int blueBits;
    

    int refreshRate;
} GLFWvidmode;









typedef struct
{
    

    unsigned short* red;
    

    unsigned short* green;
    

    unsigned short* blue;
    

    unsigned int size;
} GLFWgammaramp;





































 int glfwInit(void);























 void glfwTerminate(void);



















 void glfwGetVersion(int* major, int* minor, int* rev);





























 const char* glfwGetVersionString(void);
























 GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun cbfun);





















 GLFWmonitor** glfwGetMonitors(int* count);












 GLFWmonitor* glfwGetPrimaryMonitor(void);












 void glfwGetMonitorPos(GLFWmonitor* monitor, int* xpos, int* ypos);


















 void glfwGetMonitorPhysicalSize(GLFWmonitor* monitor, int* width, int* height);















 const char* glfwGetMonitorName(GLFWmonitor* monitor);

















 GLFWmonitorfun glfwSetMonitorCallback(GLFWmonitorfun cbfun);























 const GLFWvidmode* glfwGetVideoModes(GLFWmonitor* monitor, int* count);

















 const GLFWvidmode* glfwGetVideoMode(GLFWmonitor* monitor);











 void glfwSetGamma(GLFWmonitor* monitor, float gamma);













 const GLFWgammaramp* glfwGetGammaRamp(GLFWmonitor* monitor);












 void glfwSetGammaRamp(GLFWmonitor* monitor, const GLFWgammaramp* ramp);












 void glfwDefaultWindowHints(void);





















 void glfwWindowHint(int target, int hint);


























































 GLFWwindow* glfwCreateWindow(int width, int height, const char* title, GLFWmonitor* monitor, GLFWwindow* share);





















 void glfwDestroyWindow(GLFWwindow* window);












 int glfwWindowShouldClose(GLFWwindow* window);














 void glfwSetWindowShouldClose(GLFWwindow* window, int value);













 void glfwSetWindowTitle(GLFWwindow* window, const char* title);
















 void glfwGetWindowPos(GLFWwindow* window, int* xpos, int* ypos);































 void glfwSetWindowPos(GLFWwindow* window, int xpos, int ypos);
















 void glfwGetWindowSize(GLFWwindow* window, int* width, int* height);























 void glfwSetWindowSize(GLFWwindow* window, int width, int height);
















 void glfwGetFramebufferSize(GLFWwindow* window, int* width, int* height);
















 void glfwIconifyWindow(GLFWwindow* window);
















 void glfwRestoreWindow(GLFWwindow* window);















 void glfwShowWindow(GLFWwindow* window);















 void glfwHideWindow(GLFWwindow* window);











 GLFWmonitor* glfwGetWindowMonitor(GLFWwindow* window);













 int glfwGetWindowAttrib(GLFWwindow* window, int attrib);














 void glfwSetWindowUserPointer(GLFWwindow* window, void* pointer);












 void* glfwGetWindowUserPointer(GLFWwindow* window);















 GLFWwindowposfun glfwSetWindowPosCallback(GLFWwindow* window, GLFWwindowposfun cbfun);















 GLFWwindowsizefun glfwSetWindowSizeCallback(GLFWwindow* window, GLFWwindowsizefun cbfun);























 GLFWwindowclosefun glfwSetWindowCloseCallback(GLFWwindow* window, GLFWwindowclosefun cbfun);























 GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow* window, GLFWwindowrefreshfun cbfun);



















 GLFWwindowfocusfun glfwSetWindowFocusCallback(GLFWwindow* window, GLFWwindowfocusfun cbfun);














 GLFWwindowiconifyfun glfwSetWindowIconifyCallback(GLFWwindow* window, GLFWwindowiconifyfun cbfun);














 GLFWframebuffersizefun glfwSetFramebufferSizeCallback(GLFWwindow* window, GLFWframebuffersizefun cbfun);
























 void glfwPollEvents(void);


























 void glfwWaitEvents(void);











 int glfwGetInputMode(GLFWwindow* window, int mode);


































 void glfwSetInputMode(GLFWwindow* window, int mode, int value);

























 int glfwGetKey(GLFWwindow* window, int key);

















 int glfwGetMouseButton(GLFWwindow* window, int button);

























 void glfwGetCursorPos(GLFWwindow* window, double* xpos, double* ypos);





















 void glfwSetCursorPos(GLFWwindow* window, double xpos, double ypos);

































 GLFWkeyfun glfwSetKeyCallback(GLFWwindow* window, GLFWkeyfun cbfun);


















 GLFWcharfun glfwSetCharCallback(GLFWwindow* window, GLFWcharfun cbfun);




















 GLFWmousebuttonfun glfwSetMouseButtonCallback(GLFWwindow* window, GLFWmousebuttonfun cbfun);















 GLFWcursorposfun glfwSetCursorPosCallback(GLFWwindow* window, GLFWcursorposfun cbfun);















 GLFWcursorenterfun glfwSetCursorEnterCallback(GLFWwindow* window, GLFWcursorenterfun cbfun);


















 GLFWscrollfun glfwSetScrollCallback(GLFWwindow* window, GLFWscrollfun cbfun);










 int glfwJoystickPresent(int joy);


















 const float* glfwGetJoystickAxes(int joy, int* count);


















 const unsigned char* glfwGetJoystickButtons(int joy, int* count);

















 const char* glfwGetJoystickName(int joy);
















 void glfwSetClipboardString(GLFWwindow* window, const char* string);






















 const char* glfwGetClipboardString(GLFWwindow* window);

















 double glfwGetTime(void);














 void glfwSetTime(double time);

















 void glfwMakeContextCurrent(GLFWwindow* window);















 GLFWwindow* glfwGetCurrentContext(void);



















 void glfwSwapBuffers(GLFWwindow* window);




























 void glfwSwapInterval(int interval);




















 int glfwExtensionSupported(const char* extension);




















 GLFWglproc glfwGetProcAddress(const char* procname);









 
 
#line 2268 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"


 
 
#line 2273 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"





}
#line 2280 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"

#line 2282 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glfw3.h"


#line 16 "d:\\my documents\\programs\\jotunengine2\\stdafx.h"


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"













































































#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_fixes.hpp"























































#line 79 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"










#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"


























































#line 60 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 62 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 64 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"











#line 76 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"























#line 100 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"






























































































































#line 227 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"






















#line 250 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"


#line 253 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 255 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 257 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 259 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 261 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 263 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 265 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 267 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 269 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 271 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 273 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"























































































#line 361 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"































#line 393 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"






#line 400 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 402 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 404 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"



#line 408 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"








#line 417 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"
















#line 434 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 436 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 438 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"


#line 441 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"





#line 447 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"











#line 459 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"
#line 460 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"


















#line 479 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"















#line 495 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 497 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 499 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 501 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 503 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 505 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"












#line 518 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 520 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"





#line 526 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 528 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 530 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 532 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"











#line 544 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"






#line 551 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"




#line 556 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"


#line 559 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"


#line 562 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"


#line 565 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"


#line 568 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

















#line 586 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"
































#line 619 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"












#line 632 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"











#line 644 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 646 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"




#line 651 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"









#line 661 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"


#line 664 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"



#line 668 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 670 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"











#line 682 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 684 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"


















#line 703 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"

#line 705 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\setup.hpp"
#line 90 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"




#line 95 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_detail.hpp"
































#line 1 "d:\\programs overflow\\vc\\include\\cassert"



#line 1 "d:\\programs overflow\\vc\\include\\assert.h"




















#line 1 "d:\\programs overflow\\vc\\include\\crtdefs.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22 "d:\\programs overflow\\vc\\include\\assert.h"










extern "C" {
#line 34 "d:\\programs overflow\\vc\\include\\assert.h"

__declspec(dllimport) void __cdecl _wassert(  const wchar_t * _Message,   const wchar_t *_File,   unsigned _Line);


}
#line 40 "d:\\programs overflow\\vc\\include\\assert.h"



#line 44 "d:\\programs overflow\\vc\\include\\assert.h"
#line 5 "d:\\programs overflow\\vc\\include\\cassert"





#line 34 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_detail.hpp"


#line 37 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_detail.hpp"

namespace glm{
namespace detail
{
	class half;




#line 47 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_detail.hpp"
	typedef signed __int64						sint64;
	typedef unsigned __int64					uint64;









#line 59 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_detail.hpp"

	template<bool C>
	struct If
	{
		template<typename F, typename T>
		static  inline T apply(F functor, const T& val)
		{
			return functor(val);
		}
	};

	template<>
	struct If<false>
	{
		template<typename F, typename T>
		static  inline T apply(F, const T& val)
		{
			return val;
		}
	};

	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	

	
	
	
	
	
	

	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	

	
	
	
	

	
	

	union uif32
	{
		 inline uif32() :
			i(0)
		{}

		 inline uif32(float f) :
			f(f)
		{}

		 inline uif32(unsigned int i) :
			i(i)
		{}

		float f;
		unsigned int i;
	};

	union uif64
	{
		 inline uif64() :
			i(0)
		{}

		 inline uif64(double f) :
			f(f)
		{}

		 inline uif64(uint64 i) :
			i(i)
		{}

		double f;
		uint64 i;
	};

	typedef uif32 uif;

	
	

	template <typename T>
	struct is_int
	{
		enum is_int_enum
		{
			_YES = 0,
			_NO = 1
		};
	};












	
	

	template <typename T>
	struct is_uint
	{
		enum is_uint_enum
		{
			_YES = 0,
			_NO = 1
		};
	};












	

	
	

	template <typename T>
	struct is_float
	{
		enum is_float_enum
		{
			_YES = 0,
			_NO = 1
		};
	};












	template <> struct is_float<detail::half> { enum is_float_enum { _YES = 1, _NO = 0 }; };
	template <> struct is_float<float> { enum is_float_enum { _YES = 1, _NO = 0 }; };
	template <> struct is_float<double> { enum is_float_enum { _YES = 1, _NO = 0 }; };
	template <> struct is_float<long double> { enum is_float_enum { _YES = 1, _NO = 0 }; };

	
	

	template <typename T>
	struct is_bool
	{
		enum is_bool_enum
		{
			_YES = 0,
			_NO = 1
		};
	};
	
	template <>
	struct is_bool<bool>
	{
		enum is_bool_enum
		{
			_YES = 1,
			_NO = 0
		};
	};
	
	
	

	template <typename T>
	struct is_vector
	{
		enum is_vector_enum
		{
			_YES = 0,
			_NO = 1
		};
	};












	
	

	template <typename T>
	struct is_matrix
	{
		enum is_matrix_enum
		{
			_YES = 0,
			_NO = 1
		};
	};












	
	

	template <typename T>
	struct type
	{
		enum type_enum
		{
			is_float = is_float<T>::_YES,
			is_int = is_int<T>::_YES,
			is_uint = is_uint<T>::_YES,
			is_bool = is_bool<T>::_YES
		};
	};
	
	
	
	
	typedef signed char							int8;
	typedef signed short						int16;
	typedef signed int							int32;
	typedef detail::sint64						int64;
	
	typedef unsigned char						uint8;
	typedef unsigned short						uint16;
	typedef unsigned int						uint32;
	typedef detail::uint64						uint64;
	
	typedef detail::half						float16;
	typedef float								float32;
	typedef double								float64;
	
	
	

	struct float_or_int_value
	{
		enum
		{
			GLM_ERROR,
			GLM_FLOAT,
			GLM_INT
		};
	};

	template <typename T>
	struct float_or_int_trait
	{
		enum{ID = float_or_int_value::GLM_ERROR};
	};

	template <>
	struct float_or_int_trait<int8>
	{
		enum{ID = float_or_int_value::GLM_INT};
	};

	template <>
	struct float_or_int_trait<int16>
	{
		enum{ID = float_or_int_value::GLM_INT};
	};

	template <>
	struct float_or_int_trait<int32>
	{
		enum{ID = float_or_int_value::GLM_INT};
	};

	template <>
	struct float_or_int_trait<int64>
	{
		enum{ID = float_or_int_value::GLM_INT};
	};

	template <>
	struct float_or_int_trait<uint8>
	{
		enum{ID = float_or_int_value::GLM_INT};
	};

	template <>
	struct float_or_int_trait<uint16>
	{
		enum{ID = float_or_int_value::GLM_INT};
	};

	template <>
	struct float_or_int_trait<uint32>
	{
		enum{ID = float_or_int_value::GLM_INT};
	};

	template <>
	struct float_or_int_trait<uint64>
	{
		enum{ID = float_or_int_value::GLM_INT};
	};

	template <>
	struct float_or_int_trait<float16>
	{
		enum{ID = float_or_int_value::GLM_FLOAT};
	};

	template <>
	struct float_or_int_trait<float32>
	{
		enum{ID = float_or_int_value::GLM_FLOAT};
	};

	template <>
	struct float_or_int_trait<float64>
	{
		enum{ID = float_or_int_value::GLM_FLOAT};
	};

}
}








#line 449 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_detail.hpp"






#line 456 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_detail.hpp"

















#line 474 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_detail.hpp"






#line 481 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_detail.hpp"

#line 483 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_detail.hpp"
#line 97 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_vectorize.hpp"































































































































































#line 98 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"































#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_half.hpp"

































namespace glm{
namespace detail
{
	typedef short hdata;

	 float toFloat32(hdata value);
	 hdata toFloat16(float const & value);

	class half
	{
	public: 
		
		 half();
		 half(half const & s);
			
		template <typename U>
		 explicit half(U const & s);

		
		
		
		 operator float() const;

		
		 half& operator= (half const & s);
		 half& operator+=(half const & s);
		 half& operator-=(half const & s);
		 half& operator*=(half const & s);
		 half& operator/=(half const & s);
		 half& operator++();
		 half& operator--();
	
		 float toFloat() const{return toFloat32(data);}

		 hdata _data() const{return data;}

	private:
		hdata data;
	};

	 half operator+ (half const & s1, half const & s2);

	 half operator- (half const & s1, half const & s2);

	 half operator* (half const & s1, half const & s2);

	 half operator/ (half const & s1, half const & s2);

	
	 half operator- (half const & s);

	 half operator-- (half const & s, int);

	 half operator++ (half const & s, int);

	 bool operator==(
		detail::half const & x, 
		detail::half const & y);

	 bool operator!=(
		detail::half const & x, 
		detail::half const & y);

	 bool operator<(
		detail::half const & x, 
		detail::half const & y);

	 bool operator<=(
		detail::half const & x, 
		detail::half const & y);

	 bool operator>(
		detail::half const & x, 
		detail::half const & y);

	 bool operator>=(
		detail::half const & x, 
		detail::half const & y);

}
}

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_half.inl"


































namespace glm{
namespace detail
{
	 inline float overflow()
	{
		volatile float f = 1e10;

		for(int i = 0; i < 10; ++i)	
			f *= f;             
								
		return f;
	}

	 inline float toFloat32(hdata value)
	{
		int s = (value >> 15) & 0x00000001;
		int e = (value >> 10) & 0x0000001f;
		int m =  value        & 0x000003ff;

		if(e == 0)
		{
			if(m == 0)
			{
				
				
				

				detail::uif result;
				result.i = (unsigned int)(s << 31);
				return result.f;
			}
			else
			{
				
				
				

				while(!(m & 0x00000400))
				{
					m <<= 1;
					e -=  1;
				}

				e += 1;
				m &= ~0x00000400;
			}
		}
		else if(e == 31)
		{
			if(m == 0)
			{
				
				
				

				uif result;
				result.i = (unsigned int)((s << 31) | 0x7f800000);
				return result.f;
			}
			else
			{
				
				
				

				uif result;
				result.i = (unsigned int)((s << 31) | 0x7f800000 | (m << 13));
				return result.f;
			}
		}

		
		
		

		e = e + (127 - 15);
		m = m << 13;

		
		
		

		uif Result;
		Result.i = (unsigned int)((s << 31) | (e << 23) | m);
		return Result.f;
	}

	 inline hdata toFloat16(float const & f)
	{
		uif Entry;
		Entry.f = f;
		int i = (int)Entry.i;

		
		
		
		
		
		
		
		
		

		int s =  (i >> 16) & 0x00008000;
		int e = ((i >> 23) & 0x000000ff) - (127 - 15);
		int m =   i        & 0x007fffff;

		
		
		

		if(e <= 0)
		{
			if(e < -10)
			{
				
				
				
				
				
				
				

				return hdata(s);
			}

			
			
			
			
			
			

			m = (m | 0x00800000) >> (1 - e);

			
			
			
			
			
			
			
			

			if(m & 0x00001000) 
				m += 0x00002000;

			
			
			

			return hdata(s | (m >> 13));
		}
		else if(e == 0xff - (127 - 15))
		{
			if(m == 0)
			{
				
				
				
				

				return hdata(s | 0x7c00);
			}
			else
			{
				
				
				
				
				
				
				
				

				m >>= 13;

				return hdata(s | 0x7c00 | m | (m == 0));
			}
		}
		else
		{
			
			
			
			

			
			
			

			if(m &  0x00001000)
			{
				m += 0x00002000;

				if(m & 0x00800000)
				{
					m =  0;     
					e += 1;     
				}
			}

			
			
			

			if (e > 30)
			{
				overflow();        

				return hdata(s | 0x7c00);
				
			}   

			
			
			

			return hdata(s | (e << 10) | (m >> 13));
		}
	}

	 inline half::half() :
		data(0)
	{}

	 inline half::half(half const & s) :
		data(s.data)
	{}

	template <typename U>
	 inline half::half(U const & s) :
		data(toFloat16(float(s)))
	{}








	 inline half::operator float() const
	{
		return toFloat32(this->data);
	}

	
	 inline half& half::operator= (half const & s)
	{
		data = s.data;
		return *this;
	}

	 inline half& half::operator+=(half const & s)
	{
		data = toFloat16(toFloat32(data) + toFloat32(s.data));
		return *this;
	}

	 inline half& half::operator-=(half const & s)
	{
		data = toFloat16(toFloat32(data) - toFloat32(s.data));
		return *this;
	}

	 inline half& half::operator*=(half const & s)
	{
		data = toFloat16(toFloat32(data) * toFloat32(s.data));		
		return *this;
	}

	 inline half& half::operator/=(half const & s)
	{
		data = toFloat16(toFloat32(data) / toFloat32(s.data));
		return *this;
	}

	 inline half& half::operator++()
	{
		float Casted = toFloat32(data);
		this->data = toFloat16(++Casted);
		return *this;
	}

	 inline half& half::operator--()
	{
		float Casted = toFloat32(data);
		this->data = toFloat16(--Casted);
		return *this;
	}

	
	

	 inline detail::half operator+ (detail::half const & s1, detail::half const & s2)
	{
		return detail::half(float(s1) + float(s2));
	}

	 inline detail::half operator- (detail::half const & s1, detail::half const & s2)
	{
		return detail::half(float(s1) - float(s2));
	}

	 inline detail::half operator* (detail::half const & s1, detail::half const & s2)
	{
		return detail::half(float(s1) * float(s2));
	}

	 inline detail::half operator/ (detail::half const & s1, detail::half const & s2)
	{
		return detail::half(float(s1) / float(s2));
	}

	
	 inline detail::half operator- (detail::half const & s)
	{
		return detail::half(-float(s));
	}

	 inline detail::half operator-- (detail::half const & s, int)
	{
		return detail::half(float(s) - 1.0f);
	}

	 inline detail::half operator++ (detail::half const & s, int)
	{
		return detail::half(float(s) + 1.0f);
	}

	 inline bool operator==
	(
		detail::half const & x, 
		detail::half const & y
	)
	{
		return x._data() == y._data();
	}

	 inline bool operator!=
	(
		detail::half const & x, 
		detail::half const & y
	)
	{
		return x._data() != y._data();
	}

	 inline bool operator<
	(
		detail::half const & x, 
		detail::half const & y
	)
	{
		return float(x) < float(y);
	}

	 inline bool operator<=
	(
		detail::half const & x, 
		detail::half const & y
	)
	{
		return float(x) <= float(y);
	}

	 inline bool operator>
	(
		detail::half const & x, 
		detail::half const & y
	)
	{
		return float(x) > float(y);
	}

	 inline bool operator>=
	(
		detail::half const & x, 
		detail::half const & y
	)
	{
		return float(x) >= float(y);
	}

}
}
#line 117 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_half.hpp"

#line 119 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_half.hpp"
#line 33 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_float.hpp"


































namespace glm
{



	typedef float				lowp_float_t;
#line 42 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_float.hpp"
	typedef float				mediump_float_t;
	typedef double				highp_float_t;

	
	

	
	
	
	
	
	typedef lowp_float_t		lowp_float;

	
	
	
	
	
	typedef mediump_float_t     mediump_float;

	
	
	
	
	
	typedef highp_float_t		highp_float;


	typedef mediump_float				float_t;








#line 80 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_float.hpp"

	
}

#line 85 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_float.hpp"
#line 34 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_int.hpp"


































namespace glm{
namespace detail
{
	typedef signed short			lowp_int_t;
	typedef signed int				mediump_int_t;
	typedef sint64					highp_int_t;

	typedef unsigned short			lowp_uint_t;
	typedef unsigned int			mediump_uint_t;
	typedef uint64					highp_uint_t;

	template <> struct is_int<signed char> { enum is_int_enum { _YES = 1, _NO = 0 }; };
	template <> struct is_int<signed short> { enum is_int_enum { _YES = 1, _NO = 0 }; };
	template <> struct is_int<signed int> { enum is_int_enum { _YES = 1, _NO = 0 }; };
	template <> struct is_int<signed long> { enum is_int_enum { _YES = 1, _NO = 0 }; };
	template <> struct is_int<highp_int_t> { enum is_int_enum { _YES = 1, _NO = 0 }; };

	template <> struct is_uint<unsigned char> { enum is_uint_enum { _YES = 1, _NO = 0 }; };
	template <> struct is_uint<unsigned short> { enum is_uint_enum { _YES = 1, _NO = 0 }; };
	template <> struct is_uint<unsigned int> { enum is_uint_enum { _YES = 1, _NO = 0 }; };
	template <> struct is_uint<unsigned long> { enum is_uint_enum { _YES = 1, _NO = 0 }; };
	template <> struct is_uint<highp_uint_t> { enum is_uint_enum { _YES = 1, _NO = 0 }; };
}

	
	

	
	
	
	
	
	typedef detail::lowp_int_t				lowp_int;

	
	
	
	
	
	typedef detail::mediump_int_t			mediump_int;

	
	
	
	
	
	typedef detail::highp_int_t				highp_int;

	
	
	
	
	
	typedef detail::lowp_uint_t				lowp_uint;

	
	
	
	
	
	typedef detail::mediump_uint_t			mediump_uint;

	
	
	
	
	
	typedef detail::highp_uint_t				highp_uint;


	typedef mediump_int                 int_t;








#line 115 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_int.hpp"


	typedef mediump_uint				uint_t;








#line 127 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_int.hpp"

	
	
	
	typedef uint_t								uint;

	
}

#line 137 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_int.hpp"
#line 35 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_gentype.hpp"































#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_size.hpp"

































namespace glm{
namespace detail
{
	
	typedef int sizeType;

}
}

#line 44 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_size.hpp"
#line 33 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_gentype.hpp"

namespace glm
{
	enum profile
	{
		nice,
		fast,
		simd
	};

namespace detail
{
	template
	<
		typename VALTYPE, 
		template <typename> class TYPE
	>
	struct genType
	{
	public:
		enum ctor{null};

		typedef VALTYPE value_type;
		typedef VALTYPE & value_reference;
		typedef VALTYPE * value_pointer;
		typedef VALTYPE const * value_const_pointer;
		typedef TYPE<bool> bool_type;

		typedef sizeType size_type;
		static bool is_vector();
		static bool is_matrix();
		
		typedef TYPE<VALTYPE> type;
		typedef TYPE<VALTYPE> * pointer;
		typedef TYPE<VALTYPE> const * const_pointer;
		typedef TYPE<VALTYPE> const * const const_pointer_const;
		typedef TYPE<VALTYPE> * const pointer_const;
		typedef TYPE<VALTYPE> & reference;
		typedef TYPE<VALTYPE> const & const_reference;
		typedef TYPE<VALTYPE> const & param_type;

		
		

		value_const_pointer value_address() const{return value_pointer(this);}
		value_pointer value_address(){return value_pointer(this);}

	
	
	
	
	
	
	

	
	};

	template
	<
		typename VALTYPE, 
		template <typename> class TYPE
	>
	bool genType<VALTYPE, TYPE>::is_vector()
	{
		return true;
	}
































































	}
}



#line 170 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_gentype.hpp"
#line 37 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec1.hpp"































#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec.hpp"

































namespace glm{
namespace detail
{

}
}

#line 42 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec.hpp"
#line 33 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec1.hpp"



#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_swizzle.hpp"































#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_swizzle_func.hpp"


















































































































































































































































































































































































































































































































































































































































































































































































































#line 788 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_swizzle_func.hpp"

#line 33 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_swizzle.hpp"

namespace glm
{
	enum comp
	{
		X = 0,
		R = 0,
		S = 0,
		Y = 1,
		G = 1,
		T = 1,
		Z = 2,
		B = 2,
		P = 2,
		W = 3,
		A = 3,
		Q = 3
	};
}

namespace glm{
namespace detail
{
	
	template <typename T, int N>
	struct _swizzle_base0
	{
		typedef T       value_type;

	protected:
		 inline value_type&         elem   (size_t i)       { return (reinterpret_cast<value_type*>(_buffer))[i]; }
		 inline const value_type&   elem   (size_t i) const { return (reinterpret_cast<const value_type*>(_buffer))[i]; }

		
		
		
		char    _buffer[1];
	};

	template <typename T, typename V, int E0, int E1, int E2, int E3, int N>
	struct _swizzle_base1 : public _swizzle_base0<T,N>
	{
	};

	template <typename T, typename V, int E0, int E1>
	struct _swizzle_base1<T,V,E0,E1,-1,-2,2> : public _swizzle_base0<T,2>
	{
		 inline V operator ()()  const { return V(this->elem(E0), this->elem(E1)); }
	};

	template <typename T, typename V, int E0, int E1, int E2>
	struct _swizzle_base1<T,V,E0,E1,E2,-1,3> : public _swizzle_base0<T,3>
	{
		 inline V operator ()()  const { return V(this->elem(E0), this->elem(E1), this->elem(E2)); }
	};

	template <typename T, typename V, int E0, int E1, int E2, int E3>
	struct _swizzle_base1<T,V,E0,E1,E2,E3,4> : public _swizzle_base0<T,4>
	{ 
		 inline V operator ()()  const { return V(this->elem(E0), this->elem(E1), this->elem(E2), this->elem(E3)); }
	};

	
	










	template <typename ValueType, typename VecType, int N, int E0, int E1, int E2, int E3, int DUPLICATE_ELEMENTS>
	struct _swizzle_base2 : public _swizzle_base1<ValueType,VecType,E0,E1,E2,E3,N>
	{
		typedef VecType vec_type;
		typedef ValueType value_type;

		 inline _swizzle_base2& operator= (const ValueType& t)
		{
			for (int i = 0; i < N; ++i)
				(*this)[i] = t;
			return *this;
		}

		 inline _swizzle_base2& operator= (const VecType& that)
		{
			struct op { 
				 inline void operator() (value_type& e, value_type& t) { e = t; } 
			};
			_apply_op(that, op());
			return *this;
		}

		 inline void operator -= (const VecType& that)
		{
			struct op { 
				 inline void operator() (value_type& e, value_type& t) { e -= t; } 
			};
			_apply_op(that, op());
		}

		 inline void operator += (const VecType& that)
		{
			struct op { 
				 inline void operator() (value_type& e, value_type& t) { e += t; } 
			};
			_apply_op(that, op());
		}

		 inline void operator *= (const VecType& that)
		{
			struct op { 
				 inline void operator() (value_type& e, value_type& t) { e *= t; } 
			};
			_apply_op(that, op());
		}

		 inline void operator /= (const VecType& that)
		{
			struct op { 
				 inline void operator() (value_type& e, value_type& t) { e /= t; } 
			};
			_apply_op(that, op());
		}

		 inline value_type& operator[]  (size_t i)
		{

			static
#line 166 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_swizzle.hpp"
				const int offset_dst[4] = { E0, E1, E2, E3 };
			return this->elem(offset_dst[i]);
		}
		 inline value_type  operator[]  (size_t i) const
		{

			static
#line 174 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_swizzle.hpp"
				const int offset_dst[4] = { E0, E1, E2, E3 };
			return this->elem(offset_dst[i]);
		}
	protected:
		template <typename T>
		 inline void _apply_op(const VecType& that, T op)
		{
			
			
			
			ValueType t[N];
			for (int i = 0; i < N; ++i)
				t[i] = that[i];
			for (int i = 0; i < N; ++i)
				op( (*this)[i], t[i] );
		}
	};

	
	template <typename ValueType, typename VecType, int N, int E0, int E1, int E2, int E3>
	struct _swizzle_base2<ValueType,VecType,N,E0,E1,E2,E3,1> : public _swizzle_base1<ValueType,VecType,E0,E1,E2,E3,N>
	{
		typedef VecType         vec_type;        
		typedef ValueType       value_type;

		struct Stub {};
		 inline _swizzle_base2& operator= (Stub const &) { return *this; }

		 inline value_type  operator[]  (size_t i) const
		{

			static
#line 207 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_swizzle.hpp"
				const int offset_dst[4] = { E0, E1, E2, E3 };
			return this->elem(offset_dst[i]);
		}
	};

	template <int N,typename ValueType, typename VecType, int E0,int E1,int E2,int E3>
	struct swizzle : public _swizzle_base2<ValueType,VecType,N,E0,E1,E2,E3,(E0==E1||E0==E2||E0==E3||E1==E2||E1==E3||E2==E3)>
	{
		typedef _swizzle_base2<ValueType,VecType,N,E0,E1,E2,E3,(E0==E1||E0==E2||E0==E3||E1==E2||E1==E3||E2==E3)> base_type;

		using base_type::operator=;

		 inline operator VecType () const { return (*this)(); }
	};







































































































 
}
}

namespace glm
{
	namespace detail
	{
		template <int N, typename T, typename V, int E0, int E1, int E2, int E3>  inline V operator - ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const T& b) { return a() - b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3>  inline V operator - ( const T& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a - b(); }
		template <int N, typename T, typename V, int E0, int E1, int E2, int E3>  inline V operator * ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const T& b) { return a() * b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3>  inline V operator * ( const T& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a * b(); }
		template <int N, typename T, typename V, int E0, int E1, int E2, int E3, int F0, int F1, int F2, int F3>  inline V operator + ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const glm::detail::swizzle<N,T,V,F0,F1,F2,F3>& b) { return a() + b(); } template <int N, typename T, typename V, int E0, int E1, int E2, int E3>  inline V operator + ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const V& b) { return a() + b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3>  inline V operator + ( const V& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a + b(); }
		template <int N, typename T, typename V, int E0, int E1, int E2, int E3, int F0, int F1, int F2, int F3>  inline V operator - ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const glm::detail::swizzle<N,T,V,F0,F1,F2,F3>& b) { return a() - b(); } template <int N, typename T, typename V, int E0, int E1, int E2, int E3>  inline V operator - ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const V& b) { return a() - b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3>  inline V operator - ( const V& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a - b(); }
		template <int N, typename T, typename V, int E0, int E1, int E2, int E3, int F0, int F1, int F2, int F3>  inline V operator * ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const glm::detail::swizzle<N,T,V,F0,F1,F2,F3>& b) { return a() * b(); } template <int N, typename T, typename V, int E0, int E1, int E2, int E3>  inline V operator * ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const V& b) { return a() * b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3>  inline V operator * ( const V& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a * b(); }
		template <int N, typename T, typename V, int E0, int E1, int E2, int E3, int F0, int F1, int F2, int F3>  inline V operator / ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const glm::detail::swizzle<N,T,V,F0,F1,F2,F3>& b) { return a() / b(); } template <int N, typename T, typename V, int E0, int E1, int E2, int E3>  inline V operator / ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const V& b) { return a() / b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3>  inline V operator / ( const V& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a / b(); }
	}

	
	
	
	
	
	
	
	
	

	
	
	
	
	

	
	
	
	
}




















































































































































































































































































































































































































































































































#line 862 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_swizzle.hpp"

#line 37 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec1.hpp"

namespace glm{
namespace detail
{
	template <typename T> struct tref1;
	template <typename T> struct tref2;
	template <typename T> struct tref3;
	template <typename T> struct tref4;
	template <typename T> struct tvec1;
	template <typename T> struct tvec2;
	template <typename T> struct tvec3;
	template <typename T> struct tvec4;

	template <typename T>
	struct tvec1
	{
		enum ctor{null};

		typedef T value_type;
		typedef std::size_t size_type;
		typedef tvec1<T> type;
		typedef tvec1<bool> bool_type;

		  size_type length() const;

		
		



#line 68 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec1.hpp"
			union {value_type x, r, s;};
#line 70 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec1.hpp"

		
		

		 value_type & operator[](size_type i);
		 value_type const & operator[](size_type i) const;

		
		

		 tvec1();
		 tvec1(tvec1<T> const & v);

		
		

		 explicit tvec1(
			ctor);
		 explicit tvec1(
			value_type const & s);

		
		

		 tvec1(tref1<T> const & r);

		
		

		
		template <typename U> 
		 explicit tvec1(U const & s);

		
		

		
		template <typename U> 
		 explicit tvec1(tvec2<U> const & v);
		
		template <typename U> 
		 explicit tvec1(tvec3<U> const & v);
		
		template <typename U> 
		 explicit tvec1(tvec4<U> const & v);

		
		

		 tvec1<T> & operator= (tvec1<T> const & v);
		template <typename U> 
		 tvec1<T> & operator= (tvec1<U> const & v);

		template <typename U> 
		 tvec1<T> & operator+=(U const & s);
		template <typename U> 
		 tvec1<T> & operator+=(tvec1<U> const & v);
		template <typename U> 
		 tvec1<T> & operator-=(U const & s);
		template <typename U> 
		 tvec1<T> & operator-=(tvec1<U> const & v);
		template <typename U> 
		 tvec1<T> & operator*=(U const & s);
		template <typename U> 
		 tvec1<T> & operator*=(tvec1<U> const & v);
		template <typename U> 
		 tvec1<T> & operator/=(U const & s);
		template <typename U> 
		 tvec1<T> & operator/=(tvec1<U> const & v);
		 tvec1<T> & operator++();
		 tvec1<T> & operator--();

		
		

		template <typename U> 
		 tvec1<T> & operator%=(U const & s);
		template <typename U> 
		 tvec1<T> & operator%=(tvec1<U> const & v);
		template <typename U> 
		 tvec1<T> & operator&=(U const & s);
		template <typename U> 
		 tvec1<T> & operator&=(tvec1<U> const & v);
		template <typename U> 
		 tvec1<T> & operator|=(U const & s);
		template <typename U> 
		 tvec1<T> & operator|=(tvec1<U> const & v);
		template <typename U> 
		 tvec1<T> & operator^=(U const & s);
		template <typename U> 
		 tvec1<T> & operator^=(tvec1<U> const & v);
		template <typename U> 
		 tvec1<T> & operator<<=(U const & s);
		template <typename U> 
		 tvec1<T> & operator<<=(tvec1<U> const & v);
		template <typename U> 
		 tvec1<T> & operator>>=(U const & s);
		template <typename U> 
		 tvec1<T> & operator>>=(tvec1<U> const & v);

		
		

		 value_type swizzle(comp X) const;
		 tvec2<T> swizzle(comp X, comp Y) const;
		 tvec3<T> swizzle(comp X, comp Y, comp Z) const;
		 tvec4<T> swizzle(comp X, comp Y, comp Z, comp W) const;
		 tref1<T> swizzle(comp X);
	};

	template <typename T>
	struct tref1
	{
		 tref1(T & x);
		 tref1(tref1<T> const & r);
		 tref1(tvec1<T> const & v);

		 tref1<T> & operator= (tref1<T> const & r);
		 tref1<T> & operator= (tvec1<T> const & v);

		T& x;
	};

	template <typename T> struct is_vector<tvec1<T> > { enum is_vector_enum { _YES = 1, _NO = 0 }; };

	typedef detail::tvec1<highp_float>		highp_vec1_t;
	typedef detail::tvec1<mediump_float>	mediump_vec1_t;
	typedef detail::tvec1<lowp_float>		lowp_vec1_t;
	typedef detail::tvec1<highp_int>		highp_ivec1_t;
	typedef detail::tvec1<mediump_int>		mediump_ivec1_t;
	typedef detail::tvec1<lowp_int>			lowp_ivec1_t;
	typedef detail::tvec1<highp_uint>		highp_uvec1_t;
	typedef detail::tvec1<mediump_uint>		mediump_uvec1_t;
	typedef detail::tvec1<lowp_uint>		lowp_uvec1_t;

}
}


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec1.inl"




























namespace glm{
namespace detail
{
	template <typename T>
	 inline  typename tvec1<T>::size_type tvec1<T>::length() const
	{
		return 1;
	}

	
	

	template <typename T>
	 inline typename tvec1<T>::value_type & tvec1<T>::operator[]
	(
		size_type i
	)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec1.inl", 47), 0) );
		return (&x)[i];
	}

	template <typename T>
	 inline typename tvec1<T>::value_type const & tvec1<T>::operator[]
	(
		size_type i
	) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec1.inl", 57), 0) );
		return (&x)[i];
	}

	
	

	template <typename T>
	 inline tvec1<T>::tvec1() :
		x(value_type(0))
	{}

	template <typename T>
	 inline tvec1<T>::tvec1
	(
		ctor
	)
	{}

	template <typename T>
	 inline tvec1<T>::tvec1
	(
		tvec1<T> const & v
	) :
		x(v.x)
	{}

	
	

	template <typename T>
	 inline tvec1<T>::tvec1
	(
		value_type const & s
	) :
		x(s)
	{}

	
	

	template <typename T>
	 inline tvec1<T>::tvec1
	(
		tref1<T> const & r
	) :
		x(r.x)
	{}

	
	
		
	template <typename T>
	template <typename U> 
	 inline tvec1<T>::tvec1
	(
		U const & s
	) :
		x(value_type(s))
	{}

	
	

	template <typename T>
	template <typename U> 
	 inline tvec1<T>::tvec1
	(
		tvec2<U> const & v
	) :
		x(value_type(v.x))
	{}

	template <typename T>
	template <typename U> 
	 inline tvec1<T>::tvec1
	(
		tvec3<U> const & v
	) :
		x(value_type(v.x))
	{}

	template <typename T>
	template <typename U> 
	 inline tvec1<T>::tvec1
	(
		tvec4<U> const & v
	) :
		x(value_type(v.x))
	{}

	
	

	template <typename T>
	 inline tvec1<T> & tvec1<T>::operator=
	(
		tvec1<T> const & v
	)
	{
		this->x = v.x;
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator=
	(
		tvec1<U> const & v
	)
	{
		this->x = T(v.x);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator+=
	(
		U const & s
	)
	{
		this->x += T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator+=
	(
		tvec1<U> const & v
	)
	{
		this->x += T(v.x);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator-=
	(
		U const & s
	)
	{
		this->x -= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator-=
	(
		tvec1<U> const & v
	)
	{
		this->x -= T(v.x);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator*=
	(
		U const & s
	)
	{
		this->x *= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator*=
	(	
		tvec1<U> const & v
	)
	{
		this->x *= T(v.x);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator/=
	(
		U const & s
	)
	{
		this->x /= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator/=
	(
		tvec1<U> const & v
	)
	{
		this->x /= T(v.x);
		return *this;
	}

	template <typename T>
	 inline tvec1<T> & tvec1<T>::operator++()
	{
		++this->x;
		return *this;
	}

	template <typename T>
	 inline tvec1<T> & tvec1<T>::operator--()
	{
		--this->x;
		return *this;
	}

	
	

	template <typename T> 
	 inline bool operator==
	(
		tvec1<T> const & v1, 
		tvec1<T> const & v2
	)
	{
		return (v1.x == v2.x);
	}

	template <typename T> 
	 inline bool operator!=
	(
		tvec1<T> const & v1, 
		tvec1<T> const & v2
	)
	{
		return (v1.x != v2.x);
	}

	
	

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator%=
	(
		U const & s
	)
	{
		this->x %= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator%=
	(
		tvec1<U> const & v
	)
	{
		this->x %= T(v.x);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator&=
	(
		U const & s
	)
	{
		this->x &= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator&=
	(
		tvec1<U> const & v
	)
	{
		this->x &= T(v.x);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator|=
	(
		U const & s
	)
	{
		this->x |= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator|=
	(
		tvec1<U> const & v
	)
	{
		this->x |= U(v.x);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator^=
	(
		U const & s
	)
	{
		this->x ^= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator^=
	(
		tvec1<U> const & v
	)
	{
		this->x ^= T(v.x);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator<<=
	(
		U const & s
	)
	{
		this->x <<= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator<<=
	(
		tvec1<U> const & v
	)
	{
		this->x <<= T(v.x);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator>>=
	(
		U const & s
	)
	{
		this->x >>= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec1<T> & tvec1<T>::operator>>=
	(
		tvec1<U> const & v
	)
	{
		this->x >>= T(v.x);
		return *this;
	}

	
	

	template <typename T>
	 inline T 
	tvec1<T>::swizzle(comp x) const
	{
		return (*this)[x];
	}

	template <typename T>
	 inline tvec2<T> 
	tvec1<T>::swizzle
	(
		comp x, 
		comp y
	) const
	{
		return tvec2<T>(
			(*this)[x],
			(*this)[y]);
	}

	template <typename T>
	 inline tvec3<T> 
	tvec1<T>::swizzle
	(
		comp x, 
		comp y, 
		comp z
	) const
	{
		return tvec3<T>(
			(*this)[x],
			(*this)[y],
			(*this)[z]);
	}

	template <typename T>
	 inline tvec4<T> 
	tvec1<T>::swizzle
	(
		comp x, 
		comp y, 
		comp z, 
		comp w
	) const
	{
		return tvec4<T>(
			(*this)[x],
			(*this)[y],
			(*this)[z],
			(*this)[w]);
	}

	template <typename T>
	 inline tref1<T> 
	tvec1<T>::swizzle
	(
		comp x
	)
	{
		return tref1<T>(
			(*this)[x]);
	}

	
	

	template <typename T> 
	 inline tvec1<T> operator+ 
	(
		tvec1<T> const & v, 
		typename tvec1<T>::value_type const & s
	)
	{
		return tvec1<T>(
			v.x + s);
	}

	template <typename T> 
	 inline tvec1<T> operator+ 
	(
		typename tvec1<T>::value_type const & s, 
		tvec1<T> const & v
	)
	{
		return tvec1<T>(
			s + v.x);
	}

	template <typename T> 
	 inline tvec1<T> operator+ 
	(
		tvec1<T> const & v1, 
		tvec1<T> const & v2
	)
	{
		return tvec1<T>(
			v1.x + v2.x);
	}

	
	template <typename T> 
	 inline tvec1<T> operator- 
	(
		tvec1<T> const & v, 
		typename tvec1<T>::value_type const & s
	)
	{
		return tvec1<T>(
			v.x - s);
	}

	template <typename T> 
	 inline tvec1<T> operator- 
	(
		typename tvec1<T>::value_type const & s, 
		tvec1<T> const & v
	)
	{
		return tvec1<T>(
			s - v.x);
	}

	template <typename T> 
	 inline tvec1<T> operator- 
	(
		tvec1<T> const & v1, 
		tvec1<T> const & v2
	)
	{
		return tvec1<T>(
			v1.x - v2.x);
	}

	
	template <typename T> 
	 inline tvec1<T> operator* 
	(
		tvec1<T> const & v, 
		typename tvec1<T>::value_type const & s
	)
	{
		return tvec1<T>(
			v.x * s);
	}

	template <typename T> 
	 inline tvec1<T> operator* 
	(
		typename tvec1<T>::value_type const & s, 
		tvec1<T> const & v
	)
	{
		return tvec1<T>(
			s * v.x);
	}

	template <typename T> 
	 inline tvec1<T> operator*
	(
		tvec1<T> const & v1, 
		tvec1<T> const & v2
	)
	{
		return tvec1<T>(
			v1.x * v2.x);
	}

	
	template <typename T> 
	 inline tvec1<T> operator/ 
	(
		tvec1<T> const & v, 
		typename tvec1<T>::value_type const & s
	)
	{
		return tvec1<T>(
			v.x / s);
	}

	template <typename T> 
	 inline tvec1<T> operator/ 
	(
		typename tvec1<T>::value_type const & s, 
		tvec1<T> const & v
	)
	{
		return tvec1<T>(
			s / v.x);
	}

	template <typename T> 
	 inline tvec1<T> operator/ 
	(
		tvec1<T> const & v1, 
		tvec1<T> const & v2
	)
	{
		return tvec1<T>(
			v1.x / v2.x);
	}

	
	template <typename T> 
	 inline tvec1<T> operator- 
	(
		tvec1<T> const & v
	)
	{
		return tvec1<T>(
			-v.x);
	}

	template <typename T> 
	 inline tvec1<T> operator++ 
	(
		tvec1<T> const & v, 
		int
	)
	{
		return tvec1<T>(
			v.x + T(1));
	}

	template <typename T> 
	 inline tvec1<T> operator-- 
	(
		tvec1<T> const & v, 
		int
	)
	{
		return tvec1<T>(
			v.x - T(1));
	}

	
	

	template <typename T>
	 inline tvec1<T> operator% 
	(
		tvec1<T> const & v, 
		typename tvec1<T>::value_type const & s
	)
	{
		return tvec1<T>(
			v.x % s);
	}

	template <typename T>
	 inline tvec1<T> operator% 
	(
		typename tvec1<T>::value_type const & s, 
		tvec1<T> const & v
	)
	{
		return tvec1<T>(
			s % v.x);
	}

	template <typename T>
	 inline tvec1<T> operator% 
	(
		tvec1<T> const & v1, 
		tvec1<T> const & v2
	)
	{
		return tvec1<T>(
			v1.x % v2.x);
	}

	template <typename T>
	 inline tvec1<T> operator& 
	(
		tvec1<T> const & v, 
		typename tvec1<T>::value_type const & s
	)
	{
		return tvec1<T>(
			v.x & s);
	}

	template <typename T>
	 inline tvec1<T> operator& 
	(
		typename tvec1<T>::value_type const & s, 
		tvec1<T> const & v
	)
	{
		return tvec1<T>(
			s & v.x);
	}

	template <typename T>
	 inline tvec1<T> operator& 
	(
		tvec1<T> const & v1, 
		tvec1<T> const & v2
	)
	{
		return tvec1<T>(
			v1.x & v2.x);
	}

	template <typename T>
	 inline tvec1<T> operator| 
	(
		tvec1<T> const & v, 
		typename tvec1<T>::value_type const & s
	)
	{
		return tvec1<T>(
			v.x | s);
	}

	template <typename T>
	 inline tvec1<T> operator| 
	(
		typename tvec1<T>::value_type const & s, 
		tvec1<T> const & v
	)
	{
		return tvec1<T>(
			s | v.x);
	}

	template <typename T>
	 inline tvec1<T> operator| 
	(
		tvec1<T> const & v1, 
		tvec1<T> const & v2
	)
	{
		return tvec1<T>(
			v1.x | v2.x);
	}
		
	template <typename T>
	 inline tvec1<T> operator^ 
	(
		tvec1<T> const & v, 
		typename tvec1<T>::value_type const & s
	)
	{
		return tvec1<T>(
			v.x ^ s);
	}

	template <typename T>
	 inline tvec1<T> operator^ 
	(
		typename tvec1<T>::value_type const & s, 
		tvec1<T> const & v
	)
	{
		return tvec1<T>(
			s ^ v.x);
	}

	template <typename T>
	 inline tvec1<T> operator^ 
	(
		tvec1<T> const & v1, 
		tvec1<T> const & v2
	)
	{
		return tvec1<T>(
			v1.x ^ v2.x);
	}

	template <typename T>
	 inline tvec1<T> operator<< 
	(
		tvec1<T> const & v, 
		typename tvec1<T>::value_type const & s
	)
	{
		return tvec1<T>(
			v.x << s);
	}

	template <typename T>
	 inline tvec1<T> operator<< 
	(
		typename tvec1<T>::value_type const & s, 
		tvec1<T> const & v
	)
	{
		return tvec1<T>(
			s << v.x);
	}

	template <typename T>
	 inline tvec1<T> operator<< 
	(
		tvec1<T> const & v1, 
		tvec1<T> const & v2
	)
	{
		return tvec1<T>(
			v1.x << v2.x);
	}

	template <typename T>
	 inline tvec1<T> operator>> 
	(
		tvec1<T> const & v, 
		typename tvec1<T>::value_type const & s
	)
	{
		return tvec1<T>(
			v.x >> s);
	}

	template <typename T>
	 inline tvec1<T> operator>> 
	(
		typename tvec1<T>::value_type const & s, 
		tvec1<T> const & v
	)
	{
		return tvec1<T>(
			s >> v.x);
	}

	template <typename T>
	 inline tvec1<T> operator>> 
	(
		tvec1<T> const & v1, 
		tvec1<T> const & v2
	)
	{
		return tvec1<T>(
			v1.x >> v2.x);
	}

	template <typename T> 
	 inline tvec1<T> operator~ 
	(
		tvec1<T> const & v
	)
	{
		return tvec1<T>(
			~v.x);
	}

	
	

	template <typename T> 
	 inline tref1<T>::tref1
	(
		T & x
	) :
		x(x)
	{}

	template <typename T> 
	 inline tref1<T>::tref1
	(
		tref1<T> const & r
	) :
		x(r.x)
	{}

	template <typename T> 
	 inline tref1<T>::tref1
	(
		tvec1<T> const & v
	) :
		x(v.x)
	{}

	template <typename T> 
	 inline tref1<T> & tref1<T>::operator= 
	(
		tref1<T> const & r
	)
	{
		x = r.x;
		return *this;
	}

	template <typename T> 
	 inline tref1<T> & tref1<T>::operator= 
	(
		tvec1<T> const & v
	)
	{
		x = v.x;
		return *this;
	}

}
}
#line 210 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec1.hpp"
#line 211 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec1.hpp"

#line 213 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec1.hpp"
#line 39 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec2.hpp"





































namespace glm{
namespace detail
{
	template <typename T> struct tref2;
	template <typename T> struct tref3;
	template <typename T> struct tref4;
	template <typename T> struct tvec3;
	template <typename T> struct tvec4;

	template <typename T>
	struct tvec2
	{
		enum ctor{null};

		typedef T value_type;
		typedef std::size_t size_type;
		typedef tvec2<T> type;
		typedef tvec2<bool> bool_type;

		  size_type length() const;

		
		


		union 
		{
			struct{value_type x, y;};
			struct{value_type r, g;};
			struct{value_type s, t;};











#line 80 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec2.hpp"
		};

















#line 99 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec2.hpp"

		
		

		 value_type & operator[](size_type i);
		 value_type const & operator[](size_type i) const;

		
		

		 tvec2();
		 tvec2(tvec2<T> const & v);

		
		

		 explicit tvec2(
			ctor);
		 explicit tvec2(
			value_type const & s);
		 explicit tvec2(
			value_type const & s1, 
			value_type const & s2);

		
		

		 tvec2(tref2<T> const & r);

		template <int E0, int E1>
		 tvec2(const glm::detail::swizzle<2,T,tvec2<T>,E0,E1,-1,-2>& that)
		{
			*this = that();
		}

		
		

		
		template <typename U> 
		 explicit tvec2(
			U const & x);
		
		template <typename U, typename V> 
		 explicit tvec2(
			U const & x, 
			V const & y);

		
		

		
		template <typename U> 
		 explicit tvec2(tvec2<U> const & v);
		
		template <typename U> 
		 explicit tvec2(tvec3<U> const & v);
		
		template <typename U> 
		 explicit tvec2(tvec4<U> const & v);

		
		

		 tvec2<T> & operator= (tvec2<T> const & v);
		template <typename U> 
		 tvec2<T> & operator= (tvec2<U> const & v);

		template <typename U> 
		 tvec2<T> & operator+=(U const & s);
		template <typename U> 
		 tvec2<T> & operator+=(tvec2<U> const & v);
		template <typename U> 
		 tvec2<T> & operator-=(U const & s);
		template <typename U> 
		 tvec2<T> & operator-=(tvec2<U> const & v);
		template <typename U> 
		 tvec2<T> & operator*=(U const & s);
		template <typename U> 
		 tvec2<T> & operator*=(tvec2<U> const & v);
		template <typename U> 
		 tvec2<T> & operator/=(U const & s);
		template <typename U> 
		 tvec2<T> & operator/=(tvec2<U> const & v);
		 tvec2<T> & operator++();
		 tvec2<T> & operator--();

		
		

		template <typename U> 
		 tvec2<T> & operator%= (U const & s);
		template <typename U> 
		 tvec2<T> & operator%= (tvec2<U> const & v);
		template <typename U> 
		 tvec2<T> & operator&= (U const & s);
		template <typename U> 
		 tvec2<T> & operator&= (tvec2<U> const & v);
		template <typename U> 
		 tvec2<T> & operator|= (U const & s);
		template <typename U> 
		 tvec2<T> & operator|= (tvec2<U> const & v);
		template <typename U> 
		 tvec2<T> & operator^= (U const & s);
		template <typename U> 
		 tvec2<T> & operator^= (tvec2<U> const & v);
		template <typename U> 
		 tvec2<T> & operator<<=(U const & s);
		template <typename U> 
		 tvec2<T> & operator<<=(tvec2<U> const & v);
		template <typename U> 
		 tvec2<T> & operator>>=(U const & s);
		template <typename U> 
		 tvec2<T> & operator>>=(tvec2<U> const & v);

		
		

		 value_type swizzle(comp X) const;
		 tvec2<T> swizzle(comp X, comp Y) const;
		 tvec3<T> swizzle(comp X, comp Y, comp Z) const;
		 tvec4<T> swizzle(comp X, comp Y, comp Z, comp W) const;
		 tref2<T> swizzle(comp X, comp Y);
	};

	template <typename T>
	struct tref2
	{
		 tref2(T & x, T & y);
		 tref2(tref2<T> const & r);
		 explicit tref2(tvec2<T> const & v);

		 tref2<T> & operator= (tref2<T> const & r);
		 tref2<T> & operator= (tvec2<T> const & v);

		 tvec2<T> operator() ();

		T & x;
		T & y;
	};

	template <typename T> struct is_vector<tvec2<T> > { enum is_vector_enum { _YES = 1, _NO = 0 }; };

} 

	
	

	
	
	
	
	
	typedef detail::tvec2<highp_float>		highp_vec2;

	
	
	
	
	
	typedef detail::tvec2<mediump_float>	mediump_vec2;

	
	
	
	
	
	typedef detail::tvec2<lowp_float>		lowp_vec2;

	
	
	
	
	
	typedef detail::tvec2<highp_int>		highp_ivec2;

	
	
	
	
	
	typedef detail::tvec2<mediump_int>		mediump_ivec2;

	
	
	
	
	
	typedef detail::tvec2<lowp_int>			lowp_ivec2;
	
	
	
	
	
	
	typedef detail::tvec2<highp_uint>		highp_uvec2;

	
	
	
	
	
	typedef detail::tvec2<mediump_uint>		mediump_uvec2;

	
	
	
	
	
	typedef detail::tvec2<lowp_uint>		lowp_uvec2;

	
}


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec2.inl"




























namespace glm{
namespace detail
{
	template <typename T>
	 inline  typename tvec2<T>::size_type tvec2<T>::length() const
	{
		return 2;
	}

	
	

	template <typename T>
	 inline typename tvec2<T>::value_type & 
	tvec2<T>::operator[]
	(
		size_type i
	)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec2.inl", 48), 0) );
		return (&x)[i];
	}

	template <typename T>
	 inline typename tvec2<T>::value_type const & 
	tvec2<T>::operator[]
	(
		size_type i
	) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec2.inl", 59), 0) );
		return (&x)[i];
	}

	
	

	template <typename T>
	 inline tvec2<T>::tvec2() :
		x(value_type(0)),
		y(value_type(0))
	{}

	template <typename T>
	 inline tvec2<T>::tvec2
	(
		ctor
	)
	{}

	template <typename T>
	 inline tvec2<T>::tvec2
	(
		tvec2<T> const & v
	) :
		x(v.x),
		y(v.y)
	{}

	
	

	template <typename T>
	 inline tvec2<T>::tvec2
	(
		value_type const & s
	) :
		x(s),
		y(s)
	{}

	template <typename T>
	 inline tvec2<T>::tvec2
	(
		value_type const & s1, 
		value_type const & s2
	) :
		x(s1),
		y(s2)
	{}

	
	

	template <typename T>
	 inline tvec2<T>::tvec2
	(
		tref2<T> const & r
	) :
		x(r.x),
		y(r.y)
	{}

	
	
		
	template <typename T>
	template <typename U> 
	 inline tvec2<T>::tvec2
	(
		U const & x
	) :
		x(value_type(x)),
		y(value_type(x))
	{}

	template <typename T>
	template <typename U, typename V> 
	 inline tvec2<T>::tvec2
	(
		U const & a, 
		V const & b
	) :
		x(value_type(a)),
		y(value_type(b))
	{}

	
	

	template <typename T>
	template <typename U> 
	 inline tvec2<T>::tvec2
	(
		tvec2<U> const & v
	) :
		x(value_type(v.x)),
		y(value_type(v.y))
	{}

	template <typename T>
	template <typename U> 
	 inline tvec2<T>::tvec2
	(
		tvec3<U> const & v
	) :
		x(value_type(v.x)),
		y(value_type(v.y))
	{}

	template <typename T>
	template <typename U> 
	 inline tvec2<T>::tvec2
	(
		tvec4<U> const & v
	) :
		x(value_type(v.x)),
		y(value_type(v.y))
	{}

	
	

	template <typename T>
	 inline tvec2<T> & tvec2<T>::operator= 
	(
		tvec2<T> const & v
	)
	{
		this->x = v.x;
		this->y = v.y;
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator= 
	(
		tvec2<U> const & v
	)
	{
		this->x = T(v.x);
		this->y = T(v.y);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator+=
	(
		U const & s
	)
	{
		this->x += T(s);
		this->y += T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator+=
	(
		tvec2<U> const & v
	)
	{
		this->x += T(v.x);
		this->y += T(v.y);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator-=
	(
		U const & s
	)
	{
		this->x -= T(s);
		this->y -= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator-=
	(
		tvec2<U> const & v
	)
	{
		this->x -= T(v.x);
		this->y -= T(v.y);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator*=
	(
		U const & s
	)
	{
		this->x *= T(s);
		this->y *= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator*=
	(
		tvec2<U> const & v
	)
	{
		this->x *= T(v.x);
		this->y *= T(v.y);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator/=
	(
		U const & s
	)
	{
		this->x /= T(s);
		this->y /= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator/=
	(
		tvec2<U> const & v
	)
	{
		this->x /= T(v.x);
		this->y /= T(v.y);
		return *this;
	}

	template <typename T>
	 inline tvec2<T> & tvec2<T>::operator++()
	{
		++this->x;
		++this->y;
		return *this;
	}

	template <typename T>
	 inline tvec2<T> & tvec2<T>::operator--()
	{
		--this->x;
		--this->y;
		return *this;
	}

	
	

	template <typename T> 
	 inline bool operator==
	(
		tvec2<T> const & v1, 
		tvec2<T> const & v2
	)
	{
		return (v1.x == v2.x) && (v1.y == v2.y);
	}

	template <typename T> 
	 inline bool operator!=
	(
		tvec2<T> const & v1, 
		tvec2<T> const & v2
	)
	{
		return (v1.x != v2.x) || (v1.y != v2.y);
	}

	
	

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator%=
	(
		U const & s
	)
	{
		this->x %= T(s);
		this->y %= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator%=
	(
		tvec2<U> const & v
	)
	{
		this->x %= T(v.x);
		this->y %= T(v.y);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator&=
	(
		U const & s
	)
	{
		this->x &= T(s);
		this->y &= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator&=
	(
		tvec2<U> const & v
	)
	{
		this->x &= T(v.x);
		this->y &= T(v.y);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator|=
	(
		U const & s
	)
	{
		this->x |= T(s);
		this->y |= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator|=
	(
		tvec2<U> const & v
	)
	{
		this->x |= T(v.x);
		this->y |= T(v.y);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator^=
	(
		U const & s
	)
	{
		this->x ^= T(s);
		this->y ^= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator^=
	(
		tvec2<U> const & v
	)
	{
		this->x ^= T(v.x);
		this->y ^= T(v.y);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator<<=
	(
		U const & s
	)
	{
		this->x <<= T(s);
		this->y <<= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator<<=
	(
		tvec2<U> const & v
	)
	{
		this->x <<= T(v.x);
		this->y <<= T(v.y);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator>>=
	(
		U const & s
	)
	{
		this->x >>= T(s);
		this->y >>= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec2<T> & tvec2<T>::operator>>=
	(
		tvec2<U> const & v
	)
	{
		this->x >>= T(v.x);
		this->y >>= T(v.y);
		return *this;
	}

	
	

	template <typename T>
	 inline typename tvec2<T>::value_type tvec2<T>::swizzle
	(
		comp x
	) const
	{
		return (*this)[x];
	}

	template <typename T>
	 inline tvec2<T> tvec2<T>::swizzle
	(
		comp x, 
		comp y
	) const
	{
		return tvec2<T>(
			(*this)[x],
			(*this)[y]);
	}

	template <typename T>
	 inline tvec3<T> tvec2<T>::swizzle
	(
		comp x, 
		comp y, 
		comp z
	) const
	{
		return tvec3<T>(
			(*this)[x],
			(*this)[y],
			(*this)[z]);
	}

	template <typename T>
	 inline tvec4<T> tvec2<T>::swizzle
	(
		comp x, 
		comp y, 
		comp z, 
		comp w
	) const
	{
		return tvec4<T>(
			(*this)[x],
			(*this)[y],
			(*this)[z],
			(*this)[w]);
	}

	template <typename T>
	 inline tref2<T> tvec2<T>::swizzle
	(
		comp x, 
		comp y
	)
	{
		return tref2<T>(
			(*this)[x],
			(*this)[y]);
	}

	
	

	template <typename T> 
	 inline tvec2<T> operator+ 
	(
		tvec2<T> const & v, 
		T const & s
	)
	{
		return tvec2<T>(
			v.x + T(s),
			v.y + T(s));
	}

	template <typename T> 
	 inline tvec2<T> operator+ 
	(
		T const & s, 
		tvec2<T> const & v
	)
	{
		return tvec2<T>(
			T(s) + v.x,
			T(s) + v.y);
	}

	template <typename T> 
	 inline tvec2<T> operator+ 
	(
		tvec2<T> const & v1, 
		tvec2<T> const & v2
	)
	{
		return tvec2<T>(
			v1.x + T(v2.x),
			v1.y + T(v2.y));
	}

	
	template <typename T> 
	 inline tvec2<T> operator-
	(
		tvec2<T> const & v, 
		T const & s
	)
	{
		return tvec2<T>(
			v.x - T(s),
			v.y - T(s));
	}

	template <typename T> 
	 inline tvec2<T> operator- 
	(
		T const & s, 
		tvec2<T> const & v
	)
	{
		return tvec2<T>(
			T(s) - v.x,
			T(s) - v.y);
	}

	template <typename T> 
	 inline tvec2<T> operator- 
	(
		tvec2<T> const & v1, 
		tvec2<T> const & v2
	)
	{
		return tvec2<T>(
			v1.x - T(v2.x),
			v1.y - T(v2.y));
	}

	
	template <typename T> 
	 inline tvec2<T> operator* 
	(
		tvec2<T> const & v, 
		T const & s
	)
	{
		return tvec2<T>(
			v.x * T(s),
			v.y * T(s));
	}

	template <typename T> 
	 inline tvec2<T> operator* 
	(
		T const & s, 
		tvec2<T> const & v
	)
	{
		return tvec2<T>(
			T(s) * v.x,
			T(s) * v.y);
	}

	template <typename T> 
	 inline tvec2<T> operator*
	(
		tvec2<T> const & v1, 
		tvec2<T> const & v2
	)
	{
		return tvec2<T>(
			v1.x * T(v2.x),
			v1.y * T(v2.y));
	}

	
	template <typename T> 
	 inline tvec2<T> operator/
	(
		tvec2<T> const & v, 
		T const & s
	)
	{
		return tvec2<T>(
			v.x / T(s),
			v.y / T(s));
	}

	template <typename T> 
	 inline tvec2<T> operator/
	(
		T const & s, 
		tvec2<T> const & v
	)
	{
		return tvec2<T>(
			T(s) / v.x,
			T(s) / v.y);
	}

	template <typename T> 
	 inline tvec2<T> operator/ 
	(
		tvec2<T> const & v1, 
		tvec2<T> const & v2
	)
	{
		return tvec2<T>(
			v1.x / T(v2.x),
			v1.y / T(v2.y));
	}

	
	template <typename T> 
	 inline tvec2<T> operator- 
	(
		tvec2<T> const & v
	)
	{
		return tvec2<T>(
			-v.x, 
			-v.y);
	}

	template <typename T> 
	 inline tvec2<T> operator++ 
	(
		tvec2<T> const & v, 
		int
	)
	{
		return tvec2<T>(
			v.x + T(1), 
			v.y + T(1));
	}

	template <typename T> 
	 inline tvec2<T> operator-- 
	(
		tvec2<T> const & v, 
		int
	)
	{
		return tvec2<T>(
			v.x - T(1), 
			v.y - T(1));
	}

	
	

	template <typename T>
	 inline tvec2<T> operator% 
	(
		tvec2<T> const & v, 
		T const & s
	)
	{
		return tvec2<T>(
			v.x % T(s),
			v.y % T(s));
	}

	template <typename T>
	 inline tvec2<T> operator%
	(
		T const & s, 
		tvec2<T> const & v
	)
	{
		return tvec2<T>(
			T(s) % v.x,
			T(s) % v.y);
	}

	template <typename T>
	 inline tvec2<T> operator% 
	(
		tvec2<T> const & v1, 
		tvec2<T> const & v2
	)
	{
		return tvec2<T>(
			v1.x % T(v2.x),
			v1.y % T(v2.y));
	}

	template <typename T>
	 inline tvec2<T> operator& 
	(
		tvec2<T> const & v, 
		T const & s
	)
	{
		return tvec2<T>(
			v.x & T(s),
			v.y & T(s));
	}

	template <typename T>
	 inline tvec2<T> operator& 
	(
		T const & s, 
		tvec2<T> const & v
	)
	{
		return tvec2<T>(
			T(s) & v.x,
			T(s) & v.y);
	}

	template <typename T>
	 inline tvec2<T> operator& 
	(
		tvec2<T> const & v1, 
		tvec2<T> const & v2
	)
	{
		return tvec2<T>(
			v1.x & T(v2.x),
			v1.y & T(v2.y));
	}

	template <typename T>
	 inline tvec2<T> operator| 
	(
		tvec2<T> const & v, 
		T const & s
	)
	{
		return tvec2<T>(
			v.x | T(s),
			v.y | T(s));
	}

	template <typename T>
	 inline tvec2<T> operator| 
	(
		T const & s, 
		tvec2<T> const & v
	)
	{
		return tvec2<T>(
			T(s) | v.x,
			T(s) | v.y);
	}

	template <typename T>
	 inline tvec2<T> operator| 
	(
		tvec2<T> const & v1, 
		tvec2<T> const & v2
	)
	{
		return tvec2<T>(
			v1.x | T(v2.x),
			v1.y | T(v2.y));
	}
		
	template <typename T>
	 inline tvec2<T> operator^ 
	(
		tvec2<T> const & v, 
		T const & s
	)
	{
		return tvec2<T>(
			v.x ^ T(s),
			v.y ^ T(s));
	}

	template <typename T>
	 inline tvec2<T> operator^ 
	(
		T const & s, 
		tvec2<T> const & v
	)
	{
		return tvec2<T>(
			T(s) ^ v.x,
			T(s) ^ v.y);
	}

	template <typename T>
	 inline tvec2<T> operator^ 
	(
		tvec2<T> const & v1, 
		tvec2<T> const & v2
	)
	{
		return tvec2<T>(
			v1.x ^ T(v2.x),
			v1.y ^ T(v2.y));
	}

	template <typename T>
	 inline tvec2<T> operator<< 
	(
		tvec2<T> const & v, 
		T const & s
	)
	{
		return tvec2<T>(
			v.x << T(s),
			v.y << T(s));
	}

	template <typename T>
	 inline tvec2<T> operator<< 
	(
		T const & s, 
		tvec2<T> const & v
	)
	{
		return tvec2<T>(
			s << T(v.x),
			s << T(v.y));
	}

	template <typename T>
	 inline tvec2<T> operator<< 
	(
		tvec2<T> const & v1, 
		tvec2<T> const & v2
	)
	{
		return tvec2<T>(
			v1.x << T(v2.x),
			v1.y << T(v2.y));
	}

	template <typename T>
	 inline tvec2<T> operator>> 
	(
		tvec2<T> const & v, 
		T const & s
	)
	{
		return tvec2<T>(
			v.x >> T(s),
			v.y >> T(s));
	}

	template <typename T>
	 inline tvec2<T> operator>> 
	(
		T const & s, 
		tvec2<T> const & v
	)
	{
		return tvec2<T>(
			T(s) >> v.x,
			T(s) >> v.y);
	}

	template <typename T>
	 inline tvec2<T> operator>>
	(
		tvec2<T> const & v1, 
		tvec2<T> const & v2
	)
	{
		return tvec2<T>(
			v1.x >> T(v2.x),
			v1.y >> T(v2.y));
	}

	template <typename T> 
	 inline tvec2<T> operator~ 
	(
		tvec2<T> const & v
	)
	{
		return tvec2<T>(
			~v.x,
			~v.y);
	}

	
	

	template <typename T> 
	tref2<T>::tref2
	(
		T & x, 
		T & y
	) :
		x(x),
		y(y)
	{}

	template <typename T> 
	tref2<T>::tref2
	(
		tref2<T> const & r
	) :
		x(r.x),
		y(r.y)
	{}

	template <typename T> 
	tref2<T>::tref2
	(
		tvec2<T> const & v
	) :
		x(v.x),
		y(v.y)
	{}

	template <typename T> 
	tref2<T>& tref2<T>::operator= 
	(
		tref2<T> const & r
	)
	{
		x = r.x;
		y = r.y;
		return *this;
	}

	template <typename T> 
	tref2<T>& tref2<T>::operator= 
	(
		tvec2<T> const & v
	)
	{
		x = v.x;
		y = v.y;
		return *this;
	}

	template <typename T> 
	 inline tvec2<T> tref2<T>::operator() ()
	{
		return tvec2<T>(this->x, this->y);
	}
}
}
#line 315 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec2.hpp"
#line 316 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec2.hpp"

#line 318 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec2.hpp"
#line 40 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec3.hpp"





































namespace glm{
namespace detail
{
	template <typename T> struct tref2;
	template <typename T> struct tref3;
	template <typename T> struct tref4;
	template <typename T> struct tvec2;
	template <typename T> struct tvec4;

	template <typename T>
	struct tvec3
	{	
		enum ctor{null};

		typedef T value_type;
		typedef std::size_t size_type;
		typedef tvec3<T> type;
		typedef tvec3<bool> bool_type;

		  size_type length() const;

		
		


		union 
		{
			struct{value_type x, y, z;};
			struct{value_type r, g, b;};
			struct{value_type s, t, p;};











#line 80 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec3.hpp"
		};


















#line 100 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec3.hpp"

		
		

		 value_type & operator[](size_type i);
		 value_type const & operator[](size_type i) const;

		
		

		 tvec3();
		 tvec3(tvec3<T> const & v);

		
		

		 explicit tvec3(
			ctor);
		 explicit tvec3(
			value_type const & s);
		 explicit tvec3(
			value_type const & s1, 
			value_type const & s2, 
			value_type const & s3);

		
		

		
		template <typename U> 
		 explicit tvec3(
			U const & x);
		
		template <typename U, typename V, typename W> 
		 explicit tvec3(
			U const & x, 
			V const & y, 
			W const & z);			

		
		

		
		template <typename A, typename B> 
		 explicit tvec3(tvec2<A> const & v, B const & s);
		
		template <typename A, typename B> 
		 explicit tvec3(A const & s, tvec2<B> const & v);
		
		template <typename U> 
		 explicit tvec3(tvec3<U> const & v);
		
		template <typename U> 
		 explicit tvec3(tvec4<U> const & v);

		
		

		 tvec3(tref3<T> const & r);

		template <typename A, typename B> 
		 explicit tvec3(tref2<A> const & v, B const & s);

		template <typename A, typename B> 
		 explicit tvec3(A const & s, tref2<B> const & v);

		template <int E0, int E1, int E2>
		 tvec3(glm::detail::swizzle<3, T, tvec3<T>, E0, E1, E2, -1> const & that)
		{
			*this = that();
		}

		template <int E0, int E1>
		 tvec3(glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v, T const & s)
		{
			*this = tvec3<T>(v(), s);
		}

		template <int E0, int E1>
		 tvec3(T const & s, glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v)
		{
			*this = tvec3<T>(s, v());
		}

		
		

		 tvec3<T> & operator= (tvec3<T> const & v);
		template <typename U> 
		 tvec3<T> & operator= (tvec3<U> const & v);

		template <typename U> 
		 tvec3<T> & operator+=(U const & s);
		template <typename U> 
		 tvec3<T> & operator+=(tvec3<U> const & v);
		template <typename U> 
		 tvec3<T> & operator-=(U const & s);
		template <typename U> 
		 tvec3<T> & operator-=(tvec3<U> const & v);
		template <typename U> 
		 tvec3<T> & operator*=(U const & s);
		template <typename U> 
		 tvec3<T> & operator*=(tvec3<U> const & v);
		template <typename U> 
		 tvec3<T> & operator/=(U const & s);
		template <typename U> 
		 tvec3<T> & operator/=(tvec3<U> const & v);
		 tvec3<T> & operator++();
		 tvec3<T> & operator--();

		
		

		template <typename U>
		 tvec3<T> & operator%= (U const & s);
		template <typename U>
		 tvec3<T> & operator%= (tvec3<U> const & v);
		template <typename U>
		 tvec3<T> & operator&= (U const & s);
		template <typename U>
		 tvec3<T> & operator&= (tvec3<U> const & v);
		template <typename U>
		 tvec3<T> & operator|= (U const & s);
		template <typename U>
		 tvec3<T> & operator|= (tvec3<U> const & v);
		template <typename U>
		 tvec3<T> & operator^= (U const & s);
		template <typename U>
		 tvec3<T> & operator^= (tvec3<U> const & v);
		template <typename U>
		 tvec3<T> & operator<<=(U const & s);
		template <typename U>
		 tvec3<T> & operator<<=(tvec3<U> const & v);
		template <typename U>
		 tvec3<T> & operator>>=(U const & s);
		template <typename U>
		 tvec3<T> & operator>>=(tvec3<U> const & v);

		
		

		 value_type swizzle(comp X) const;
		 tvec2<T> swizzle(comp X, comp Y) const;
		 tvec3<T> swizzle(comp X, comp Y, comp Z) const;
		 tvec4<T> swizzle(comp X, comp Y, comp Z, comp W) const;
		 tref2<T> swizzle(comp X, comp Y);
		 tref3<T> swizzle(comp X, comp Y, comp Z);
	};

	template <typename T>
	struct tref3
	{
		 tref3(T & x, T & y, T & z);
		 tref3(tref3<T> const & r);
		 explicit tref3(tvec3<T> const & v);

		 tref3<T> & operator= (tref3<T> const & r);
		 tref3<T> & operator= (tvec3<T> const & v);

		 tvec3<T> operator() ();

		T & x;
		T & y;
		T & z;
	};

	template <typename T> struct is_vector<tvec3<T> > { enum is_vector_enum { _YES = 1, _NO = 0 }; };
} 

	
	

	
	
	
	
	
	typedef detail::tvec3<highp_float>		highp_vec3;

	
	
	
	
	
	typedef detail::tvec3<mediump_float>	mediump_vec3;

	
	
	
	
	
	typedef detail::tvec3<lowp_float>		lowp_vec3;

	
	
	
	
	
	typedef detail::tvec3<highp_int>		highp_ivec3;

	
	
	
	
	
	typedef detail::tvec3<mediump_int>		mediump_ivec3;

	
	
	
	
	
	typedef detail::tvec3<lowp_int>			lowp_ivec3;

	
	
	
	
	
	typedef detail::tvec3<highp_uint>		highp_uvec3;

	
	
	
	
	
	typedef detail::tvec3<mediump_uint>		mediump_uvec3;

	
	
	
	
	
	typedef detail::tvec3<lowp_uint>		lowp_uvec3;

	
}


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec3.inl"




























namespace glm{
namespace detail
{
	template <typename T>
	 inline  typename tvec3<T>::size_type tvec3<T>::length() const
	{
		return 3;
	}

	
	

	template <typename T>
	 inline typename tvec3<T>::value_type & 
	tvec3<T>::operator[]
	(
		size_type i
	)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec3.inl", 48), 0) );
		return (&x)[i];
	}

	template <typename T>
	 inline typename tvec3<T>::value_type const & 
	tvec3<T>::operator[]
	(
		size_type i
	) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec3.inl", 59), 0) );
		return (&x)[i];
	}

	
	

	template <typename T>
	 inline tvec3<T>::tvec3() :
		x(value_type(0)),
		y(value_type(0)),
		z(value_type(0))
	{}

	template <typename T>
	 inline tvec3<T>::tvec3
	(
		ctor
	)
	{}

	template <typename T>
	 inline tvec3<T>::tvec3
	(
		tvec3<T> const & v
	) :
		x(v.x),
		y(v.y),
		z(v.z)
	{}

	
	

	template <typename T>
	 inline tvec3<T>::tvec3
	(
		value_type const & s
	) :
		x(s),
		y(s),
		z(s)
	{}

	template <typename T>
	 inline tvec3<T>::tvec3
	(
		value_type const & s0, 
		value_type const & s1, 
		value_type const & s2
	) :
		x(s0),
		y(s1),
		z(s2)
	{}

	
	

	template <typename T>
	 inline tvec3<T>::tvec3
	(
		tref3<T> const & r
	) :
		x(r.x),
		y(r.y),
		z(r.z)
	{}

	template <typename T>
	template <typename A, typename B> 
	 inline tvec3<T>::tvec3
	(
		tref2<A> const & v, 
		B const & s
	) : 
		x(value_type(v.x)),
		y(value_type(v.y)),
		z(value_type(s))
	{}

	template <typename T>
	template <typename A, typename B> 
	 inline tvec3<T>::tvec3
	(
		A const & s, 
		tref2<B> const & v
	) :
		x(value_type(s)),
		y(value_type(v.x)),
		z(value_type(v.y))
	{}

	
	
		
	template <typename T>
	template <typename U> 
	 inline tvec3<T>::tvec3
	(
		U const & s
	) :
		x(value_type(s)),
		y(value_type(s)),
		z(value_type(s))
	{}

	template <typename T>
	template <typename A, typename B, typename C> 
	 inline tvec3<T>::tvec3
	(
		A const & x, 
		B const & y, 
		C const & z
	) :
		x(value_type(x)),
		y(value_type(y)),
		z(value_type(z))
	{}

	
	

	template <typename T>
	template <typename A, typename B> 
	 inline tvec3<T>::tvec3
	(
		tvec2<A> const & v, 
		B const & s
	) :
		x(value_type(v.x)),
		y(value_type(v.y)),
		z(value_type(s))
	{}

	template <typename T>
	template <typename A, typename B> 
	 inline tvec3<T>::tvec3
	(	
		A const & s, 
		tvec2<B> const & v
	) :
		x(value_type(s)),
		y(value_type(v.x)),
		z(value_type(v.y))
	{}

	template <typename T>
	template <typename U> 
	 inline tvec3<T>::tvec3
	(
		tvec3<U> const & v
	) :
		x(value_type(v.x)),
		y(value_type(v.y)),
		z(value_type(v.z))
	{}

	template <typename T>
	template <typename U> 
	 inline tvec3<T>::tvec3
	(
		tvec4<U> const & v
	) :
		x(value_type(v.x)),
		y(value_type(v.y)),
		z(value_type(v.z))
	{}

	
	

	template <typename T>
	 inline tvec3<T>& tvec3<T>::operator= 
	(
		tvec3<T> const & v
	)
	{
		this->x = v.x;
		this->y = v.y;
		this->z = v.z;
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T>& tvec3<T>::operator= 
	(
		tvec3<U> const & v
	)
	{
		this->x = T(v.x);
		this->y = T(v.y);
		this->z = T(v.z);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator+=
	(
		U const & s
	)
	{
		this->x += T(s);
		this->y += T(s);
		this->z += T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator+=
	(
		tvec3<U> const & v
	)
	{
		this->x += T(v.x);
		this->y += T(v.y);
		this->z += T(v.z);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator-=
	(
		U const & s
	)
	{
		this->x -= T(s);
		this->y -= T(s);
		this->z -= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator-=
	(
		tvec3<U> const & v
	)
	{
		this->x -= T(v.x);
		this->y -= T(v.y);
		this->z -= T(v.z);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator*=
	(
		U const & s
	)
	{
		this->x *= T(s);
		this->y *= T(s);
		this->z *= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator*=
	(
		tvec3<U> const & v
	)
	{
		this->x *= T(v.x);
		this->y *= T(v.y);
		this->z *= T(v.z);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator/=
	(
		U const & s
	)
	{
		this->x /= T(s);
		this->y /= T(s);
		this->z /= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator/=
	(
		tvec3<U> const & v
	)
	{
		this->x /= T(v.x);
		this->y /= T(v.y);
		this->z /= T(v.z);
		return *this;
	}

	template <typename T>
	 inline tvec3<T> & tvec3<T>::operator++()
	{
		++this->x;
		++this->y;
		++this->z;
		return *this;
	}

	template <typename T>
	 inline tvec3<T> & tvec3<T>::operator--()
	{
		--this->x;
		--this->y;
		--this->z;
		return *this;
	}

	
	

	template <typename T> 
	 inline bool operator==
	(
		tvec3<T> const & v1, 
		tvec3<T> const & v2
	)
	{
		return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z);
	}

	template <typename T> 
	 inline bool operator!=
	(
		tvec3<T> const & v1, 
		tvec3<T> const & v2
	)
	{
		return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z);
	}

	
	

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator%=
	(
		U const & s
	)
	{
		this->x %= s;
		this->y %= s;
		this->z %= s;
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator%=
	(
		tvec3<U> const & v
	)
	{
		this->x %= v.x;
		this->y %= v.y;
		this->z %= v.z;
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator&=
	(	
		U const & s
	)
	{
		this->x &= s;
		this->y &= s;
		this->z &= s;
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator&=
	(
		tvec3<U> const & v
	)
	{
		this->x &= v.x;
		this->y &= v.y;
		this->z &= v.z;
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator|=
	(
		U const & s
	)
	{
		this->x |= s;
		this->y |= s;
		this->z |= s;
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator|=
	(
		tvec3<U> const & v
	)
	{
		this->x |= v.x;
		this->y |= v.y;
		this->z |= v.z;
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator^=
	(
		U const & s
	)
	{
		this->x ^= s;
		this->y ^= s;
		this->z ^= s;
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator^=
	(
		tvec3<U> const & v
	)
	{
		this->x ^= v.x;
		this->y ^= v.y;
		this->z ^= v.z;
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator<<=
	(
		U const & s
	)
	{
		this->x <<= s;
		this->y <<= s;
		this->z <<= s;
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator<<=
	(
		tvec3<U> const & v
	)
	{
		this->x <<= T(v.x);
		this->y <<= T(v.y);
		this->z <<= T(v.z);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator>>=
	(
		U const & s
	)
	{
		this->x >>= T(s);
		this->y >>= T(s);
		this->z >>= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec3<T> & tvec3<T>::operator>>=
	(
		tvec3<U> const & v
	)
	{
		this->x >>= T(v.x);
		this->y >>= T(v.y);
		this->z >>= T(v.z);
		return *this;
	}

	
	

	template <typename T>
	 inline typename tvec3<T>::value_type 
	tvec3<T>::swizzle
	(
		comp x
	) const
	{
		return (*this)[x];
	}

	template <typename T>
	 inline tvec2<T> tvec3<T>::swizzle
	(
		comp x, 
		comp y
	) const
	{
		return tvec2<T>(
			(*this)[x],
			(*this)[y]);
	}

	template <typename T>
	 inline tvec3<T> tvec3<T>::swizzle
	(
		comp x, 
		comp y, 
		comp z
	) const
	{
		return tvec3<T>(
			(*this)[x],
			(*this)[y],
			(*this)[z]);
	}

	template <typename T>
	 inline tvec4<T> tvec3<T>::swizzle
	(
		comp x, 
		comp y, 
		comp z, 
		comp w
	) const
	{
		return tvec4<T>(
			(*this)[x],
			(*this)[y],
			(*this)[z],
			(*this)[w]);
	}

	template <typename T>
	 inline tref2<T> tvec3<T>::swizzle
	(
		comp x, 
		comp y
	)
	{
		return tref2<T>(
			(*this)[x],
			(*this)[y]);
	}

	template <typename T>
	 inline tref3<T> tvec3<T>::swizzle
	(
		comp x, 
		comp y, 
		comp z
	)
	{
		return tref3<T>(
			(*this)[x],
			(*this)[y],
			(*this)[z]);
	}

	
	

	template <typename T> 
	 inline tvec3<T> operator+
	(
		tvec3<T> const & v, 
		T const & s
	)
	{
		return tvec3<T>(
			v.x + T(s),
			v.y + T(s),
			v.z + T(s));
	}

	template <typename T> 
	 inline tvec3<T> operator+ 
	(
		T const & s, 
		tvec3<T> const & v
	)
	{
		return tvec3<T>(
			T(s) + v.x,
			T(s) + v.y,
			T(s) + v.z);
	}

	template <typename T> 
	 inline tvec3<T> operator+ 
	(
		tvec3<T> const & v1, 
		tvec3<T> const & v2
	)
	{
		return tvec3<T>(
			v1.x + T(v2.x),
			v1.y + T(v2.y),
			v1.z + T(v2.z));
	}

	
	template <typename T> 
	 inline tvec3<T> operator- 
	(
		tvec3<T> const & v, 
		T const & s
	)
	{
		return tvec3<T>(
			v.x - T(s),
			v.y - T(s),
			v.z - T(s));
	}

	template <typename T> 
	 inline tvec3<T> operator- 
	(
		T const & s, 
		tvec3<T> const & v
	)
	{
		return tvec3<T>(
			T(s) - v.x,
			T(s) - v.y,
			T(s) - v.z);
	}

	template <typename T> 
	 inline tvec3<T> operator- 
	(
		tvec3<T> const & v1, 
		tvec3<T> const & v2
	)
	{
		return tvec3<T>(
			v1.x - T(v2.x),
			v1.y - T(v2.y),
			v1.z - T(v2.z));
	}

	
	template <typename T> 
	 inline tvec3<T> operator*
	(
		tvec3<T> const & v, 
		T const & s
	)
	{
		return tvec3<T>(
			v.x * T(s),
			v.y * T(s),
			v.z * T(s));
	}

	template <typename T> 
	 inline tvec3<T> operator* 
	(
		T const & s, 
		tvec3<T> const & v
	)
	{
		return tvec3<T>(
			T(s) * v.x,
			T(s) * v.y,
			T(s) * v.z);
	}

	template <typename T> 
	 inline tvec3<T> operator* 
	(
		tvec3<T> const & v1, 
		tvec3<T> const & v2
	)
	{
		return tvec3<T>(
			v1.x * T(v2.x),
			v1.y * T(v2.y),
			v1.z * T(v2.z));
	}

	
	template <typename T> 
	 inline tvec3<T> operator/
	(
		tvec3<T> const & v, 
		T const & s
	)
	{
		return tvec3<T>(
			v.x / T(s),
			v.y / T(s),
			v.z / T(s));
	}

	template <typename T> 
	 inline tvec3<T> operator/ 
	(
		T const & s, 
		tvec3<T> const & v
	)
	{
		return tvec3<T>(
			T(s) / v.x,
			T(s) / v.y,
			T(s) / v.z);
	}

	template <typename T> 
	 inline tvec3<T> operator/ 
	(
		tvec3<T> const & v1, 
		tvec3<T> const & v2
	)
	{
		return tvec3<T>(
			v1.x / T(v2.x),
			v1.y / T(v2.y),
			v1.z / T(v2.z));
	}

	
	template <typename T> 
	 inline tvec3<T> operator- 
	(
		tvec3<T> const & v
	)
	{
		return tvec3<T>(
			-v.x, 
			-v.y, 
			-v.z);
	}

	template <typename T> 
	 inline tvec3<T> operator++ 
	(
		tvec3<T> const & v, 
		int
	)
	{
		return tvec3<T>(
			v.x + T(1), 
			v.y + T(1), 
			v.z + T(1));
	}

	template <typename T> 
	 inline tvec3<T> operator-- 
	(
		tvec3<T> const & v, 
		int
	)
	{
		return tvec3<T>(
			v.x - T(1), 
			v.y - T(1), 
			v.z - T(1));
	}

	
	

	template <typename T>
	 inline tvec3<T> operator% 
	(
		tvec3<T> const & v, 
		T const & s
	)
	{
		return tvec3<T>(
			v.x % T(s),
			v.y % T(s),
			v.z % T(s));
	}

	template <typename T>
	 inline tvec3<T> operator%
	(
		T const & s, 
		tvec3<T> const & v
	)
	{
		return tvec3<T>(
			T(s) % v.x,
			T(s) % v.y,
			T(s) % v.z);
	}

	template <typename T>
	 inline tvec3<T> operator% 
	(
		tvec3<T> const & v1, 
		tvec3<T> const & v2
	)
	{
		return tvec3<T>(
			v1.x % T(v2.x),
			v1.y % T(v2.y),
			v1.z % T(v2.z));
	}

	template <typename T>
	 inline tvec3<T> operator& 
	(
		tvec3<T> const & v, 
		T const & s
	)
	{
		return tvec3<T>(
			v.x & T(s),
			v.y & T(s),
			v.z & T(s));
	}

	template <typename T>
	 inline tvec3<T> operator& 
	(
		T const & s, 
		tvec3<T> const & v
	)
	{
		return tvec3<T>(
			T(s) & v.x,
			T(s) & v.y,
			T(s) & v.z);
	}

	template <typename T>
	 inline tvec3<T> operator& 
	(
		tvec3<T> const & v1, 
		tvec3<T> const & v2
	)
	{
		return tvec3<T>(
			v1.x & T(v2.x),
			v1.y & T(v2.y),
			v1.z & T(v2.z));
	}

	template <typename T>
	 inline tvec3<T> operator| 
	(
		tvec3<T> const & v, 
		T const & s
	)
	{
		return tvec3<T>(
			v.x | T(s),
			v.y | T(s),
			v.z | T(s));
	}

	template <typename T>
	 inline tvec3<T> operator| 
	(
		T const & s, 
		tvec3<T> const & v
	)
	{
		return tvec3<T>(
			T(s) | v.x,
			T(s) | v.y,
			T(s) | v.z);
	}

	template <typename T>
	 inline tvec3<T> operator| 
	(
		tvec3<T> const & v1, 
		tvec3<T> const & v2
	)
	{
		return tvec3<T>(
			v1.x | T(v2.x),
			v1.y | T(v2.y),
			v1.z | T(v2.z));
	}
		
	template <typename T>
	 inline tvec3<T> operator^ 
	(
		tvec3<T> const & v, 
		T const & s
	)
	{
		return tvec3<T>(
			v.x ^ T(s),
			v.y ^ T(s),
			v.z ^ T(s));
	}

	template <typename T>
	 inline tvec3<T> operator^ 
	(
		T const & s, 
		tvec3<T> const & v
	)
	{
		return tvec3<T>(
			T(s) ^ v.x,
			T(s) ^ v.y,
			T(s) ^ v.z);
	}

	template <typename T>
	 inline tvec3<T> operator^ 
	(
		tvec3<T> const & v1, 
		tvec3<T> const & v2
	)
	{
		return tvec3<T>(
			v1.x ^ T(v2.x),
			v1.y ^ T(v2.y),
			v1.z ^ T(v2.z));
	}

	template <typename T>
	 inline tvec3<T> operator<< 
	(
		tvec3<T> const & v, 
		T const & s
	)
	{
		return tvec3<T>(
			v.x << T(s),
			v.y << T(s),
			v.z << T(s));
	}

	template <typename T>
	 inline tvec3<T> operator<< 
	(
		T const & s, 
		tvec3<T> const & v
	)
	{
		return tvec3<T>(
			T(s) << v.x,
			T(s) << v.y,
			T(s) << v.z);
	}

	template <typename T>
	 inline tvec3<T> operator<< 
	(
		tvec3<T> const & v1, 
		tvec3<T> const & v2
	)
	{
		return tvec3<T>(
			v1.x << T(v2.x),
			v1.y << T(v2.y),
			v1.z << T(v2.z));
	}

	template <typename T>
	 inline tvec3<T> operator>> 
	(
		tvec3<T> const & v, 
		T const & s
	)
	{
		return tvec3<T>(
			v.x >> T(s),
			v.y >> T(s),
			v.z >> T(s));
	}

	template <typename T>
	 inline tvec3<T> operator>> 
	(
		T const & s, 
		tvec3<T> const & v
	)
	{
		return tvec3<T>(
			s >> T(v.x),
			s >> T(v.y),
			s >> T(v.z));
	}

	template <typename T>
	 inline tvec3<T> operator>> 
	(
		tvec3<T> const & v1, 
		tvec3<T> const & v2
	)
	{
		return tvec3<T>(
			v1.x >> T(v2.x),
			v1.y >> T(v2.y),
			v1.z >> T(v2.z));
	}

	template <typename T> 
	 inline tvec3<T> operator~ 
	(
		tvec3<T> const & v
	)
	{
		return tvec3<T>(
			~v.x,
			~v.y,
			~v.z);
	}

	
	

	template <typename T> 
	 inline tref3<T>::tref3(T & x, T & y, T & z) :
		x(x),
		y(y),
		z(z)
	{}

	template <typename T> 
	 inline tref3<T>::tref3
	(
		tref3<T> const & r
	) :
		x(r.x),
		y(r.y),
		z(r.z)
	{}

	template <typename T> 
	 inline tref3<T>::tref3
	(
		tvec3<T> const & v
	) :
		x(v.x),
		y(v.y),
		z(v.z)
	{}

	template <typename T> 
	 inline tref3<T> & tref3<T>::operator=
	(
		tref3<T> const & r
	)
	{
		x = r.x;
		y = r.y;
		z = r.z;
		return *this;
	}

	template <typename T> 
	 inline tref3<T> & tref3<T>::operator=
	(
		tvec3<T> const & v
	)
	{
		x = v.x;
		y = v.y;
		z = v.z;
		return *this;
	}

	template <typename T> 
	 inline tvec3<T> tref3<T>::operator() ()
	{
		return tvec3<T>(this->x, this->y, this->z);
	}

}
}
#line 340 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec3.hpp"
#line 341 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec3.hpp"

#line 343 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec3.hpp"
#line 41 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec4.hpp"





































namespace glm{
namespace detail
{
	template <typename T> struct tref2;
	template <typename T> struct tref3;
	template <typename T> struct tref4;
	template <typename T> struct tvec2;
	template <typename T> struct tvec3;

	template <typename T>
	struct tvec4
	{
		enum ctor{null};

		typedef T value_type;
		typedef std::size_t size_type;
		typedef tvec4<T> type;
		typedef tvec4<bool> bool_type;

		  size_type length() const;

		
		


		union 
		{
			struct{value_type x, y, z, w;};
			struct{value_type r, g, b, a;};
			struct{value_type s, t, p, q;};











#line 80 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec4.hpp"
		};



















#line 101 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec4.hpp"

		
		

		 value_type & operator[](size_type i);
		 value_type const & operator[](size_type i) const;

		
		

		 tvec4();
		 tvec4(type const & v);

		
		

		 explicit tvec4(
			ctor);
		 explicit tvec4(
			value_type const & s);
		 explicit tvec4(
			value_type const & s0, 
			value_type const & s1, 
			value_type const & s2, 
			value_type const & s3);

		
		

		
		template <typename U> 
		 explicit tvec4(
			U const & x);
		
		template <typename A, typename B, typename C, typename D> 
		 explicit tvec4(
			A const & x, 
			B const & y, 
			C const & z, 
			D const & w);			

		
		

		
		template <typename A, typename B, typename C> 
		 explicit tvec4(tvec2<A> const & v, B const & s1, C const & s2);
		
		template <typename A, typename B, typename C> 
		 explicit tvec4(A const & s1, tvec2<B> const & v, C const & s2);
		
		template <typename A, typename B, typename C> 
		 explicit tvec4(A const & s1, B const & s2, tvec2<C> const & v);
		
		template <typename A, typename B> 
		 explicit tvec4(tvec3<A> const & v, B const & s);
		
		template <typename A, typename B> 
		 explicit tvec4(A const & s, tvec3<B> const & v);
		
		template <typename A, typename B> 
		 explicit tvec4(tvec2<A> const & v1, tvec2<B> const & v2);
		
		template <typename U> 
		 explicit tvec4(tvec4<U> const & v);

		template <int E0, int E1, int E2, int E3>
		 tvec4(glm::detail::swizzle<4, T, tvec4<T>, E0, E1, E2, E3> const & that)
		{
			*this = that();
		}

		template <int E0, int E1, int F0, int F1>
		 tvec4(glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v, glm::detail::swizzle<2, T, tvec2<T>, F0, F1, -1, -2> const & u)
		{
			*this = tvec4<T>(v(), u());
		}

		template <int E0, int E1>
		 tvec4(T const & x, T const & y, glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v)
		{
			*this = tvec4<T>(x, y, v());
		}

		template <int E0, int E1>
		 tvec4(T const & x, glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v, T const & w)
		{
			*this = tvec4<T>(x, v(), w);
		}

		template <int E0, int E1>
		 tvec4(glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v, T const & z, T const & w)
		{
			*this = tvec4<T>(v(), z, w);
		}

		template <int E0, int E1, int E2>
		 tvec4(glm::detail::swizzle<3, T, tvec3<T>, E0, E1, E2, -1> const & v, T const & w)
		{
			*this = tvec4<T>(v(), w);
		}

		template <int E0, int E1, int E2>
		 tvec4(T const & x, glm::detail::swizzle<3, T, tvec3<T>, E0, E1, E2, -1> const & v)
		{
			*this = tvec4<T>(x, v());
		}

		
		

		 tvec4(tref4<T> const & r);

		
		template <typename A, typename B, typename C> 
		 explicit tvec4(tref2<A> const & v, B const & s1, C const & s2);
		
		template <typename A, typename B, typename C> 
		 explicit tvec4(A const & s1, tref2<B> const & v, C const & s2);
		
		template <typename A, typename B, typename C> 
		 explicit tvec4(A const & s1, B const & s2, tref2<C> const & v);
		
		template <typename A, typename B> 
		 explicit tvec4(tref3<A> const & v, B const & s);
		
		template <typename A, typename B> 
		 explicit tvec4(A const & s, tref3<B> const & v);
		
		template <typename A, typename B> 
		 explicit tvec4(tref2<A> const & v1, tref2<B> const & v2);
		
		template <typename A, typename B> 
		 explicit tvec4(tvec2<A> const & v1, tref2<B> const & v2);
		
		template <typename A, typename B> 
		 explicit tvec4(tref2<A> const & v1, tvec2<B> const & v2);

		
		

		 tvec4<T> & operator= (tvec4<T> const & v);
		template <typename U>
		 tvec4<T> & operator= (tvec4<U> const & v);

		template <typename U>
		 tvec4<T> & operator+=(U const & s);
		template <typename U>
		 tvec4<T> & operator+=(tvec4<U> const & v);
		template <typename U>
		 tvec4<T> & operator-=(U const & s);
		template <typename U>
		 tvec4<T> & operator-=(tvec4<U> const & v);
		template <typename U>
		 tvec4<T> & operator*=(U const & s);
		template <typename U>
		 tvec4<T> & operator*=(tvec4<U> const & v);
		template <typename U>
		 tvec4<T> & operator/=(U const & s);
		template <typename U>
		 tvec4<T> & operator/=(tvec4<U> const & v);
		 tvec4<T> & operator++();
		 tvec4<T> & operator--();

		
		

		template <typename U>
		 tvec4<T> & operator%= (U const & s);
		template <typename U>
		 tvec4<T> & operator%= (tvec4<U> const & v);
		template <typename U>
		 tvec4<T> & operator&= (U const & s);
		template <typename U>
		 tvec4<T> & operator&= (tvec4<U> const & v);
		template <typename U>
		 tvec4<T> & operator|= (U const & s);
		template <typename U>
		 tvec4<T> & operator|= (tvec4<U> const & v);
		template <typename U>
		 tvec4<T> & operator^= (U const & s);
		template <typename U>
		 tvec4<T> & operator^= (tvec4<U> const & v);
		template <typename U>
		 tvec4<T> & operator<<=(U const & s);
		template <typename U>
		 tvec4<T> & operator<<=(tvec4<U> const & v);
		template <typename U>
		 tvec4<T> & operator>>=(U const & s);
		template <typename U>
		 tvec4<T> & operator>>=(tvec4<U> const & v);

		
		

		 value_type swizzle(comp X) const;
		 tvec2<T> swizzle(comp X, comp Y) const;
		 tvec3<T> swizzle(comp X, comp Y, comp Z) const;
		 tvec4<T> swizzle(comp X, comp Y, comp Z, comp W) const;
		 tref2<T> swizzle(comp X, comp Y);
		 tref3<T> swizzle(comp X, comp Y, comp Z);
		 tref4<T> swizzle(comp X, comp Y, comp Z, comp W);
	};

	template <typename T>
	struct tref4
	{
		 tref4(T & x, T & y, T & z, T & w);
		 tref4(tref4<T> const & r);
		 explicit tref4(tvec4<T> const & v);

		 tref4<T> & operator= (tref4<T> const & r);
		 tref4<T> & operator= (tvec4<T> const & v);

		 tvec4<T> operator() ();

		T & x;
		T & y;
		T & z;
		T & w;
	};

	template <typename T> struct is_vector<tvec4<T> > { enum is_vector_enum { _YES = 1, _NO = 0 }; };
}

	
	

	
	
	
	
	
	typedef detail::tvec4<highp_float>		highp_vec4;

	
	
	
	
	
	typedef detail::tvec4<mediump_float>	mediump_vec4;

	
	
	
	
	
	typedef detail::tvec4<lowp_float>		lowp_vec4;

	
	
	
	
	
	typedef detail::tvec4<highp_int>		highp_ivec4;

	
	
	
	
	
	typedef detail::tvec4<mediump_int>		mediump_ivec4;

	
	
	
	
	
	typedef detail::tvec4<lowp_int>			lowp_ivec4;

	
	
	
	
	
	typedef detail::tvec4<highp_uint>		highp_uvec4;

	
	
	
	
	
	typedef detail::tvec4<mediump_uint>		mediump_uvec4;

	
	
	
	
	
	typedef detail::tvec4<lowp_uint>		lowp_uvec4;

	
}


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec4.inl"




























namespace glm{
namespace detail
{
	template <typename T>
	 inline  typename tvec4<T>::size_type tvec4<T>::length() const
	{
		return 4;
	}

	
	

	template <typename T>
	 inline typename tvec4<T>::value_type & 
	tvec4<T>::operator[]
	(
		size_type i
	)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec4.inl", 48), 0) );
		return (&x)[i];
	}

	template <typename T>
	 inline typename tvec4<T>::value_type const & 
	tvec4<T>::operator[]
	(
		size_type i
	) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec4.inl", 59), 0) );
		return (&x)[i];
	}

	
	

	template <typename T>
	 inline tvec4<T>::tvec4() :
		x(value_type(0)),
		y(value_type(0)),
		z(value_type(0)),
		w(value_type(0))
	{}

	template <typename T> 
	 inline tvec4<T>::tvec4
	(
		ctor
	)
	{}

	template <typename T>
	 inline tvec4<T>::tvec4
	(
		type const & v
	) :
		x(v.x),
		y(v.y),
		z(v.z),
		w(v.w)
	{}

	
	

	template <typename T>
	 inline tvec4<T>::tvec4
	(
		value_type const & s
	) :
		x(s),
		y(s),
		z(s),
		w(s)
	{}

	template <typename T>
	 inline tvec4<T>::tvec4
	(
		value_type const & s1, 
		value_type const & s2, 
		value_type const & s3, 
		value_type const & s4
	) :
		x(s1),
		y(s2),
		z(s3),
		w(s4)
	{}

	
	

	template <typename T>
	 inline tvec4<T>::tvec4
	(
		tref4<T> const & r
	) :
		x(r.x),
		y(r.y),
		z(r.z),
		w(r.w)
	{}

	template <typename T>
	template <typename A, typename B, typename C> 
	 inline tvec4<T>::tvec4
	(
		tref2<A> const & v, 
		B const & s1, 
		C const & s2
	) :
		x(value_type(v.x)),
		y(value_type(v.y)),
		z(value_type(s1)),
		w(value_type(s2))
	{}

	template <typename T>
	template <typename A, typename B, typename C> 
	 inline tvec4<T>::tvec4
	(
		A const & s1, 
		tref2<B> const & v, 
		C const & s2
	) :
		x(value_type(s1)),
		y(value_type(v.x)),
		z(value_type(v.y)),
		w(value_type(s2))
	{}

	template <typename T>
	template <typename A, typename B, typename C> 
	 inline tvec4<T>::tvec4
	(
		A const & s1, 
		B const & s2, 
		tref2<C> const & v
	) :
		x(value_type(s1)),
		y(value_type(s2)),
		z(value_type(v.x)),
		w(value_type(v.y))
	{}

	template <typename T>
	template <typename A, typename B> 
	 inline tvec4<T>::tvec4
	(
		tref3<A> const & v, 
		B const & s
	) :
		x(value_type(v.x)),
		y(value_type(v.y)),
		z(value_type(v.z)),
		w(value_type(s))
	{}

	template <typename T>
	template <typename A, typename B> 
	 inline tvec4<T>::tvec4
	(
		A const & s, 
		tref3<B> const & v
	) :
		x(value_type(s)),
		y(value_type(v.x)),
		z(value_type(v.y)),
		w(value_type(v.z))
	{}

	template <typename T>
	template <typename A, typename B> 
	 inline tvec4<T>::tvec4
	(
		tref2<A> const & v1, 
		tref2<B> const & v2
	) :
		x(value_type(v1.x)),
		y(value_type(v1.y)),
		z(value_type(v2.x)),
		w(value_type(v2.y))
	{}

	template <typename T>
	template <typename A, typename B> 
	 inline tvec4<T>::tvec4
	(
		tvec2<A> const & v1, 
		tref2<B> const & v2
	) :
		x(value_type(v1.x)),
		y(value_type(v1.y)),
		z(value_type(v2.x)),
		w(value_type(v2.y))
	{}

	template <typename T>
	template <typename A, typename B> 
	 inline tvec4<T>::tvec4
	(
		tref2<A> const & v1, 
		tvec2<B> const & v2
	) :
		x(value_type(v1.x)),
		y(value_type(v1.y)),
		z(value_type(v2.x)),
		w(value_type(v2.y))
	{}

	
	
		
	template <typename T>
	template <typename U> 
	 inline tvec4<T>::tvec4
	(
		U const & x
	) :
		x(value_type(x)),
		y(value_type(x)),
		z(value_type(x)),
		w(value_type(x))
	{}

	template <typename T>
	template <typename A, typename B, typename C, typename D> 
	 inline tvec4<T>::tvec4
	(
		A const & x, 
		B const & y, 
		C const & z, 
		D const & w
	) :
		x(value_type(x)),
		y(value_type(y)),
		z(value_type(z)),
		w(value_type(w))
	{}

	
	

	template <typename T>
	template <typename A, typename B, typename C> 
	 inline tvec4<T>::tvec4
	(
		tvec2<A> const & v, 
		B const & s1, 
		C const & s2
	) :
		x(value_type(v.x)),
		y(value_type(v.y)),
		z(value_type(s1)),
		w(value_type(s2))
	{}

	template <typename T>
	template <typename A, typename B, typename C> 
	 inline tvec4<T>::tvec4
	(
		A const & s1, 
		tvec2<B> const & v, 
		C const & s2
	) :
		x(value_type(s1)),
		y(value_type(v.x)),
		z(value_type(v.y)),
		w(value_type(s2))
	{}

	template <typename T>
	template <typename A, typename B, typename C> 
	 inline tvec4<T>::tvec4
	(
		A const & s1, 
		B const & s2, 
		tvec2<C> const & v
	) :
		x(value_type(s1)),
		y(value_type(s2)),
		z(value_type(v.x)),
		w(value_type(v.y))
	{}

	template <typename T>
	template <typename A, typename B> 
	 inline tvec4<T>::tvec4
	(
		tvec3<A> const & v, 
		B const & s
	) :
		x(value_type(v.x)),
		y(value_type(v.y)),
		z(value_type(v.z)),
		w(value_type(s))
	{}

	template <typename T>
	template <typename A, typename B> 
	 inline tvec4<T>::tvec4
	(
		A const & s, 
		tvec3<B> const & v
	) :
		x(value_type(s)),
		y(value_type(v.x)),
		z(value_type(v.y)),
		w(value_type(v.z))
	{}

	template <typename T>
	template <typename A, typename B> 
	 inline tvec4<T>::tvec4
	(
		tvec2<A> const & v1, 
		tvec2<B> const & v2
	) :
		x(value_type(v1.x)),
		y(value_type(v1.y)),
		z(value_type(v2.x)),
		w(value_type(v2.y))
	{}

	template <typename T>
	template <typename U> 
	 inline tvec4<T>::tvec4
	(
		tvec4<U> const & v
	) :
		x(value_type(v.x)),
		y(value_type(v.y)),
		z(value_type(v.z)),
		w(value_type(v.w))
	{}

	
	

	template <typename T>
	 inline tvec4<T> & tvec4<T>::operator= 
	(
		tvec4<T> const & v
	)
	{
		this->x = v.x;
		this->y = v.y;
		this->z = v.z;
		this->w = v.w;
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator= 
	(
		tvec4<U> const & v
	)
	{
		this->x = T(v.x);
		this->y = T(v.y);
		this->z = T(v.z);
		this->w = T(v.w);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator+=
	(
		U const & s
	)
	{
		this->x += T(s);
		this->y += T(s);
		this->z += T(s);
		this->w += T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator+=
	(
		tvec4<U> const & v
	)
	{
		this->x += T(v.x);
		this->y += T(v.y);
		this->z += T(v.z);
		this->w += T(v.w);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator-=
	(
		U const & s
	)
	{
		this->x -= T(s);
		this->y -= T(s);
		this->z -= T(s);
		this->w -= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator-=
	(
		tvec4<U> const & v
	)
	{
		this->x -= T(v.x);
		this->y -= T(v.y);
		this->z -= T(v.z);
		this->w -= T(v.w);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator*=
	(
		U const & s
	)
	{
		this->x *= T(s);
		this->y *= T(s);
		this->z *= T(s);
		this->w *= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator*=
	(
		tvec4<U> const & v
	)
	{
		this->x *= T(v.x);
		this->y *= T(v.y);
		this->z *= T(v.z);
		this->w *= T(v.w);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator/=
	(
		U const & s
	)
	{
		this->x /= T(s);
		this->y /= T(s);
		this->z /= T(s);
		this->w /= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator/=
	(
		tvec4<U> const & v
	)
	{
		this->x /= T(v.x);
		this->y /= T(v.y);
		this->z /= T(v.z);
		this->w /= T(v.w);
		return *this;
	}

	template <typename T>
	 inline tvec4<T> & tvec4<T>::operator++()
	{
		++this->x;
		++this->y;
		++this->z;
		++this->w;
		return *this;
	}

	template <typename T>
	 inline tvec4<T> & tvec4<T>::operator--()
	{
		--this->x;
		--this->y;
		--this->z;
		--this->w;
		return *this;
	}

	
	

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator%=
	(
		U const & s
	)
	{
		this->x %= T(s);
		this->y %= T(s);
		this->z %= T(s);
		this->w %= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator%=
	(
		tvec4<U> const & v
	)
	{
		this->x %= T(v.x);
		this->y %= T(v.y);
		this->z %= T(v.z);
		this->w %= T(v.w);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator&=
	(
		U const & s
	)
	{
		this->x &= T(s);
		this->y &= T(s);
		this->z &= T(s);
		this->w &= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator&=
	(
		tvec4<U> const & v
	)
	{
		this->x &= T(v.x);
		this->y &= T(v.y);
		this->z &= T(v.z);
		this->w &= T(v.w);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator|=
	(
		U const & s
	)
	{
		this->x |= T(s);
		this->y |= T(s);
		this->z |= T(s);
		this->w |= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator|=
	(
		tvec4<U> const & v
	)
	{
		this->x |= T(v.x);
		this->y |= T(v.y);
		this->z |= T(v.z);
		this->w |= T(v.w);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator^=
	(
		U const & s
	)
	{
		this->x ^= T(s);
		this->y ^= T(s);
		this->z ^= T(s);
		this->w ^= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator^=
	(
		tvec4<U> const & v
	)
	{
		this->x ^= T(v.x);
		this->y ^= T(v.y);
		this->z ^= T(v.z);
		this->w ^= T(v.w);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator<<=
	(
		U const & s
	)
	{
		this->x <<= T(s);
		this->y <<= T(s);
		this->z <<= T(s);
		this->w <<= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator<<=
	(
		tvec4<U> const & v
	)
	{
		this->x <<= T(v.x);
		this->y <<= T(v.y);
		this->z <<= T(v.z);
		this->w <<= T(v.w);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator>>=
	(
		U const & s
	)
	{
		this->x >>= T(s);
		this->y >>= T(s);
		this->z >>= T(s);
		this->w >>= T(s);
		return *this;
	}

	template <typename T>
	template <typename U> 
	 inline tvec4<T> & tvec4<T>::operator>>=
	(
		tvec4<U> const & v
	)
	{
		this->x >>= T(v.x);
		this->y >>= T(v.y);
		this->z >>= T(v.z);
		this->w >>= T(v.w);
		return *this;
	}

	
	

	template <typename T>
	 inline typename tvec4<T>::value_type 
	tvec4<T>::swizzle
	(	
		comp x
	) const
	{
		return (*this)[x];
	}

	template <typename T>
	 inline tvec2<T> tvec4<T>::swizzle
	(
		comp x, 
		comp y
	) const
	{
		return tvec2<T>(
			(*this)[x],
			(*this)[y]);
	}

	template <typename T>
	 inline tvec3<T> tvec4<T>::swizzle
	(
		comp x, 
		comp y, 
		comp z
	) const
	{
		return tvec3<T>(
			(*this)[x],
			(*this)[y],
			(*this)[z]);
	}

	template <typename T>
	 inline tvec4<T> tvec4<T>::swizzle
	(
		comp x, 
		comp y, 
		comp z, 
		comp w
	) const
	{
		return tvec4<T>(
			(*this)[x],
			(*this)[y],
			(*this)[z],
			(*this)[w]);
	}

	template <typename T>
	 inline tref2<T> tvec4<T>::swizzle
	(
		comp x, 
		comp y
	)
	{
		return tref2<T>(
			(*this)[x],
			(*this)[y]);
	}

	template <typename T>
	 inline tref3<T> tvec4<T>::swizzle
	(
		comp x, 
		comp y, 
		comp z
	)
	{
		return tref3<T>(
			(*this)[x],
			(*this)[y],
			(*this)[z]);
	}

	template <typename T>
	 inline tref4<T> tvec4<T>::swizzle
	(
		comp x, 
		comp y, 
		comp z, 
		comp w
	)
	{
		return tref4<T>(
			(*this)[x],
			(*this)[y],
			(*this)[z],
			(*this)[w]);
	}

	
	

	template <typename T> 
	 inline tvec4<T> operator+ 
	(
		tvec4<T> const & v, 
		typename tvec4<T>::value_type const & s
	)
	{
		return tvec4<T>(
			v.x + s,
			v.y + s,
			v.z + s,
			v.w + s);
	}

	template <typename T> 
	 inline tvec4<T> operator+ 
	(
		typename tvec4<T>::value_type const & s, 
		tvec4<T> const & v
	)
	{
		return tvec4<T>(
			s + v.x,
			s + v.y,
			s + v.z,
			s + v.w);
	}

	template <typename T> 
	 inline tvec4<T> operator+ 
	(
		tvec4<T> const & v1, 
		tvec4<T> const & v2
	)
	{
		return tvec4<T>(
			v1.x + v2.x,
			v1.y + v2.y,
			v1.z + v2.z,
			v1.w + v2.w);
	}

	
	template <typename T> 
	 inline tvec4<T> operator- 
	(
		tvec4<T> const & v, 
		typename tvec4<T>::value_type const & s
	)
	{
		return tvec4<T>(
			v.x - s,
			v.y - s,
			v.z - s,
			v.w - s);
	}

	template <typename T> 
	 inline tvec4<T> operator- 
	(
		typename tvec4<T>::value_type const & s, 
		tvec4<T> const & v
	)
	{
		return tvec4<T>(
			s - v.x,
			s - v.y,
			s - v.z,
			s - v.w);
	}

	template <typename T> 
	 inline tvec4<T> operator- 
	(
		tvec4<T> const & v1, 
		tvec4<T> const & v2
	)
	{
		return tvec4<T>(
			v1.x - v2.x,
			v1.y - v2.y,
			v1.z - v2.z,
			v1.w - v2.w);
	}

	
	template <typename T> 
	 inline tvec4<T> operator* 
	(
		tvec4<T> const & v, 
		typename tvec4<T>::value_type const & s
	)
	{
		return tvec4<T>(
			v.x * s,
			v.y * s,
			v.z * s,
			v.w * s);
	}

	template <typename T> 
	 inline tvec4<T> operator* 
	(
		typename tvec4<T>::value_type const & s, 
		tvec4<T> const & v
	)
	{
		return tvec4<T>(
			s * v.x,
			s * v.y,
			s * v.z,
			s * v.w);
	}

	template <typename T> 
	 inline tvec4<T> operator*
	(
		tvec4<T> const & v1, 
		tvec4<T> const & v2
	)
	{
		return tvec4<T>(
			v1.x * v2.x,
			v1.y * v2.y,
			v1.z * v2.z,
			v1.w * v2.w);
	}

	
	template <typename T> 
	 inline tvec4<T> operator/ 
	(
		tvec4<T> const & v, 
		typename tvec4<T>::value_type const & s
	)
	{
		return tvec4<T>(
			v.x / s,
			v.y / s,
			v.z / s,
			v.w / s);
	}

	template <typename T> 
	 inline tvec4<T> operator/ 
	(
		typename tvec4<T>::value_type const & s, 
		tvec4<T> const & v
	)
	{
		return tvec4<T>(
			s / v.x,
			s / v.y,
			s / v.z,
			s / v.w);
	}

	template <typename T> 
	 inline tvec4<T> operator/ 
	(
		tvec4<T> const & v1, 
		tvec4<T> const & v2
	)
	{
		return tvec4<T>(
			v1.x / v2.x,
			v1.y / v2.y,
			v1.z / v2.z,
			v1.w / v2.w);
	}

	
	template <typename T> 
	 inline tvec4<T> operator- 
	(
		tvec4<T> const & v
	)
	{
		return tvec4<T>(
			-v.x, 
			-v.y, 
			-v.z, 
			-v.w);
	}

	template <typename T> 
	 inline tvec4<T> operator++ 
	(
		tvec4<T> const & v, 
		int
	)
	{
		typename tvec4<T>::value_type One(1);
		return tvec4<T>(
			v.x + One, 
			v.y + One, 
			v.z + One, 
			v.w + One);
	}

	template <typename T> 
	 inline tvec4<T> operator-- 
	(
		tvec4<T> const & v, 
		int
	)
	{
		typename tvec4<T>::value_type One(1);
		return tvec4<T>(
			v.x - One, 
			v.y - One, 
			v.z - One, 
			v.w - One);
	}

	
	

	template <typename T> 
	 inline bool operator==
	(
		tvec4<T> const & v1, 
		tvec4<T> const & v2
	)
	{
		return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z) && (v1.w == v2.w);
	}

	template <typename T> 
	 inline bool operator!=
	(
		tvec4<T> const & v1, 
		tvec4<T> const & v2
	)
	{
		return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z) || (v1.w != v2.w);
	}

	
	

	template <typename T>
	 inline tvec4<T> operator% 
	(
		tvec4<T> const & v, 
		typename tvec4<T>::value_type const & s
	)
	{
		return tvec4<T>(
			v.x % s,
			v.y % s,
			v.z % s,
			v.w % s);
	}

	template <typename T>
	 inline tvec4<T> operator% 
	(
		typename tvec4<T>::value_type const & s, 
		tvec4<T> const & v
	)
	{
		return tvec4<T>(
			s % v.x,
			s % v.y,
			s % v.z,
			s % v.w);
	}

	template <typename T>
	 inline tvec4<T> operator%
	(
		tvec4<T> const & v1, 
		tvec4<T> const & v2
	)
	{
		return tvec4<T>(
			v1.x % v2.x,
			v1.y % v2.y,
			v1.z % v2.z,
			v1.w % v2.w);
	}

	template <typename T>
	 inline tvec4<T> operator& 
	(
		tvec4<T> const & v, 
		typename tvec4<T>::value_type const & s
	)
	{
		return tvec4<T>(
			v.x & s,
			v.y & s,
			v.z & s,
			v.w & s);
	}

	template <typename T>
	 inline tvec4<T> operator& 
	(
		typename tvec4<T>::value_type const & s, 
		tvec4<T> const & v
	)
	{
		return tvec4<T>(
			s & v.x,
			s & v.y,
			s & v.z,
			s & v.w);
	}

	template <typename T>
	 inline tvec4<T> operator&
	(
		tvec4<T> const & v1,
		tvec4<T> const & v2
	)
	{
		return tvec4<T>(
			v1.x & v2.x,
			v1.y & v2.y,
			v1.z & v2.z,
			v1.w & v2.w);
	}

	template <typename T>
	 inline tvec4<T> operator|
	(
		tvec4<T> const & v, 
		typename tvec4<T>::value_type const & s
	)
	{
		return tvec4<T>(
			v.x | s,
			v.y | s,
			v.z | s,
			v.w | s);
	}

	template <typename T>
	 inline tvec4<T> operator|
	(
		typename tvec4<T>::value_type const & s, 
		tvec4<T> const & v
	)
	{
		return tvec4<T>(
			s | v.x,
			s | v.y,
			s | v.z,
			s | v.w);
	}

	template <typename T>
	 inline tvec4<T> operator|
	(
		tvec4<T> const & v1, 
		tvec4<T> const & v2
	)
	{
		return tvec4<T>(
			v1.x | v2.x,
			v1.y | v2.y,
			v1.z | v2.z,
			v1.w | v2.w);
	}
		
	template <typename T>
	 inline tvec4<T> operator^
	(
		tvec4<T> const & v, 
		typename tvec4<T>::value_type const & s
	)
	{
		return tvec4<T>(
			v.x ^ s,
			v.y ^ s,
			v.z ^ s,
			v.w ^ s);
	}

	template <typename T>
	 inline tvec4<T> operator^
	(
		typename tvec4<T>::value_type const & s, 
		tvec4<T> const & v
	)
	{
		return tvec4<T>(
			s ^ v.x,
			s ^ v.y,
			s ^ v.z,
			s ^ v.w);
	}

	template <typename T>
	 inline tvec4<T> operator^
	(
		tvec4<T> const & v1,
		tvec4<T> const & v2
	)
	{
		return tvec4<T>(
			v1.x ^ v2.x,
			v1.y ^ v2.y,
			v1.z ^ v2.z,
			v1.w ^ v2.w);
	}

	template <typename T>
	 inline tvec4<T> operator<<
	(
		tvec4<T> const & v,
		typename tvec4<T>::value_type const & s
	)
	{
		return tvec4<T>(
			v.x << s,
			v.y << s,
			v.z << s,
			v.w << s);
	}

	template <typename T>
	 inline tvec4<T> operator<<
	(
		typename tvec4<T>::value_type const & s,
		tvec4<T> const & v
	)
	{
		return tvec4<T>(
			s << v.x,
			s << v.y,
			s << v.z,
			s << v.w);
	}

	template <typename T>
	 inline tvec4<T> operator<<
	(
		tvec4<T> const & v1,
		tvec4<T> const & v2
	)
	{
		return tvec4<T>(
			v1.x << v2.x,
			v1.y << v2.y,
			v1.z << v2.z,
			v1.w << v2.w);
	}

	template <typename T>
	 inline tvec4<T> operator>>
	(
		tvec4<T> const & v,
		typename tvec4<T>::value_type const & s
	)
	{
		return tvec4<T>(
			v.x >> s,
			v.y >> s,
			v.z >> s,
			v.w >> s);
	}

	template <typename T>
	 inline tvec4<T> operator>>
	(
		typename tvec4<T>::value_type const & s,
		tvec4<T> const & v
	)
	{
		return tvec4<T>(
			s >> v.x,
			s >> v.y,
			s >> v.z,
			s >> v.w);
	}

	template <typename T>
	 inline tvec4<T> operator>>
	(
		tvec4<T> const & v1,
		tvec4<T> const & v2
	)
	{
		return tvec4<T>(
			v1.x >> v2.x,
			v1.y >> v2.y,
			v1.z >> v2.z,
			v1.w >> v2.w);
	}

	template <typename T> 
	 inline tvec4<T> operator~
	(
		tvec4<T> const & v
	)
	{
		return tvec4<T>(
			~v.x,
			~v.y,
			~v.z,
			~v.w);
	}

	
	

	template <typename T> 
	tref4<T>::tref4
	(
		T & x, 
		T & y, 
		T & z, 
		T & w
	) :
		x(x),
		y(y),
		z(z),
		w(w)
	{}

	template <typename T> 
	tref4<T>::tref4
	(
		tref4<T> const & r
	) :
		x(r.x),
		y(r.y),
		z(r.z),
		w(r.w)
	{}

	template <typename T> 
	tref4<T>::tref4
	(
		tvec4<T> const & v
	) :
		x(v.x),
		y(v.y),
		z(v.z),
		w(v.w)
	{}

	template <typename T> 
	tref4<T>& tref4<T>::operator= 
	(
		tref4<T> const & r
	)
	{
		x = r.x;
		y = r.y;
		z = r.z;
		w = r.w;
		return *this;
	}

	template <typename T> 
	tref4<T>& tref4<T>::operator= 
	(
		tvec4<T> const & v
	)
	{
		x = v.x;
		y = v.y;
		z = v.z;
		w = v.w;
		return *this;
	}

	template <typename T> 
	 inline tvec4<T> tref4<T>::operator() ()
	{
		return tvec4<T>(this->x, this->y, this->z, this->w);
	}

}
}
#line 397 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec4.hpp"
#line 398 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec4.hpp"

#line 400 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_vec4.hpp"
#line 42 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x2.hpp"































#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat.hpp"

































namespace glm{
namespace detail
{

}
}

#line 42 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat.hpp"
#line 33 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x2.hpp"

namespace glm{
namespace detail
{
	template <typename T> struct tvec1;
	template <typename T> struct tvec2;
	template <typename T> struct tvec3;
	template <typename T> struct tvec4;
	template <typename T> struct tmat2x2;
	template <typename T> struct tmat2x3;
	template <typename T> struct tmat2x4;
	template <typename T> struct tmat3x2;
	template <typename T> struct tmat3x3;
	template <typename T> struct tmat3x4;
	template <typename T> struct tmat4x2;
	template <typename T> struct tmat4x3;
	template <typename T> struct tmat4x4;

	template <typename T> 
	struct tmat2x2
	{
		
		enum ctor{null};
		typedef T value_type;
		typedef std::size_t size_type;
		typedef tvec2<T> col_type;
		typedef tvec2<T> row_type;
		typedef tmat2x2<T> type;
		typedef tmat2x2<T> transpose_type;

		static  size_type col_size();
		static  size_type row_size();

		  size_type length() const;

	public:
		
		 tmat2x2<T> _inverse() const;

	private:
		
		
		col_type value[2];

	public:
		
		
		 tmat2x2();
		 tmat2x2(
			tmat2x2 const & m);

		 explicit tmat2x2(
			ctor Null);
		 explicit tmat2x2(
			value_type const & x);
		 explicit tmat2x2(
			value_type const & x1, value_type const & y1, 
			value_type const & x2, value_type const & y2);
		 explicit tmat2x2(
			col_type const & v1, 
			col_type const & v2);

		
		
		template <typename U> 
		 explicit tmat2x2(
			U const & x);

		template <typename U, typename V, typename M, typename N> 
		 explicit tmat2x2(
			U const & x1, V const & y1, 
			M const & x2, N const & y2);
			
		template <typename U, typename V> 
		 explicit tmat2x2(
			tvec2<U> const & v1, 
			tvec2<V> const & v2);

		
		
		template <typename U> 
		 explicit tmat2x2(tmat2x2<U> const & m);

		 explicit tmat2x2(tmat3x3<T> const & x);
		 explicit tmat2x2(tmat4x4<T> const & x);
		 explicit tmat2x2(tmat2x3<T> const & x);
		 explicit tmat2x2(tmat3x2<T> const & x);
		 explicit tmat2x2(tmat2x4<T> const & x);
		 explicit tmat2x2(tmat4x2<T> const & x);
		 explicit tmat2x2(tmat3x4<T> const & x);
		 explicit tmat2x2(tmat4x3<T> const & x);

		
		

		 col_type & operator[](size_type i);
		 col_type const & operator[](size_type i) const;

		
		 tmat2x2<T> & operator=(tmat2x2<T> const & m);
		template <typename U> 
		 tmat2x2<T> & operator=(tmat2x2<U> const & m);
		template <typename U> 
		 tmat2x2<T> & operator+=(U const & s);
		template <typename U> 
		 tmat2x2<T> & operator+=(tmat2x2<U> const & m);
		template <typename U> 
		 tmat2x2<T> & operator-=(U const & s);
		template <typename U> 
		 tmat2x2<T> & operator-=(tmat2x2<U> const & m);
		template <typename U> 
		 tmat2x2<T> & operator*=(U const & s);
		template <typename U> 
		 tmat2x2<T> & operator*=(tmat2x2<U> const & m);
		template <typename U> 
		 tmat2x2<T> & operator/=(U const & s);
		template <typename U> 
		 tmat2x2<T> & operator/=(tmat2x2<U> const & m);
		 tmat2x2<T> & operator++();
		 tmat2x2<T> & operator--();
	};

	
	template <typename T> 
	 tmat2x2<T> operator+ (
		tmat2x2<T> const & m, 
		typename tmat2x2<T>::value_type const & s);

	template <typename T> 
	 tmat2x2<T> operator+ (
		typename tmat2x2<T>::value_type const & s, 
		tmat2x2<T> const & m);

	template <typename T> 
	 tmat2x2<T> operator+ (
		tmat2x2<T> const & m1, 
		tmat2x2<T> const & m2);

	template <typename T> 
	 tmat2x2<T> operator- (
		tmat2x2<T> const & m, 
		typename tmat2x2<T>::value_type const & s);

	template <typename T> 
	 tmat2x2<T> operator- (
		typename tmat2x2<T>::value_type const & s, 
		tmat2x2<T> const & m);

	template <typename T> 
	 tmat2x2<T> operator- (
		tmat2x2<T> const & m1, 
		tmat2x2<T> const & m2);

	template <typename T> 
	 tmat2x2<T> operator* (
		tmat2x2<T> const & m, 
		typename tmat2x2<T>::value_type const & s);

	template <typename T> 
	 tmat2x2<T> operator* (
		typename tmat2x2<T>::value_type const & s, 
		tmat2x2<T> const & m);

	template <typename T> 
	 typename tmat2x2<T>::col_type operator* (
		tmat2x2<T> const & m, 
		typename tmat2x2<T>::row_type const & v);

	template <typename T> 
	 typename tmat2x2<T>::row_type operator* (
		typename tmat2x2<T>::col_type const & v, 
		tmat2x2<T> const & m);

	template <typename T> 
	 tmat2x2<T> operator* (
		tmat2x2<T> const & m1, 
		tmat2x2<T> const & m2);
		
	template <typename T>
	 tmat3x2<T> operator* (
		tmat2x2<T> const & m1, 
		tmat3x2<T> const & m2);
		
	template <typename T>
	 tmat4x2<T> operator* (
		tmat2x2<T> const & m1, 
		tmat4x2<T> const & m2);

	template <typename T> 
	 tmat2x2<T> operator/ (
		tmat2x2<T> const & m, 
		typename tmat2x2<T>::value_type const & s);

	template <typename T> 
	 tmat2x2<T> operator/ (
		typename tmat2x2<T>::value_type const & s,
		tmat2x2<T> const & m);

	template <typename T> 
	 typename tmat2x2<T>::col_type operator/ (
		tmat2x2<T> const & m, 
		typename tmat2x2<T>::row_type const & v);

	template <typename T> 
	 typename tmat2x2<T>::row_type operator/ (
		typename tmat2x2<T>::col_type const & v, 
		tmat2x2<T> const & m);

	template <typename T> 
	 tmat2x2<T> operator/ (
		tmat2x2<T> const & m1, 
		tmat2x2<T> const & m2);

	
	template <typename T> 
	 tmat2x2<T> const operator-  (
		tmat2x2<T> const & m);

	template <typename T> 
	 tmat2x2<T> const operator-- (
		tmat2x2<T> const & m, 
		int);

	template <typename T> 
	 tmat2x2<T> const operator++ (
		tmat2x2<T> const & m, 
		int);
} 

	
	

	
	
	
	
	
	typedef detail::tmat2x2<lowp_float>		lowp_mat2;

	
	
	
	
	
	typedef detail::tmat2x2<mediump_float>	mediump_mat2;

	
	
	
	
	
	typedef detail::tmat2x2<highp_float>	highp_mat2;

	
	
	
	
	
	typedef detail::tmat2x2<lowp_float>		lowp_mat2x2;

	
	
	
	
	
	typedef detail::tmat2x2<mediump_float>	mediump_mat2x2;

	
	
	
	
	
	typedef detail::tmat2x2<highp_float>	highp_mat2x2;

	
}


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x2.inl"




























namespace glm{
namespace detail
{
	template <typename T>
	 inline  typename tmat2x2<T>::size_type tmat2x2<T>::length() const
	{
		return 2;
	}

	template <typename T>
	 inline typename tmat2x2<T>::size_type tmat2x2<T>::col_size()
	{
		return 2;
	}

	template <typename T>
	 inline typename tmat2x2<T>::size_type tmat2x2<T>::row_size()
	{
		return 2;
	}

	
	

	template <typename T>
	 inline typename tmat2x2<T>::col_type &
	tmat2x2<T>::operator[]
	(
		size_type i
	)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x2.inl", 60), 0) );
		return this->value[i];
	}

	template <typename T>
	 inline typename tmat2x2<T>::col_type const &
	tmat2x2<T>::operator[]
	(
		size_type i
	) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x2.inl", 71), 0) );
		return this->value[i];
	}

	
	

	template <typename T> 
	 inline tmat2x2<T>::tmat2x2()
	{
		this->value[0] = col_type(1, 0);
		this->value[1] = col_type(0, 1);
	}

	template <typename T> 
	 inline tmat2x2<T>::tmat2x2
	(
		tmat2x2<T> const & m
	)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}

	template <typename T> 
	 inline tmat2x2<T>::tmat2x2
	(
		ctor
	)
	{}

	template <typename T> 
	 inline tmat2x2<T>::tmat2x2
	(
		value_type const & s
	)
	{
		value_type const Zero(0);
		this->value[0] = col_type(s, Zero);
		this->value[1] = col_type(Zero, s);
	}

	template <typename T> 
	 inline tmat2x2<T>::tmat2x2
	(
		value_type const & x0, value_type const & y0, 
		value_type const & x1, value_type const & y1
	)
	{
		this->value[0] = col_type(x0, y0);
		this->value[1] = col_type(x1, y1);
	}

	template <typename T> 
	 inline tmat2x2<T>::tmat2x2
	(
		col_type const & v0, 
		col_type const & v1
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
	}

	
	
	template <typename T> 
	template <typename U> 
	 tmat2x2<T>::tmat2x2
	(
		U const & s
	)
	{
		value_type const Zero(0);
		this->value[0] = tvec2<T>(value_type(s), Zero);
		this->value[1] = tvec2<T>(Zero, value_type(s));
	}
	
	template <typename T> 
	template <typename X1, typename Y1, typename X2, typename Y2> 
	 tmat2x2<T>::tmat2x2
	(
		X1 const & x1, Y1 const & y1, 
		X2 const & x2, Y2 const & y2
	)
	{
		this->value[0] = col_type(value_type(x1), value_type(y1));
		this->value[1] = col_type(value_type(x2), value_type(y2));
	}
	
	template <typename T> 
	template <typename V1, typename V2> 
	 tmat2x2<T>::tmat2x2
	(
		tvec2<V1> const & v1, 
		tvec2<V2> const & v2
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
	}

	
	

	template <typename T> 
	template <typename U> 
	 inline tmat2x2<T>::tmat2x2
	(
		tmat2x2<U> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T> 
	 inline tmat2x2<T>::tmat2x2
	(
		tmat3x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T> 
	 inline tmat2x2<T>::tmat2x2
	(
		tmat4x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T> 
	 inline tmat2x2<T>::tmat2x2
	(
		tmat2x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T> 
	 inline tmat2x2<T>::tmat2x2
	(
		tmat3x2<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	template <typename T> 
	 inline tmat2x2<T>::tmat2x2
	(
		tmat2x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T> 
	 inline tmat2x2<T>::tmat2x2
	(
		tmat4x2<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	template <typename T> 
	 inline tmat2x2<T>::tmat2x2
	(
		tmat3x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T> 
	 inline tmat2x2<T>::tmat2x2
	(
		tmat4x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T> 
	 inline tmat2x2<T> tmat2x2<T>::_inverse() const
	{
		typename tmat2x2<T>::value_type Determinant = this->value[0][0] * this->value[1][1] - this->value[1][0] * this->value[0][1];

		tmat2x2<T> Inverse(
			+ this->value[1][1] / Determinant,
			- this->value[0][1] / Determinant,
			- this->value[1][0] / Determinant, 
			+ this->value[0][0] / Determinant);
		return Inverse;
	}

	
	

	
	template <typename T> 
	 inline tmat2x2<T>& tmat2x2<T>::operator=
	(
		tmat2x2<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x2<T>& tmat2x2<T>::operator=
	(
		tmat2x2<U> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x2<T>& tmat2x2<T>::operator+=
	(
		U const & s
	)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x2<T>& tmat2x2<T>::operator+=
	(
		tmat2x2<U> const & m
	)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x2<T>& tmat2x2<T>::operator-=
	(
		U const & s
	)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x2<T>& tmat2x2<T>::operator-=
	(
		tmat2x2<U> const & m
	)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x2<T>& tmat2x2<T>::operator*= 
	(
		U const & s
	)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x2<T>& tmat2x2<T>::operator*= 
	(
		tmat2x2<U> const & m
	)
	{
		return (*this = *this * m);
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x2<T>& tmat2x2<T>::operator/= 
	(
		U const & s
	)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x2<T>& tmat2x2<T>::operator/= 
	(
		tmat2x2<U> const & m
	)
	{
		return (*this = *this / m);
	}

	template <typename T> 
	 inline tmat2x2<T>& tmat2x2<T>::operator++ ()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template <typename T> 
	 inline tmat2x2<T>& tmat2x2<T>::operator-- ()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	
	

	template <typename T>
	 inline tmat2x2<T> operator+ 
	(
		tmat2x2<T> const & m, 
		typename tmat2x2<T>::value_type const & s
	)
	{
		return tmat2x2<T>(
			m[0] + s,
			m[1] + s);
	}

	template <typename T>
	 inline tmat2x2<T> operator+ 
	(
		typename tmat2x2<T>::value_type const & s, 
		tmat2x2<T> const & m
	)
	{
		return tmat2x2<T>(
			m[0] + s,
			m[1] + s);
	}

	template <typename T>
	 inline tmat2x2<T> operator+ 
	(
		tmat2x2<T> const & m1, 
		tmat2x2<T> const & m2
	)
	{
		return tmat2x2<T>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template <typename T>
	 inline tmat2x2<T> operator- 
	(
		tmat2x2<T> const & m, 
		typename tmat2x2<T>::value_type const & s
	)
	{
		return tmat2x2<T>(
			m[0] - s,
			m[1] - s);
	}

	template <typename T>
	 inline tmat2x2<T> operator- 
	(
		typename tmat2x2<T>::value_type const & s, 
		tmat2x2<T> const & m
	)
	{
		return tmat2x2<T>(
			s - m[0],
			s - m[1]);
	}

	template <typename T>
	 inline tmat2x2<T> operator- 
	(
		tmat2x2<T> const & m1, 
		tmat2x2<T> const & m2
	)
	{
		return tmat2x2<T>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template <typename T>
	 inline tmat2x2<T> operator* 
	(
		tmat2x2<T> const & m, 
		typename tmat2x2<T>::value_type const & s
	)
	{
		return tmat2x2<T>(
			m[0] * s,
			m[1] * s);
	}

	template <typename T>
	 inline tmat2x2<T> operator* 
	(	
		typename tmat2x2<T>::value_type const & s, 
		tmat2x2<T> const & m
	)
	{
		return tmat2x2<T>(
			m[0] * s,
			m[1] * s);
	}

	template <typename T>
	 inline typename tmat2x2<T>::col_type operator*
	(
		tmat2x2<T> const & m, 
		typename tmat2x2<T>::row_type const & v
	)
	{
		return detail::tvec2<T>(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y);
	}

	template <typename T>
	 inline typename tmat2x2<T>::row_type operator*
	(
		typename tmat2x2<T>::col_type const & v, 
		tmat2x2<T> const & m
	)
	{
		return detail::tvec2<T>(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1]);
	}

	template <typename T>
	 inline tmat2x2<T> operator*
	(
		tmat2x2<T> const & m1,
		tmat2x2<T> const & m2
	)
	{
		return tmat2x2<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
	}

	template <typename T>
	 inline tmat3x2<T> operator*
	(
		tmat2x2<T> const & m1, 
		tmat3x2<T> const & m2
	)
	{
		return tmat3x2<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
	}

	template <typename T>
	 inline tmat4x2<T> operator*
	(
		tmat2x2<T> const & m1, 
		tmat4x2<T> const & m2
	)
	{
		return tmat4x2<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
	}

	template <typename T> 
	 inline tmat2x2<T> operator/ 
	(
		tmat2x2<T> const & m, 
		typename tmat2x2<T>::value_type const & s
	)
	{
		return tmat2x2<T>(
			m[0] / s,
			m[1] / s);
	}

	template <typename T> 
	 inline tmat2x2<T> operator/ 
	(
		typename tmat2x2<T>::value_type const & s, 
		tmat2x2<T> const & m
	)
	{
		return tmat2x2<T>(
			s / m[0],
			s / m[1]);
	}

	template <typename T> 
	 inline typename tmat2x2<T>::col_type operator/ 
	(
		tmat2x2<T> const & m, 
		typename tmat2x2<T>::row_type & v
	)
	{
		return m._inverse() * v;
	}

	template <typename T> 
	 inline typename tmat2x2<T>::row_type operator/ 
	(
		typename tmat2x2<T>::col_type const & v,
		tmat2x2<T> const & m
	)
	{
		return v * m._inverse();
	}

	template <typename T> 
	 inline tmat2x2<T> operator/ 
	(
		tmat2x2<T> const & m1, 
		tmat2x2<T> const & m2
	)
	{
		return m1 * m2._inverse();
	}

	
	template <typename T> 
	 inline tmat2x2<T> const operator- 
	(
		tmat2x2<T> const & m
	)
	{
		return tmat2x2<T>(
			-m[0], 
			-m[1]);
	}

	template <typename T> 
	 inline tmat2x2<T> const operator++ 
	(
		tmat2x2<T> const & m, 
		int
	) 
	{
		return tmat2x2<T>(
			m[0] + T(1),
			m[1] + T(1));
	}

	template <typename T> 
	 inline tmat2x2<T> const operator-- 
	(
		tmat2x2<T> const & m, 
		int
	) 
	{
		return tmat2x2<T>(
			m[0] - T(1),
			m[1] - T(1));
	}

	
	

	template <typename T> 
	 inline bool operator==
	(
		tmat2x2<T> const & m1, 
		tmat2x2<T> const & m2
	)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template <typename T> 
	 inline bool operator!=
	(
		tmat2x2<T> const & m1, 
		tmat2x2<T> const & m2
	)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}

} 
} 
#line 312 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x2.hpp"
#line 313 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x2.hpp"

#line 315 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x2.hpp"
#line 44 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x3.hpp"

































namespace glm{
namespace detail
{
	template <typename T> struct tvec1;
	template <typename T> struct tvec2;
	template <typename T> struct tvec3;
	template <typename T> struct tvec4;
	template <typename T> struct tmat2x2;
	template <typename T> struct tmat2x3;
	template <typename T> struct tmat2x4;
	template <typename T> struct tmat3x2;
	template <typename T> struct tmat3x3;
	template <typename T> struct tmat3x4;
	template <typename T> struct tmat4x2;
	template <typename T> struct tmat4x3;
	template <typename T> struct tmat4x4;

	template <typename T> 
	struct tmat2x3
	{
		enum ctor{null};
		typedef T value_type;
		typedef std::size_t size_type;
		typedef tvec3<T> col_type;
		typedef tvec2<T> row_type;
		typedef tmat2x3<T> type;
		typedef tmat3x2<T> transpose_type;

		static  size_type col_size();
		static  size_type row_size();

		  size_type length() const;

	private:
		
		col_type value[2];

	public:
		
		 tmat2x3();
		 tmat2x3(tmat2x3 const & m);

		 explicit tmat2x3(
			ctor);
		 explicit tmat2x3(
			value_type const & s);
		 explicit tmat2x3(
			value_type const & x0, value_type const & y0, value_type const & z0,
			value_type const & x1, value_type const & y1, value_type const & z1);
		 explicit tmat2x3(
			col_type const & v0, 
			col_type const & v1);

		
		
		template <typename U> 
		 explicit tmat2x3(
			U const & x);
			
		template <typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2> 
		 explicit tmat2x3(
			X1 const & x1, Y1 const & y1, Z1 const & z1, 
			X2 const & x2, Y2 const & y2, Z2 const & z2);
			
		template <typename U, typename V> 
		 explicit tmat2x3(
			tvec3<U> const & v1, 
			tvec3<V> const & v2);

		
		
		template <typename U> 
		 explicit tmat2x3(tmat2x3<U> const & m);

		 explicit tmat2x3(tmat2x2<T> const & x);
		 explicit tmat2x3(tmat3x3<T> const & x);
		 explicit tmat2x3(tmat4x4<T> const & x);
		 explicit tmat2x3(tmat2x4<T> const & x);
		 explicit tmat2x3(tmat3x2<T> const & x);
		 explicit tmat2x3(tmat3x4<T> const & x);
		 explicit tmat2x3(tmat4x2<T> const & x);
		 explicit tmat2x3(tmat4x3<T> const & x);

		
		 col_type & operator[](size_type i);
		 col_type const & operator[](size_type i) const;

		
		 tmat2x3<T> & operator=  (tmat2x3<T> const & m);
		template <typename U> 
		 tmat2x3<T> & operator=  (tmat2x3<U> const & m);
		template <typename U> 
		 tmat2x3<T> & operator+= (U const & s);
		template <typename U> 
		 tmat2x3<T> & operator+= (tmat2x3<U> const & m);
		template <typename U> 
		 tmat2x3<T> & operator-= (U const & s);
		template <typename U> 
		 tmat2x3<T> & operator-= (tmat2x3<U> const & m);
		template <typename U> 
		 tmat2x3<T> & operator*= (U const & s);
		template <typename U> 
		 tmat2x3<T> & operator*= (tmat2x3<U> const & m);
		template <typename U> 
		 tmat2x3<T> & operator/= (U const & s);

		 tmat2x3<T> & operator++ ();
		 tmat2x3<T> & operator-- ();
	};

	
	template <typename T> 
	 tmat2x3<T> operator+ (
		tmat2x3<T> const & m, 
		typename tmat2x3<T>::value_type const & s);

	template <typename T> 
	 tmat2x3<T> operator+ (
		tmat2x3<T> const & m1, 
		tmat2x3<T> const & m2);

	template <typename T> 
	 tmat2x3<T> operator- (
		tmat2x3<T> const & m, 
		typename tmat2x3<T>::value_type const & s);

	template <typename T> 
	 tmat2x3<T> operator- (
		tmat2x3<T> const & m1, 
		tmat2x3<T> const & m2);

	template <typename T> 
	 tmat2x3<T> operator* (
		tmat2x3<T> const & m, 
		typename tmat2x3<T>::value_type const & s);

	template <typename T> 
	 tmat2x3<T> operator* (
		typename tmat2x3<T>::value_type const & s, 
		tmat2x3<T> const & m);

	template <typename T>
	 typename tmat2x3<T>::col_type operator* (
		tmat2x3<T> const & m, 
		typename tmat2x3<T>::row_type const & v);

	template <typename T> 
	 typename tmat2x3<T>::row_type operator* (
		typename tmat2x3<T>::col_type const & v, 
		tmat2x3<T> const & m);

	template <typename T>
	 tmat2x3<T> operator* (
		tmat2x3<T> const & m1, 
		tmat2x2<T> const & m2);

	template <typename T>
	 tmat3x3<T> operator* (
		tmat2x3<T> const & m1, 
		tmat3x2<T> const & m2);
		
	template <typename T>
	 tmat4x3<T> operator* (
		tmat2x3<T> const & m1, 
		tmat4x2<T> const & m2);

	template <typename T> 
	 tmat2x3<T> operator/ (
		tmat2x3<T> const & m, 
		typename tmat2x3<T>::value_type const & s);

	template <typename T> 
	 tmat2x3<T> operator/ (
		typename tmat2x3<T>::value_type const & s,
		tmat2x3<T> const & m);

	
	template <typename T> 
	 tmat2x3<T> const operator-  (
		tmat2x3<T> const & m);

	template <typename T> 
	 tmat2x3<T> const operator-- (
		tmat2x3<T> const & m, 
		int);

	template <typename T> 
	 tmat2x3<T> const operator++ (
		tmat2x3<T> const & m, 
		int);

} 

	
	

	
	
	
	
	
	typedef detail::tmat2x3<lowp_float>		lowp_mat2x3;
    
	
	
	
	
	
	typedef detail::tmat2x3<mediump_float>	mediump_mat2x3;
    
	
	
	
	
	
	typedef detail::tmat2x3<highp_float>	highp_mat2x3;

	
}


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x3.inl"




























namespace glm{
namespace detail
{
	template <typename T>
	 inline  typename tmat2x3<T>::size_type tmat2x3<T>::length() const
	{
		return 2;
	}

	template <typename T>
	 inline typename tmat2x3<T>::size_type tmat2x3<T>::col_size()
	{
		return 3;
	}

	template <typename T>
	 inline typename tmat2x3<T>::size_type tmat2x3<T>::row_size()
	{
		return 2;
	}

	
	

	template <typename T>
	 inline typename tmat2x3<T>::col_type &
	tmat2x3<T>::operator[]
	(
		size_type i
	)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x3.inl", 60), 0) );
		return this->value[i];
	}

	template <typename T>
	 inline typename tmat2x3<T>::col_type const &
	tmat2x3<T>::operator[]
	(
		size_type i
	) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x3.inl", 71), 0) );
		return this->value[i];
	}

	
	

	template <typename T> 
	 inline tmat2x3<T>::tmat2x3()
	{
		this->value[0] = col_type(T(1), T(0), T(0));
		this->value[1] = col_type(T(0), T(1), T(0));
	}

	template <typename T> 
	 inline tmat2x3<T>::tmat2x3
	(
		tmat2x3<T> const & m
	)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}

	template <typename T> 
	 inline tmat2x3<T>::tmat2x3
	(
		ctor
	)
	{}

	template <typename T> 
	 inline tmat2x3<T>::tmat2x3
	(
		value_type const & s
	)
	{
		this->value[0] = col_type(s, T(0), T(0));
		this->value[1] = col_type(T(0), s, T(0));
	}

	template <typename T> 
	 inline tmat2x3<T>::tmat2x3
	(
		value_type const & x0, value_type const & y0, value_type const & z0,
		value_type const & x1, value_type const & y1, value_type const & z1
	)
	{
		this->value[0] = col_type(x0, y0, z0);
		this->value[1] = col_type(x1, y1, z1);
	}

	template <typename T> 
	 inline tmat2x3<T>::tmat2x3
	(
		col_type const & v0, 
		col_type const & v1
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
	}

	
	
	template <typename T> 
	template <typename U> 
	 tmat2x3<T>::tmat2x3
	(
		U const & s
	)
	{
		value_type const Zero(0);
		this->value[0] = tvec3<T>(value_type(s), Zero, Zero);
		this->value[1] = tvec3<T>(Zero, value_type(s), Zero);
	}
	
	template <typename T> 
	template <
		typename X1, typename Y1, typename Z1, 
		typename X2, typename Y2, typename Z2> 
	 tmat2x3<T>::tmat2x3
	(
		X1 const & x1, Y1 const & y1, Z1 const & z1, 
		X2 const & x2, Y2 const & y2, Z2 const & z2
	)		
	{
		this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1));
		this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2));
	}
	
	template <typename T> 
	template <typename V1, typename V2> 
	 tmat2x3<T>::tmat2x3
	(
		tvec3<V1> const & v1, 
		tvec3<V2> const & v2
	)		
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
	}

	
	
    
	template <typename T> 
	template <typename U> 
	 inline tmat2x3<T>::tmat2x3
	(
		tmat2x3<U> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T> 
	 inline tmat2x3<T>::tmat2x3
	(
		tmat2x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], T(0));
		this->value[1] = col_type(m[1], T(0));
	}

	template <typename T> 
	 inline tmat2x3<T>::tmat2x3
	(
		tmat3x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T> 
	 inline tmat2x3<T>::tmat2x3
	(
		tmat4x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T> 
	 inline tmat2x3<T>::tmat2x3
	(
		tmat2x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T> 
	 inline tmat2x3<T>::tmat2x3
	(
		tmat3x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], T(0));
		this->value[1] = col_type(m[1], T(0));
	}

	template <typename T> 
	 inline tmat2x3<T>::tmat2x3
	(
		tmat3x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T> 
	 inline tmat2x3<T>::tmat2x3
	(
		tmat4x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], T(0));
		this->value[1] = col_type(m[1], T(0));
	}

	template <typename T> 
	 inline tmat2x3<T>::tmat2x3
	(
		tmat4x3<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	
	

	template <typename T> 
	 inline tmat2x3<T>& tmat2x3<T>::operator= 
	(
		tmat2x3<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x3<T>& tmat2x3<T>::operator= 
	(
		tmat2x3<U> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x3<T> & tmat2x3<T>::operator+= 
	(
		U const & s
	)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x3<T>& tmat2x3<T>::operator+=
	(
		tmat2x3<U> const & m
	)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x3<T>& tmat2x3<T>::operator-= 
	(
		U const & s
	)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x3<T>& tmat2x3<T>::operator-= 
	(
		tmat2x3<U> const & m
	)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x3<T>& tmat2x3<T>::operator*= 
	(
		U const & s
	)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x3<T> & tmat2x3<T>::operator*= 
	(
		tmat2x3<U> const & m
	)
	{
		return (*this = tmat2x3<U>(*this * m));
	}

	template <typename T>
	template <typename U> 
	 inline tmat2x3<T> & tmat2x3<T>::operator/= 
	(
		U const & s
	)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	template <typename T> 
	 inline tmat2x3<T> & tmat2x3<T>::operator++ ()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template <typename T> 
	 inline tmat2x3<T> & tmat2x3<T>::operator-- ()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	
	

	template <typename T> 
	 inline tmat2x3<T> operator+ 
	(
		tmat2x3<T> const & m, 
		typename tmat2x3<T>::value_type const & s
	)
	{
		return tmat2x3<T>(
			m[0] + s,
			m[1] + s);
	}

	template <typename T> 
	 inline tmat2x3<T> operator+ 
	(
		tmat2x3<T> const & m1, 
		tmat2x3<T> const & m2
	)
	{
		return tmat2x3<T>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template <typename T> 
	 inline tmat2x3<T> operator- 
	(
		tmat2x3<T> const & m, 
		typename tmat2x3<T>::value_type const & s
	)
	{
		return tmat2x3<T>(
			m[0] - s,
			m[1] - s);
	}

	template <typename T> 
	 inline tmat2x3<T> operator- 
	(
		tmat2x3<T> const & m1, 
		tmat2x3<T> const & m2
	)
	{
		return tmat2x3<T>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template <typename T> 
	 inline tmat2x3<T> operator* 
	(
		tmat2x3<T> const & m, 
		typename tmat2x3<T>::value_type const & s
	)
	{
		return tmat2x3<T>(
			m[0] * s,
			m[1] * s);
	}

	template <typename T> 
	 inline tmat2x3<T> operator* 
	(
		typename tmat2x3<T>::value_type const & s, 
		tmat2x3<T> const & m
	)
	{
		return tmat2x3<T>(
			m[0] * s,
			m[1] * s);
	}

	template <typename T>
	 inline typename tmat2x3<T>::col_type operator* 
	(
		tmat2x3<T> const & m, 
		typename tmat2x3<T>::row_type const & v)
	{
		return typename tmat2x3<T>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y);
	}

	template <typename T> 
	 inline typename tmat2x3<T>::row_type operator* 
	(
		typename tmat2x3<T>::col_type const & v, 
		tmat2x3<T> const & m) 
	{
		return typename tmat2x3<T>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
	}

	template <typename T>
	 inline tmat2x3<T> operator* 
	(
		tmat2x3<T> const & m1, 
		tmat2x2<T> const & m2
	)
	{
		return tmat2x3<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
	}

	template <typename T> 
	 inline tmat3x3<T> operator* 
	(
		tmat2x3<T> const & m1, 
		tmat3x2<T> const & m2
	)
	{
		typename tmat2x3<T>::value_type SrcA00 = m1[0][0];
		typename tmat2x3<T>::value_type SrcA01 = m1[0][1];
		typename tmat2x3<T>::value_type SrcA02 = m1[0][2];
		typename tmat2x3<T>::value_type SrcA10 = m1[1][0];
		typename tmat2x3<T>::value_type SrcA11 = m1[1][1];
		typename tmat2x3<T>::value_type SrcA12 = m1[1][2];

		typename tmat2x3<T>::value_type SrcB00 = m2[0][0];
		typename tmat2x3<T>::value_type SrcB01 = m2[0][1];
		typename tmat2x3<T>::value_type SrcB10 = m2[1][0];
		typename tmat2x3<T>::value_type SrcB11 = m2[1][1];
		typename tmat2x3<T>::value_type SrcB20 = m2[2][0];
		typename tmat2x3<T>::value_type SrcB21 = m2[2][1];

		tmat3x3<T> Result(tmat3x3<T>::null);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		return Result;
	}

	template <typename T>
	 inline tmat4x3<T> operator* 
	(
		tmat2x3<T> const & m1, 
		tmat4x2<T> const & m2
	)
	{
		return tmat4x3<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
	}

	template <typename T> 
	 inline tmat2x3<T> operator/ 
	(
		tmat2x3<T> const & m, 
		typename tmat2x3<T>::value_type const & s
	)
	{
		return tmat2x3<T>(
			m[0] / s,
			m[1] / s);
	}

	template <typename T> 
	 inline tmat2x3<T> operator/ 
	(
		typename tmat2x3<T>::value_type const & s, 
		tmat2x3<T> const & m
	)
	{
		return tmat2x3<T>(
			s / m[0],
			s / m[1]);
	}

	
	template <typename T> 
	 inline tmat2x3<T> const operator- 
	(
		tmat2x3<T> const & m
	)
	{
		return tmat2x3<T>(
			-m[0], 
			-m[1]);
	}

	template <typename T> 
	 inline tmat2x3<T> const operator++ 
	(
		tmat2x3<T> const & m, 
		int
	) 
	{
		return tmat2x3<T>(
			m[0] + typename tmat2x3<T>::value_type(1),
			m[1] + typename tmat2x3<T>::value_type(1));
	}

	template <typename T> 
	 inline tmat2x3<T> const operator-- 
	(
		tmat2x3<T> const & m, 
		int
	) 
	{
		return tmat2x3<T>(
			m[0] - typename tmat2x3<T>::value_type(1),
			m[1] - typename tmat2x3<T>::value_type(1));
	}

	
	

	template <typename T> 
	 inline bool operator==
	(
		tmat2x3<T> const & m1, 
		tmat2x3<T> const & m2
	)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template <typename T> 
	 inline bool operator!=
	(
		tmat2x3<T> const & m1, 
		tmat2x3<T> const & m2
	)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
} 
#line 256 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x3.hpp"
#line 257 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x3.hpp"

#line 259 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x3.hpp"
#line 45 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x4.hpp"

































namespace glm{
namespace detail
{
	template <typename T> struct tvec1;
	template <typename T> struct tvec2;
	template <typename T> struct tvec3;
	template <typename T> struct tvec4;
	template <typename T> struct tmat2x2;
	template <typename T> struct tmat2x3;
	template <typename T> struct tmat2x4;
	template <typename T> struct tmat3x2;
	template <typename T> struct tmat3x3;
	template <typename T> struct tmat3x4;
	template <typename T> struct tmat4x2;
	template <typename T> struct tmat4x3;
	template <typename T> struct tmat4x4;

	template <typename T> 
	struct tmat2x4
	{
		enum ctor{null};
		typedef T value_type;
		typedef std::size_t size_type;
		typedef tvec4<T> col_type;
		typedef tvec2<T> row_type;
		typedef tmat2x4<T> type;
		typedef tmat4x2<T> transpose_type;

		static  size_type col_size();
		static  size_type row_size();

		  size_type length() const;

	private:
		
		col_type value[2];

	public:
		
		 tmat2x4();
		 tmat2x4(tmat2x4 const & m);

		 explicit tmat2x4(
			ctor);
		 explicit tmat2x4(
			value_type const & s);
		 explicit tmat2x4(
			value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
			value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1);
		 explicit tmat2x4(
			col_type const & v0, 
			col_type const & v1);

		
		
		template <typename U> 
		 explicit tmat2x4(
			U const & x);
			
		template <
			typename X1, typename Y1, typename Z1, typename W1, 
			typename X2, typename Y2, typename Z2, typename W2> 
		 explicit tmat2x4(
			X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1, 
			X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2);
			
		template <typename U, typename V> 
		 explicit tmat2x4(
			tvec4<U> const & v1, 
			tvec4<V> const & v2);

		
		
		template <typename U> 
		 explicit tmat2x4(tmat2x4<U> const & m);

		 explicit tmat2x4(tmat2x2<T> const & x);
		 explicit tmat2x4(tmat3x3<T> const & x);
		 explicit tmat2x4(tmat4x4<T> const & x);
		 explicit tmat2x4(tmat2x3<T> const & x);
		 explicit tmat2x4(tmat3x2<T> const & x);
		 explicit tmat2x4(tmat3x4<T> const & x);
		 explicit tmat2x4(tmat4x2<T> const & x);
		 explicit tmat2x4(tmat4x3<T> const & x);

		
		 col_type & operator[](size_type i);
		 col_type const & operator[](size_type i) const;

		
		 tmat2x4<T>& operator=  (tmat2x4<T> const & m);
		template <typename U> 
		 tmat2x4<T>& operator=  (tmat2x4<U> const & m);
		template <typename U> 
		 tmat2x4<T>& operator+= (U const & s);
		template <typename U> 
		 tmat2x4<T>& operator+= (tmat2x4<U> const & m);
		template <typename U> 
		 tmat2x4<T>& operator-= (U const & s);
		template <typename U> 
		 tmat2x4<T>& operator-= (tmat2x4<U> const & m);
		template <typename U> 
		 tmat2x4<T>& operator*= (U const & s);
		template <typename U> 
		 tmat2x4<T>& operator*= (tmat2x4<U> const & m);
		template <typename U> 
		 tmat2x4<T>& operator/= (U const & s);

		 tmat2x4<T>& operator++ ();
		 tmat2x4<T>& operator-- ();
	};

	
	template <typename T> 
	 tmat2x4<T> operator+ (
		tmat2x4<T> const & m, 
		typename tmat2x4<T>::value_type const & s);

	template <typename T> 
	 tmat2x4<T> operator+ (
		tmat2x4<T> const & m1, 
		tmat2x4<T> const & m2);

	template <typename T> 
	 tmat2x4<T> operator- (
		tmat2x4<T> const & m, 
		typename tmat2x4<T>::value_type const & s);

	template <typename T> 
	 tmat2x4<T> operator- (
		tmat2x4<T> const & m1, 
		tmat2x4<T> const & m2);

	template <typename T> 
	 tmat2x4<T> operator* (
		tmat2x4<T> const & m, 
		typename tmat2x4<T>::value_type const & s);

	template <typename T> 
	 tmat2x4<T> operator* (
		typename tmat2x4<T>::value_type const & s, 
		tmat2x4<T> const & m);

	template <typename T>
	 typename tmat2x4<T>::col_type operator* (
		tmat2x4<T> const & m, 
		typename tmat2x4<T>::row_type const & v);

	template <typename T> 
	 typename tmat2x4<T>::row_type operator* (
		typename tmat2x4<T>::col_type const & v, 
		tmat2x4<T> const & m);

	template <typename T>
	 tmat4x4<T> operator* (
		tmat2x4<T> const & m1, 
		tmat4x2<T> const & m2);
		
	template <typename T>
	 tmat2x4<T> operator* (
		tmat2x4<T> const & m1, 
		tmat2x2<T> const & m2);
		
	template <typename T>
	 tmat3x4<T> operator* (
		tmat2x4<T> const & m1, 
		tmat3x2<T> const & m2);

	template <typename T> 
	 tmat2x4<T> operator/ (
		tmat2x4<T> const & m, 
		typename tmat2x4<T>::value_type const & s);

	template <typename T> 
	 tmat2x4<T> operator/ (
		typename tmat2x4<T>::value_type const & s, 
		tmat2x4<T> const & m);

	
	template <typename T> 
	 tmat2x4<T> const operator-  (
		tmat2x4<T> const & m);

	template <typename T> 
	 tmat2x4<T> const operator-- (
		tmat2x4<T> const & m, 
		int);

	template <typename T> 
	 tmat2x4<T> const operator++ (
		tmat2x4<T> const & m, 
		int);

} 

	
	

	
	
	
	
	
	typedef detail::tmat2x4<lowp_float>		lowp_mat2x4;

	
	
	
	
	
	typedef detail::tmat2x4<mediump_float>	mediump_mat2x4;

	
	
	
	
	
	typedef detail::tmat2x4<highp_float>	highp_mat2x4;

	
}


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x4.inl"




























namespace glm{
namespace detail
{
	template <typename T>
	 inline  typename tmat2x4<T>::size_type tmat2x4<T>::length() const
	{
		return 2;
	}

	template <typename T>
	 inline typename tmat2x4<T>::size_type tmat2x4<T>::col_size()
	{
		return 4;
	}

	template <typename T>
	 inline typename tmat2x4<T>::size_type tmat2x4<T>::row_size()
	{
		return 2;
	}

	
	

	template <typename T>
	 inline typename tmat2x4<T>::col_type &
	tmat2x4<T>::operator[]
	(
		size_type i
	)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x4.inl", 60), 0) );
		return this->value[i];
	}

	template <typename T>
	 inline typename tmat2x4<T>::col_type const &
	tmat2x4<T>::operator[]
	(
		size_type i
	) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x4.inl", 71), 0) );
		return this->value[i];
	}

	
	

	template <typename T> 
	 inline tmat2x4<T>::tmat2x4()
	{
		value_type const Zero(0);
		value_type const One(1);
		this->value[0] = col_type(One, Zero, Zero, Zero);
		this->value[1] = col_type(Zero, One, Zero, Zero);
	}

	template <typename T> 
	 inline tmat2x4<T>::tmat2x4
	(
		tmat2x4<T> const & m
	)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}

	template <typename T> 
	 inline tmat2x4<T>::tmat2x4
	(
		ctor
	)
	{}

	template <typename T> 
	 inline tmat2x4<T>::tmat2x4
	(
		value_type const & s
	)
	{
		value_type const Zero(0);
		this->value[0] = col_type(s, Zero, Zero, Zero);
		this->value[1] = col_type(Zero, s, Zero, Zero);
	}

	template <typename T> 
	 inline tmat2x4<T>::tmat2x4
	(
		value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
		value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1
	)
	{
		this->value[0] = col_type(x0, y0, z0, w0);
		this->value[1] = col_type(x1, y1, z1, w1);
	}

	template <typename T> 
	 inline tmat2x4<T>::tmat2x4
	(
		col_type const & v0, 
		col_type const & v1
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
	}

	
	
	template <typename T> 
	template <typename U> 
	 tmat2x4<T>::tmat2x4
	(
		U const & s
	)
	{
		value_type const Zero(0);
		this->value[0] = tvec4<T>(value_type(s), Zero, Zero, Zero);
		this->value[1] = tvec4<T>(Zero, value_type(s), Zero, Zero);
	}
	
	template <typename T> 
	template <
		typename X1, typename Y1, typename Z1, typename W1, 
		typename X2, typename Y2, typename Z2, typename W2> 
	 tmat2x4<T>::tmat2x4
	(
		X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1, 
		X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2 
	)		
	{
		this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1), value_type(w1));
		this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2), value_type(w2));
	}
	
	template <typename T> 
	template <typename V1, typename V2> 
	 tmat2x4<T>::tmat2x4
	(
		tvec4<V1> const & v1, 
		tvec4<V2> const & v2
	)		
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
	}

	
	

	template <typename T> 
	template <typename U> 
	 inline tmat2x4<T>::tmat2x4
	(
		tmat2x4<U> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T> 
	 inline tmat2x4<T>::tmat2x4
	(
		tmat2x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], detail::tvec2<T>(0));
		this->value[1] = col_type(m[1], detail::tvec2<T>(0));
	}

	template <typename T> 
	 inline tmat2x4<T>::tmat2x4
	(
		tmat3x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0], T(0));
		this->value[1] = col_type(m[1], T(0));
	}

	template <typename T> 
	 inline tmat2x4<T>::tmat2x4
	(
		tmat4x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T> 
	 inline tmat2x4<T>::tmat2x4
	(
		tmat2x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0], T(0));
		this->value[1] = col_type(m[1], T(0));
	}

	template <typename T> 
	 inline tmat2x4<T>::tmat2x4
	(
		tmat3x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], detail::tvec2<T>(0));
		this->value[1] = col_type(m[1], detail::tvec2<T>(0));
	}

	template <typename T> 
	 inline tmat2x4<T>::tmat2x4
	(
		tmat3x4<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	template <typename T> 
	 inline tmat2x4<T>::tmat2x4
	(
		tmat4x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], detail::tvec2<T>(T(0)));
		this->value[1] = col_type(m[1], detail::tvec2<T>(T(0)));
	}

	template <typename T> 
	 inline tmat2x4<T>::tmat2x4
	(
		tmat4x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0], T(0));
		this->value[1] = col_type(m[1], T(0));
	}

	
	

	template <typename T> 
	 inline tmat2x4<T>& tmat2x4<T>::operator= 
	(
		tmat2x4<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x4<T>& tmat2x4<T>::operator= 
	(
		tmat2x4<U> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x4<T>& tmat2x4<T>::operator+= 
	(
		U const & s
	)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x4<T>& tmat2x4<T>::operator+= 
	(
		tmat2x4<U> const & m
	)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x4<T>& tmat2x4<T>::operator-= 
	(
		U const & s
	)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x4<T>& tmat2x4<T>::operator-= 
	(
		tmat2x4<U> const & m
	)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x4<T>& tmat2x4<T>::operator*= 
	(
		U const & s
	)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x4<T>& tmat2x4<T>::operator*=
	(
		tmat2x4<U> const & m
	)
	{
		return (*this = tmat2x4<T>(*this * m));
	}

	template <typename T> 
	template <typename U> 
	 inline tmat2x4<T> & tmat2x4<T>::operator/= 
	(
		U const & s
	)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	template <typename T> 
	 inline tmat2x4<T>& tmat2x4<T>::operator++ ()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template <typename T> 
	 inline tmat2x4<T>& tmat2x4<T>::operator-- ()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	
	

	template <typename T> 
	 inline tmat2x4<T> operator+
	(
		tmat2x4<T> const & m, 
		typename tmat2x4<T>::value_type const & s
	)
	{
		return tmat2x4<T>(
			m[0] + s,
			m[1] + s);
	}

	template <typename T> 
	 inline tmat2x4<T> operator+ 
	(
		tmat2x4<T> const & m1, 
		tmat2x4<T> const & m2
	)
	{
		return tmat2x4<T>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template <typename T> 
	 inline tmat2x4<T> operator- 
	(
		tmat2x4<T> const & m, 
		typename tmat2x4<T>::value_type const & s
	)
	{
		return tmat2x4<T>(
			m[0] - s,
			m[1] - s);
	}

	template <typename T> 
	 inline tmat2x4<T> operator- 
	(
		tmat2x4<T> const & m1, 
		tmat2x4<T> const & m2
	)
	{
		return tmat2x4<T>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template <typename T> 
	 inline tmat2x4<T> operator* 
	(
		tmat2x4<T> const & m, 
		typename tmat2x4<T>::value_type const & s
	)
	{
		return tmat2x4<T>(
			m[0] * s,
			m[1] * s);
	}

	template <typename T> 
	 inline tmat2x4<T> operator*
	(
		typename tmat2x4<T>::value_type const & s, 
		tmat2x4<T> const & m
	)
	{
		return tmat2x4<T>(
			m[0] * s,
			m[1] * s);
	}

	template <typename T>
	 inline typename tmat2x4<T>::col_type operator* 
	(
		tmat2x4<T> const & m, 
		typename tmat2x4<T>::row_type const & v
	)
	{
		return typename tmat2x4<T>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y,
			m[0][3] * v.x + m[1][3] * v.y);
	}

	template <typename T> 
	 inline typename tmat2x4<T>::row_type operator* 
	(
		typename tmat2x4<T>::col_type const & v, 
		tmat2x4<T> const & m
	) 
	{
		return typename tmat2x4<T>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
	}

	template <typename T> 
	 inline tmat4x4<T> operator* 
	(
		tmat2x4<T> const & m1, 
		tmat4x2<T> const & m2
	)
	{
		typename tmat2x4<T>::value_type SrcA00 = m1[0][0];
		typename tmat2x4<T>::value_type SrcA01 = m1[0][1];
		typename tmat2x4<T>::value_type SrcA02 = m1[0][2];
		typename tmat2x4<T>::value_type SrcA03 = m1[0][3];
		typename tmat2x4<T>::value_type SrcA10 = m1[1][0];
		typename tmat2x4<T>::value_type SrcA11 = m1[1][1];
		typename tmat2x4<T>::value_type SrcA12 = m1[1][2];
		typename tmat2x4<T>::value_type SrcA13 = m1[1][3];

		typename tmat2x4<T>::value_type SrcB00 = m2[0][0];
		typename tmat2x4<T>::value_type SrcB01 = m2[0][1];
		typename tmat2x4<T>::value_type SrcB10 = m2[1][0];
		typename tmat2x4<T>::value_type SrcB11 = m2[1][1];
		typename tmat2x4<T>::value_type SrcB20 = m2[2][0];
		typename tmat2x4<T>::value_type SrcB21 = m2[2][1];
		typename tmat2x4<T>::value_type SrcB30 = m2[3][0];
		typename tmat2x4<T>::value_type SrcB31 = m2[3][1];

		tmat4x4<T> Result(tmat4x4<T>::null);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
		return Result;
	}

	template <typename T>
	 inline tmat2x4<T> operator* 
	(
		tmat2x4<T> const & m1, 
		tmat2x2<T> const & m2
	)
	{
		return tmat2x4<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
	}

	template <typename T>
	 inline tmat3x4<T> operator* 
	(
		tmat2x4<T> const & m1, 
		tmat3x2<T> const & m2
	)
	{
		return tmat3x4<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
	}

	template <typename T> 
	 inline tmat2x4<T> operator/ 
	(
		tmat2x4<T> const & m, 
		typename tmat2x4<T>::value_type const & s
	)
	{
		return tmat2x4<T>(
			m[0] / s,
			m[1] / s);        
	}

	template <typename T> 
	 inline tmat2x4<T> operator/ 
	(
		typename tmat2x4<T>::value_type const & s, 
		tmat2x4<T> const & m
	)
	{
		return tmat2x4<T>(
			s / m[0],
			s / m[1]);        
	}

	
	template <typename T> 
	 inline tmat2x4<T> const operator- 
	(
		tmat2x4<T> const & m
	)
	{
		return tmat2x4<T>(
			-m[0], 
			-m[1]);
	}

	template <typename T> 
	 inline tmat2x4<T> const operator++ 
	(
		tmat2x4<T> const & m, 
		int
	) 
	{
		return tmat2x4<T>(
			m[0] + typename tmat2x4<T>::value_type(1),
			m[1] + typename tmat2x4<T>::value_type(1));
	}

	template <typename T> 
	 inline tmat2x4<T> const operator-- 
	(
		tmat2x4<T> const & m, 
		int
	) 
	{
		return tmat2x4<T>(
			m[0] - typename tmat2x4<T>::value_type(1),
			m[1] - typename tmat2x4<T>::value_type(1));
	}

	
	

	template <typename T> 
	 inline bool operator==
	(
		tmat2x4<T> const & m1, 
		tmat2x4<T> const & m2
	)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template <typename T> 
	 inline bool operator!=
	(
		tmat2x4<T> const & m1, 
		tmat2x4<T> const & m2
	)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
} 
#line 258 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x4.hpp"
#line 259 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x4.hpp"

#line 261 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat2x4.hpp"
#line 46 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x2.hpp"

































namespace glm{
namespace detail
{
	template <typename T> struct tvec1;
	template <typename T> struct tvec2;
	template <typename T> struct tvec3;
	template <typename T> struct tvec4;
	template <typename T> struct tmat2x2;
	template <typename T> struct tmat2x3;
	template <typename T> struct tmat2x4;
	template <typename T> struct tmat3x2;
	template <typename T> struct tmat3x3;
	template <typename T> struct tmat3x4;
	template <typename T> struct tmat4x2;
	template <typename T> struct tmat4x3;
	template <typename T> struct tmat4x4;

	template <typename T> 
	struct tmat3x2
	{
		enum ctor{null};
		typedef T value_type;
		typedef std::size_t size_type;
		typedef tvec2<T> col_type;
		typedef tvec3<T> row_type;
		typedef tmat3x2<T> type;
		typedef tmat2x3<T> transpose_type;

		static  size_type col_size();
		static  size_type row_size();

		  size_type length() const;

	private:
		
		col_type value[3];

	public:
		
		 tmat3x2();
		 tmat3x2(tmat3x2 const & m);

		 explicit tmat3x2(
			ctor);
		 explicit tmat3x2(
			value_type const & s);
		 explicit tmat3x2(
			value_type const & x0, value_type const & y0,
			value_type const & x1, value_type const & y1,
			value_type const & x2, value_type const & y2);
		 explicit tmat3x2(
			col_type const & v0, 
			col_type const & v1,
			col_type const & v2);

		
		
		template <typename U> 
		 explicit tmat3x2(
			U const & x);
			
		template 
		<
			typename X1, typename Y1, 
			typename X2, typename Y2, 
			typename X3, typename Y3
		> 
		 explicit tmat3x2(
			X1 const & x1, Y1 const & y1, 
			X2 const & x2, Y2 const & y2,
			X3 const & x3, Y3 const & y3);
			
		template <typename V1, typename V2, typename V3> 
		 explicit tmat3x2(
			tvec2<V1> const & v1, 
			tvec2<V2> const & v2,
			tvec2<V3> const & v3);

		
		template <typename U> 
		 explicit tmat3x2(tmat3x2<U> const & m);

		 explicit tmat3x2(tmat2x2<T> const & x);
		 explicit tmat3x2(tmat3x3<T> const & x);
		 explicit tmat3x2(tmat4x4<T> const & x);
		 explicit tmat3x2(tmat2x3<T> const & x);
		 explicit tmat3x2(tmat2x4<T> const & x);
		 explicit tmat3x2(tmat3x4<T> const & x);
		 explicit tmat3x2(tmat4x2<T> const & x);
		 explicit tmat3x2(tmat4x3<T> const & x);

		
		 col_type & operator[](size_type i);
		 col_type const & operator[](size_type i) const;

		
		 tmat3x2<T> & operator=  (tmat3x2<T> const & m);
		template <typename U> 
		 tmat3x2<T> & operator=  (tmat3x2<U> const & m);
		template <typename U> 
		 tmat3x2<T> & operator+= (U const & s);
		template <typename U> 
		 tmat3x2<T> & operator+= (tmat3x2<U> const & m);
		template <typename U> 
		 tmat3x2<T> & operator-= (U const & s);
		template <typename U> 
		 tmat3x2<T> & operator-= (tmat3x2<U> const & m);
		template <typename U> 
		 tmat3x2<T> & operator*= (U const & s);
		template <typename U> 
		 tmat3x2<T> & operator*= (tmat3x2<U> const & m);
		template <typename U> 
		 tmat3x2<T> & operator/= (U const & s);

		 tmat3x2<T> & operator++ ();
		 tmat3x2<T> & operator-- ();
	};

	
	template <typename T> 
	 tmat3x2<T> operator+ (
		tmat3x2<T> const & m, 
		typename tmat3x2<T>::value_type const & s);

	template <typename T> 
	 tmat3x2<T> operator+ (
		tmat3x2<T> const & m1, 
		tmat3x2<T> const & m2);

	template <typename T> 
	 tmat3x2<T> operator- (
		tmat3x2<T> const & m, 
		typename tmat3x2<T>::value_type const & s);

	template <typename T> 
	 tmat3x2<T> operator- (
		tmat3x2<T> const & m1, 
		tmat3x2<T> const & m2);

	template <typename T> 
	 tmat3x2<T> operator* (
		tmat3x2<T> const & m, 
		typename tmat3x2<T>::value_type const & s);

	template <typename T> 
	 tmat3x2<T> operator* (
		typename tmat3x2<T>::value_type const & s, 
		tmat3x2<T> const & m);

	template <typename T>
	 typename tmat3x2<T>::col_type operator* (
		tmat3x2<T> const & m, 
		typename tmat3x2<T>::row_type const & v);

	template <typename T> 
	 typename tmat3x2<T>::row_type operator* (
		typename tmat3x2<T>::col_type const & v,
		tmat3x2<T> const & m);

	template <typename T>
	 tmat2x2<T> operator* (
		tmat3x2<T> const & m1, 
		tmat2x3<T> const & m2);
		
	template <typename T>
	 tmat3x2<T> operator* (
		tmat3x2<T> const & m1, 
		tmat3x3<T> const & m2);
		
	template <typename T>
	 tmat4x2<T> operator* (
		tmat3x2<T> const & m1, 
		tmat4x3<T> const & m2);

	template <typename T> 
	 tmat3x2<T> operator/ (
		tmat3x2<T> const & m, 
		typename tmat3x2<T>::value_type const & s);

	template <typename T> 
	 tmat3x2<T> operator/ (
		typename tmat3x2<T>::value_type const & s, 
		tmat3x2<T> const & m);

	
	template <typename T> 
	 tmat3x2<T> const operator-  (
		tmat3x2<T> const & m);

	template <typename T> 
	 tmat3x2<T> const operator-- (
		tmat3x2<T> const & m, 
		int);

	template <typename T> 
	 tmat3x2<T> const operator++ (
		tmat3x2<T> const & m, 
		int);
} 

	
	

	
	
	
	
	
	typedef detail::tmat3x2<lowp_float>		lowp_mat3x2;

	
	
	
	
	
	typedef detail::tmat3x2<mediump_float>	mediump_mat3x2;

	
	
	
	
	
	typedef detail::tmat3x2<highp_float>	highp_mat3x2;

	
}


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x2.inl"




























namespace glm{
namespace detail
{
	template <typename T>
	 inline  typename tmat3x2<T>::size_type tmat3x2<T>::length() const
	{
		return 3;
	}

	template <typename T>
	 inline typename tmat3x2<T>::size_type tmat3x2<T>::col_size()
	{
		return 2;
	}

	template <typename T>
	 inline typename tmat3x2<T>::size_type tmat3x2<T>::row_size()
	{
		return 3;
	}

	
	

	template <typename T>
	 inline typename tmat3x2<T>::col_type &
	tmat3x2<T>::operator[]
	(
		size_type i
	)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x2.inl", 60), 0) );
		return this->value[i];
	}

	template <typename T>
	 inline typename tmat3x2<T>::col_type const & 
	tmat3x2<T>::operator[]
	(
		size_type i
	) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x2.inl", 71), 0) );
		return this->value[i];
	}

	
	

	template <typename T> 
	 inline tmat3x2<T>::tmat3x2()
	{
		this->value[0] = col_type(1, 0);
		this->value[1] = col_type(0, 1);
		this->value[2] = col_type(0, 0);
	}

	template <typename T> 
	 inline tmat3x2<T>::tmat3x2
	(
		tmat3x2<T> const & m
	)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}

	template <typename T> 
	 inline tmat3x2<T>::tmat3x2
	(
		ctor
	)
	{}

	template <typename T> 
	 inline tmat3x2<T>::tmat3x2
	(
		value_type const & s
	)
	{
		this->value[0] = col_type(s, 0);
		this->value[1] = col_type(0, s);
		this->value[2] = col_type(0, 0);
	}

	template <typename T> 
	 inline tmat3x2<T>::tmat3x2
	(
		value_type const & x0, value_type const & y0,
		value_type const & x1, value_type const & y1,
		value_type const & x2, value_type const & y2
	)
	{
		this->value[0] = col_type(x0, y0);
		this->value[1] = col_type(x1, y1);
		this->value[2] = col_type(x2, y2);
	}

	template <typename T> 
	 inline tmat3x2<T>::tmat3x2
	(
		col_type const & v0, 
		col_type const & v1, 
		col_type const & v2
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
	}

	
	
	template <typename T> 
	template <typename U> 
	 tmat3x2<T>::tmat3x2
	(
		U const & s
	)
	{
		value_type const Zero(0);
		this->value[0] = tvec2<T>(value_type(s), Zero);
		this->value[1] = tvec2<T>(Zero, value_type(s));
		this->value[2] = tvec2<T>(Zero);
	}
	
	template <typename T> 
	template <
		typename X1, typename Y1, 
		typename X2, typename Y2, 
		typename X3, typename Y3> 
	 tmat3x2<T>::tmat3x2
	(
		X1 const & x1, Y1 const & y1, 
		X2 const & x2, Y2 const & y2, 
		X3 const & x3, Y3 const & y3
	)		
	{
		this->value[0] = col_type(value_type(x1), value_type(y1));
		this->value[1] = col_type(value_type(x2), value_type(y2));
		this->value[2] = col_type(value_type(x3), value_type(y3));
	}
	
	template <typename T> 
	template <typename V1, typename V2, typename V3> 
	 tmat3x2<T>::tmat3x2
	(
		tvec2<V1> const & v1, 
		tvec2<V2> const & v2, 
		tvec2<V3> const & v3
	)		
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
	}

	
	

	template <typename T> 
	template <typename U> 
	 inline tmat3x2<T>::tmat3x2
	(
		tmat3x2<U> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T> 
	 inline tmat3x2<T>::tmat3x2
	(
		tmat2x2<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = col_type(T(0));
	}

	template <typename T> 
	 inline tmat3x2<T>::tmat3x2
	(
		tmat3x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T> 
	 inline tmat3x2<T>::tmat3x2
	(
		tmat4x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T> 
	 inline tmat3x2<T>::tmat3x2
	(
		tmat2x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(T(0));
	}

	template <typename T> 
	 inline tmat3x2<T>::tmat3x2
	(
		tmat2x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(T(0));
	}

	template <typename T> 
	 inline tmat3x2<T>::tmat3x2
	(
		tmat3x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T> 
	 inline tmat3x2<T>::tmat3x2
	(
		tmat4x2<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
	}

	template <typename T> 
	 inline tmat3x2<T>::tmat3x2
	(
		tmat4x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	
	

	template <typename T> 
	 inline tmat3x2<T>& tmat3x2<T>::operator= 
	(
		tmat3x2<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x2<T>& tmat3x2<T>::operator= 
	(
		tmat3x2<U> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x2<T>& tmat3x2<T>::operator+= 
	(
		U const & s
	)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x2<T>& tmat3x2<T>::operator+= 
	(
		tmat3x2<U> const & m
	)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x2<T>& tmat3x2<T>::operator-= 
	(
		U const & s
	)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x2<T>& tmat3x2<T>::operator-= 
	(
		tmat3x2<U> const & m
	)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x2<T>& tmat3x2<T>::operator*= 
	(
		U const & s
	)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x2<T>& tmat3x2<T>::operator*= 
	(
		tmat3x2<U> const & m
	)
	{
		return (*this = tmat3x2<T>(*this * m));
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x2<T> & tmat3x2<T>::operator/= 
	(
		U const & s
	)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	template <typename T> 
	 inline tmat3x2<T>& tmat3x2<T>::operator++ ()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template <typename T> 
	 inline tmat3x2<T>& tmat3x2<T>::operator-- ()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	
	

	template <typename T> 
	 inline tmat3x2<T> operator+ 
	(
		tmat3x2<T> const & m, 
		typename tmat3x2<T>::value_type const & s
	)
	{
		return tmat3x2<T>(
			m[0] + s,
			m[1] + s,
			m[2] + s);
	}

	template <typename T> 
	 inline tmat3x2<T> operator+ 
	(
		tmat3x2<T> const & m1, 
		tmat3x2<T> const & m2
	)
	{
		return tmat3x2<T>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template <typename T> 
	 inline tmat3x2<T> operator- 
	(
		tmat3x2<T> const & m, 
		typename tmat3x2<T>::value_type const & s
	)
	{
		return tmat3x2<T>(
			m[0] - s,
			m[1] - s,
			m[2] - s);
	}

	template <typename T> 
	 inline tmat3x2<T> operator- 
	(	
		tmat3x2<T> const & m1, 
		tmat3x2<T> const & m2
	)
	{
		return tmat3x2<T>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template <typename T> 
	 inline tmat3x2<T> operator* 
	(
		tmat3x2<T> const & m, 
		typename tmat3x2<T>::value_type const & s
	)
	{
		return tmat3x2<T>(
			m[0] * s,
			m[1] * s,
			m[2] * s);
	}

	template <typename T> 
	 inline tmat3x2<T> operator* 
	(
		typename tmat3x2<T>::value_type const & s, 
		tmat3x2<T> const & m
	)
	{
		return tmat3x2<T>(
			m[0] * s,
			m[1] * s,
			m[2] * s);
	}
   
	template <typename T>
	 inline typename tmat3x2<T>::col_type operator* 
	(
		tmat3x2<T> const & m, 
		typename tmat3x2<T>::row_type const & v)
	{
		return typename tmat3x2<T>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
	}

	template <typename T> 
	 inline typename tmat3x2<T>::row_type operator* 
	(
		typename tmat3x2<T>::col_type const & v, 
		tmat3x2<T> const & m) 
	{
		return typename tmat3x2<T>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1]);
	}

	template <typename T> 
	 inline tmat2x2<T> operator* 
	(
		tmat3x2<T> const & m1, 
		tmat2x3<T> const & m2
	)
	{
		const T SrcA00 = m1[0][0];
		const T SrcA01 = m1[0][1];
		const T SrcA10 = m1[1][0];
		const T SrcA11 = m1[1][1];
		const T SrcA20 = m1[2][0];
		const T SrcA21 = m1[2][1];

		const T SrcB00 = m2[0][0];
		const T SrcB01 = m2[0][1];
		const T SrcB02 = m2[0][2];
		const T SrcB10 = m2[1][0];
		const T SrcB11 = m2[1][1];
		const T SrcB12 = m2[1][2];

		tmat2x2<T> Result(tmat2x2<T>::null);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		return Result;
	}

	template <typename T>
	 inline tmat3x2<T> operator* 
	(
		tmat3x2<T> const & m1, 
		tmat3x3<T> const & m2
	)
	{
		return tmat3x2<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
	}

	template <typename T>
	 inline tmat4x2<T> operator* 
	(
		tmat3x2<T> const & m1, 
		tmat4x3<T> const & m2
	)
	{
		return tmat4x2<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
	}

	template <typename T> 
	 inline tmat3x2<T> operator/ 
	(
		tmat3x2<T> const & m, 
		typename tmat3x2<T>::value_type const & s
	)
	{
		return tmat3x2<T>(
			m[0] / s,
			m[1] / s,
			m[2] / s);        
	}

	template <typename T> 
	 inline tmat3x2<T> operator/ 
	(
		typename tmat3x2<T>::value_type const & s, 
		tmat3x2<T> const & m
	)
	{
		return tmat3x2<T>(
			s / m[0],
			s / m[1],
			s / m[2]);        
	}

	
	template <typename T> 
	 inline tmat3x2<T> const operator- 
	(
		tmat3x2<T> const & m
	)
	{
		return tmat3x2<T>(
			-m[0], 
			-m[1],
			-m[2]);
	}

	template <typename T> 
	 inline tmat3x2<T> const operator++ 
	(
		tmat3x2<T> const & m, 
		int
	) 
	{
		typename tmat3x2<T>::value_type One(1);
		return tmat3x2<T>(
			m[0] + One,
			m[1] + One,
			m[2] + One);
	}

	template <typename T> 
	 inline tmat3x2<T> const operator-- 
	(
		tmat3x2<T> const & m, 
		int
	) 
	{
		typename tmat3x2<T>::value_type One(1);
		return tmat3x2<T>(
			m[0] - One,
			m[1] - One,
			m[2] - One);
	}

	
	

	template <typename T> 
	 inline bool operator==
	(
		tmat3x2<T> const & m1, 
		tmat3x2<T> const & m2
	)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template <typename T> 
	 inline bool operator!=
	(
		tmat3x2<T> const & m1, 
		tmat3x2<T> const & m2
	)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}

} 
} 
#line 263 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x2.hpp"
#line 264 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x2.hpp"

#line 266 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x2.hpp"
#line 47 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x3.hpp"

































namespace glm{
namespace detail
{
	template <typename T> struct tvec1;
	template <typename T> struct tvec2;
	template <typename T> struct tvec3;
	template <typename T> struct tvec4;
	template <typename T> struct tmat2x2;
	template <typename T> struct tmat2x3;
	template <typename T> struct tmat2x4;
	template <typename T> struct tmat3x2;
	template <typename T> struct tmat3x3;
	template <typename T> struct tmat3x4;
	template <typename T> struct tmat4x2;
	template <typename T> struct tmat4x3;
	template <typename T> struct tmat4x4;

	template <typename T> 
	struct tmat3x3
	{
		enum ctor{null};
		typedef T value_type;
		typedef std::size_t size_type;
		typedef tvec3<T> col_type;
		typedef tvec3<T> row_type;
		typedef tmat3x3<T> type;
		typedef tmat3x3<T> transpose_type;

		static  size_type col_size();
		static  size_type row_size();

		  size_type length() const;

	public:
		
		
		 tmat3x3<T> _inverse() const;
		
        
	private:
		
		col_type value[3];

	public:
		
		 tmat3x3();
		 tmat3x3(tmat3x3 const & m);

		 explicit tmat3x3(
			ctor Null);
		 explicit tmat3x3(
			value_type const & s);
		 explicit tmat3x3(
			value_type const & x0, value_type const & y0, value_type const & z0,
			value_type const & x1, value_type const & y1, value_type const & z1,
			value_type const & x2, value_type const & y2, value_type const & z2);
		 explicit tmat3x3(
			col_type const & v0, 
			col_type const & v1,
			col_type const & v2);

		
		
		template <typename U> 
		 explicit tmat3x3(
			U const & x);
			
		template 
		<
			typename X1, typename Y1, typename Z1, 
			typename X2, typename Y2, typename Z2, 
			typename X3, typename Y3, typename Z3
		> 
		 explicit tmat3x3(
			X1 const & x1, Y1 const & y1, Z1 const & z1, 
			X2 const & x2, Y2 const & y2, Z2 const & z2, 
			X3 const & x3, Y3 const & y3, Z3 const & z3);
			
		template <typename V1, typename V2, typename V3> 
		 explicit tmat3x3(
			tvec3<V1> const & v1, 
			tvec3<V2> const & v2,
			tvec3<V3> const & v3);
            
		
		template <typename U> 
		 explicit tmat3x3(tmat3x3<U> const & m);

		 explicit tmat3x3(tmat2x2<T> const & x);
		 explicit tmat3x3(tmat4x4<T> const & x);
		 explicit tmat3x3(tmat2x3<T> const & x);
		 explicit tmat3x3(tmat3x2<T> const & x);
		 explicit tmat3x3(tmat2x4<T> const & x);
		 explicit tmat3x3(tmat4x2<T> const & x);
		 explicit tmat3x3(tmat3x4<T> const & x);
		 explicit tmat3x3(tmat4x3<T> const & x);

		
		 col_type & operator[](size_type i);
		 col_type const & operator[](size_type i) const;

		
		 tmat3x3<T>& operator=  (tmat3x3<T> const & m);
		template <typename U> 
		 tmat3x3<T>& operator=  (tmat3x3<U> const & m);
		template <typename U> 
		 tmat3x3<T>& operator+= (U const & s);
		template <typename U> 
		 tmat3x3<T>& operator+= (tmat3x3<U> const & m);
		template <typename U> 
		 tmat3x3<T>& operator-= (U const & s);
		template <typename U> 
		 tmat3x3<T>& operator-= (tmat3x3<U> const & m);
		template <typename U> 
		 tmat3x3<T>& operator*= (U const & s);
		template <typename U> 
		 tmat3x3<T>& operator*= (tmat3x3<U> const & m);
		template <typename U> 
		 tmat3x3<T>& operator/= (U const & s);
		template <typename U> 
		 tmat3x3<T>& operator/= (tmat3x3<U> const & m);
		 tmat3x3<T>& operator++ ();
		 tmat3x3<T>& operator-- ();
	};

	
	template <typename T> 
	 tmat3x3<T> operator+ (
		tmat3x3<T> const & m, 
		typename tmat3x3<T>::value_type const & s);

	template <typename T> 
	 tmat3x3<T> operator+ (
		typename tmat3x3<T>::value_type const & s, 
		tmat3x3<T> const & m);

	template <typename T> 
	 tmat3x3<T> operator+ (
		tmat3x3<T> const & m1, 
		tmat3x3<T> const & m2);
	    
	template <typename T> 
	 tmat3x3<T> operator- (
		tmat3x3<T> const & m, 
		typename tmat3x3<T>::value_type const & s);

	template <typename T> 
	 tmat3x3<T> operator- (
		typename tmat3x3<T>::value_type const & s, 
		tmat3x3<T> const & m);

	template <typename T> 
	 tmat3x3<T> operator- (
		tmat3x3<T> const & m1, 
		tmat3x3<T> const & m2);

	template <typename T> 
	 tmat3x3<T> operator* (
		tmat3x3<T> const & m, 
		typename tmat3x3<T>::value_type const & s);

	template <typename T> 
	 tmat3x3<T> operator* (
		typename tmat3x3<T>::value_type const & s, 
		tmat3x3<T> const & m);

	template <typename T> 
	 typename tmat3x3<T>::col_type operator* (
		tmat3x3<T> const & m, 
		typename tmat3x3<T>::row_type const & v);

	template <typename T> 
	 typename tmat3x3<T>::row_type operator* (
		typename tmat3x3<T>::col_type const & v, 
		tmat3x3<T> const & m);

	template <typename T> 
	 tmat3x3<T> operator* (
		tmat3x3<T> const & m1, 
		tmat3x3<T> const & m2);
		
	template <typename T>
	 tmat2x3<T> operator* (
		tmat3x3<T> const & m1, 
		tmat2x3<T> const & m2);
		
	template <typename T>
	 tmat4x3<T> operator* (
		tmat3x3<T> const & m1, 
		tmat4x3<T> const & m2);

	template <typename T> 
	 tmat3x3<T> operator/ (
		tmat3x3<T> const & m, 
		typename tmat3x3<T>::value_type const & s);

	template <typename T> 
	 tmat3x3<T> operator/ (
		typename tmat3x3<T>::value_type const & s, 
		tmat3x3<T> const & m);

	template <typename T> 
	 typename tmat3x3<T>::col_type operator/ (
		tmat3x3<T> const & m, 
		typename tmat3x3<T>::row_type const & v);

	template <typename T> 
	 typename tmat3x3<T>::row_type operator/ (
		typename tmat3x3<T>::col_type const & v, 
		tmat3x3<T> const & m);

	template <typename T> 
	 tmat3x3<T> operator/ (
		tmat3x3<T> const & m1, 
		tmat3x3<T> const & m2);

	
	template <typename T> 
	 tmat3x3<T> const operator-  (
		tmat3x3<T> const & m);

	template <typename T> 
	 tmat3x3<T> const operator-- (
		tmat3x3<T> const & m, 
		int);

	template <typename T> 
	 tmat3x3<T> const operator++ (
		tmat3x3<T> const & m, 
		int);
} 

	
	

	
	
	
	
	
	typedef detail::tmat3x3<lowp_float>		lowp_mat3;
	
	
	
	
	
	
	typedef detail::tmat3x3<mediump_float>	mediump_mat3;
	
	
	
	
	
	
	typedef detail::tmat3x3<highp_float>	highp_mat3;

	
	
	
	
	
	typedef detail::tmat3x3<lowp_float>		lowp_mat3x3;

	
	
	
	
	
	typedef detail::tmat3x3<mediump_float>	mediump_mat3x3;

	
	
	
	
	
	typedef detail::tmat3x3<highp_float>	highp_mat3x3;

	
}


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x3.inl"




























namespace glm{
namespace detail
{
	template <typename T>
	 inline  typename tmat3x3<T>::size_type tmat3x3<T>::length() const
	{
		return 3;
	}

	template <typename T>
	 inline typename tmat3x3<T>::size_type tmat3x3<T>::col_size()
	{
		return 3;
	}

	template <typename T>
	 inline typename tmat3x3<T>::size_type tmat3x3<T>::row_size()
	{
		return 3;
	}

	
	

	template <typename T>
	 inline typename tmat3x3<T>::col_type &
	tmat3x3<T>::operator[]
	(
		size_type i
	)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x3.inl", 60), 0) );
		return this->value[i];
	}

	template <typename T>
	 inline typename tmat3x3<T>::col_type const &
	tmat3x3<T>::operator[]
	(
		size_type i
	) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x3.inl", 71), 0) );
		return this->value[i];
	}

	
	

	template <typename T> 
	 inline tmat3x3<T>::tmat3x3()
	{
		value_type const Zero(0);
		value_type const One(1);
		this->value[0] = col_type(One, Zero, Zero);
		this->value[1] = col_type(Zero, One, Zero);
		this->value[2] = col_type(Zero, Zero, One);
	}

	template <typename T> 
	 inline tmat3x3<T>::tmat3x3
	(
		tmat3x3<T> const & m
	)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}

	template <typename T> 
	 inline tmat3x3<T>::tmat3x3
	(
		ctor
	)
	{}

	template <typename T> 
	 inline tmat3x3<T>::tmat3x3
	(
		value_type const & s
	)
	{
		value_type const Zero(0);
		this->value[0] = col_type(s, Zero, Zero);
		this->value[1] = col_type(Zero, s, Zero);
		this->value[2] = col_type(Zero, Zero, s);
	}

	template <typename T> 
	 inline tmat3x3<T>::tmat3x3
	(
		value_type const & x0, value_type const & y0, value_type const & z0, 
		value_type const & x1, value_type const & y1, value_type const & z1,
		value_type const & x2, value_type const & y2, value_type const & z2
	)
	{
		this->value[0] = col_type(x0, y0, z0);
		this->value[1] = col_type(x1, y1, z1);
		this->value[2] = col_type(x2, y2, z2);
	}

	template <typename T> 
	 inline tmat3x3<T>::tmat3x3
	(
		col_type const & v0, 
		col_type const & v1, 
		col_type const & v2
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
	}

	
	
	template <typename T> 
	template <typename U> 
	 tmat3x3<T>::tmat3x3
	(
		U const & s
	)
	{
		value_type const Zero(0);
		this->value[0] = tvec3<T>(value_type(s), Zero, Zero);
		this->value[1] = tvec3<T>(Zero, value_type(s), Zero);
		this->value[2] = tvec3<T>(Zero, Zero, value_type(s));
	}
	
	template <typename T> 
	template <
		typename X1, typename Y1, typename Z1, 
		typename X2, typename Y2, typename Z2, 
		typename X3, typename Y3, typename Z3>  
	 tmat3x3<T>::tmat3x3
	(
		X1 const & x1, Y1 const & y1, Z1 const & z1, 
		X2 const & x2, Y2 const & y2, Z2 const & z2, 
		X3 const & x3, Y3 const & y3, Z3 const & z3 
	)
	{
		this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1));
		this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2));
		this->value[2] = col_type(value_type(x3), value_type(y3), value_type(z3));
	}
	
	template <typename T> 
	template <typename V1, typename V2, typename V3> 
	 tmat3x3<T>::tmat3x3
	(
		tvec3<V1> const & v1, 
		tvec3<V2> const & v2, 
		tvec3<V3> const & v3
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
	}

	
	

	template <typename T> 
	template <typename U> 
	 inline tmat3x3<T>::tmat3x3
	(
		tmat3x3<U> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T> 
	 inline tmat3x3<T>::tmat3x3
	(
		tmat2x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], value_type(0));
		this->value[1] = col_type(m[1], value_type(0));
		this->value[2] = col_type(detail::tvec2<T>(0), value_type(1));
	}

	template <typename T> 
	 inline tmat3x3<T>::tmat3x3
	(
		tmat4x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T> 
	 inline tmat3x3<T>::tmat3x3
	(
		tmat2x3<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = col_type(detail::tvec2<T>(0), value_type(1));
	}

	template <typename T> 
	 inline tmat3x3<T>::tmat3x3
	(
		tmat3x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], value_type(0));
		this->value[1] = col_type(m[1], value_type(0));
		this->value[2] = col_type(m[2], value_type(1));
	}

	template <typename T> 
	 inline tmat3x3<T>::tmat3x3
	(
		tmat2x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(detail::tvec2<T>(0), value_type(1));
	}

	template <typename T> 
	 inline tmat3x3<T>::tmat3x3
	(
		tmat4x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], value_type(0));
		this->value[1] = col_type(m[1], value_type(0));
		this->value[2] = col_type(m[2], value_type(1));
	}

	template <typename T> 
	 inline tmat3x3<T>::tmat3x3
	(
		tmat3x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T> 
	 inline tmat3x3<T>::tmat3x3
	(
		tmat4x3<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
	}

	
	

	template <typename T> 
	 inline tmat3x3<T> & tmat3x3<T>::operator=
	(
		tmat3x3<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x3<T> & tmat3x3<T>::operator=
	(
		tmat3x3<U> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x3<T> & tmat3x3<T>::operator+= 
	(
		U const & s
	)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x3<T> & tmat3x3<T>::operator+=
	(
		tmat3x3<U> const & m
	)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x3<T> & tmat3x3<T>::operator-= 
	(
		U const & s
	)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x3<T> & tmat3x3<T>::operator-= 
	(
		tmat3x3<U> const & m
	)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x3<T> & tmat3x3<T>::operator*= 
	(
		U const & s
	)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x3<T> & tmat3x3<T>::operator*= 
	(
		tmat3x3<U> const & m
	)
	{
		return (*this = *this * m);
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x3<T> & tmat3x3<T>::operator/= 
	(
		U const & s
	)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x3<T> & tmat3x3<T>::operator/= 
	(
		tmat3x3<U> const & m
	)
	{
		return (*this = *this / m);
	}

	template <typename T> 
	 inline tmat3x3<T> & tmat3x3<T>::operator++ ()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template <typename T> 
	 inline tmat3x3<T> & tmat3x3<T>::operator-- ()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template <typename T> 
	 inline tmat3x3<T> tmat3x3<T>::_inverse() const
	{
		T S00 = value[0][0];
		T S01 = value[0][1];
		T S02 = value[0][2];

		T S10 = value[1][0];
		T S11 = value[1][1];
		T S12 = value[1][2];

		T S20 = value[2][0];
		T S21 = value[2][1];
		T S22 = value[2][2];












		tmat3x3<T> Inverse(
			S11 * S22 - S21 * S12,
			S12 * S20 - S22 * S10,
			S10 * S21 - S20 * S11,
			S02 * S21 - S01 * S22,
			S00 * S22 - S02 * S20,
			S01 * S20 - S00 * S21,
			S12 * S01 - S11 * S02,
			S10 * S02 - S12 * S00,
			S11 * S00 - S10 * S01);

		T Determinant = S00 * (S11 * S22 - S21 * S12)
						- S10 * (S01 * S22 - S21 * S02)
						+ S20 * (S01 * S12 - S11 * S02);

		Inverse /= Determinant;
		return Inverse;
	}

	
	

	template <typename T> 
	 inline tmat3x3<T> operator+ 
	(
		tmat3x3<T> const & m, 
		typename tmat3x3<T>::value_type const & s
	)
	{
		return tmat3x3<T>(
			m[0] + s,
			m[1] + s,
			m[2] + s);
	}

	template <typename T> 
	 inline tmat3x3<T> operator+ 
	(
		typename tmat3x3<T>::value_type const & s, 
		tmat3x3<T> const & m
	)
	{
		return tmat3x3<T>(
			m[0] + s,
			m[1] + s,
			m[2] + s);
	}

	template <typename T> 
	 inline tmat3x3<T> operator+ 
	(
		tmat3x3<T> const & m1, 
		tmat3x3<T> const & m2
	)
	{
		return tmat3x3<T>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template <typename T> 
	 inline tmat3x3<T> operator- 
	(
		tmat3x3<T> const & m, 
		typename tmat3x3<T>::value_type const & s
	)
	{
		return tmat3x3<T>(
			m[0] - s,
			m[1] - s,
			m[2] - s);
	}

	template <typename T> 
	 inline tmat3x3<T> operator- 
	(
		typename tmat3x3<T>::value_type const & s, 
		tmat3x3<T> const & m
	)
	{
		return tmat3x3<T>(
			s - m[0],
			s - m[1],
			s - m[2]);
	}

	template <typename T> 
	 inline tmat3x3<T> operator- 
	(
		tmat3x3<T> const & m1, 
		tmat3x3<T> const & m2
	)
	{
		return tmat3x3<T>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template <typename T> 
	 inline tmat3x3<T> operator* 
	(
		tmat3x3<T> const & m, 
		typename tmat3x3<T>::value_type const & s
	)
	{
		return tmat3x3<T>(
			m[0] * s,
			m[1] * s,
			m[2] * s);
	}

	template <typename T> 
	 inline tmat3x3<T> operator* 
	(
		typename tmat3x3<T>::value_type const & s, 
		tmat3x3<T> const & m
	)
	{
		return tmat3x3<T>(
			m[0] * s,
			m[1] * s,
			m[2] * s);
	}

	template <typename T> 
	 inline typename tmat3x3<T>::col_type operator* 
	(
		tmat3x3<T> const & m, 
		typename tmat3x3<T>::row_type const & v
	)
	{
		return typename tmat3x3<T>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
	}

	template <typename T> 
	 inline typename tmat3x3<T>::row_type operator* 
	(
		typename tmat3x3<T>::col_type const & v, 
		tmat3x3<T> const & m
	)
	{
		return typename tmat3x3<T>::row_type(
			m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
			m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
			m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
	}

	template <typename T> 
	 inline tmat3x3<T> operator* 
	(
		tmat3x3<T> const & m1, 
		tmat3x3<T> const & m2
	)
	{
		typename tmat3x3<T>::value_type const SrcA00 = m1[0][0];
		typename tmat3x3<T>::value_type const SrcA01 = m1[0][1];
		typename tmat3x3<T>::value_type const SrcA02 = m1[0][2];
		typename tmat3x3<T>::value_type const SrcA10 = m1[1][0];
		typename tmat3x3<T>::value_type const SrcA11 = m1[1][1];
		typename tmat3x3<T>::value_type const SrcA12 = m1[1][2];
		typename tmat3x3<T>::value_type const SrcA20 = m1[2][0];
		typename tmat3x3<T>::value_type const SrcA21 = m1[2][1];
		typename tmat3x3<T>::value_type const SrcA22 = m1[2][2];

		typename tmat3x3<T>::value_type const SrcB00 = m2[0][0];
		typename tmat3x3<T>::value_type const SrcB01 = m2[0][1];
		typename tmat3x3<T>::value_type const SrcB02 = m2[0][2];
		typename tmat3x3<T>::value_type const SrcB10 = m2[1][0];
		typename tmat3x3<T>::value_type const SrcB11 = m2[1][1];
		typename tmat3x3<T>::value_type const SrcB12 = m2[1][2];
		typename tmat3x3<T>::value_type const SrcB20 = m2[2][0];
		typename tmat3x3<T>::value_type const SrcB21 = m2[2][1];
		typename tmat3x3<T>::value_type const SrcB22 = m2[2][2];

		tmat3x3<T> Result(tmat3x3<T>::null);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		return Result;
	}

	template <typename T>
	 inline tmat2x3<T> operator* 
	(
		tmat3x3<T> const & m1, 
		tmat2x3<T> const & m2
	)
	{
		return tmat2x3<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
	}

	template <typename T>
	 inline tmat4x3<T> operator* 
	(
		tmat3x3<T> const & m1, 
		tmat4x3<T> const & m2
	)
	{
		return tmat4x3<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
	}

	template <typename T> 
	 inline tmat3x3<T> operator/ 
	(
		tmat3x3<T> const & m, 
		typename tmat3x3<T>::value_type const & s
	)
	{
		return tmat3x3<T>(
			m[0] / s,
			m[1] / s,
			m[2] / s);
	}

	template <typename T> 
	 inline tmat3x3<T> operator/ 
	(
		typename tmat3x3<T>::value_type const & s, 
		tmat3x3<T> const & m
	)
	{
		return tmat3x3<T>(
			s / m[0],
			s / m[1],
			s / m[2]);
	}

	template <typename T> 
	 inline typename tmat3x3<T>::col_type operator/ 
	(
		tmat3x3<T> const & m, 
		typename tmat3x3<T>::row_type const & v
	)
	{
		return m._inverse() * v;
	}

	template <typename T> 
	 inline typename tmat3x3<T>::row_type operator/ 
	(
		typename tmat3x3<T>::col_type const & v, 
		tmat3x3<T> const & m
	)
	{
		return v * m._inverse();
	}

	template <typename T> 
	 inline tmat3x3<T> operator/ 
	(
		tmat3x3<T> const & m1, 
		tmat3x3<T> const & m2
	)
	{
		return m1 * m2._inverse();
	}

	
	template <typename T> 
	 inline tmat3x3<T> const operator- 
	(
		tmat3x3<T> const & m
	)
	{
		return tmat3x3<T>(
			-m[0], 
			-m[1],
			-m[2]);
	}

	template <typename T> 
	 inline tmat3x3<T> const operator++ 
	(
		tmat3x3<T> const & m, 
		int
	) 
	{
		return tmat3x3<T>(
			m[0] + T(1),
			m[1] + T(1),
			m[2] + T(1));
	}

	template <typename T> 
	 inline tmat3x3<T> const operator-- 
	(
		tmat3x3<T> const & m, 
		int
	) 
	{
		return tmat3x3<T>(
			m[0] - T(1),
			m[1] - T(1),
			m[2] - T(1));
	}

	
	

	template <typename T> 
	 inline bool operator==
	(
		tmat3x3<T> const & m1, 
		tmat3x3<T> const & m2
	)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template <typename T> 
	 inline bool operator!=
	(
		tmat3x3<T> const & m1, 
		tmat3x3<T> const & m2
	)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}

} 
} 
#line 316 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x3.hpp"
#line 317 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x3.hpp"

#line 319 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x3.hpp"
#line 48 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x4.hpp"

































namespace glm{
namespace detail
{
	template <typename T> struct tvec1;
	template <typename T> struct tvec2;
	template <typename T> struct tvec3;
	template <typename T> struct tvec4;
	template <typename T> struct tmat2x2;
	template <typename T> struct tmat2x3;
	template <typename T> struct tmat2x4;
	template <typename T> struct tmat3x2;
	template <typename T> struct tmat3x3;
	template <typename T> struct tmat3x4;
	template <typename T> struct tmat4x2;
	template <typename T> struct tmat4x3;
	template <typename T> struct tmat4x4;

	template <typename T> 
	struct tmat3x4
	{
		enum ctor{null};
		typedef T value_type;
		typedef std::size_t size_type;
		typedef tvec4<T> col_type;
		typedef tvec3<T> row_type;
		typedef tmat3x4<T> type;
		typedef tmat4x3<T> transpose_type;

		static  size_type col_size();
		static  size_type row_size();

		  size_type length() const;

	private:
		
		col_type value[3];

	public:
		
		 tmat3x4();
		 tmat3x4(tmat3x4 const & m);

		 explicit tmat3x4(
			ctor Null);
		 explicit tmat3x4(
			value_type const & s);
		 explicit tmat3x4(
			value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
			value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1,
			value_type const & x2, value_type const & y2, value_type const & z2, value_type const & w2);
		 explicit tmat3x4(
			col_type const & v0, 
			col_type const & v1,
			col_type const & v2);

		
		
		template <typename U> 
		 explicit tmat3x4(
            U const & x);
			
		template 
        <
            typename X1, typename Y1, typename Z1, typename W1, 
            typename X2, typename Y2, typename Z2, typename W2, 
            typename X3, typename Y3, typename Z3, typename W3 
        > 
		 explicit tmat3x4(
            X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1, 
            X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2, 
            X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3);
			
		template <typename V1, typename V2, typename V3> 
		 explicit tmat3x4(
            tvec4<V1> const & v1, 
            tvec4<V2> const & v2,
            tvec4<V3> const & v3);
            
		
		template <typename U> 
		 explicit tmat3x4(tmat3x4<U> const & m);

		 explicit tmat3x4(tmat2x2<T> const & x);
		 explicit tmat3x4(tmat3x3<T> const & x);
		 explicit tmat3x4(tmat4x4<T> const & x);
		 explicit tmat3x4(tmat2x3<T> const & x);
		 explicit tmat3x4(tmat3x2<T> const & x);
		 explicit tmat3x4(tmat2x4<T> const & x);
		 explicit tmat3x4(tmat4x2<T> const & x);
		 explicit tmat3x4(tmat4x3<T> const & x);

		
		 col_type & operator[](size_type i);
		 col_type const & operator[](size_type i) const;

		
		 tmat3x4<T> & operator=  (tmat3x4<T> const & m);
		template <typename U> 
		 tmat3x4<T> & operator=  (tmat3x4<U> const & m);
		template <typename U> 
		 tmat3x4<T> & operator+= (U const & s);
		template <typename U> 
		 tmat3x4<T> & operator+= (tmat3x4<U> const & m);
		template <typename U> 
		 tmat3x4<T> & operator-= (U const & s);
		template <typename U> 
		 tmat3x4<T> & operator-= (tmat3x4<U> const & m);
		template <typename U> 
		 tmat3x4<T> & operator*= (U const & s);
		template <typename U> 
		 tmat3x4<T> & operator*= (tmat3x4<U> const & m);
		template <typename U> 
		 tmat3x4<T> & operator/= (U const & s);

		 tmat3x4<T> & operator++ ();
		 tmat3x4<T> & operator-- ();
	};

	
	template <typename T> 
	 tmat3x4<T> operator+ (
		tmat3x4<T> const & m, 
		typename tmat3x4<T>::value_type const & s);
	    
	template <typename T> 
	 tmat3x4<T> operator+ (
		tmat3x4<T> const & m1, 
		tmat3x4<T> const & m2);
	    
	template <typename T> 
	 tmat3x4<T> operator- (
		tmat3x4<T> const & m, 
		typename tmat3x4<T>::value_type const & s);

	template <typename T> 
	 tmat3x4<T> operator- (
		tmat3x4<T> const & m1, 
		tmat3x4<T> const & m2);

	template <typename T> 
	 tmat3x4<T> operator* (
		tmat3x4<T> const & m, 
		typename tmat3x4<T>::value_type const & s);

	template <typename T> 
	 tmat3x4<T> operator* (
		typename tmat3x4<T>::value_type const & s, 
		tmat3x4<T> const & m);

	template <typename T>
	 typename tmat3x4<T>::col_type operator* (
		tmat3x4<T> const & m, 
		typename tmat3x4<T>::row_type const & v);

	template <typename T> 
	 typename tmat3x4<T>::row_type operator* (
		typename tmat3x4<T>::col_type const & v, 
		tmat3x4<T> const & m);

	template <typename T>
	 tmat4x4<T> operator* (
		tmat3x4<T> const & m1, 
		tmat4x3<T> const & m2);
		
	template <typename T>
	 tmat2x4<T> operator* (
		tmat3x4<T> const & m1, 
		tmat2x3<T> const & m2);
		
	template <typename T>
	 tmat3x4<T> operator* (
		tmat3x4<T> const & m1, 
		tmat3x3<T> const & m2);

	template <typename T> 
	 tmat3x4<T> operator/ (
		tmat3x4<T> const & m, 
		typename tmat3x4<T>::value_type const & s);

	template <typename T> 
	 tmat3x4<T> operator/ (
		typename tmat3x4<T>::value_type const & s, 
		tmat3x4<T> const & m);

	
	template <typename T> 
	 tmat3x4<T> const operator-  (
		tmat3x4<T> const & m);

	template <typename T> 
	 tmat3x4<T> const operator-- (
		tmat3x4<T> const & m, 
		int);

	template <typename T> 
	 tmat3x4<T> const operator++ (
		tmat3x4<T> const & m, 
		int);

}

	
	

	
	
	
	
	
	typedef detail::tmat3x4<lowp_float>		lowp_mat3x4;

	
	
	
	
	
	typedef detail::tmat3x4<mediump_float>	mediump_mat3x4;

	
	
	
	
	
	typedef detail::tmat3x4<highp_float>	highp_mat3x4;

	
}


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x4.inl"




























namespace glm{
namespace detail
{
	template <typename T>
	 inline  typename tmat3x4<T>::size_type tmat3x4<T>::length() const
	{
		return 3;
	}

	template <typename T>
	 inline typename tmat3x4<T>::size_type tmat3x4<T>::col_size()
	{
		return 4;
	}

	template <typename T>
	 inline typename tmat3x4<T>::size_type tmat3x4<T>::row_size()
	{
		return 3;
	}

	
	

	template <typename T>
	 inline typename tmat3x4<T>::col_type & 
	tmat3x4<T>::operator[]
	(
		size_type i
	)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x4.inl", 60), 0) );
		return this->value[i];
	}

	template <typename T>
	 inline typename tmat3x4<T>::col_type const & 
	tmat3x4<T>::operator[]
	(
		size_type i
	) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x4.inl", 71), 0) );
		return this->value[i];
	}

	
	

	template <typename T> 
	 inline tmat3x4<T>::tmat3x4()
	{
		this->value[0] = col_type(1, 0, 0, 0);
		this->value[1] = col_type(0, 1, 0, 0);
		this->value[2] = col_type(0, 0, 1, 0);
	}

	template <typename T> 
	 inline tmat3x4<T>::tmat3x4
	(
		tmat3x4<T> const & m
	)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}

	template <typename T> 
	 inline tmat3x4<T>::tmat3x4
	(
		ctor
	)
	{}

	template <typename T> 
	 inline tmat3x4<T>::tmat3x4
	(
		value_type const & s
	)
	{
		value_type const Zero(0);
		this->value[0] = col_type(s, Zero, Zero, Zero);
		this->value[1] = col_type(Zero, s, Zero, Zero);
		this->value[2] = col_type(Zero, Zero, s, Zero);
	}

	template <typename T> 
	 inline tmat3x4<T>::tmat3x4
	(
		value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
		value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1,
		value_type const & x2, value_type const & y2, value_type const & z2, value_type const & w2
	)
	{
		this->value[0] = col_type(x0, y0, z0, w0);
		this->value[1] = col_type(x1, y1, z1, w1);
		this->value[2] = col_type(x2, y2, z2, w2);
	}

	template <typename T> 
	 inline tmat3x4<T>::tmat3x4
	(
		col_type const & v0, 
		col_type const & v1, 
		col_type const & v2
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
	}

	
	
	template <typename T> 
	template <typename U> 
	 tmat3x4<T>::tmat3x4
	(
		U const & s
	)
	{
		value_type const Zero(0);
		this->value[0] = tvec4<T>(value_type(s), Zero, Zero, Zero);
		this->value[1] = tvec4<T>(Zero, value_type(s), Zero, Zero);
		this->value[2] = tvec4<T>(Zero, Zero, value_type(s), Zero);
	}
	
	template <typename T> 
	template <
		typename X1, typename Y1, typename Z1, typename W1, 
		typename X2, typename Y2, typename Z2, typename W2, 
		typename X3, typename Y3, typename Z3, typename W3>  
	 tmat3x4<T>::tmat3x4
	(
		X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1, 
		X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2, 
		X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3  
	)
	{
		this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1), value_type(w1));
		this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2), value_type(w2));
		this->value[2] = col_type(value_type(x3), value_type(y3), value_type(z3), value_type(w3));
	}
	
	template <typename T> 
	template <typename V1, typename V2, typename V3> 
	 tmat3x4<T>::tmat3x4
	(
		tvec4<V1> const & v1, 
		tvec4<V2> const & v2, 
		tvec4<V3> const & v3
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
	}

	
	template <typename T> 
	template <typename U> 
	 inline tmat3x4<T>::tmat3x4
	(
		tmat3x4<U> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T> 
	 inline tmat3x4<T>::tmat3x4
	(
		tmat2x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], detail::tvec2<T>(0));
		this->value[1] = col_type(m[1], detail::tvec2<T>(0));
		this->value[2] = col_type(T(0), T(0), T(1), T(0));
	}

	template <typename T> 
	 inline tmat3x4<T>::tmat3x4
	(
		tmat3x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0], T(0));
		this->value[1] = col_type(m[1], T(0));
		this->value[2] = col_type(m[2], T(0));
	}

	template <typename T> 
	 inline tmat3x4<T>::tmat3x4
	(
		tmat4x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T> 
	 inline tmat3x4<T>::tmat3x4
	(
		tmat2x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0], T(0));
		this->value[1] = col_type(m[1], T(0));
		this->value[2] = col_type(T(0), T(0), T(1), T(0));
	}

	template <typename T> 
	 inline tmat3x4<T>::tmat3x4
	(
		tmat3x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], detail::tvec2<T>(0));
		this->value[1] = col_type(m[1], detail::tvec2<T>(0));
		this->value[2] = col_type(m[2], T(0), T(1));
	}

	template <typename T> 
	 inline tmat3x4<T>::tmat3x4
	(
		tmat2x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(T(0), T(0), T(1), T(0));
	}

	template <typename T> 
	 inline tmat3x4<T>::tmat3x4
	(
		tmat4x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], detail::tvec2<T>(T(0)));
		this->value[1] = col_type(m[1], detail::tvec2<T>(T(0)));
		this->value[2] = col_type(m[2], detail::tvec2<T>(T(1), T(0)));
	}

	template <typename T> 
	 inline tmat3x4<T>::tmat3x4
	(
		tmat4x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0], T(0));
		this->value[1] = col_type(m[1], T(0));
		this->value[2] = col_type(m[2], T(0));
	}

	
	

	template <typename T> 
	 inline tmat3x4<T>& tmat3x4<T>::operator= 
	(
		tmat3x4<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x4<T>& tmat3x4<T>::operator= 
	(
		tmat3x4<U> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x4<T>& tmat3x4<T>::operator+= 
	(
		U const & s
	)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x4<T>& tmat3x4<T>::operator+= 
	(
		tmat3x4<U> const & m
	)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x4<T>& tmat3x4<T>::operator-= 
	(
		U const & s
	)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x4<T>& tmat3x4<T>::operator-= 
	(
		tmat3x4<U> const & m
	)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x4<T>& tmat3x4<T>::operator*= 
	(
		U const & s
	)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x4<T>& tmat3x4<T>::operator*= 
	(
		tmat3x4<U> const & m
	)
	{
		return (*this = tmat3x4<T>(*this * m));
	}

	template <typename T> 
	template <typename U> 
	 inline tmat3x4<T> & tmat3x4<T>::operator/= 
	(
		U const & s
	)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	template <typename T> 
	 inline tmat3x4<T>& tmat3x4<T>::operator++ ()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template <typename T> 
	 inline tmat3x4<T>& tmat3x4<T>::operator-- ()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	
	

	template <typename T> 
	 inline tmat3x4<T> operator+ 
	(
		tmat3x4<T> const & m, 
		typename tmat3x4<T>::value_type const & s
	)
	{
		return tmat3x4<T>(
			m[0] + s,
			m[1] + s,
			m[2] + s);
	}

	template <typename T> 
	 inline tmat3x4<T> operator+ 
	(
		tmat3x4<T> const & m1, 
		tmat3x4<T> const & m2
	)
	{
		return tmat3x4<T>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template <typename T> 
	 inline tmat3x4<T> operator- 
	(
		tmat3x4<T> const & m, 
		typename tmat3x4<T>::value_type const & s
	)
	{
		return tmat3x4<T>(
			m[0] - s,
			m[1] - s,
			m[2] - s);
	}

	template <typename T> 
	 inline tmat3x4<T> operator- 
	(
		tmat3x4<T> const & m1, 
		tmat3x4<T> const & m2
	)
	{
		return tmat3x4<T>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template <typename T> 
	 inline tmat3x4<T> operator* 
	(
		tmat3x4<T> const & m, 
		typename tmat3x4<T>::value_type const & s
	)
	{
		return tmat3x4<T>(
			m[0] * s,
			m[1] * s,
			m[2] * s);
	}

	template <typename T> 
	 inline tmat3x4<T> operator* 
	(
		typename tmat3x4<T>::value_type const & s, 
		tmat3x4<T> const & m
	)
	{
		return tmat3x4<T>(
			m[0] * s,
			m[1] * s,
			m[2] * s);
	}

	template <typename T>
	 inline typename tmat3x4<T>::col_type operator* 
	(
		tmat3x4<T> const & m, 
		typename tmat3x4<T>::row_type const & v
	)
	{
		return typename tmat3x4<T>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
			m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
	}

	template <typename T> 
	 inline typename tmat3x4<T>::row_type operator* 
	(
		typename tmat3x4<T>::col_type const & v, 
		tmat3x4<T> const & m
	)
	{
		return typename tmat3x4<T>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
	}

	template <typename T> 
	 inline tmat4x4<T> operator* 
	(
		tmat3x4<T> const & m1, 
		tmat4x3<T> const & m2
	)
	{
		const T SrcA00 = m1[0][0];
		const T SrcA01 = m1[0][1];
		const T SrcA02 = m1[0][2];
		const T SrcA03 = m1[0][3];
		const T SrcA10 = m1[1][0];
		const T SrcA11 = m1[1][1];
		const T SrcA12 = m1[1][2];
		const T SrcA13 = m1[1][3];
		const T SrcA20 = m1[2][0];
		const T SrcA21 = m1[2][1];
		const T SrcA22 = m1[2][2];
		const T SrcA23 = m1[2][3];

		const T SrcB00 = m2[0][0];
		const T SrcB01 = m2[0][1];
		const T SrcB02 = m2[0][2];
		const T SrcB10 = m2[1][0];
		const T SrcB11 = m2[1][1];
		const T SrcB12 = m2[1][2];
		const T SrcB20 = m2[2][0];
		const T SrcB21 = m2[2][1];
		const T SrcB22 = m2[2][2];
		const T SrcB30 = m2[3][0];
		const T SrcB31 = m2[3][1];
		const T SrcB32 = m2[3][2];

		tmat4x4<T> Result(tmat4x4<T>::null);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
		return Result;
	}

	template <typename T>
	 inline tmat2x4<T> operator* 
	(
		tmat3x4<T> const & m1, 
		tmat2x3<T> const & m2
	)
	{
		return tmat2x4<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
	}

	template <typename T>
	 inline tmat3x4<T> operator* 
	(
		tmat3x4<T> const & m1, 
		tmat3x3<T> const & m2
	)
	{
		return tmat3x4<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
	}

	template <typename T> 
	 inline tmat3x4<T> operator/ 
	(
		tmat3x4<T> const & m, 
		typename tmat3x4<T>::value_type const & s
	)
	{
		return tmat3x4<T>(
			m[0] / s,
			m[1] / s,
			m[2] / s);
	}

	template <typename T> 
	 inline tmat3x4<T> operator/
	(
		typename tmat3x4<T>::value_type const & s, 
		tmat3x4<T> const & m
	)
	{
		return tmat3x4<T>(
			s / m[0],
			s / m[1],
			s / m[2]);
	}

	
	template <typename T> 
	 inline tmat3x4<T> const operator- 
	(
		tmat3x4<T> const & m
	)
	{
		return tmat3x4<T>(
			-m[0], 
			-m[1],
			-m[2]);
	}

	template <typename T> 
	 inline tmat3x4<T> const operator++ 
	(
		tmat3x4<T> const & m, 
		int
	) 
	{
		return tmat3x4<T>(
			m[0] + T(1),
			m[1] + T(1),
			m[2] + T(1));
	}

	template <typename T> 
	 inline tmat3x4<T> const operator-- 
	(
		tmat3x4<T> const & m, 
		int
	) 
	{
		return tmat3x4<T>(
			m[0] - T(1),
			m[1] - T(1),
			m[2] - T(1));
	}

	
	

	template <typename T> 
	 inline bool operator==
	(
		tmat3x4<T> const & m1, 
		tmat3x4<T> const & m2
	)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template <typename T> 
	 inline bool operator!=
	(
		tmat3x4<T> const & m1, 
		tmat3x4<T> const & m2
	)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
} 
#line 264 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x4.hpp"
#line 265 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x4.hpp"

#line 267 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat3x4.hpp"
#line 49 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x2.hpp"

































namespace glm{
namespace detail
{
	template <typename T> struct tvec1;
	template <typename T> struct tvec2;
	template <typename T> struct tvec3;
	template <typename T> struct tvec4;
	template <typename T> struct tmat2x2;
	template <typename T> struct tmat2x3;
	template <typename T> struct tmat2x4;
	template <typename T> struct tmat3x2;
	template <typename T> struct tmat3x3;
	template <typename T> struct tmat3x4;
	template <typename T> struct tmat4x2;
	template <typename T> struct tmat4x3;
	template <typename T> struct tmat4x4;

	template <typename T> 
	struct tmat4x2
	{
		enum ctor{null};
		typedef T value_type;
		typedef std::size_t size_type;
		typedef tvec2<T> col_type;
		typedef tvec4<T> row_type;
		typedef tmat4x2<T> type;
		typedef tmat2x4<T> transpose_type;

		static  size_type col_size();
		static  size_type row_size();

		  size_type length() const;

	private:
		
		col_type value[4];

	public:
		
		 tmat4x2();
		 tmat4x2(tmat4x2 const & m);

		 explicit tmat4x2(
			ctor Null);
		 explicit tmat4x2(
			value_type const & x);
		 explicit tmat4x2(
			value_type const & x0, value_type const & y0,
			value_type const & x1, value_type const & y1,
			value_type const & x2, value_type const & y2,
			value_type const & x3, value_type const & y3);
		 explicit tmat4x2(
			col_type const & v0, 
			col_type const & v1,
			col_type const & v2,
			col_type const & v3);

		
		
		template <typename U> 
		 explicit tmat4x2(
			U const & x);
			
		template 
		<
			typename X1, typename Y1, 
			typename X2, typename Y2, 
			typename X3, typename Y3,
			typename X4, typename Y4
		> 
		 explicit tmat4x2(
			X1 const & x1, Y1 const & y1, 
			X2 const & x2, Y2 const & y2,
			X3 const & x3, Y3 const & y3,
			X4 const & x4, Y4 const & y4);
			
		template <typename V1, typename V2, typename V3, typename V4> 
		 explicit tmat4x2(
			tvec2<V1> const & v1, 
			tvec2<V2> const & v2,
			tvec2<V3> const & v3,
			tvec2<V4> const & v4);
            
		
		template <typename U> 
		 explicit tmat4x2(tmat4x2<U> const & m);
			
		 explicit tmat4x2(tmat2x2<T> const & x);
		 explicit tmat4x2(tmat3x3<T> const & x);
		 explicit tmat4x2(tmat4x4<T> const & x);
		 explicit tmat4x2(tmat2x3<T> const & x);
		 explicit tmat4x2(tmat3x2<T> const & x);
		 explicit tmat4x2(tmat2x4<T> const & x);
		 explicit tmat4x2(tmat4x3<T> const & x);
		 explicit tmat4x2(tmat3x4<T> const & x);

		
		 col_type & operator[](size_type i);
		 col_type const & operator[](size_type i) const;

		
		 tmat4x2<T>& operator=  (tmat4x2<T> const & m);
		template <typename U> 
		 tmat4x2<T>& operator=  (tmat4x2<U> const & m);
		template <typename U> 
		 tmat4x2<T>& operator+= (U const & s);
		template <typename U> 
		 tmat4x2<T>& operator+= (tmat4x2<U> const & m);
		template <typename U> 
		 tmat4x2<T>& operator-= (U const & s);
		template <typename U> 
		 tmat4x2<T>& operator-= (tmat4x2<U> const & m);
		template <typename U> 
		 tmat4x2<T>& operator*= (U const & s);
		template <typename U> 
		 tmat4x2<T>& operator*= (tmat4x2<U> const & m);
		template <typename U> 
		 tmat4x2<T>& operator/= (U const & s);

		 tmat4x2<T>& operator++ ();
		 tmat4x2<T>& operator-- ();
	};

	
	template <typename T> 
	 tmat4x2<T> operator+ (
		tmat4x2<T> const & m, 
		typename tmat4x2<T>::value_type const & s);

	template <typename T> 
	 tmat4x2<T> operator+ (
		tmat4x2<T> const & m1, 
		tmat4x2<T> const & m2);

	template <typename T> 
	 tmat4x2<T> operator- (
		tmat4x2<T> const & m, 
		typename tmat4x2<T>::value_type const & s);

	template <typename T> 
	 tmat4x2<T> operator- (
		tmat4x2<T> const & m1, 
		tmat4x2<T> const & m2);

	template <typename T> 
	 tmat4x2<T> operator* (
		tmat4x2<T> const & m, 
		typename tmat4x2<T>::value_type const & s);

	template <typename T> 
	 tmat4x2<T> operator* (
		typename tmat4x2<T>::value_type const & s, 
		tmat4x2<T> const & m);

	template <typename T>
	 typename tmat4x2<T>::col_type operator* (
		tmat4x2<T> const & m, 
		typename tmat4x2<T>::row_type const & v);

	template <typename T> 
	 typename tmat4x2<T>::row_type operator* (
		typename tmat4x2<T>::col_type const & v, 
		tmat4x2<T> const & m);

	template <typename T>
	 tmat3x2<T> operator* (
		tmat4x2<T> const & m1, 
		tmat3x4<T> const & m2);
		
	template <typename T>
	 tmat4x2<T> operator* (
		tmat4x2<T> const & m1, 
		tmat4x4<T> const & m2);
		
	template <typename T>
	 tmat2x3<T> operator* (
		tmat4x3<T> const & m1, 
		tmat2x4<T> const & m2);

	template <typename T> 
	 tmat4x2<T> operator/ (
		tmat4x2<T> const & m, 
		typename tmat4x2<T>::value_type const & s);

	template <typename T> 
	 tmat4x2<T> operator/ (
		typename tmat4x2<T>::value_type const & s, 
		tmat4x2<T> const & m);

	
	template <typename T> 
	 tmat4x2<T> const operator-  (
		tmat4x2<T> const & m);

	template <typename T> 
	 tmat4x2<T> const operator-- (
		tmat4x2<T> const & m, 
		int);

	template <typename T> 
	 tmat4x2<T> const operator++ (
		tmat4x2<T> const & m, 
		int);
} 

	
	

	
	
	
	
	
	typedef detail::tmat4x2<lowp_float>		lowp_mat4x2;

	
	
	
	
	
	typedef detail::tmat4x2<mediump_float>	mediump_mat4x2;

	
	
	
	
	
	typedef detail::tmat4x2<highp_float>	highp_mat4x2;

	
}


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x2.inl"




























namespace glm{
namespace detail
{
	template <typename T>
	 inline  typename tmat4x2<T>::size_type tmat4x2<T>::length() const
	{
		return 4;
	}

	template <typename T>
	 inline typename tmat4x2<T>::size_type tmat4x2<T>::col_size()
	{
		return 2;
	}

	template <typename T>
	 inline typename tmat4x2<T>::size_type tmat4x2<T>::row_size()
	{
		return 4;
	}

	
	

	template <typename T>
	 inline typename tmat4x2<T>::col_type & 
	tmat4x2<T>::operator[]
	(
		size_type i
	)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x2.inl", 60), 0) );
		return this->value[i];
	}

	template <typename T>
	 inline typename tmat4x2<T>::col_type const & 
	tmat4x2<T>::operator[]
	(
		size_type i
	) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x2.inl", 71), 0) );
		return this->value[i];
	}

	
	

	template <typename T> 
	 inline tmat4x2<T>::tmat4x2()
	{
		value_type const Zero(0);
		value_type const One(1);
		this->value[0] = col_type(One, Zero);
		this->value[1] = col_type(Zero, One);
		this->value[2] = col_type(Zero, Zero);
		this->value[3] = col_type(Zero, Zero);
	}

	template <typename T> 
	 inline tmat4x2<T>::tmat4x2
	(
		tmat4x2<T> const & m
	)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
		this->value[3] = m.value[3];
	}

	template <typename T> 
	 inline tmat4x2<T>::tmat4x2
	(
		ctor
	)
	{}

	template <typename T> 
	 inline tmat4x2<T>::tmat4x2
	(
		value_type const & s
	)
	{
		value_type const Zero(0);
		this->value[0] = col_type(s, Zero);
		this->value[1] = col_type(Zero, s);
		this->value[2] = col_type(Zero, Zero);
		this->value[3] = col_type(Zero, Zero);
	}

	template <typename T> 
	 inline tmat4x2<T>::tmat4x2
	(
		value_type const & x0, value_type const & y0,
		value_type const & x1, value_type const & y1,
		value_type const & x2, value_type const & y2,
		value_type const & x3, value_type const & y3
	)
	{
		this->value[0] = col_type(x0, y0);
		this->value[1] = col_type(x1, y1);
		this->value[2] = col_type(x2, y2);
		this->value[3] = col_type(x3, y3);
	}

	template <typename T> 
	 inline tmat4x2<T>::tmat4x2
	(
		col_type const & v0, 
		col_type const & v1, 
		col_type const & v2,
		col_type const & v3
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
		this->value[3] = v3;
	}

	
	
	template <typename T> 
	template <typename U> 
	 tmat4x2<T>::tmat4x2
	(
		U const & s
	)
	{
		value_type const Zero(0);
		this->value[0] = tvec2<T>(value_type(s), Zero);
		this->value[1] = tvec2<T>(Zero, value_type(s));
		this->value[2] = tvec2<T>(Zero, Zero);
		this->value[3] = tvec2<T>(Zero, Zero);
	}
	
	template <typename T> 
	template <
		typename X1, typename Y1, 
		typename X2, typename Y2, 
		typename X3, typename Y3, 
		typename X4, typename Y4>  
	 tmat4x2<T>::tmat4x2
	(
		X1 const & x1, Y1 const & y1, 
		X2 const & x2, Y2 const & y2,
		X3 const & x3, Y3 const & y3,
		X4 const & x4, Y4 const & y4
	)		
	{
		this->value[0] = col_type(value_type(x1), value_type(y1));
		this->value[1] = col_type(value_type(x2), value_type(y2));
		this->value[2] = col_type(value_type(x3), value_type(y3));
		this->value[3] = col_type(value_type(x4), value_type(y4));
	}
	
	template <typename T> 
	template <typename V1, typename V2, typename V3, typename V4> 
	 tmat4x2<T>::tmat4x2
	(
		tvec2<V1> const & v1, 
		tvec2<V2> const & v2, 
		tvec2<V3> const & v3,
		tvec2<V4> const & v4
	)		
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
		this->value[3] = col_type(v4);
	}

	
	template <typename T> 
	template <typename U> 
	 inline tmat4x2<T>::tmat4x2
	(
		tmat4x2<U> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T> 
	 inline tmat4x2<T>::tmat4x2
	(
		tmat2x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(value_type(0));
		this->value[3] = col_type(value_type(0));
	}

	template <typename T> 
	 inline tmat4x2<T>::tmat4x2
	(
		tmat3x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(value_type(0));
	}

	template <typename T> 
	 inline tmat4x2<T>::tmat4x2
	(
		tmat4x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T> 
	 inline tmat4x2<T>::tmat4x2
	(
		tmat2x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(value_type(0));
		this->value[3] = col_type(value_type(0));
	}

	template <typename T> 
	 inline tmat4x2<T>::tmat4x2
	(
		tmat3x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(value_type(0));
	}

	template <typename T> 
	 inline tmat4x2<T>::tmat4x2
	(
		tmat2x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(value_type(0));
		this->value[3] = col_type(value_type(0));
	}

	template <typename T> 
	 inline tmat4x2<T>::tmat4x2
	(
		tmat4x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T> 
	 inline tmat4x2<T>::tmat4x2
	(
		tmat3x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(value_type(0));
	}

	
	

	template <typename T> 
	 inline tmat4x2<T>& tmat4x2<T>::operator= 
	(
		tmat4x2<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x2<T>& tmat4x2<T>::operator= 
	(
		tmat4x2<U> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x2<T> & tmat4x2<T>::operator+= 
	(
		U const & s
	)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x2<T> & tmat4x2<T>::operator+= 
	(
		tmat4x2<U> const & m
	)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x2<T> & tmat4x2<T>::operator-= 
	(
		U const & s
	)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x2<T> & tmat4x2<T>::operator-= 
	(
		tmat4x2<U> const & m
	)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x2<T> & tmat4x2<T>::operator*= 
	(
		U const & s
	)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x2<T> & tmat4x2<T>::operator*= 
	(
		tmat4x2<U> const & m
	)
	{
		return (*this = tmat4x2<T>(*this * m));
	}

	template <typename T>
	template <typename U> 
	 inline tmat4x2<T> & tmat4x2<T>::operator/= 
	(
		U const & s
	)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	template <typename T> 
	 inline tmat4x2<T> & tmat4x2<T>::operator++ ()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template <typename T> 
	 inline tmat4x2<T> & tmat4x2<T>::operator-- ()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	
	

	template <typename T> 
	 inline tmat4x2<T> operator+ 
	(
		tmat4x2<T> const & m, 
		typename tmat4x2<T>::value_type const & s
	)
	{
		return tmat4x2<T>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template <typename T> 
	 inline tmat4x2<T> operator+ 
	(	
		tmat4x2<T> const & m1, 
		tmat4x2<T> const & m2
	)
	{
		return tmat4x2<T>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template <typename T> 
	 inline tmat4x2<T> operator- 
	(
		tmat4x2<T> const & m, 
		typename tmat4x2<T>::value_type const & s
	)
	{
		return tmat4x2<T>(
			m[0] - s,
			m[1] - s,
			m[2] - s,
			m[3] - s);
	}

	template <typename T> 
	 inline tmat4x2<T> operator- 
	(	
		tmat4x2<T> const & m1, 
		tmat4x2<T> const & m2
	)
	{
		return tmat4x2<T>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template <typename T> 
	 inline tmat4x2<T> operator* 
	(
		tmat4x2<T> const & m, 
		typename tmat4x2<T>::value_type const & s
	)
	{
		return tmat4x2<T>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T> 
	 inline tmat4x2<T> operator* 
	(
		typename tmat4x2<T>::value_type const & s, 
		tmat4x2<T> const & m
	)
	{
		return tmat4x2<T>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T>
	 inline typename tmat4x2<T>::col_type operator* 
	(
		tmat4x2<T> const & m, 
		typename tmat4x2<T>::row_type const & v)
	{
		return typename tmat4x2<T>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
	}

	template <typename T> 
	 inline typename tmat4x2<T>::row_type operator* 
	(
		typename tmat4x2<T>::col_type const & v, 
		tmat4x2<T> const & m) 
	{
		return typename tmat4x2<T>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1],
			v.x * m[3][0] + v.y * m[3][1]);
	}

	template <typename T> 
	 inline tmat2x2<T> operator* 
	(
		tmat4x2<T> const & m1, 
		tmat2x4<T> const & m2
	)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA30 = m1[3][0];
		T const SrcA31 = m1[3][1];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB03 = m2[0][3];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB13 = m2[1][3];

		tmat2x2<T> Result(tmat2x2<T>::null);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		return Result;
	}

	template <typename T>
	 inline tmat3x2<T> operator* 
	(
		tmat4x2<T> const & m1, 
		tmat3x4<T> const & m2
	)
	{
		return tmat3x2<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
	}

	template <typename T>
	 inline tmat4x2<T> operator* 
	(
		tmat4x2<T> const & m1, 
		tmat4x4<T> const & m2
	)
	{
		return tmat4x2<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
	}

	template <typename T> 
	 inline tmat4x2<T> operator/ 
	(
		tmat4x2<T> const & m, 
		typename tmat4x2<T>::value_type const & s
	)
	{
		return tmat4x2<T>(
			m[0] / s,
			m[1] / s,
			m[2] / s,
			m[3] / s);        
	}

	template <typename T> 
	 inline tmat4x2<T> operator/ 
	(
		typename tmat4x2<T>::value_type const & s, 
		tmat4x2<T> const & m
	)
	{
		return tmat4x2<T>(
			s / m[0],
			s / m[1],
			s / m[2],
			s / m[3]);        
	}

	
	template <typename T> 
	 inline tmat4x2<T> const operator- 
	(
		tmat4x2<T> const & m
	)
	{
		return tmat4x2<T>(
			-m[0], 
			-m[1], 
			-m[2], 
			-m[3]);
	}

	template <typename T> 
	 inline tmat4x2<T> const operator++ 
	(
		tmat4x2<T> const & m, 
		int
	) 
	{
		return tmat4x2<T>(
			m[0] + typename tmat4x2<T>::value_type(1),
			m[1] + typename tmat4x2<T>::value_type(1),
			m[2] + typename tmat4x2<T>::value_type(1),
			m[3] + typename tmat4x2<T>::value_type(1));
	}

	template <typename T> 
	 inline tmat4x2<T> const operator-- 
	(
		tmat4x2<T> const & m, 
		int
	) 
	{
		return tmat4x2<T>(
			m[0] - typename tmat4x2<T>::value_type(1),
			m[1] - typename tmat4x2<T>::value_type(1),
			m[2] - typename tmat4x2<T>::value_type(1),
			m[3] - typename tmat4x2<T>::value_type(1));
	}

	
	

	template <typename T> 
	 inline bool operator==
	(
		tmat4x2<T> const & m1, 
		tmat4x2<T> const & m2
	)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template <typename T> 
	 inline bool operator!=
	(
		tmat4x2<T> const & m1, 
		tmat4x2<T> const & m2
	)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} 
} 
#line 268 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x2.hpp"
#line 269 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x2.hpp"

#line 271 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x2.hpp"
#line 50 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x3.hpp"

































namespace glm{
namespace detail
{
	template <typename T> struct tvec1;
	template <typename T> struct tvec2;
	template <typename T> struct tvec3;
	template <typename T> struct tvec4;
	template <typename T> struct tmat2x2;
	template <typename T> struct tmat2x3;
	template <typename T> struct tmat2x4;
	template <typename T> struct tmat3x2;
	template <typename T> struct tmat3x3;
	template <typename T> struct tmat3x4;
	template <typename T> struct tmat4x2;
	template <typename T> struct tmat4x3;
	template <typename T> struct tmat4x4;

	template <typename T> 
	struct tmat4x3
	{
		enum ctor{null};
		typedef T value_type;
		typedef std::size_t size_type;
		typedef tvec3<T> col_type;
		typedef tvec4<T> row_type;
		typedef tmat4x3<T> type;
		typedef tmat3x4<T> transpose_type;

		static  size_type col_size();
		static  size_type row_size();

		  size_type length() const;

	private:
		
		col_type value[4];

	public:
		
		 tmat4x3();
		 tmat4x3(tmat4x3 const & m);

		 explicit tmat4x3(
			ctor Null);
		 explicit tmat4x3(
			value_type const & x);
		 explicit tmat4x3(
			value_type const & x0, value_type const & y0, value_type const & z0,
			value_type const & x1, value_type const & y1, value_type const & z1,
			value_type const & x2, value_type const & y2, value_type const & z2,
			value_type const & x3, value_type const & y3, value_type const & z3);
		 explicit tmat4x3(
			col_type const & v0, 
			col_type const & v1,
			col_type const & v2,
			col_type const & v3);

		
		
		template <typename U> 
		 explicit tmat4x3(
			U const & x);

		template <
			typename X1, typename Y1, typename Z1, 
			typename X2, typename Y2, typename Z2, 
			typename X3, typename Y3, typename Z3, 
			typename X4, typename Y4, typename Z4> 
		 explicit tmat4x3(
			X1 const & x1, Y1 const & y1, Z1 const & z1, 
			X2 const & x2, Y2 const & y2, Z2 const & z2, 
			X3 const & x3, Y3 const & y3, Z3 const & z3, 
			X4 const & x4, Y4 const & y4, Z4 const & z4);
			
		template <typename V1, typename V2, typename V3, typename V4> 
		 explicit tmat4x3(
			tvec3<V1> const & v1, 
			tvec3<V2> const & v2,
			tvec3<V3> const & v3,
			tvec3<V4> const & v4);

		
		template <typename U> 
		 explicit tmat4x3(tmat4x3<U> const & m);
			
		 explicit tmat4x3(tmat2x2<T> const & x);
		 explicit tmat4x3(tmat3x3<T> const & x);
		 explicit tmat4x3(tmat4x4<T> const & x);
		 explicit tmat4x3(tmat2x3<T> const & x);
		 explicit tmat4x3(tmat3x2<T> const & x);
		 explicit tmat4x3(tmat2x4<T> const & x);
		 explicit tmat4x3(tmat4x2<T> const & x);
		 explicit tmat4x3(tmat3x4<T> const & x);

		
		 col_type & operator[](size_type i);
		 col_type const & operator[](size_type i) const;

		
		 tmat4x3<T> & operator=  (tmat4x3<T> const & m);
		template <typename U> 
		 tmat4x3<T> & operator=  (tmat4x3<U> const & m);
		template <typename U> 
		 tmat4x3<T> & operator+= (U const & s);
		template <typename U> 
		 tmat4x3<T> & operator+= (tmat4x3<U> const & m);
		template <typename U> 
		 tmat4x3<T> & operator-= (U const & s);
		template <typename U> 
		 tmat4x3<T> & operator-= (tmat4x3<U> const & m);
		template <typename U> 
		 tmat4x3<T> & operator*= (U const & s);
		template <typename U> 
		 tmat4x3<T> & operator*= (tmat4x3<U> const & m);
		template <typename U> 
		 tmat4x3<T> & operator/= (U const & s);

		 tmat4x3<T> & operator++ ();
		 tmat4x3<T> & operator-- ();
	};

	
	template <typename T> 
	 tmat4x3<T> operator+ (
		tmat4x3<T> const & m, 
		typename tmat4x3<T>::value_type const & s);

	template <typename T> 
	 tmat4x3<T> operator+ (
		tmat4x3<T> const & m1, 
		tmat4x3<T> const & m2);

	template <typename T> 
	 tmat4x3<T> operator- (
		tmat4x3<T> const & m, 
		typename tmat4x3<T>::value_type const & s);

	template <typename T> 
	 tmat4x3<T> operator- (
		tmat4x3<T> const & m1, 
		tmat4x3<T> const & m2);

	template <typename T> 
	 tmat4x3<T> operator* (
		tmat4x3<T> const & m, 
		typename tmat4x3<T>::value_type const & s);

	template <typename T> 
	 tmat4x3<T> operator* (
		typename tmat4x3<T>::value_type const & s, 
		tmat4x3<T> const & m);

	template <typename T>
	 typename tmat4x3<T>::col_type operator* (
		tmat4x3<T> const & m, 
		typename tmat4x3<T>::row_type const & v);

	template <typename T> 
	 typename tmat4x3<T>::row_type operator* (
		typename tmat4x3<T>::col_type const & v, 
		tmat4x3<T> const & m);

	template <typename T> 
	 tmat2x3<T> operator* (
		tmat4x3<T> const & m1, 
		tmat2x4<T> const & m2);

	template <typename T> 
	 tmat3x3<T> operator* (
		tmat4x3<T> const & m1, 
		tmat3x4<T> const & m2);
		
	template <typename T>
	 tmat4x3<T> operator* (
		tmat4x3<T> const & m1, 
		tmat4x4<T> const & m2);

	template <typename T> 
	 tmat4x3<T> operator/ (
		tmat4x3<T> const & m, 
		typename tmat4x3<T>::value_type const & s);

	template <typename T> 
	 tmat4x3<T> operator/ (
		typename tmat4x3<T>::value_type const & s, 
		tmat4x3<T> const & m);

	
	template <typename T> 
	 tmat4x3<T> const operator- (
		tmat4x3<T> const & m);

	template <typename T> 
	 tmat4x3<T> const operator-- (
		tmat4x3<T> const & m, 
		int);

	template <typename T> 
	 tmat4x3<T> const operator++ (
		tmat4x3<T> const & m, 
		int);
}

	
	

	
	
	
	
	
	typedef detail::tmat4x3<lowp_float>		lowp_mat4x3;

	
	
	
	
	
	typedef detail::tmat4x3<mediump_float>	mediump_mat4x3;

	
	
	
	
	
	typedef detail::tmat4x3<highp_float>	highp_mat4x3;

	
}


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x3.inl"




























namespace glm{
namespace detail
{
	template <typename T>
	 inline  typename tmat4x3<T>::size_type tmat4x3<T>::length() const
	{
		return 4;
	}

	template <typename T>
	 inline typename tmat4x3<T>::size_type tmat4x3<T>::col_size()
	{
		return 3;
	}

	template <typename T>
	 inline typename tmat4x3<T>::size_type tmat4x3<T>::row_size()
	{
		return 4;
	}

	
	

	template <typename T>
	 inline typename tmat4x3<T>::col_type & 
	tmat4x3<T>::operator[]
	(
		size_type i
	)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x3.inl", 60), 0) );
		return this->value[i];
	}

	template <typename T>
	 inline typename tmat4x3<T>::col_type const & 
	tmat4x3<T>::operator[]
	(
		size_type i
	) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x3.inl", 71), 0) );
		return this->value[i];
	}

	
	

	template <typename T> 
	 inline tmat4x3<T>::tmat4x3()
	{
		value_type const Zero(0);
		value_type const One(1);
		this->value[0] = col_type(One, Zero, Zero);
		this->value[1] = col_type(Zero, One, Zero);
		this->value[2] = col_type(Zero, Zero, One);
		this->value[3] = col_type(Zero, Zero, Zero);
	}

	template <typename T> 
	 inline tmat4x3<T>::tmat4x3
	(
		tmat4x3<T> const & m
	)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
		this->value[3] = m.value[3];
	}

	template <typename T> 
	 inline tmat4x3<T>::tmat4x3
	(
		ctor
	)
	{}

	template <typename T> 
	 inline tmat4x3<T>::tmat4x3
	(
		value_type const & s
	)
	{
		value_type const Zero(0);
		this->value[0] = col_type(s, Zero, Zero);
		this->value[1] = col_type(Zero, s, Zero);
		this->value[2] = col_type(Zero, Zero, s);
		this->value[3] = col_type(Zero, Zero, Zero);
	}

	template <typename T> 
	 inline tmat4x3<T>::tmat4x3
	(
		value_type const & x0, value_type const & y0, value_type const & z0,
		value_type const & x1, value_type const & y1, value_type const & z1,
		value_type const & x2, value_type const & y2, value_type const & z2,
		value_type const & x3, value_type const & y3, value_type const & z3
	)
	{
		this->value[0] = col_type(x0, y0, z0);
		this->value[1] = col_type(x1, y1, z1);
		this->value[2] = col_type(x2, y2, z2);
		this->value[3] = col_type(x3, y3, z3);
	}

	template <typename T> 
	 inline tmat4x3<T>::tmat4x3
	(
		col_type const & v0, 
		col_type const & v1, 
		col_type const & v2,
		col_type const & v3
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
		this->value[3] = v3;
	}

	
	
	template <typename T> 
	template <typename U> 
	 tmat4x3<T>::tmat4x3
	(
		U const & s
	)
	{
		value_type const Zero(0);
		this->value[0] = tvec3<T>(value_type(s), Zero, Zero);
		this->value[1] = tvec3<T>(Zero, value_type(s), Zero);
		this->value[2] = tvec3<T>(Zero, Zero, value_type(s));
		this->value[3] = tvec3<T>(Zero, Zero, Zero);
	}
	
	template <typename T> 
	template <
		typename X1, typename Y1, typename Z1, 
		typename X2, typename Y2, typename Z2, 
		typename X3, typename Y3, typename Z3, 
		typename X4, typename Y4, typename Z4>  
	 tmat4x3<T>::tmat4x3
	(
		X1 const & x1, Y1 const & y1, Z1 const & z1, 
		X2 const & x2, Y2 const & y2, Z2 const & z2, 
		X3 const & x3, Y3 const & y3, Z3 const & z3, 
		X4 const & x4, Y4 const & y4, Z4 const & z4
	)		
	{
		this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1));
		this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2));
		this->value[2] = col_type(value_type(x3), value_type(y3), value_type(z3));
		this->value[3] = col_type(value_type(x4), value_type(y4), value_type(z4));
	}
	
	template <typename T> 
	template <typename V1, typename V2, typename V3, typename V4> 
	 tmat4x3<T>::tmat4x3
	(
		tvec3<V1> const & v1, 
		tvec3<V2> const & v2, 
		tvec3<V3> const & v3,
		tvec3<V4> const & v4
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
		this->value[3] = col_type(v4);
	}

	
	

	template <typename T> 
	template <typename U> 
	 inline tmat4x3<T>::tmat4x3
	(
		tmat4x3<U> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T> 
	 inline tmat4x3<T>::tmat4x3
	(
		tmat2x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], value_type(0));
		this->value[1] = col_type(m[1], value_type(0));
		this->value[2] = col_type(m[2], value_type(1));
		this->value[3] = col_type(value_type(0));
	}

	template <typename T> 
	 inline tmat4x3<T>::tmat4x3
	(
		tmat3x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(value_type(0));
	}

	template <typename T> 
	 inline tmat4x3<T>::tmat4x3
	(
		tmat4x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T> 
	 inline tmat4x3<T>::tmat4x3
	(
		tmat2x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(value_type(0), value_type(0), value_type(1));
		this->value[3] = col_type(value_type(0));
	}

	template <typename T> 
	 inline tmat4x3<T>::tmat4x3
	(
		tmat3x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], value_type(0));
		this->value[1] = col_type(m[1], value_type(0));
		this->value[2] = col_type(m[2], value_type(1));
		this->value[3] = col_type(value_type(0));
	}

	template <typename T> 
	 inline tmat4x3<T>::tmat4x3
	(
		tmat2x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(value_type(0), value_type(0), value_type(1));
		this->value[3] = col_type(value_type(0));
	}

	template <typename T> 
	 inline tmat4x3<T>::tmat4x3
	(
		tmat4x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], value_type(0));
		this->value[1] = col_type(m[1], value_type(0));
		this->value[2] = col_type(m[2], value_type(1));
		this->value[3] = col_type(m[3], value_type(0));
	}

	template <typename T> 
	 inline tmat4x3<T>::tmat4x3
	(
		tmat3x4<T> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(value_type(0));
	}

	
	

	template <typename T> 
	 inline tmat4x3<T>& tmat4x3<T>::operator= 
	(
		tmat4x3<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x3<T>& tmat4x3<T>::operator= 
	(
		tmat4x3<U> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x3<T> & tmat4x3<T>::operator+= 
	(
		U const & s
	)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x3<T> & tmat4x3<T>::operator+= 
	(
		tmat4x3<U> const & m
	)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x3<T> & tmat4x3<T>::operator-= 
	(
		U const & s
	)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x3<T> & tmat4x3<T>::operator-= 
	(
		tmat4x3<U> const & m
	)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x3<T> & tmat4x3<T>::operator*= 
	(
		U const & s
	)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x3<T> & tmat4x3<T>::operator*= 
	(
		tmat4x3<U> const & m
	)
	{
		return (*this = tmat4x3<T>(*this * m));
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x3<T> & tmat4x3<T>::operator/= 
	(
		U const & s
	)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	template <typename T> 
	 inline tmat4x3<T> & tmat4x3<T>::operator++ ()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template <typename T> 
	 inline tmat4x3<T> & tmat4x3<T>::operator-- ()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	
	

	template <typename T> 
	 inline tmat4x3<T> operator+ (
		tmat4x3<T> const & m, 
		typename tmat4x3<T>::value_type const & s)
	{
		return tmat4x3<T>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template <typename T> 
	 inline tmat4x3<T> operator+ (
		tmat4x3<T> const & m1, 
		tmat4x3<T> const & m2)
	{
		return tmat4x3<T>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template <typename T> 
	 inline tmat4x3<T> operator- (
		tmat4x3<T> const & m, 
		typename tmat4x3<T>::value_type const & s)
	{
		return tmat4x3<T>(
			m[0] - s,
			m[1] - s,
			m[2] - s,
			m[3] - s);
	}

	template <typename T> 
	 inline tmat4x3<T> operator- (
		tmat4x3<T> const & m1, 
		tmat4x3<T> const & m2)
	{
		return tmat4x3<T>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template <typename T> 
	 inline tmat4x3<T> operator* (
		tmat4x3<T> const & m, 
		typename tmat4x3<T>::value_type const & s)
	{
		return tmat4x3<T>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T> 
	 inline tmat4x3<T> operator* (
		typename tmat4x3<T>::value_type const & s, 
		tmat4x3<T> const & m)
	{
		return tmat4x3<T>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T>
	 inline typename tmat4x3<T>::col_type operator* 
	(
		tmat4x3<T> const & m, 
		typename tmat4x3<T>::row_type const & v)
	{
		return typename tmat4x3<T>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
	}

	template <typename T> 
	 inline typename tmat4x3<T>::row_type operator* 
	(
		typename tmat4x3<T>::col_type const & v, 
		tmat4x3<T> const & m) 
	{
		return typename tmat4x3<T>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
			v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
	}

	template <typename T>
	 inline tmat2x3<T> operator* 
	(
		tmat4x3<T> const & m1, 
		tmat2x4<T> const & m2
	)
	{
		return tmat2x3<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
	}

	template <typename T> 
	 inline tmat3x3<T> operator* 
	(
		tmat4x3<T> const & m1, 
		tmat3x4<T> const & m2
	)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA02 = m1[0][2];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA12 = m1[1][2];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA22 = m1[2][2];
		T const SrcA30 = m1[3][0];
		T const SrcA31 = m1[3][1];
		T const SrcA32 = m1[3][2];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB03 = m2[0][3];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB13 = m2[1][3];
		T const SrcB20 = m2[2][0];
		T const SrcB21 = m2[2][1];
		T const SrcB22 = m2[2][2];
		T const SrcB23 = m2[2][3];

		tmat3x3<T> Result(tmat3x3<T>::null);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
		return Result;
	}

	template <typename T>
	 inline tmat4x3<T> operator* 
	(
		tmat4x3<T> const & m1, 
		tmat4x4<T> const & m2
	)
	{
		return tmat4x3<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
	}

	template <typename T> 
	 inline tmat4x3<T> operator/ 
	(
		tmat4x3<T> const & m, 
		typename tmat4x3<T>::value_type const & s
	)
	{
		return tmat4x3<T>(
			m[0] / s,
			m[1] / s,
			m[2] / s,
			m[3] / s);        
	}

	template <typename T> 
	 inline tmat4x3<T> operator/ 
	(
		typename tmat4x3<T>::value_type const & s, 
		tmat4x3<T> const & m
	)
	{
		return tmat4x3<T>(
			s / m[0],
			s / m[1],
			s / m[2],
			s / m[3]);        
	}

	
	template <typename T> 
	 inline tmat4x3<T> const operator- 
	(
		tmat4x3<T> const & m
	)
	{
		return tmat4x3<T>(
			-m[0], 
			-m[1],
			-m[2],
			-m[3]);
	}

	template <typename T> 
	 inline tmat4x3<T> const operator++ 
	(
		tmat4x3<T> const & m, 
		int
	) 
	{
		return tmat4x3<T>(
			m[0] + T(1),
			m[1] + T(1),
			m[2] + T(1),
			m[3] + T(1));
	}

	template <typename T> 
	 inline tmat4x3<T> const operator-- 
	(
		tmat4x3<T> const & m, 
		int
	) 
	{
		return tmat4x3<T>(
			m[0] - T(1),
			m[1] - T(1),
			m[2] - T(1),
			m[3] - T(1));
	}

	
	

	template <typename T> 
	 inline bool operator==
	(
		tmat4x3<T> const & m1, 
		tmat4x3<T> const & m2
	)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template <typename T> 
	 inline bool operator!=
	(
		tmat4x3<T> const & m1, 
		tmat4x3<T> const & m2
	)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} 
} 

#line 266 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x3.hpp"
#line 267 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x3.hpp"

#line 269 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x3.hpp"
#line 51 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x4.hpp"

































namespace glm{
namespace detail
{
	template <typename T> struct tvec1;
	template <typename T> struct tvec2;
	template <typename T> struct tvec3;
	template <typename T> struct tvec4;
	template <typename T> struct tmat2x2;
	template <typename T> struct tmat2x3;
	template <typename T> struct tmat2x4;
	template <typename T> struct tmat3x2;
	template <typename T> struct tmat3x3;
	template <typename T> struct tmat3x4;
	template <typename T> struct tmat4x2;
	template <typename T> struct tmat4x3;
	template <typename T> struct tmat4x4;

	template <typename T> 
	struct tmat4x4
	{
		enum ctor{null};
		typedef T value_type;
		typedef std::size_t size_type;
		typedef tvec4<T> col_type;
		typedef tvec4<T> row_type;
		typedef tmat4x4<T> type;
		typedef tmat4x4<T> transpose_type;

		static  size_type col_size();
		static  size_type row_size();

		  size_type length() const;

	public:
		
		
		 tmat4x4<T> _inverse() const;
		

	private:
		
		col_type value[4];

	public:
		
		 tmat4x4();
		 tmat4x4(tmat4x4 const & m);

		 explicit tmat4x4(
			ctor Null);
		 explicit tmat4x4(
			value_type const & x);
		 explicit tmat4x4(
			value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
			value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1,
			value_type const & x2, value_type const & y2, value_type const & z2, value_type const & w2,
			value_type const & x3, value_type const & y3, value_type const & z3, value_type const & w3);
		 explicit tmat4x4(
			col_type const & v0, 
			col_type const & v1,
			col_type const & v2,
			col_type const & v3);

		
		
		template <typename U> 
		 explicit tmat4x4(
			U const & x);
			
		template <
			typename X1, typename Y1, typename Z1, typename W1, 
			typename X2, typename Y2, typename Z2, typename W2, 
			typename X3, typename Y3, typename Z3, typename W3, 
			typename X4, typename Y4, typename Z4, typename W4> 
		 explicit tmat4x4(
			X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1, 
			X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2, 
			X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3, 
			X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4);
			
		template <typename V1, typename V2, typename V3, typename V4> 
		 explicit tmat4x4(
			tvec4<V1> const & v1, 
			tvec4<V2> const & v2,
			tvec4<V3> const & v3,
			tvec4<V4> const & v4);
            
		
		template <typename U> 
		 explicit tmat4x4(tmat4x4<U> const & m);

		 explicit tmat4x4(tmat2x2<T> const & x);
		 explicit tmat4x4(tmat3x3<T> const & x);
		 explicit tmat4x4(tmat2x3<T> const & x);
		 explicit tmat4x4(tmat3x2<T> const & x);
		 explicit tmat4x4(tmat2x4<T> const & x);
		 explicit tmat4x4(tmat4x2<T> const & x);
		 explicit tmat4x4(tmat3x4<T> const & x);
		 explicit tmat4x4(tmat4x3<T> const & x);

		
		 col_type & operator[](size_type i);
		 col_type const & operator[](size_type i) const;

		
		 tmat4x4<T> & operator=  (tmat4x4<T> const & m);
		template <typename U>
		 tmat4x4<T> & operator=  (tmat4x4<U> const & m);
		template <typename U>
		 tmat4x4<T> & operator+= (U const & s);
		template <typename U>
		 tmat4x4<T> & operator+= (tmat4x4<U> const & m);
		template <typename U>
		 tmat4x4<T> & operator-= (U const & s);
		template <typename U>
		 tmat4x4<T> & operator-= (tmat4x4<U> const & m);
		template <typename U>
		 tmat4x4<T> & operator*= (U const & s);
		template <typename U>
		 tmat4x4<T> & operator*= (tmat4x4<U> const & m);
		template <typename U>
		 tmat4x4<T> & operator/= (U const & s);
		template <typename U>
		 tmat4x4<T> & operator/= (tmat4x4<U> const & m);
		 tmat4x4<T> & operator++ ();
		 tmat4x4<T> & operator-- ();
	};

	
	template <typename T> 
	 tmat4x4<T> operator+ (
		tmat4x4<T> const & m, 
		typename tmat4x4<T>::value_type const & s);

	template <typename T> 
	 tmat4x4<T> operator+ (
		typename tmat4x4<T>::value_type const & s, 
		tmat4x4<T> const & m);

	template <typename T> 
	 tmat4x4<T> operator+ (
		tmat4x4<T> const & m1, 
		tmat4x4<T> const & m2);
	    
	template <typename T> 
	 tmat4x4<T> operator- (
		tmat4x4<T> const & m, 
		typename tmat4x4<T>::value_type const & s);

	template <typename T> 
	 tmat4x4<T> operator- (
		typename tmat4x4<T>::value_type const & s, 
		tmat4x4<T> const & m);

	template <typename T> 
	 tmat4x4<T> operator- (
		tmat4x4<T> const & m1, 
		tmat4x4<T> const & m2);

	template <typename T> 
	 tmat4x4<T> operator* (
		tmat4x4<T> const & m, 
		typename tmat4x4<T>::value_type const & s);

	template <typename T> 
	 tmat4x4<T> operator* (
		typename tmat4x4<T>::value_type const & s, 
		tmat4x4<T> const & m);

	template <typename T> 
	 typename tmat4x4<T>::col_type operator* (
		tmat4x4<T> const & m, 
		typename tmat4x4<T>::row_type const & v);

	template <typename T> 
	 typename tmat4x4<T>::row_type operator* (
		typename tmat4x4<T>::col_type const & v, 
		tmat4x4<T> const & m);
		
	template <typename T>
	 tmat2x4<T> operator* (
		tmat4x4<T> const & m1, 
		tmat2x4<T> const & m2);

	template <typename T>
	 tmat3x4<T> operator* (
		tmat4x4<T> const & m1, 
		tmat3x4<T> const & m2);

	template <typename T> 
	 tmat4x4<T> operator* (
		tmat4x4<T> const & m1, 
		tmat4x4<T> const & m2);

	template <typename T> 
	 tmat4x4<T> operator/ (
		tmat4x4<T> const & m, 
		typename tmat4x4<T>::value_type const & s);

	template <typename T> 
	 tmat4x4<T> operator/ (
		typename tmat4x4<T>::value_type const & s, 
		tmat4x4<T> const & m);

	template <typename T> 
	 typename tmat4x4<T>::col_type operator/ (
		tmat4x4<T> const & m, 
		typename tmat4x4<T>::row_type const & v);

	template <typename T> 
	 typename tmat4x4<T>::row_type operator/ (
		typename tmat4x4<T>::col_type & v, 
		tmat4x4<T> const & m);

	template <typename T> 
	 tmat4x4<T> operator/ (
		tmat4x4<T> const & m1, 
		tmat4x4<T> const & m2);

	
	template <typename T> 
	 tmat4x4<T> const operator-  (
		tmat4x4<T> const & m);

	template <typename T> 
	 tmat4x4<T> const operator-- (
		tmat4x4<T> const & m, int);

	template <typename T> 
	 tmat4x4<T> const operator++ (
		tmat4x4<T> const & m, int);

} 

	
	

	
	
	
	
	
	typedef detail::tmat4x4<lowp_float>		lowp_mat4;

	
	
	
	
	
	typedef detail::tmat4x4<mediump_float>	mediump_mat4;

	
	
	
	
	
	typedef detail::tmat4x4<highp_float>	highp_mat4;

	
	
	
	
	
	typedef detail::tmat4x4<lowp_float>		lowp_mat4x4;

	
	
	
	
	
	typedef detail::tmat4x4<mediump_float>	mediump_mat4x4;

	
	
	
	
	
	typedef detail::tmat4x4<highp_float>	highp_mat4x4;

	
}


#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x4.inl"




























namespace glm{
namespace detail
{
	template <typename T>
	 inline  typename tmat4x4<T>::size_type tmat4x4<T>::length() const
	{
		return 4;
	}

	template <typename T>
	 inline typename tmat4x4<T>::size_type tmat4x4<T>::col_size()
	{
		return 4;
	}

	template <typename T>
	 inline typename tmat4x4<T>::size_type tmat4x4<T>::row_size()
	{
		return 4;
	}

	
	

	template <typename T>
	 inline typename tmat4x4<T>::col_type & 
	tmat4x4<T>::operator[]
	(
		size_type i
	)
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x4.inl", 60), 0) );
		return this->value[i];
	}

	template <typename T>
	 inline typename tmat4x4<T>::col_type const & 
	tmat4x4<T>::operator[]
	(
		size_type i
	) const
	{
		(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x4.inl", 71), 0) );
		return this->value[i];
	}

	
	

	template <typename T> 
	 inline tmat4x4<T>::tmat4x4()
	{
		value_type Zero(0);
		value_type One(1);
		this->value[0] = col_type(One, Zero, Zero, Zero);
		this->value[1] = col_type(Zero, One, Zero, Zero);
		this->value[2] = col_type(Zero, Zero, One, Zero);
		this->value[3] = col_type(Zero, Zero, Zero, One);
	}

	template <typename T> 
	 inline tmat4x4<T>::tmat4x4
	(
		tmat4x4<T> const & m
	)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
		this->value[3] = m.value[3];
	}

	template <typename T> 
	 inline tmat4x4<T>::tmat4x4
	(
		ctor
	)
	{}

	template <typename T> 
	 inline tmat4x4<T>::tmat4x4
	(
		value_type const & s
	)
	{
		value_type const Zero(0);
		this->value[0] = col_type(s, Zero, Zero, Zero);
		this->value[1] = col_type(Zero, s, Zero, Zero);
		this->value[2] = col_type(Zero, Zero, s, Zero);
		this->value[3] = col_type(Zero, Zero, Zero, s);
	}

	template <typename T> 
	 inline tmat4x4<T>::tmat4x4
	(
		value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
		value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1,
		value_type const & x2, value_type const & y2, value_type const & z2, value_type const & w2,
		value_type const & x3, value_type const & y3, value_type const & z3, value_type const & w3
	)
	{
		this->value[0] = col_type(x0, y0, z0, w0);
		this->value[1] = col_type(x1, y1, z1, w1);
		this->value[2] = col_type(x2, y2, z2, w2);
		this->value[3] = col_type(x3, y3, z3, w3);
	}

	template <typename T> 
	 inline tmat4x4<T>::tmat4x4
	(
		col_type const & v0, 
		col_type const & v1, 
		col_type const & v2,
		col_type const & v3
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
		this->value[3] = v3;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x4<T>::tmat4x4
	(
		tmat4x4<U> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	
	
	template <typename T> 
	template <typename U> 
	 tmat4x4<T>::tmat4x4
	(
		U const & s
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<U>::is_float || std::numeric_limits<U>::is_integer) ? 1 : -1];

		value_type const Zero(0);
		this->value[0] = tvec4<T>(value_type(s), Zero, Zero, Zero);
		this->value[1] = tvec4<T>(Zero, value_type(s), Zero, Zero);
		this->value[2] = tvec4<T>(Zero, Zero, value_type(s), Zero);
		this->value[3] = tvec4<T>(Zero, Zero, Zero, value_type(s));
	}
	
	template <typename T> 
	template <
		typename X1, typename Y1, typename Z1, typename W1, 
		typename X2, typename Y2, typename Z2, typename W2, 
		typename X3, typename Y3, typename Z3, typename W3, 
		typename X4, typename Y4, typename Z4, typename W4>  
	 tmat4x4<T>::tmat4x4
	(
		X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1, 
		X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2, 
		X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3, 
		X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<X1>::is_float || std::numeric_limits<X1>::is_integer) ? 1 : -1];
		typedef char __CASSERT____LINE__[(detail::type<Y1>::is_float || std::numeric_limits<Y1>::is_integer) ? 1 : -1];
		typedef char __CASSERT____LINE__[(detail::type<Z1>::is_float || std::numeric_limits<Z1>::is_integer) ? 1 : -1];
		typedef char __CASSERT____LINE__[(detail::type<W1>::is_float || std::numeric_limits<W1>::is_integer) ? 1 : -1];

		typedef char __CASSERT____LINE__[(detail::type<X2>::is_float || std::numeric_limits<X2>::is_integer) ? 1 : -1];
		typedef char __CASSERT____LINE__[(detail::type<Y2>::is_float || std::numeric_limits<Y2>::is_integer) ? 1 : -1];
		typedef char __CASSERT____LINE__[(detail::type<Z2>::is_float || std::numeric_limits<Z2>::is_integer) ? 1 : -1];
		typedef char __CASSERT____LINE__[(detail::type<W2>::is_float || std::numeric_limits<W2>::is_integer) ? 1 : -1];

		typedef char __CASSERT____LINE__[(detail::type<X3>::is_float || std::numeric_limits<X3>::is_integer) ? 1 : -1];
		typedef char __CASSERT____LINE__[(detail::type<Y3>::is_float || std::numeric_limits<Y3>::is_integer) ? 1 : -1];
		typedef char __CASSERT____LINE__[(detail::type<Z3>::is_float || std::numeric_limits<Z3>::is_integer) ? 1 : -1];
		typedef char __CASSERT____LINE__[(detail::type<W3>::is_float || std::numeric_limits<W3>::is_integer) ? 1 : -1];

		typedef char __CASSERT____LINE__[(detail::type<X4>::is_float || std::numeric_limits<X4>::is_integer) ? 1 : -1];
		typedef char __CASSERT____LINE__[(detail::type<Y4>::is_float || std::numeric_limits<Y4>::is_integer) ? 1 : -1];
		typedef char __CASSERT____LINE__[(detail::type<Z4>::is_float || std::numeric_limits<Z4>::is_integer) ? 1 : -1];
		typedef char __CASSERT____LINE__[(detail::type<W4>::is_float || std::numeric_limits<W4>::is_integer) ? 1 : -1];

		this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1), value_type(w1));
		this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2), value_type(w2));
		this->value[2] = col_type(value_type(x3), value_type(y3), value_type(z3), value_type(w3));
		this->value[3] = col_type(value_type(x4), value_type(y4), value_type(z4), value_type(w4));
	}
	
	template <typename T> 
	template <typename V1, typename V2, typename V3, typename V4> 
	 tmat4x4<T>::tmat4x4
	(
		tvec4<V1> const & v1, 
		tvec4<V2> const & v2, 
		tvec4<V3> const & v3,
		tvec4<V4> const & v4
	)		
	{
		typedef char __CASSERT____LINE__[(detail::type<V1>::is_float || std::numeric_limits<V1>::is_integer) ? 1 : -1];
		typedef char __CASSERT____LINE__[(detail::type<V2>::is_float || std::numeric_limits<V2>::is_integer) ? 1 : -1];
		typedef char __CASSERT____LINE__[(detail::type<V3>::is_float || std::numeric_limits<V3>::is_integer) ? 1 : -1];
		typedef char __CASSERT____LINE__[(detail::type<V4>::is_float || std::numeric_limits<V4>::is_integer) ? 1 : -1];

		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
		this->value[3] = col_type(v4);
	}

	
	
	template <typename T> 
	 inline tmat4x4<T>::tmat4x4
	(
		tmat2x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], detail::tvec2<T>(0));
		this->value[1] = col_type(m[1], detail::tvec2<T>(0));
		this->value[2] = col_type(value_type(0));
		this->value[3] = col_type(value_type(0), value_type(0), value_type(0), value_type(1));
	}

	template <typename T> 
	 inline tmat4x4<T>::tmat4x4
	(
		tmat3x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0], value_type(0));
		this->value[1] = col_type(m[1], value_type(0));
		this->value[2] = col_type(m[2], value_type(0));
		this->value[3] = col_type(value_type(0), value_type(0), value_type(0), value_type(1));
	}

	template <typename T> 
	 inline tmat4x4<T>::tmat4x4
	(
		tmat2x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0], value_type(0));
		this->value[1] = col_type(m[1], value_type(0));
		this->value[2] = col_type(value_type(0));
		this->value[3] = col_type(value_type(0), value_type(0), value_type(0), value_type(1));
	}

	template <typename T> 
	 inline tmat4x4<T>::tmat4x4
	(
		tmat3x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], detail::tvec2<T>(0));
		this->value[1] = col_type(m[1], detail::tvec2<T>(0));
		this->value[2] = col_type(m[2], detail::tvec2<T>(0));
		this->value[3] = col_type(value_type(0), value_type(0), value_type(0), value_type(1));
	}

	template <typename T> 
	 inline tmat4x4<T>::tmat4x4
	(
		tmat2x4<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = col_type(T(0));
		this->value[3] = col_type(T(0), T(0), T(0), T(1));
	}

	template <typename T> 
	 inline tmat4x4<T>::tmat4x4
	(
		tmat4x2<T> const & m
	)
	{
		this->value[0] = col_type(m[0], detail::tvec2<T>(0));
		this->value[1] = col_type(m[1], detail::tvec2<T>(0));
		this->value[2] = col_type(T(0));
		this->value[3] = col_type(T(0), T(0), T(0), T(1));
	}

	template <typename T> 
	 inline tmat4x4<T>::tmat4x4
	(
		tmat3x4<T> const & m
	)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = col_type(T(0), T(0), T(0), T(1));
	}

	template <typename T> 
	 inline tmat4x4<T>::tmat4x4
	(
		tmat4x3<T> const & m
	)
	{
		this->value[0] = col_type(m[0], T(0));
		this->value[1] = col_type(m[1], T(0));
		this->value[2] = col_type(m[2], T(0));
		this->value[3] = col_type(m[3], T(1));
	}

	
	

	template <typename T> 
	 inline tmat4x4<T>& tmat4x4<T>::operator= 
	(
		tmat4x4<T> const & m
	)
	{
		
		
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x4<T>& tmat4x4<T>::operator= 
	(
		tmat4x4<U> const & m
	)
	{
		
		
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x4<T>& tmat4x4<T>::operator+= 
	(
		U const & s
	)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x4<T>& tmat4x4<T>::operator+= 
	(
		tmat4x4<U> const & m
	)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template <typename T> 
	template <typename U> 
	 inline tmat4x4<T> & tmat4x4<T>::operator-= 
	(
		U const & s
	)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template <typename T> 
	template <typename U>
	 inline tmat4x4<T> & tmat4x4<T>::operator-= 
	(
		tmat4x4<U> const & m
	)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template <typename T> 
	template <typename U>
	 inline tmat4x4<T> & tmat4x4<T>::operator*= 
	(
		U const & s
	)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template <typename T> 
	template <typename U>
	 inline tmat4x4<T> & tmat4x4<T>::operator*= 
	(
		tmat4x4<U> const & m
	)
	{
		return (*this = *this * m);
	}

	template <typename T> 
	template <typename U>
	 inline tmat4x4<T> & tmat4x4<T>::operator/= 
	(
		U const & s
	)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	template <typename T> 
	template <typename U>
	 inline tmat4x4<T> & tmat4x4<T>::operator/= 
	(
		tmat4x4<U> const & m
	)
	{
		return (*this = *this / m);
	}

	template <typename T> 
	 inline tmat4x4<T> & tmat4x4<T>::operator++ ()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template <typename T> 
	 inline tmat4x4<T> & tmat4x4<T>::operator-- ()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	template <typename T> 
	 inline tmat4x4<T> tmat4x4<T>::_inverse() const
	{
		
		value_type SubFactor00 = this->value[2][2] * this->value[3][3] - this->value[3][2] * this->value[2][3];
		value_type SubFactor01 = this->value[2][1] * this->value[3][3] - this->value[3][1] * this->value[2][3];
		value_type SubFactor02 = this->value[2][1] * this->value[3][2] - this->value[3][1] * this->value[2][2];
		value_type SubFactor03 = this->value[2][0] * this->value[3][3] - this->value[3][0] * this->value[2][3];
		value_type SubFactor04 = this->value[2][0] * this->value[3][2] - this->value[3][0] * this->value[2][2];
		value_type SubFactor05 = this->value[2][0] * this->value[3][1] - this->value[3][0] * this->value[2][1];
		value_type SubFactor06 = this->value[1][2] * this->value[3][3] - this->value[3][2] * this->value[1][3];
		value_type SubFactor07 = this->value[1][1] * this->value[3][3] - this->value[3][1] * this->value[1][3];
		value_type SubFactor08 = this->value[1][1] * this->value[3][2] - this->value[3][1] * this->value[1][2];
		value_type SubFactor09 = this->value[1][0] * this->value[3][3] - this->value[3][0] * this->value[1][3];
		value_type SubFactor10 = this->value[1][0] * this->value[3][2] - this->value[3][0] * this->value[1][2];
		value_type SubFactor11 = this->value[1][1] * this->value[3][3] - this->value[3][1] * this->value[1][3];
		value_type SubFactor12 = this->value[1][0] * this->value[3][1] - this->value[3][0] * this->value[1][1];
		value_type SubFactor13 = this->value[1][2] * this->value[2][3] - this->value[2][2] * this->value[1][3];
		value_type SubFactor14 = this->value[1][1] * this->value[2][3] - this->value[2][1] * this->value[1][3];
		value_type SubFactor15 = this->value[1][1] * this->value[2][2] - this->value[2][1] * this->value[1][2];
		value_type SubFactor16 = this->value[1][0] * this->value[2][3] - this->value[2][0] * this->value[1][3];
		value_type SubFactor17 = this->value[1][0] * this->value[2][2] - this->value[2][0] * this->value[1][2];
		value_type SubFactor18 = this->value[1][0] * this->value[2][1] - this->value[2][0] * this->value[1][1];






















		tmat4x4<T> Inverse(
			+ this->value[1][1] * SubFactor00 - this->value[1][2] * SubFactor01 + this->value[1][3] * SubFactor02,
			- this->value[1][0] * SubFactor00 + this->value[1][2] * SubFactor03 - this->value[1][3] * SubFactor04,
			+ this->value[1][0] * SubFactor01 - this->value[1][1] * SubFactor03 + this->value[1][3] * SubFactor05,
			- this->value[1][0] * SubFactor02 + this->value[1][1] * SubFactor04 - this->value[1][2] * SubFactor05,

			- this->value[0][1] * SubFactor00 + this->value[0][2] * SubFactor01 - this->value[0][3] * SubFactor02,
			+ this->value[0][0] * SubFactor00 - this->value[0][2] * SubFactor03 + this->value[0][3] * SubFactor04,
			- this->value[0][0] * SubFactor01 + this->value[0][1] * SubFactor03 - this->value[0][3] * SubFactor05,
			+ this->value[0][0] * SubFactor02 - this->value[0][1] * SubFactor04 + this->value[0][2] * SubFactor05,

			+ this->value[0][1] * SubFactor06 - this->value[0][2] * SubFactor07 + this->value[0][3] * SubFactor08,
			- this->value[0][0] * SubFactor06 + this->value[0][2] * SubFactor09 - this->value[0][3] * SubFactor10,
			+ this->value[0][0] * SubFactor11 - this->value[0][1] * SubFactor09 + this->value[0][3] * SubFactor12,
			- this->value[0][0] * SubFactor08 + this->value[0][1] * SubFactor10 - this->value[0][2] * SubFactor12,

			- this->value[0][1] * SubFactor13 + this->value[0][2] * SubFactor14 - this->value[0][3] * SubFactor15,
			+ this->value[0][0] * SubFactor13 - this->value[0][2] * SubFactor16 + this->value[0][3] * SubFactor17,
			- this->value[0][0] * SubFactor14 + this->value[0][1] * SubFactor16 - this->value[0][3] * SubFactor18,
			+ this->value[0][0] * SubFactor15 - this->value[0][1] * SubFactor17 + this->value[0][2] * SubFactor18);

		value_type Determinant = 
			+ this->value[0][0] * Inverse[0][0] 
			+ this->value[0][1] * Inverse[1][0] 
			+ this->value[0][2] * Inverse[2][0] 
			+ this->value[0][3] * Inverse[3][0];

		Inverse /= Determinant;
		return Inverse;
	}

	
	template <typename T> 
	 inline tmat4x4<T> operator+ 
	(
		tmat4x4<T> const & m, 
		typename tmat4x4<T>::value_type const & s
	)
	{
		return tmat4x4<T>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template <typename T> 
	 inline tmat4x4<T> operator+ 
	(
		typename tmat4x4<T>::value_type const & s, 
		tmat4x4<T> const & m
	)
	{
		return tmat4x4<T>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template <typename T> 
	 inline tmat4x4<T> operator+ 
	(
		tmat4x4<T> const & m1, 
		tmat4x4<T> const & m2
	)
	{
		return tmat4x4<T>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}
    
	template <typename T> 
	 inline tmat4x4<T> operator- 
	(
		tmat4x4<T> const & m, 
		typename tmat4x4<T>::value_type const & s
	)
	{
		return tmat4x4<T>(
			m[0] - s,
			m[1] - s,
			m[2] - s,
			m[3] - s);
	}

	template <typename T> 
	 inline tmat4x4<T> operator- 
	(
		typename tmat4x4<T>::value_type const & s, 
		tmat4x4<T> const & m
	)
	{
		return tmat4x4<T>(
			s - m[0],
			s - m[1],
			s - m[2],
			s - m[3]);
	}

	template <typename T> 
	 inline tmat4x4<T> operator- 
	(
		tmat4x4<T> const & m1, 
		tmat4x4<T> const & m2
	)
	{
		return tmat4x4<T>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template <typename T> 
	 inline tmat4x4<T> operator* 
	(
		tmat4x4<T> const & m, 
		typename tmat4x4<T>::value_type const  & s
	)
	{
		return tmat4x4<T>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T> 
	 inline tmat4x4<T> operator* 
	(
		typename tmat4x4<T>::value_type const & s, 
		tmat4x4<T> const & m
	)
	{
		return tmat4x4<T>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T> 
	 inline typename tmat4x4<T>::col_type operator* 
	(
		tmat4x4<T> const & m, 
		typename tmat4x4<T>::row_type const & v
	)
	{
		return typename tmat4x4<T>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w,
			m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z + m[3][3] * v.w);
	}

	template <typename T> 
	 inline typename tmat4x4<T>::row_type operator* 
	(
		typename tmat4x4<T>::col_type const & v, 
		tmat4x4<T> const & m
	)
	{
		return typename tmat4x4<T>::row_type(
			m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z + m[0][3] * v.w,
			m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z + m[1][3] * v.w,
			m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z + m[2][3] * v.w,
			m[3][0] * v.x + m[3][1] * v.y + m[3][2] * v.z + m[3][3] * v.w);
	}

	template <typename T>
	 inline tmat2x4<T> operator* 
	(
		tmat4x4<T> const & m1, 
		tmat2x4<T> const & m2
	)
	{
		return tmat2x4<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
	}

	template <typename T>
	 inline tmat3x4<T> operator* 
	(
		tmat4x4<T> const & m1, 
		tmat3x4<T> const & m2
	)
	{
		return tmat3x4<T>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
	}

	template <typename T> 
	 inline tmat4x4<T> operator* 
	(
		tmat4x4<T> const & m1, 
		tmat4x4<T> const & m2
	)
	{
		typename tmat4x4<T>::col_type const SrcA0 = m1[0];
		typename tmat4x4<T>::col_type const SrcA1 = m1[1];
		typename tmat4x4<T>::col_type const SrcA2 = m1[2];
		typename tmat4x4<T>::col_type const SrcA3 = m1[3];

		typename tmat4x4<T>::col_type const SrcB0 = m2[0];
		typename tmat4x4<T>::col_type const SrcB1 = m2[1];
		typename tmat4x4<T>::col_type const SrcB2 = m2[2];
		typename tmat4x4<T>::col_type const SrcB3 = m2[3];

		tmat4x4<T> Result(tmat4x4<T>::null);
		Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
		Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
		Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
		Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
		return Result;
	}

	template <typename T> 
	 inline tmat4x4<T> operator/ 
	(
		tmat4x4<T> const & m, 
		typename tmat4x4<T>::value_type const & s
	)
	{
		return tmat4x4<T>(
			m[0] / s,
			m[1] / s,
			m[2] / s,
			m[3] / s);
	}

	template <typename T> 
	 inline tmat4x4<T> operator/ 
	(
		typename tmat4x4<T>::value_type const & s, 
		tmat4x4<T> const & m
	)
	{
		return tmat4x4<T>(
			s / m[0],
			s / m[1],
			s / m[2],
			s / m[3]);
	}

	template <typename T> 
	 inline typename tmat4x4<T>::col_type operator/ 
	(
		tmat4x4<T> const & m, 
		typename tmat4x4<T>::row_type const & v
	)
	{
		return m._inverse() * v;
	}

	template <typename T> 
	 inline typename tmat4x4<T>::row_type operator/ 
	(
		typename tmat4x4<T>::col_type const & v, 
		tmat4x4<T> const & m
	)
	{
		return v * m._inverse();
	}
 
	template <typename T> 
	 inline tmat4x4<T> operator/ 
	(
		tmat4x4<T> const & m1, 
		tmat4x4<T> const & m2
	)
	{
		return m1 * m2._inverse();
	}

	
	template <typename T> 
	 inline tmat4x4<T> const operator- 
	(
		tmat4x4<T> const & m
	)
	{
		return tmat4x4<T>(
			-m[0], 
			-m[1],
			-m[2],
			-m[3]);
	}

	template <typename T> 
	 inline tmat4x4<T> const operator++ 
	(
		tmat4x4<T> const & m, 
		int
	) 
	{
		return tmat4x4<T>(
			m[0] + typename tmat4x4<T>::value_type(1),
			m[1] + typename tmat4x4<T>::value_type(1),
			m[2] + typename tmat4x4<T>::value_type(1),
			m[3] + typename tmat4x4<T>::value_type(1));
	}

	template <typename T> 
	 inline tmat4x4<T> const operator-- 
	(
		tmat4x4<T> const & m, 
		int
	) 
	{
		return tmat4x4<T>(
			m[0] - typename tmat4x4<T>::value_type(1),
			m[1] - typename tmat4x4<T>::value_type(1),
			m[2] - typename tmat4x4<T>::value_type(1),
			m[3] - typename tmat4x4<T>::value_type(1));
	}

	
	

	template <typename T> 
	 inline bool operator==
	(
		tmat4x4<T> const & m1, 
		tmat4x4<T> const & m2
	)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template <typename T> 
	 inline bool operator!=
	(
		tmat4x4<T> const & m1, 
		tmat4x4<T> const & m2
	)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}

} 
} 

#line 318 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x4.hpp"
#line 319 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x4.hpp"

#line 321 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type_mat4x4.hpp"
#line 52 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"

namespace glm
{
	
	

	
	














#line 75 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"












#line 88 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"












#line 101 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
	
	
	
	typedef mediump_vec2		vec2;

	
	
	
	typedef mediump_vec3		vec3;

	
	
	
	typedef mediump_vec4		vec4;

	
	
	
	typedef mediump_mat2x2		mat2x2;

	
	
	
	typedef mediump_mat2x3		mat2x3;

	
	
	
	typedef mediump_mat2x4		mat2x4;

	
	
	
	typedef mediump_mat3x2		mat3x2;

	
	
	
	typedef mediump_mat3x3		mat3x3;

	
	
	
	typedef mediump_mat3x4		mat3x4;

	
	
	
	typedef mediump_mat4x2		mat4x2;

	
	
	
	typedef mediump_mat4x3		mat4x3;

	
	
	
	typedef mediump_mat4x4		mat4x4;

#line 162 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"

	
	
	
	typedef mat2x2							mat2;

	
	
	
	typedef mat3x3							mat3;

	
	
	
	typedef mat4x4							mat4;

	
	





#line 186 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"



#line 190 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"



#line 194 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
	
	
	
	typedef mediump_ivec2		ivec2;

	
	
	
	typedef mediump_ivec3		ivec3;

	
	
	
	typedef mediump_ivec4		ivec4;
#line 209 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"

	
	





#line 218 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"



#line 222 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"



#line 226 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
	
	
	
	typedef mediump_uvec2		uvec2;

	
	
	
	typedef mediump_uvec3		uvec3;

	
	
	
	typedef mediump_uvec4		uvec4;
#line 241 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"

	
	

	
	
	
	typedef detail::tvec2<bool>		bvec2;

	
	
	
	typedef detail::tvec3<bool>		bvec3;

	
	
	
	typedef detail::tvec4<bool>		bvec4;

	
	

	
	
	
	typedef detail::tvec2<double>	dvec2;

	
	
	
	typedef detail::tvec3<double>	dvec3;

	
	
	
	typedef detail::tvec4<double>	dvec4;

	
	
	
	typedef detail::tmat2x2<double>	dmat2;

	
	
	
	typedef detail::tmat3x3<double>	dmat3;

	
	
	
	typedef detail::tmat4x4<double>	dmat4;

	
	
	
	typedef detail::tmat2x2<double>	dmat2x2;

	
	
	
	typedef detail::tmat2x3<double>	dmat2x3;

	
	
	
	typedef detail::tmat2x4<double>	dmat2x4;

	
	
	
	typedef detail::tmat3x2<double>	dmat3x2;

	
	
	
	typedef detail::tmat3x3<double>	dmat3x3;

	
	
	
	typedef detail::tmat3x4<double>	dmat3x4;

	
	
	
	typedef detail::tmat4x2<double>	dmat4x2;

	
	
	
	typedef detail::tmat4x3<double>	dmat4x3;

	
	
	
	typedef detail::tmat4x4<double>	dmat4x4;

	
}

#line 342 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\type.hpp"
#line 99 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_trigonometric.hpp"










































namespace glm
{
	
	

	
	
	
	
	
	
	template <typename genType> 
	 genType radians(genType const & degrees);

	
	
	
	
	
	
	template <typename genType> 
	 genType degrees(genType const & radians);

	
	
	
	
	
	
	
	template <typename genType> 
	 genType sin(genType const & angle);

	
	
	
	
	
	
	
	template <typename genType> 
	 genType cos(genType const & angle);

	
	
	
	
	
	
	template <typename genType> 
	 genType tan(genType const & angle); 

	
	
	
	
	
	
	
	
	template <typename genType> 
	 genType asin(genType const & x);

	
	
	
	
	
	
	
	
	template <typename genType> 
	 genType acos(genType const & x);

	
	
	
	
	
	
	
	
	
	
	template <typename genType> 
	 genType atan(genType const & y, genType const & x);

	
	
	
	
	
	
	
	template <typename genType> 
	 genType atan(genType const & y_over_x);

	
	
	
	
	
	
	template <typename genType> 
	 genType sinh(genType const & angle);

	
	
	
	
	
	
	template <typename genType> 
	 genType cosh(genType const & angle);

	
	
	
	
	
	
	template <typename genType> 
	 genType tanh(genType const & angle);

	
	
	
	
	
	
	template <typename genType> 
	 genType asinh(genType const & x);
	
	
	
	
	
	
	
	
	template <typename genType> 
	 genType acosh(genType const & x);

	
	
	
	
	
	
	
	template <typename genType> 
	 genType atanh(genType const & x);

	
}

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_trigonometric.inl"




























namespace glm
{
	
	template <typename genType>
	 inline genType radians
	(
		genType const & degrees
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		genType const pi = genType(3.1415926535897932384626433832795);
		return degrees * (pi / genType(180));
	}

	template <typename T>  inline detail::tvec2<T> radians( detail::tvec2<T> const & v) { return detail::tvec2<T>( radians(v.x), radians(v.y)); } template <typename T>  inline detail::tvec3<T> radians( detail::tvec3<T> const & v) { return detail::tvec3<T>( radians(v.x), radians(v.y), radians(v.z)); } template <typename T>  inline detail::tvec4<T> radians( detail::tvec4<T> const & v) { return detail::tvec4<T>( radians(v.x), radians(v.y), radians(v.z), radians(v.w)); }
	
	
	template <typename genType>
	 inline genType degrees
	(
		genType const & radians
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		const genType pi = genType(3.1415926535897932384626433832795);
		return radians * (genType(180) / pi);
	}

	template <typename T>  inline detail::tvec2<T> degrees( detail::tvec2<T> const & v) { return detail::tvec2<T>( degrees(v.x), degrees(v.y)); } template <typename T>  inline detail::tvec3<T> degrees( detail::tvec3<T> const & v) { return detail::tvec3<T>( degrees(v.x), degrees(v.y), degrees(v.z)); } template <typename T>  inline detail::tvec4<T> degrees( detail::tvec4<T> const & v) { return detail::tvec4<T>( degrees(v.x), degrees(v.y), degrees(v.z), degrees(v.w)); }

	
	template <typename genType>
	 inline genType sin
	(
		genType const & angle
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return genType(::std::sin(angle));
	}

	template <typename T>  inline detail::tvec2<T> sin( detail::tvec2<T> const & v) { return detail::tvec2<T>( sin(v.x), sin(v.y)); } template <typename T>  inline detail::tvec3<T> sin( detail::tvec3<T> const & v) { return detail::tvec3<T>( sin(v.x), sin(v.y), sin(v.z)); } template <typename T>  inline detail::tvec4<T> sin( detail::tvec4<T> const & v) { return detail::tvec4<T>( sin(v.x), sin(v.y), sin(v.z), sin(v.w)); }

	
	template <typename genType>
	 inline genType cos(genType const & angle)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return genType(::std::cos(angle));
	}

	template <typename T>  inline detail::tvec2<T> cos( detail::tvec2<T> const & v) { return detail::tvec2<T>( cos(v.x), cos(v.y)); } template <typename T>  inline detail::tvec3<T> cos( detail::tvec3<T> const & v) { return detail::tvec3<T>( cos(v.x), cos(v.y), cos(v.z)); } template <typename T>  inline detail::tvec4<T> cos( detail::tvec4<T> const & v) { return detail::tvec4<T>( cos(v.x), cos(v.y), cos(v.z), cos(v.w)); }

	
	template <typename genType>
	 inline genType tan
	(
		genType const & angle
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return genType(::std::tan(angle));
	}

	template <typename T>  inline detail::tvec2<T> tan( detail::tvec2<T> const & v) { return detail::tvec2<T>( tan(v.x), tan(v.y)); } template <typename T>  inline detail::tvec3<T> tan( detail::tvec3<T> const & v) { return detail::tvec3<T>( tan(v.x), tan(v.y), tan(v.z)); } template <typename T>  inline detail::tvec4<T> tan( detail::tvec4<T> const & v) { return detail::tvec4<T>( tan(v.x), tan(v.y), tan(v.z), tan(v.w)); }

	
	template <typename genType>
	 inline genType asin
	(
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return genType(::std::asin(x));
	}

	template <typename T>  inline detail::tvec2<T> asin( detail::tvec2<T> const & v) { return detail::tvec2<T>( asin(v.x), asin(v.y)); } template <typename T>  inline detail::tvec3<T> asin( detail::tvec3<T> const & v) { return detail::tvec3<T>( asin(v.x), asin(v.y), asin(v.z)); } template <typename T>  inline detail::tvec4<T> asin( detail::tvec4<T> const & v) { return detail::tvec4<T>( asin(v.x), asin(v.y), asin(v.z), asin(v.w)); }

	
	template <typename genType>
	 inline genType acos
	(
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return genType(::std::acos(x));
	}

	template <typename T>  inline detail::tvec2<T> acos( detail::tvec2<T> const & v) { return detail::tvec2<T>( acos(v.x), acos(v.y)); } template <typename T>  inline detail::tvec3<T> acos( detail::tvec3<T> const & v) { return detail::tvec3<T>( acos(v.x), acos(v.y), acos(v.z)); } template <typename T>  inline detail::tvec4<T> acos( detail::tvec4<T> const & v) { return detail::tvec4<T>( acos(v.x), acos(v.y), acos(v.z), acos(v.w)); }

	
	template <typename genType>
	 inline genType atan
	(
		genType const & y, 
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return genType(::std::atan2(y, x));
	}

	template <typename T>  inline detail::tvec2<T> atan ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( atan(x.x, y.x), atan(x.y, y.y)); } template <typename T>  inline detail::tvec3<T> atan ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( atan(x.x, y.x), atan(x.y, y.y), atan(x.z, y.z)); } template <typename T>  inline detail::tvec4<T> atan ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( atan(x.x, y.x), atan(x.y, y.y), atan(x.z, y.z), atan(x.w, y.w)); }

	template <typename genType>
	 inline genType atan
	(
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return genType(::std::atan(x));
	}

	template <typename T>  inline detail::tvec2<T> atan( detail::tvec2<T> const & v) { return detail::tvec2<T>( atan(v.x), atan(v.y)); } template <typename T>  inline detail::tvec3<T> atan( detail::tvec3<T> const & v) { return detail::tvec3<T>( atan(v.x), atan(v.y), atan(v.z)); } template <typename T>  inline detail::tvec4<T> atan( detail::tvec4<T> const & v) { return detail::tvec4<T>( atan(v.x), atan(v.y), atan(v.z), atan(v.w)); }

	
	template <typename genType> 
	 inline genType sinh
	(
		genType const & angle
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return genType(std::sinh(angle));
	}

	template <typename T>  inline detail::tvec2<T> sinh( detail::tvec2<T> const & v) { return detail::tvec2<T>( sinh(v.x), sinh(v.y)); } template <typename T>  inline detail::tvec3<T> sinh( detail::tvec3<T> const & v) { return detail::tvec3<T>( sinh(v.x), sinh(v.y), sinh(v.z)); } template <typename T>  inline detail::tvec4<T> sinh( detail::tvec4<T> const & v) { return detail::tvec4<T>( sinh(v.x), sinh(v.y), sinh(v.z), sinh(v.w)); }

	
	template <typename genType> 
	 inline genType cosh
	(
		genType const & angle
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return genType(std::cosh(angle));
	}

	template <typename T>  inline detail::tvec2<T> cosh( detail::tvec2<T> const & v) { return detail::tvec2<T>( cosh(v.x), cosh(v.y)); } template <typename T>  inline detail::tvec3<T> cosh( detail::tvec3<T> const & v) { return detail::tvec3<T>( cosh(v.x), cosh(v.y), cosh(v.z)); } template <typename T>  inline detail::tvec4<T> cosh( detail::tvec4<T> const & v) { return detail::tvec4<T>( cosh(v.x), cosh(v.y), cosh(v.z), cosh(v.w)); }

	
	template <typename genType>
	 inline genType tanh
	(
		genType const & angle
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return genType(std::tanh(angle));
	}

	template <typename T>  inline detail::tvec2<T> tanh( detail::tvec2<T> const & v) { return detail::tvec2<T>( tanh(v.x), tanh(v.y)); } template <typename T>  inline detail::tvec3<T> tanh( detail::tvec3<T> const & v) { return detail::tvec3<T>( tanh(v.x), tanh(v.y), tanh(v.z)); } template <typename T>  inline detail::tvec4<T> tanh( detail::tvec4<T> const & v) { return detail::tvec4<T>( tanh(v.x), tanh(v.y), tanh(v.z), tanh(v.w)); }

	
	template <typename genType> 
	 inline genType asinh
	(
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];
		
		return (x < genType(0) ? genType(-1) : (x > genType(0) ? genType(1) : genType(0))) * log(abs(x) + sqrt(genType(1) + x * x));
	}

	template <typename T>  inline detail::tvec2<T> asinh( detail::tvec2<T> const & v) { return detail::tvec2<T>( asinh(v.x), asinh(v.y)); } template <typename T>  inline detail::tvec3<T> asinh( detail::tvec3<T> const & v) { return detail::tvec3<T>( asinh(v.x), asinh(v.y), asinh(v.z)); } template <typename T>  inline detail::tvec4<T> asinh( detail::tvec4<T> const & v) { return detail::tvec4<T>( asinh(v.x), asinh(v.y), asinh(v.z), asinh(v.w)); }

	
	template <typename genType> 
	 inline genType acosh
	(
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		if(x < genType(1))
			return genType(0);
		return log(x + sqrt(x * x - genType(1)));
	}

	template <typename T>  inline detail::tvec2<T> acosh( detail::tvec2<T> const & v) { return detail::tvec2<T>( acosh(v.x), acosh(v.y)); } template <typename T>  inline detail::tvec3<T> acosh( detail::tvec3<T> const & v) { return detail::tvec3<T>( acosh(v.x), acosh(v.y), acosh(v.z)); } template <typename T>  inline detail::tvec4<T> acosh( detail::tvec4<T> const & v) { return detail::tvec4<T>( acosh(v.x), acosh(v.y), acosh(v.z), acosh(v.w)); }

	
	template <typename genType>
	 inline genType atanh
	(
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];
		
		if(abs(x) >= genType(1))
			return 0;
		return genType(0.5) * log((genType(1) + x) / (genType(1) - x));
	}

	template <typename T>  inline detail::tvec2<T> atanh( detail::tvec2<T> const & v) { return detail::tvec2<T>( atanh(v.x), atanh(v.y)); } template <typename T>  inline detail::tvec3<T> atanh( detail::tvec3<T> const & v) { return detail::tvec3<T>( atanh(v.x), atanh(v.y), atanh(v.z)); } template <typename T>  inline detail::tvec4<T> atanh( detail::tvec4<T> const & v) { return detail::tvec4<T>( atanh(v.x), atanh(v.y), atanh(v.z), atanh(v.w)); }

}
#line 200 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_trigonometric.hpp"

#line 202 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_trigonometric.hpp"


#line 101 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_exponential.hpp"






































namespace glm
{
	
	

	
	
	
	
	
	
	
	
	template <typename genType> 
	 genType pow(genType const & base, genType const & exponent);

	
	
	
	
	
	
	
	template <typename genType> 
	 genType exp(genType const & x);

	
	
	
	
	
	
	
	
	
	template <typename genType> 
	 genType log(genType const & x);

	
	
	
	
	
	
	
	template <typename genType> 
	 genType exp2(genType const & x);

	
	
	
	
	
	
	
	
	template <typename genType> 
	 genType log2(genType const & x);

	
	
	
	
	
	
	
	template <typename genType> 
	 genType sqrt(genType const & x);
    
	
	
	
	
	
	
	
	template <typename genType> 
	 genType inversesqrt(genType const & x);

	
}

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_exponential.inl"




























namespace glm
{
	
	template <typename genType>
	 inline genType pow
	(
		genType const & x, 
		genType const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return genType(::std::pow(x, y));
	}

	template <typename T>  inline detail::tvec2<T> pow ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( pow(x.x, y.x), pow(x.y, y.y)); } template <typename T>  inline detail::tvec3<T> pow ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( pow(x.x, y.x), pow(x.y, y.y), pow(x.z, y.z)); } template <typename T>  inline detail::tvec4<T> pow ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( pow(x.x, y.x), pow(x.y, y.y), pow(x.z, y.z), pow(x.w, y.w)); }

	
	template <typename genType>
	 inline genType exp
	(
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return genType(::std::exp(x));
	}

	template <typename T>  inline detail::tvec2<T> exp( detail::tvec2<T> const & v) { return detail::tvec2<T>( exp(v.x), exp(v.y)); } template <typename T>  inline detail::tvec3<T> exp( detail::tvec3<T> const & v) { return detail::tvec3<T>( exp(v.x), exp(v.y), exp(v.z)); } template <typename T>  inline detail::tvec4<T> exp( detail::tvec4<T> const & v) { return detail::tvec4<T>( exp(v.x), exp(v.y), exp(v.z), exp(v.w)); }

	
	template <typename genType>
	 inline genType log
	(
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return genType(::std::log(x));
	}

	template <typename T>  inline detail::tvec2<T> log( detail::tvec2<T> const & v) { return detail::tvec2<T>( log(v.x), log(v.y)); } template <typename T>  inline detail::tvec3<T> log( detail::tvec3<T> const & v) { return detail::tvec3<T>( log(v.x), log(v.y), log(v.z)); } template <typename T>  inline detail::tvec4<T> log( detail::tvec4<T> const & v) { return detail::tvec4<T>( log(v.x), log(v.y), log(v.z), log(v.w)); }

	
	template <typename genType>
	 inline genType exp2
	(
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return genType(::std::exp(genType(0.69314718055994530941723212145818) * x));
	}

	template <typename T>  inline detail::tvec2<T> exp2( detail::tvec2<T> const & v) { return detail::tvec2<T>( exp2(v.x), exp2(v.y)); } template <typename T>  inline detail::tvec3<T> exp2( detail::tvec3<T> const & v) { return detail::tvec3<T>( exp2(v.x), exp2(v.y), exp2(v.z)); } template <typename T>  inline detail::tvec4<T> exp2( detail::tvec4<T> const & v) { return detail::tvec4<T>( exp2(v.x), exp2(v.y), exp2(v.z), exp2(v.w)); }

namespace _detail
{
	template <int _PATH = detail::float_or_int_value::GLM_ERROR>
	struct _compute_log2
	{
		template <typename T>
		T operator() (T const & Value) const;






	};

	template <>
	struct _compute_log2<detail::float_or_int_value::GLM_FLOAT>
	{
		template <typename T>
		T operator() (T const & Value) const
		{
			return T(::std::log(Value)) / T(0.69314718055994530941723212145818);
		}
	};

}

	
	template <typename genType>
	 inline genType log2
	(
		genType const & x
	)
	{
		(void)( (!!(x > genType(0))) || (_wassert(L"x > genType(0)", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_exponential.inl", 122), 0) ); 
		return _detail::_compute_log2<detail::float_or_int_trait<genType>::ID>()(x);
	}

	template <typename T>  inline detail::tvec2<T> log2( detail::tvec2<T> const & v) { return detail::tvec2<T>( log2(v.x), log2(v.y)); } template <typename T>  inline detail::tvec3<T> log2( detail::tvec3<T> const & v) { return detail::tvec3<T>( log2(v.x), log2(v.y), log2(v.z)); } template <typename T>  inline detail::tvec4<T> log2( detail::tvec4<T> const & v) { return detail::tvec4<T>( log2(v.x), log2(v.y), log2(v.z), log2(v.w)); }

	
	template <typename genType>
	 inline genType sqrt
	(
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return genType(::std::sqrt(x));
	}

	template <typename T>  inline detail::tvec2<T> sqrt( detail::tvec2<T> const & v) { return detail::tvec2<T>( sqrt(v.x), sqrt(v.y)); } template <typename T>  inline detail::tvec3<T> sqrt( detail::tvec3<T> const & v) { return detail::tvec3<T>( sqrt(v.x), sqrt(v.y), sqrt(v.z)); } template <typename T>  inline detail::tvec4<T> sqrt( detail::tvec4<T> const & v) { return detail::tvec4<T>( sqrt(v.x), sqrt(v.y), sqrt(v.z), sqrt(v.w)); }

	template <typename genType>
	 inline genType inversesqrt
	(
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];
		(void)( (!!(x > genType(0))) || (_wassert(L"x > genType(0)", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_exponential.inl", 149), 0) );

		return genType(1) / ::std::sqrt(x);
	}

	template <typename T>  inline detail::tvec2<T> inversesqrt( detail::tvec2<T> const & v) { return detail::tvec2<T>( inversesqrt(v.x), inversesqrt(v.y)); } template <typename T>  inline detail::tvec3<T> inversesqrt( detail::tvec3<T> const & v) { return detail::tvec3<T>( inversesqrt(v.x), inversesqrt(v.y), inversesqrt(v.z)); } template <typename T>  inline detail::tvec4<T> inversesqrt( detail::tvec4<T> const & v) { return detail::tvec4<T>( inversesqrt(v.x), inversesqrt(v.y), inversesqrt(v.z), inversesqrt(v.w)); }

}
#line 122 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_exponential.hpp"

#line 124 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_exponential.hpp"
#line 102 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_common.hpp"






































#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_fixes.hpp"























































#line 40 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_common.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	template <typename genType> 
	 genType abs(genType const & x);

	
	
	
	
	
	
	template <typename genType> 
	 genType sign(genType const & x);

	
	
	
	
	
	
	template <typename genType> 
	 genType floor(genType const & x);

	
	
	
	
	
	
	
	template <typename genType> 
	 genType trunc(genType const & x);

	
	
	
	
	
	
	
	
	
	
	template <typename genType> 
	 genType round(genType const & x);

	
	
	
	
	
	
	
	
	
	template <typename genType> 
	 genType roundEven(genType const & x);

	
	
	
	
	
	
	
	template <typename genType> 
	 genType ceil(genType const & x);

	
	
	
	
	
	
	template <typename genType> 
	 genType fract(genType const & x);

	
	
	
	
	
	
	
	template <typename genType> 
	 genType mod(
		genType const & x, 
		genType const & y);

	
	
	
	
	
	
	
	template <typename genType> 
	 genType mod(
		genType const & x, 
		typename genType::value_type const & y);

	
	
	
	
	
	
	
	
	
	template <typename genType> 
	 genType modf(
		genType const & x, 
		genType & i);

	
	
	
	
	
	
	template <typename genType> 
	 genType min(
		genType const & x, 
		genType const & y);

	template <typename genType> 
	 genType min(
		genType const & x, 
		typename genType::value_type const & y);

	
	
	
	
	
	
	template <typename genType> 
	 genType max(
		genType const & x, 
		genType const & y);

	template <typename genType> 
	 genType max(
		genType const & x, 
		typename genType::value_type const & y);

	
	
	
	
	
	
	
	template <typename genType> 
	 genType clamp(
		genType const & x, 
		genType const & minVal, 
		genType const & maxVal); 

	template <typename genType> 
	 genType clamp(
		genType const & x, 
		typename genType::value_type const & minVal, 
		typename genType::value_type const & maxVal); 

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename genTypeT, typename genTypeU> 
	 genTypeT mix(genTypeT const & x, genTypeT const & y, genTypeU const & a);

	
	
	
	
	template <typename genType> 
	 genType step(
		genType const & edge, 
		genType const & x);

	template <typename genType> 
	 genType step(
		typename genType::value_type const & edge, 
		genType const & x);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename genType> 
	 genType smoothstep(
		genType const & edge0, 
		genType const & edge1, 
		genType const & x);

	template <typename genType> 
	 genType smoothstep(
		typename genType::value_type const & edge0, 
		typename genType::value_type const & edge1, 
		genType const & x);

	
	
	
	
	
	
	
	
	
	
	
	
	template <typename genType> 
	 typename genType::bool_type isnan(genType const & x);

	
	
	
	
	
	
	
	
	
	
	template <typename genType> 
	 typename genType::bool_type isinf(genType const & x);

	
	
	
	
	
	
	
	
	
	template <typename genType, typename genIType>
	 genIType floatBitsToInt(genType const & value);

	
	
	
	
	
	
	
	
	
	template <typename genType, typename genUType>
	 genUType floatBitsToUint(genType const & value);

	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename genType, typename genIType>
	 genType intBitsToFloat(genIType const & value);

	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename genType, typename genUType>
	 genType uintBitsToFloat(genUType const & value);

	
	
	
	
	
	
	template <typename genType>
	 genType fma(genType const & a, genType const & b, genType const & c);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename genType, typename genIType>
	 genType frexp(genType const & x, genIType & exp);

	
	
	
	
	
	
	
	
	
	
	
	template <typename genType, typename genIType>
	 genType ldexp(genType const & x, genIType const & exp);

	
}

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_common.inl"




























namespace glm{
namespace detail
{
	template <typename genFIType, bool >
	struct Abs_
	{};

	template <typename genFIType>
	struct Abs_<genFIType, true>
	{
		 inline static genFIType get(genFIType const & x)
		{
			typedef char __CASSERT____LINE__[(detail::type<genFIType>::is_float || detail::type<genFIType>::is_int) ? 1 : -1];
#line 44 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_common.inl"
			return x >= genFIType(0) ? x : -x;
			
		}
	};

	template <typename genFIType>
	struct Abs_<genFIType, false>
	{
		 inline static genFIType get(genFIType const & x)
		{
			typedef char __CASSERT____LINE__[(detail::type<genFIType>::is_uint) ? 1 : -1];
#line 56 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_common.inl"
			return x;
		}
	};
}

	
	template <typename genFIType>
	 inline genFIType abs
	(
		genFIType const & x
	)
	{
		return detail::Abs_<genFIType, std::numeric_limits<genFIType>::is_signed>::get(x);
	}

	template <typename T>  inline detail::tvec2<T> abs( detail::tvec2<T> const & v) { return detail::tvec2<T>( abs(v.x), abs(v.y)); } template <typename T>  inline detail::tvec3<T> abs( detail::tvec3<T> const & v) { return detail::tvec3<T>( abs(v.x), abs(v.y), abs(v.z)); } template <typename T>  inline detail::tvec4<T> abs( detail::tvec4<T> const & v) { return detail::tvec4<T>( abs(v.x), abs(v.y), abs(v.z), abs(v.w)); }

	
	
	template <typename genFIType> 
	 inline genFIType sign
	(
		genFIType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genFIType>::is_float || detail::type<genFIType>::is_int) ? 1 : -1];
#line 84 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_common.inl"

		genFIType result;
		if(x > genFIType(0))
			result = genFIType(1);
		else if(x < genFIType(0))
			result = genFIType(-1);
		else
			result = genFIType(0);
		return result;
	}
	
	template <typename T>  inline detail::tvec2<T> sign( detail::tvec2<T> const & v) { return detail::tvec2<T>( sign(v.x), sign(v.y)); } template <typename T>  inline detail::tvec3<T> sign( detail::tvec3<T> const & v) { return detail::tvec3<T>( sign(v.x), sign(v.y), sign(v.z)); } template <typename T>  inline detail::tvec4<T> sign( detail::tvec4<T> const & v) { return detail::tvec4<T>( sign(v.x), sign(v.y), sign(v.z), sign(v.w)); }

	
	template <>
	 inline detail::half floor<detail::half>(detail::half const & x)
	{
		return detail::half(::std::floor(float(x)));
	}

	template <typename genType>
	 inline genType floor(genType const & x)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return ::std::floor(x);
	}

	template <typename T>  inline detail::tvec2<T> floor( detail::tvec2<T> const & v) { return detail::tvec2<T>( floor(v.x), floor(v.y)); } template <typename T>  inline detail::tvec3<T> floor( detail::tvec3<T> const & v) { return detail::tvec3<T>( floor(v.x), floor(v.y), floor(v.z)); } template <typename T>  inline detail::tvec4<T> floor( detail::tvec4<T> const & v) { return detail::tvec4<T>( floor(v.x), floor(v.y), floor(v.z), floor(v.w)); }

	
	template <typename genType>
	 inline genType trunc(genType const & x)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];
		return x < 0 ? -floor(-x) : floor(x);
	}

	template <typename T>  inline detail::tvec2<T> trunc( detail::tvec2<T> const & v) { return detail::tvec2<T>( trunc(v.x), trunc(v.y)); } template <typename T>  inline detail::tvec3<T> trunc( detail::tvec3<T> const & v) { return detail::tvec3<T>( trunc(v.x), trunc(v.y), trunc(v.z)); } template <typename T>  inline detail::tvec4<T> trunc( detail::tvec4<T> const & v) { return detail::tvec4<T>( trunc(v.x), trunc(v.y), trunc(v.z), trunc(v.w)); }

	
	template <typename genType>
	 inline genType round(genType const& x)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		if(x < 0)
			return genType(int(x - genType(0.5)));
		return genType(int(x + genType(0.5)));
	}

	template <typename T>  inline detail::tvec2<T> round( detail::tvec2<T> const & v) { return detail::tvec2<T>( round(v.x), round(v.y)); } template <typename T>  inline detail::tvec3<T> round( detail::tvec3<T> const & v) { return detail::tvec3<T>( round(v.x), round(v.y), round(v.z)); } template <typename T>  inline detail::tvec4<T> round( detail::tvec4<T> const & v) { return detail::tvec4<T>( round(v.x), round(v.y), round(v.z), round(v.w)); }











	
	
	template <typename genType>
	 inline genType roundEven(genType const & x)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];
		
		int Integer = int(x);
		genType IntegerPart = genType(Integer);
		genType FractionalPart = fract(x);

		if(FractionalPart > genType(0.5) || FractionalPart < genType(0.5))
		{
			return round(x);
		}
		else if((Integer % 2) == 0)
		{
			return IntegerPart;
		}
		else if(x <= genType(0)) 
		{
			return IntegerPart - 1;
		}
		else
		{
			return IntegerPart + 1;
		}
		
		
		
		
	}
	
	template <typename T>  inline detail::tvec2<T> roundEven( detail::tvec2<T> const & v) { return detail::tvec2<T>( roundEven(v.x), roundEven(v.y)); } template <typename T>  inline detail::tvec3<T> roundEven( detail::tvec3<T> const & v) { return detail::tvec3<T>( roundEven(v.x), roundEven(v.y), roundEven(v.z)); } template <typename T>  inline detail::tvec4<T> roundEven( detail::tvec4<T> const & v) { return detail::tvec4<T>( roundEven(v.x), roundEven(v.y), roundEven(v.z), roundEven(v.w)); }

	
	template <typename genType>
	 inline genType ceil(genType const & x)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return ::std::ceil(x);
	}

	template <typename T>  inline detail::tvec2<T> ceil( detail::tvec2<T> const & v) { return detail::tvec2<T>( ceil(v.x), ceil(v.y)); } template <typename T>  inline detail::tvec3<T> ceil( detail::tvec3<T> const & v) { return detail::tvec3<T>( ceil(v.x), ceil(v.y), ceil(v.z)); } template <typename T>  inline detail::tvec4<T> ceil( detail::tvec4<T> const & v) { return detail::tvec4<T>( ceil(v.x), ceil(v.y), ceil(v.z), ceil(v.w)); }

	
	template <typename genType>
	 inline genType fract
	(
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return x - ::std::floor(x);
	}

	template <typename T>  inline detail::tvec2<T> fract( detail::tvec2<T> const & v) { return detail::tvec2<T>( fract(v.x), fract(v.y)); } template <typename T>  inline detail::tvec3<T> fract( detail::tvec3<T> const & v) { return detail::tvec3<T>( fract(v.x), fract(v.y), fract(v.z)); } template <typename T>  inline detail::tvec4<T> fract( detail::tvec4<T> const & v) { return detail::tvec4<T>( fract(v.x), fract(v.y), fract(v.z), fract(v.w)); }

	
	template <typename genType>
	 inline genType mod
	(
		genType const & x, 
		genType const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return x - y * floor(x / y);
	}

	template <typename T>  inline detail::tvec2<T> mod ( detail::tvec2<T> const & x, typename detail::tvec2<T>::value_type const & y ) { return detail::tvec2<T>( mod(x.x, y), mod(x.y, y)); } template <typename T>  inline detail::tvec3<T> mod ( detail::tvec3<T> const & x, typename detail::tvec3<T>::value_type const & y ) { return detail::tvec3<T>( mod(x.x, y), mod(x.y, y), mod(x.z, y)); } template <typename T>  inline detail::tvec4<T> mod ( detail::tvec4<T> const & x, typename detail::tvec4<T>::value_type const & y ) { return detail::tvec4<T>( mod(x.x, y), mod(x.y, y), mod(x.z, y), mod(x.w, y)); }
	template <typename T>  inline detail::tvec2<T> mod ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( mod(x.x, y.x), mod(x.y, y.y)); } template <typename T>  inline detail::tvec3<T> mod ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( mod(x.x, y.x), mod(x.y, y.y), mod(x.z, y.z)); } template <typename T>  inline detail::tvec4<T> mod ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( mod(x.x, y.x), mod(x.y, y.y), mod(x.z, y.z), mod(x.w, y.w)); }

	
	template <typename genType>
	 inline genType modf
	(
		genType const & x, 
		genType & i
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return std::modf(x, &i);
	}

	template <typename valType>
	 inline detail::tvec2<valType> modf
	(
		detail::tvec2<valType> const & x, 
		detail::tvec2<valType> & i
	)
	{
		return detail::tvec2<valType>(
			modf(x.x, i.x),
			modf(x.y, i.y));
	}

	template <typename valType>
	 inline detail::tvec3<valType> modf
	(
		detail::tvec3<valType> const & x, 
		detail::tvec3<valType> & i
	)
	{
		return detail::tvec3<valType>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z));
	}

	template <typename valType>
	 inline detail::tvec4<valType> modf
	(
		detail::tvec4<valType> const & x, 
		detail::tvec4<valType> & i
	)
	{
		return detail::tvec4<valType>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z),
			modf(x.w, i.w));
	}

	
	
	
	
	
	
	

	
	template <typename genType>
	 inline genType min
	(
		genType const & x, 
		genType const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float || detail::type<genType>::is_int || detail::type<genType>::is_uint) ? 1 : -1];
#line 295 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_common.inl"

		return x < y ? x : y;
	}

	template <typename T>  inline detail::tvec2<T> min ( detail::tvec2<T> const & x, typename detail::tvec2<T>::value_type const & y ) { return detail::tvec2<T>( min(x.x, y), min(x.y, y)); } template <typename T>  inline detail::tvec3<T> min ( detail::tvec3<T> const & x, typename detail::tvec3<T>::value_type const & y ) { return detail::tvec3<T>( min(x.x, y), min(x.y, y), min(x.z, y)); } template <typename T>  inline detail::tvec4<T> min ( detail::tvec4<T> const & x, typename detail::tvec4<T>::value_type const & y ) { return detail::tvec4<T>( min(x.x, y), min(x.y, y), min(x.z, y), min(x.w, y)); }
	template <typename T>  inline detail::tvec2<T> min ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( min(x.x, y.x), min(x.y, y.y)); } template <typename T>  inline detail::tvec3<T> min ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( min(x.x, y.x), min(x.y, y.y), min(x.z, y.z)); } template <typename T>  inline detail::tvec4<T> min ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( min(x.x, y.x), min(x.y, y.y), min(x.z, y.z), min(x.w, y.w)); }

	
	template <typename genType>
	 inline genType max
	(
		genType const & x, 
		genType const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float || detail::type<genType>::is_int || detail::type<genType>::is_uint) ? 1 : -1];
#line 314 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_common.inl"

		return x > y ? x : y;
	}

	template <typename T>  inline detail::tvec2<T> max ( detail::tvec2<T> const & x, typename detail::tvec2<T>::value_type const & y ) { return detail::tvec2<T>( max(x.x, y), max(x.y, y)); } template <typename T>  inline detail::tvec3<T> max ( detail::tvec3<T> const & x, typename detail::tvec3<T>::value_type const & y ) { return detail::tvec3<T>( max(x.x, y), max(x.y, y), max(x.z, y)); } template <typename T>  inline detail::tvec4<T> max ( detail::tvec4<T> const & x, typename detail::tvec4<T>::value_type const & y ) { return detail::tvec4<T>( max(x.x, y), max(x.y, y), max(x.z, y), max(x.w, y)); }
	template <typename T>  inline detail::tvec2<T> max ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( max(x.x, y.x), max(x.y, y.y)); } template <typename T>  inline detail::tvec3<T> max ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( max(x.x, y.x), max(x.y, y.y), max(x.z, y.z)); } template <typename T>  inline detail::tvec4<T> max ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( max(x.x, y.x), max(x.y, y.y), max(x.z, y.z), max(x.w, y.w)); }

	
	template <typename valType>
	 inline valType clamp
	(
		valType const & x, 
		valType const & minVal, 
		valType const & maxVal
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<valType>::is_float || detail::type<valType>::is_int || detail::type<valType>::is_uint) ? 1 : -1];
#line 334 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_common.inl"
		
		return min(maxVal, max(minVal, x));
	}

	template <typename T>
	 inline detail::tvec2<T> clamp
	(
		detail::tvec2<T> const & x, 
		typename detail::tvec2<T>::value_type const & minVal, 
		typename detail::tvec2<T>::value_type const & maxVal
	)
	{
		return detail::tvec2<T>(
			clamp(x.x, minVal, maxVal),
			clamp(x.y, minVal, maxVal));
	}

	template <typename T>
	 inline detail::tvec3<T> clamp
	(
		detail::tvec3<T> const & x, 
		typename detail::tvec3<T>::value_type const & minVal, 
		typename detail::tvec3<T>::value_type const & maxVal
	)
	{
		return detail::tvec3<T>(
			clamp(x.x, minVal, maxVal),
			clamp(x.y, minVal, maxVal),
			clamp(x.z, minVal, maxVal));
	}

	template <typename T>
	 inline detail::tvec4<T> clamp
	(
		detail::tvec4<T> const & x, 
		typename detail::tvec4<T>::value_type const & minVal, 
		typename detail::tvec4<T>::value_type const & maxVal
	)
	{
		return detail::tvec4<T>(
			clamp(x.x, minVal, maxVal),
			clamp(x.y, minVal, maxVal),
			clamp(x.z, minVal, maxVal),
			clamp(x.w, minVal, maxVal));
	}

	template <typename T>
	 inline detail::tvec2<T> clamp
	(
		detail::tvec2<T> const & x, 
		detail::tvec2<T> const & minVal, 
		detail::tvec2<T> const & maxVal
	)
	{
		return detail::tvec2<T>(
			clamp(x.x, minVal.x, maxVal.x),
			clamp(x.y, minVal.y, maxVal.y));
	}

	template <typename T>
	 inline detail::tvec3<T> clamp
	(
		detail::tvec3<T> const & x, 
		detail::tvec3<T> const & minVal, 
		detail::tvec3<T> const & maxVal
	)
	{
		return detail::tvec3<T>(
			clamp(x.x, minVal.x, maxVal.x),
			clamp(x.y, minVal.y, maxVal.y),
			clamp(x.z, minVal.z, maxVal.z));
	}

	template <typename T>
	 inline detail::tvec4<T> clamp
	(
		detail::tvec4<T> const & x, 
		detail::tvec4<T> const & minVal, 
		detail::tvec4<T> const & maxVal
	)
	{
		return detail::tvec4<T>(
			clamp(x.x, minVal.x, maxVal.x),
			clamp(x.y, minVal.y, maxVal.y),
			clamp(x.z, minVal.z, maxVal.z),
			clamp(x.w, minVal.w, maxVal.w));
	}

	
	template <typename genType>
	 inline genType mix
	(
		genType const & x, 
		genType const & y, 
		genType const & a
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return x + a * (y - x);
	}

	template <typename valType>
	 inline detail::tvec2<valType> mix
	(
		detail::tvec2<valType> const & x, 
		detail::tvec2<valType> const & y, 
		valType const & a
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<valType>::is_float) ? 1 : -1];

		return x + a * (y - x);
	}

	template <typename valType>
	 inline detail::tvec3<valType> mix
	(
		detail::tvec3<valType> const & x, 
		detail::tvec3<valType> const & y, 
		valType const & a
	)
	{
		return x + a * (y - x);
	}

	template <typename valType>
	 inline detail::tvec4<valType> mix
	(
		detail::tvec4<valType> const & x, 
		detail::tvec4<valType> const & y, 
		valType const & a
	)
	{
		return x + a * (y - x);
	}

	template <typename valType>
	 inline detail::tvec2<valType> mix
	(
		detail::tvec2<valType> const & x, 
		detail::tvec2<valType> const & y, 
		detail::tvec2<valType> const & a
	)
	{
		return x + a * (y - x);
	}

	template <typename valType>
	 inline detail::tvec3<valType> mix
	(
		detail::tvec3<valType> const & x, 
		detail::tvec3<valType> const & y, 
		detail::tvec3<valType> const & a
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<valType>::is_float) ? 1 : -1];

		return x + a * (y - x);
	}

	template <typename valType>
	 inline detail::tvec4<valType> mix
	(
		detail::tvec4<valType> const & x, 
		detail::tvec4<valType> const & y, 
		detail::tvec4<valType> const & a
	)
	{
		return x + a * (y - x);
	}

	
	
	
	
	
	
	
	
	
	
	
	

	
	

	template <>
	 inline float mix
	(
		float const & x, 
		float const & y, 
		bool const & a
	)
	{
		return a ? y : x;
	}

	template <>
	 inline double mix
	(
		double const & x, 
		double const & y, 
		bool const & a
	)
	{
		return a ? y : x;
	}

	template <typename T>
	 inline detail::tvec2<T> mix
	(
		detail::tvec2<T> const & x, 
		detail::tvec2<T> const & y, 
		bool a
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		return a ? y : x;
	}

	template <typename T>
	 inline detail::tvec3<T> mix
	(
		detail::tvec3<T> const & x, 
		detail::tvec3<T> const & y, 
		bool a
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		return a ? y : x;
	}

	template <typename T>
	 inline detail::tvec4<T> mix
	(
		detail::tvec4<T> const & x, 
		detail::tvec4<T> const & y, 
		bool a
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		return a ? y : x;
	}

	template <typename T>
	 inline detail::tvec2<T> mix
	(
		detail::tvec2<T> const & x, 
		detail::tvec2<T> const & y, 
		typename detail::tvec2<T>::bool_type a
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tvec2<T> result;
		for
		(
			typename detail::tvec2<T>::size_type i = 0; 
			i < x.length(); ++i
		)
		{
			result[i] = a[i] ? y[i] : x[i];
		}
		return result;
	}

	template <typename T>
	 inline detail::tvec3<T> mix
	(
		detail::tvec3<T> const & x, 
		detail::tvec3<T> const & y, 
		typename detail::tvec3<T>::bool_type a
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tvec3<T> result;
		for
		(
			typename detail::tvec3<T>::size_type i = 0; 
			i < x.length(); ++i
		)
		{
			result[i] = a[i] ? y[i] : x[i];
		}
		return result;
	}

	template <typename T>
	 inline detail::tvec4<T> mix
	(
		detail::tvec4<T> const & x, 
		detail::tvec4<T> const & y, 
		typename detail::tvec4<T>::bool_type a
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tvec4<T> result;
		for
		(
			typename detail::tvec4<T>::size_type i = 0; 
			i < x.length(); ++i
		)
		{
			result[i] = a[i] ? y[i] : x[i];
		}
		return result;
	}

	
	template <typename genType>
	 inline genType step
	(
		genType const & edge, 
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return x < edge ? genType(0) : genType(1);
	}

	template <typename T>
	 inline detail::tvec2<T> step
	(
		typename detail::tvec2<T>::value_type const & edge, 
		detail::tvec2<T> const & x
	)
	{
		return detail::tvec2<T>(
			x.x < edge ? T(0) : T(1),
			x.y < edge ? T(0) : T(1));
	}

	template <typename T>
	 inline detail::tvec3<T> step
	(
		typename detail::tvec3<T>::value_type const & edge, 
		detail::tvec3<T> const & x
	)
	{
		return detail::tvec3<T>(
			x.x < edge ? T(0) : T(1),
			x.y < edge ? T(0) : T(1),
			x.z < edge ? T(0) : T(1));
	}

	template <typename T>
	 inline detail::tvec4<T> step
	(
		typename detail::tvec4<T>::value_type const & edge, 
		detail::tvec4<T> const & x
	)
	{
		return detail::tvec4<T>(
			x.x < edge ? T(0) : T(1),
			x.y < edge ? T(0) : T(1),
			x.z < edge ? T(0) : T(1),
			x.w < edge ? T(0) : T(1));
	}

	template <typename T>
	 inline detail::tvec2<T> step
	(
		detail::tvec2<T> const & edge, 
		detail::tvec2<T> const & x
	)
	{
		return detail::tvec2<T>(
			x.x < edge.x ? T(0) : T(1),
			x.y < edge.y ? T(0) : T(1));
	}

	template <typename T>
	 inline detail::tvec3<T> step
	(
		detail::tvec3<T> const & edge, 
		detail::tvec3<T> const & x
	)
	{
		return detail::tvec3<T>(
			x.x < edge.x ? T(0) : T(1),
			x.y < edge.y ? T(0) : T(1),
			x.z < edge.z ? T(0) : T(1));
	}

	template <typename T>
	 inline detail::tvec4<T> step
	(
		detail::tvec4<T> const & edge, 
		detail::tvec4<T> const & x
	)
	{
		return detail::tvec4<T>(
			x.x < edge.x ? T(0) : T(1),
			x.y < edge.y ? T(0) : T(1),
			x.z < edge.z ? T(0) : T(1),
			x.w < edge.w ? T(0) : T(1));
	}

	
	template <typename genType>
	 inline genType smoothstep
	(
		genType const & edge0, 
		genType const & edge1, 
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		genType tmp = clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1));
		return tmp * tmp * (genType(3) - genType(2) * tmp);
	}

	template <typename T>
	 inline detail::tvec2<T> smoothstep
	(
		typename detail::tvec2<T>::value_type const & edge0, 
		typename detail::tvec2<T>::value_type const & edge1, 
		detail::tvec2<T> const & x
	)
	{
		return detail::tvec2<T>(
			smoothstep(edge0, edge1, x.x),
			smoothstep(edge0, edge1, x.y));
	}

	template <typename T>
	 inline detail::tvec3<T> smoothstep
	(
		typename detail::tvec3<T>::value_type const & edge0, 
		typename detail::tvec3<T>::value_type const & edge1, 
		detail::tvec3<T> const & x
	)
	{
		return detail::tvec3<T>(
			smoothstep(edge0, edge1, x.x),
			smoothstep(edge0, edge1, x.y),
			smoothstep(edge0, edge1, x.z));
	}

	template <typename T>
	 inline detail::tvec4<T> smoothstep
	(
		typename detail::tvec4<T>::value_type const & edge0, 
		typename detail::tvec4<T>::value_type const & edge1, 
		detail::tvec4<T> const & x
	)
	{
		return detail::tvec4<T>(
			smoothstep(edge0, edge1, x.x),
			smoothstep(edge0, edge1, x.y),
			smoothstep(edge0, edge1, x.z),
			smoothstep(edge0, edge1, x.w));
	}

	template <typename T>
	 inline detail::tvec2<T> smoothstep
	(
		detail::tvec2<T> const & edge0, 
		detail::tvec2<T> const & edge1, 
		detail::tvec2<T> const & x
	)
	{
		return detail::tvec2<T>(
			smoothstep(edge0.x, edge1.x, x.x),
			smoothstep(edge0.y, edge1.y, x.y));
	}

	template <typename T>
	 inline detail::tvec3<T> smoothstep
	(
		detail::tvec3<T> const & edge0, 
		detail::tvec3<T> const & edge1, 
		detail::tvec3<T> const & x
	)
	{
		return detail::tvec3<T>(
			smoothstep(edge0.x, edge1.x, x.x),
			smoothstep(edge0.y, edge1.y, x.y),
			smoothstep(edge0.z, edge1.z, x.z));
	}

	template <typename T>
	 inline detail::tvec4<T> smoothstep
	(
		detail::tvec4<T> const & edge0, 
		detail::tvec4<T> const & edge1, 
		detail::tvec4<T> const & x
	)
	{
		return detail::tvec4<T>(
			smoothstep(edge0.x, edge1.x, x.x),
			smoothstep(edge0.y, edge1.y, x.y),
			smoothstep(edge0.z, edge1.z, x.z),
			smoothstep(edge0.w, edge1.w, x.w));
	}

	
	template <typename genType> 
	 inline bool isnan(genType const & x)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];


			return _isnan(x) != 0;










#line 858 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_common.inl"
	}

	template <typename T>
	 inline typename detail::tvec2<T>::bool_type isnan
	(
		detail::tvec2<T> const & x
	)
	{
		return typename detail::tvec2<T>::bool_type(
			isnan(x.x),
			isnan(x.y));
	}

	template <typename T>
	 inline typename detail::tvec3<T>::bool_type isnan
	(
		detail::tvec3<T> const & x
	)
	{
		return typename detail::tvec3<T>::bool_type(
			isnan(x.x),
			isnan(x.y),
			isnan(x.z));
	}

	template <typename T>
	 inline typename detail::tvec4<T>::bool_type isnan
	(
		detail::tvec4<T> const & x
	)
	{
		return typename detail::tvec4<T>::bool_type(
			isnan(x.x),
			isnan(x.y),
			isnan(x.z),
			isnan(x.w));
	}

	template <typename genType> 
	 inline bool isinf(
		genType const & x)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];


			return _fpclass(x) == 0x0004 || _fpclass(x) == 0x0200;











#line 916 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_common.inl"
	}

	template <typename T>
	 inline typename detail::tvec2<T>::bool_type isinf
	(
		detail::tvec2<T> const & x
	)
	{
		return typename detail::tvec2<T>::bool_type(
			isinf(x.x),
			isinf(x.y));
	}

	template <typename T>
	 inline typename detail::tvec3<T>::bool_type isinf
	(
		detail::tvec3<T> const & x
	)
	{
		return typename detail::tvec3<T>::bool_type(
			isinf(x.x),
			isinf(x.y),
			isinf(x.z));
	}

	template <typename T>
	 inline typename detail::tvec4<T>::bool_type isinf
	(
		detail::tvec4<T> const & x
	)
	{
		return typename detail::tvec4<T>::bool_type(
			isinf(x.x),
			isinf(x.y),
			isinf(x.z),
			isinf(x.w));
	}

	 inline int floatBitsToInt(float const & value)
	{
		union
		{
			float f;
			int i;
		} fi;

		fi.f = value;
		return fi.i;
	}

	 inline detail::tvec2<int> floatBitsToInt
	(
		detail::tvec2<float> const & value
	)
	{
		return detail::tvec2<int>(
			floatBitsToInt(value.x),
			floatBitsToInt(value.y));
	}

	 inline detail::tvec3<int> floatBitsToInt
	(
		detail::tvec3<float> const & value
	)
	{
		return detail::tvec3<int>(
			floatBitsToInt(value.x),
			floatBitsToInt(value.y),
			floatBitsToInt(value.z));
	}

	 inline detail::tvec4<int> floatBitsToInt
	(
		detail::tvec4<float> const & value
	)
	{
		return detail::tvec4<int>(
			floatBitsToInt(value.x),
			floatBitsToInt(value.y),
			floatBitsToInt(value.z),
			floatBitsToInt(value.w));
	}

	 inline uint floatBitsToUint(float const & value)
	{
		union
		{
			float f;
			uint u;
		} fu;

		fu.f = value;
		return fu.u;
	}

	 inline detail::tvec2<uint> floatBitsToUint
	(
		detail::tvec2<float> const & value
	)
	{
		return detail::tvec2<uint>(
			floatBitsToUint(value.x),
			floatBitsToUint(value.y));
	}

	 inline detail::tvec3<uint> floatBitsToUint
	(
		detail::tvec3<float> const & value
	)
	{
		return detail::tvec3<uint>(
			floatBitsToUint(value.x),
			floatBitsToUint(value.y),
			floatBitsToUint(value.z));
	}

	 inline detail::tvec4<uint> floatBitsToUint
	(
		detail::tvec4<float> const & value
	)
	{
		return detail::tvec4<uint>(
			floatBitsToUint(value.x),
			floatBitsToUint(value.y),
			floatBitsToUint(value.z),
			floatBitsToUint(value.w));
	}

	 inline float intBitsToFloat(int const & value)
	{
		union
		{
			float f;
			int i;
		} fi;

		fi.i = value;
		return fi.f;
	}

	 inline detail::tvec2<float> intBitsToFloat

	(
		detail::tvec2<int> const & value
	)
	{
		return detail::tvec2<float>(
			intBitsToFloat(value.x),
			intBitsToFloat(value.y));
	}

	 inline detail::tvec3<float> intBitsToFloat
	(
		detail::tvec3<int> const & value
	)
	{
		return detail::tvec3<float>(
			intBitsToFloat(value.x),
			intBitsToFloat(value.y),
			intBitsToFloat(value.z));
	}

	 inline detail::tvec4<float> intBitsToFloat
	(
		detail::tvec4<int> const & value
	)
	{
		return detail::tvec4<float>(
			intBitsToFloat(value.x),
			intBitsToFloat(value.y),
			intBitsToFloat(value.z),
			intBitsToFloat(value.w));
	}

	 inline float uintBitsToFloat(uint const & value)
	{
		union
		{
			float f;
			uint u;
		} fu;

		fu.u = value;
		return fu.f;
	}

	 inline detail::tvec2<float> uintBitsToFloat
	(
		detail::tvec2<uint> const & value
	)
	{
		return detail::tvec2<float>(
			uintBitsToFloat(value.x),
			uintBitsToFloat(value.y));
	}

	 inline detail::tvec3<float> uintBitsToFloat
	(
		detail::tvec3<uint> const & value
	)
	{
		return detail::tvec3<float>(
			uintBitsToFloat(value.x),
			uintBitsToFloat(value.y),
			uintBitsToFloat(value.z));
	}

	 inline detail::tvec4<float> uintBitsToFloat
	(
		detail::tvec4<uint> const & value
	)
	{
		return detail::tvec4<float>(
			uintBitsToFloat(value.x),
			uintBitsToFloat(value.y),
			uintBitsToFloat(value.z),
			uintBitsToFloat(value.w));
	}

	template <typename genType>
	 inline genType fma
	(
		genType const & a, 
		genType const & b, 
		genType const & c
	)
	{
		return a * b + c;
	}

	template <typename genType>
	 inline genType frexp
	(
		genType const & x, 
		int & exp
	)
	{
		return std::frexp(x, exp);
	}

	template <typename T>
	 inline detail::tvec2<T> frexp
	(
		detail::tvec2<T> const & x, 
		detail::tvec2<int> & exp
	)
	{
		return std::frexp(x, exp);
	}

	template <typename T>
	 inline detail::tvec3<T> frexp
	(
		detail::tvec3<T> const & x, 
		detail::tvec3<int> & exp
	)
	{
		return std::frexp(x, exp);
	}

	template <typename T>
	 inline detail::tvec4<T> frexp
	(
		detail::tvec4<T> const & x, 
		detail::tvec4<int> & exp
	)
	{
		return std::frexp(x, exp);
	}

	template <typename genType>
	 inline genType ldexp
	(
		genType const & x, 
		int const & exp
	)
	{
		return std::frexp(x, exp);
	}

	template <typename T>
	 inline detail::tvec2<T> ldexp
	(
		detail::tvec2<T> const & x, 
		detail::tvec2<int> const & exp
	)
	{
		return std::frexp(x, exp);
	}

	template <typename T>
	 inline detail::tvec3<T> ldexp
	(
		detail::tvec3<T> const & x, 
		detail::tvec3<int> const & exp
	)
	{
		return std::frexp(x, exp);
	}

	template <typename T>
	 inline detail::tvec4<T> ldexp
	(
		detail::tvec4<T> const & x, 
		detail::tvec4<int> const & exp
	)
	{
		return std::frexp(x, exp);
	}

}
#line 429 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_common.hpp"

#line 431 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_common.hpp"
#line 103 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_packing.hpp"






































namespace glm
{
	
	

	
	
	
	
	
	
	
	
	
	
	
	 detail::uint32 packUnorm2x16(detail::tvec2<detail::float32> const & v);

	
	
	
	
	
	
	
	
	
	
	
	 detail::uint32 packSnorm2x16(detail::tvec2<detail::float32> const & v);

	
	
	
	
	
	
	
	
	
	
	
	 detail::uint32 packUnorm4x8(detail::tvec4<detail::float32> const & v);

	
	
	
	
	
	
	
	
	
	
	
	 detail::uint32 packSnorm4x8(detail::tvec4<detail::float32> const & v);

	
	
	
	
	
	
	
	
	
	
	
	 detail::tvec2<detail::float32> unpackUnorm2x16(detail::uint32 const & p);

	
	
	
	
	
	
	
	
	
	
	
	 detail::tvec2<detail::float32> unpackSnorm2x16(detail::uint32 const & p);

	
	
	
	
	
	
	
	
	
	
	
	 detail::tvec4<detail::float32> unpackUnorm4x8(detail::uint32 const & p);

	
	
	
	
	
	
	
	
	
	
	
	 detail::tvec4<detail::float32> unpackSnorm4x8(detail::uint32 const & p);

	
	
	
	
	
	
	
	
	 double packDouble2x32(detail::tvec2<detail::uint32> const & v);

	
	
	
	
	
	
	
	 detail::tvec2<detail::uint32> unpackDouble2x32(double const & v);

	
	
	
	
	
	
	
	
	 uint packHalf2x16(vec2 const & v);
	
	
	
	
	
	
	
	
	
	 vec2 unpackHalf2x16(uint const & v);
	
	
}

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_packing.inl"




























namespace glm
{
	 inline detail::uint32 packUnorm2x16(detail::tvec2<detail::float32> const & v)
	{
		detail::uint16 A(detail::uint16(round(clamp(v.x, 0.0f, 1.0f) * 65535.0f)));
		detail::uint16 B(detail::uint16(round(clamp(v.y, 0.0f, 1.0f) * 65535.0f)));
		return detail::uint32((B << 16) | A);
	}

	 inline detail::tvec2<detail::float32> unpackUnorm2x16(detail::uint32 const & p)
	{
		detail::uint32 Mask16((1 << 16) - 1);
		detail::uint32 A((p >>  0) & Mask16);
		detail::uint32 B((p >> 16) & Mask16);
		return detail::tvec2<detail::float32>(
			A * 1.0f / 65535.0f, 
			B * 1.0f / 65535.0f);
	}
	
	 inline detail::uint32 packSnorm2x16(detail::tvec2<detail::float32> const & v)
	{
		union iu
		{
			detail::int16 i;
			detail::uint16 u;
		} A, B;
		
		detail::tvec2<detail::float32> Unpack = clamp(v ,-1.0f, 1.0f) * 32767.0f;
		A.i = detail::int16(round(Unpack.x));
		B.i = detail::int16(round(Unpack.y));
		detail::uint32 Pack = (detail::uint32(B.u) << 16) | (detail::uint32(A.u) << 0);
		return Pack;
	}

	 inline detail::tvec2<detail::float32> unpackSnorm2x16(detail::uint32 const & p)
	{
		union iu
		{
			detail::int16 i;
			detail::uint16 u;
		} A, B;
		
		detail::uint32 Mask16((1 << 16) - 1);
		A.u = detail::uint16((p >>  0) & Mask16);
		B.u = detail::uint16((p >> 16) & Mask16);
		detail::tvec2<detail::float32> Pack(A.i, B.i);
		
		return clamp(Pack * 1.0f / 32767.0f, -1.0f, 1.0f);
	}

	 inline detail::uint32 packUnorm4x8(detail::tvec4<detail::float32> const & v)
	{
		detail::uint8 A((detail::uint8)round(clamp(v.x, 0.0f, 1.0f) * 255.0f));
		detail::uint8 B((detail::uint8)round(clamp(v.y, 0.0f, 1.0f) * 255.0f));
		detail::uint8 C((detail::uint8)round(clamp(v.z, 0.0f, 1.0f) * 255.0f));
		detail::uint8 D((detail::uint8)round(clamp(v.w, 0.0f, 1.0f) * 255.0f));
		return detail::uint32((D << 24) | (C << 16) | (B << 8) | A);
	}

	 inline detail::tvec4<detail::float32> unpackUnorm4x8(detail::uint32 const & p)
	{	
		detail::uint32 Mask8((1 << 8) - 1);
		detail::uint32 A((p >>  0) & Mask8);
		detail::uint32 B((p >>  8) & Mask8);
		detail::uint32 C((p >> 16) & Mask8);
		detail::uint32 D((p >> 24) & Mask8);
		return detail::tvec4<detail::float32>(
			A * 1.0f / 255.0f, 
			B * 1.0f / 255.0f, 
			C * 1.0f / 255.0f, 
			D * 1.0f / 255.0f);
	}
	
	 inline detail::uint32 packSnorm4x8(detail::tvec4<detail::float32> const & v)
	{
		union iu
		{
			detail::int8 i;
			detail::uint8 u;
		} A, B, C, D;
	
		detail::tvec4<detail::float32> Unpack = clamp(v ,-1.0f, 1.0f) * 127.0f;
		A.i = detail::int8(round(Unpack.x));
		B.i = detail::int8(round(Unpack.y));
		C.i = detail::int8(round(Unpack.z));
		D.i = detail::int8(round(Unpack.w));
		detail::uint32 Pack = (detail::uint32(D.u) << 24) | (detail::uint32(C.u) << 16) | (detail::uint32(B.u) << 8) | (detail::uint32(A.u) << 0);
		return Pack;
	}
	
	 inline detail::tvec4<detail::float32> unpackSnorm4x8(detail::uint32 const & p)
	{	
		union iu
		{
			detail::int8 i;
			detail::uint8 u;
		} A, B, C, D;
	
		detail::uint32 Mask8((1 << 8) - 1);
		A.u = detail::uint8((p >>  0) & Mask8);
		B.u = detail::uint8((p >>  8) & Mask8);
		C.u = detail::uint8((p >> 16) & Mask8);
		D.u = detail::uint8((p >> 24) & Mask8);
		detail::tvec4<detail::float32> Pack(A.i, B.i, C.i, D.i);
	
		return clamp(Pack * 1.0f / 127.0f, -1.0f, 1.0f);
	}

	 inline double packDouble2x32(detail::tvec2<detail::uint32> const & v)
	{
		struct uint32_pair
		{
			detail::uint32 x;
			detail::uint32 y;
		};

		union helper
		{
			uint32_pair input;
			double output;
		} Helper;

		Helper.input.x = v.x;
		Helper.input.y = v.y;

		return Helper.output;
		
	}

	 inline detail::tvec2<uint> unpackDouble2x32(double const & v)
	{
		struct uint32_pair
		{
			detail::uint32 x;
			detail::uint32 y;
		};

		union helper
		{
			double input;
			uint32_pair output;
		} Helper;

		Helper.input = v;

		return detail::tvec2<uint>(Helper.output.x, Helper.output.y);
	}

	 inline uint packHalf2x16(detail::tvec2<float> const & v)
	{
		union helper
		{ 
			uint other; 
			struct 
			{ 
				detail::hdata a, b; 
			} orig; 
		} Pack; 

		Pack.orig.a = detail::toFloat16(v.x); 
		Pack.orig.b = detail::toFloat16(v.y); 
		return Pack.other;
	}

	 inline vec2 unpackHalf2x16(uint const & v)
	{
		union helper
		{ 
			uint other; 
			struct 
			{ 
				detail::hdata a, b; 
			} orig; 
		} Unpack; 
		Unpack.other = v;

		return vec2(detail::toFloat32(Unpack.orig.a), detail::toFloat32(Unpack.orig.b));
	}
}

#line 191 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_packing.hpp"

#line 193 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_packing.hpp"

#line 104 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_geometric.hpp"






































namespace glm
{
	
	

	
	
	
	
	
	
	template <typename genType> 
	 typename genType::value_type length(
		genType const & x); 

	
	
	
	
	
	
	template <typename genType> 
	 typename genType::value_type distance(
		genType const & p0, 
		genType const & p1);

	
	
	
	
	
	
	template <typename genType> 
	 typename genType::value_type dot(
		genType const & x, 
		genType const & y);

	
	
	
	
	
	
	template <typename valType> 
	 detail::tvec3<valType> cross(
		detail::tvec3<valType> const & x, 
		detail::tvec3<valType> const & y);

	
	
	
	
	template <typename genType> 
	 genType normalize(
		genType const & x);

	
	
	
	
	
	
	template <typename genType> 
	 genType faceforward(
		genType const & N, 
		genType const & I, 
		genType const & Nref);

	
	
	
	
	
	
	
	template <typename genType> 
	 genType reflect(
		genType const & I, 
		genType const & N);

	
	
	
	
	
	
	
	
	template <typename genType> 
	 genType refract(
		genType const & I, 
		genType const & N, 
		typename genType::value_type const & eta);

	
}

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_geometric.inl"




























namespace glm
{
	
	template <typename genType>
	 inline genType length
	(
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		genType sqr = x * x;
		return sqrt(sqr);
	}

	template <typename T>
	 inline typename detail::tvec2<T>::value_type length
	(
		detail::tvec2<T> const & v
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		typename detail::tvec2<T>::value_type sqr = v.x * v.x + v.y * v.y;
		return sqrt(sqr);
	}

	template <typename T>
	 inline typename detail::tvec3<T>::value_type length
	(
		detail::tvec3<T> const & v
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		typename detail::tvec3<T>::value_type sqr = v.x * v.x + v.y * v.y + v.z * v.z;
		return sqrt(sqr);
	}

	template <typename T>
	 inline typename detail::tvec4<T>::value_type length
	(
		detail::tvec4<T> const & v
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		typename detail::tvec4<T>::value_type sqr = v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w;
		return sqrt(sqr);
	}

	
	template <typename genType>
	 inline genType distance
	(
		genType const & p0, 
		genType const & p1
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return length(p1 - p0);
	}
 
	template <typename T>
	 inline typename detail::tvec2<T>::value_type distance
	(
		detail::tvec2<T> const & p0,
		detail::tvec2<T> const & p1
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		return length(p1 - p0);
	}

	template <typename T>
	 inline typename detail::tvec3<T>::value_type distance
	(
		detail::tvec3<T> const & p0,
		detail::tvec3<T> const & p1
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		return length(p1 - p0);
	}

	template <typename T>
	 inline typename detail::tvec4<T>::value_type distance
	(
		detail::tvec4<T> const & p0,
		detail::tvec4<T> const & p1
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		return length(p1 - p0);
	}

	
	template <typename genType>
	 inline genType dot
	(
		genType const & x, 
		genType const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return x * y;
	}

	template <typename T>
	 inline typename detail::tvec2<T>::value_type dot
	(
		detail::tvec2<T> const & x, 
		detail::tvec2<T> const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		return x.x * y.x + x.y * y.y;
	}

	template <typename T>
	 inline T dot
	(
		detail::tvec3<T> const & x, 
		detail::tvec3<T> const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		return x.x * y.x + x.y * y.y + x.z * y.z;
	}

















	template <typename T>
	 inline T dot
	(
		detail::tvec4<T> const & x, 
		detail::tvec4<T> const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		return x.x * y.x + x.y * y.y + x.z * y.z + x.w * y.w;
	}

	
	template <typename T>
	 inline detail::tvec3<T> cross
	(
		detail::tvec3<T> const & x, 
		detail::tvec3<T> const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		return detail::tvec3<T>(
			x.y * y.z - y.y * x.z,
			x.z * y.x - y.z * x.x,
			x.x * y.y - y.x * x.y);
	}

	
	template <typename genType>
	 inline genType normalize
	(
		genType const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<genType>::is_float) ? 1 : -1];

		return x < genType(0) ? genType(-1) : genType(1);
	}

	
	template <typename T>
	 inline detail::tvec2<T> normalize
	(
		detail::tvec2<T> const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];
		
		typename detail::tvec2<T>::value_type sqr = x.x * x.x + x.y * x.y;
		return x * inversesqrt(sqr);
	}

	template <typename T>
	 inline detail::tvec3<T> normalize
	(
		detail::tvec3<T> const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		typename detail::tvec3<T>::value_type sqr = x.x * x.x + x.y * x.y + x.z * x.z;
		return x * inversesqrt(sqr);
	}

	template <typename T>
	 inline detail::tvec4<T> normalize
	(
		detail::tvec4<T> const & x
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];
		
		typename detail::tvec4<T>::value_type sqr = x.x * x.x + x.y * x.y + x.z * x.z + x.w * x.w;
		return x * inversesqrt(sqr);
	}

	
	template <typename genType>
	 inline genType faceforward
	(
		genType const & N, 
		genType const & I, 
		genType const & Nref
	)
	{
		return dot(Nref, I) < 0 ? N : -N;
	}

	
	template <typename genType>
	 inline genType reflect
	(
		genType const & I, 
		genType const & N
	)
	{
		return I - N * dot(N, I) * genType(2);
	}

	
	template <typename genType>
	 inline genType refract
	(
		genType const & I, 
		genType const & N, 
		genType const & eta
	)
	{
		
		

		genType dotValue = dot(N, I);
		genType k = genType(1) - eta * eta * (genType(1) - dotValue * dotValue);
		if(k < genType(0))
			return genType(0);
		else
			return eta * I - (eta * dotValue + sqrt(k)) * N;
	}

	template <typename genType>
	 inline genType refract
	(
		genType const & I, 
		genType const & N, 
		typename genType::value_type const & eta
	)
	{
		
		

		typename genType::value_type dotValue = dot(N, I);
		typename genType::value_type k = typename genType::value_type(1) - eta * eta * (typename genType::value_type(1) - dotValue * dotValue);
		if(k < typename genType::value_type(0))
			return genType(0);
		else
			return eta * I - (eta * dotValue + sqrt(k)) * N;
	}

}
#line 137 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_geometric.hpp"

#line 139 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_geometric.hpp"
#line 105 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_matrix.hpp"










































namespace glm
{
	
	

	
	
	
	
	
	
	
	template <typename matType> 
	 matType matrixCompMult(
		matType const & x, 
		matType const & y);

	
	
	
	
	
	
	
	
	
	
	template <typename vecType, typename matType> 
	 matType outerProduct(
		vecType const & c, 
		vecType const & r);

	
	
	
	
	
	
	template <typename matType> 
	 typename matType::transpose_type transpose(
		matType const & x);
	
	
	
	
	
	
	
	template <typename valType> 
	 typename detail::tmat2x2<valType>::value_type determinant(
		detail::tmat2x2<valType> const & m);

	
	
	
	
	
	
	template <typename valType> 
	 typename detail::tmat3x3<valType>::value_type determinant(
		detail::tmat3x3<valType> const & m);

	
	
	
	
	
	
	template <typename valType> 
	 typename detail::tmat4x4<valType>::value_type determinant(
		detail::tmat4x4<valType> const & m);

	
	
	
	
	
	
	template <typename valType> 
	 detail::tmat2x2<valType> inverse(
		detail::tmat2x2<valType> const & m);

	
	
	
	
	
	
	template <typename valType> 
	 detail::tmat3x3<valType> inverse(
		detail::tmat3x3<valType> const & m);

	
	
	
	
	
	
	template <typename valType> 
	 detail::tmat4x4<valType> inverse(
		detail::tmat4x4<valType> const & m);

	
}

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_matrix.inl"




























namespace glm
{
	
	template <typename matType>
	 inline matType matrixCompMult
	(
		matType const & x, 
		matType const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<typename matType::value_type>::is_float) ? 1 : -1];

		matType result(matType::null);
		for(typename matType::size_type i = 0; i < matType::row_size(); ++i)
			result[i] = x[i] * y[i];
		return result;
	}

	
	template <typename T>
	 inline detail::tmat2x2<T> outerProduct
	(
		detail::tvec2<T> const & c, 
		detail::tvec2<T> const & r
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat2x2<T> m(detail::tmat2x2<T>::null);
		m[0][0] = c[0] * r[0];
		m[0][1] = c[1] * r[0];
		m[1][0] = c[0] * r[1];
		m[1][1] = c[1] * r[1];
		return m;
	}

	template <typename T>
	 inline detail::tmat3x3<T> outerProduct
	(
		detail::tvec3<T> const & c, 
		detail::tvec3<T> const & r
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat3x3<T> m(detail::tmat3x3<T>::null);
		for(typename detail::tmat3x3<T>::size_type i(0); i < m.length(); ++i)
			m[i] = c * r[i];
		return m;
	}

	template <typename T>
	 inline detail::tmat4x4<T> outerProduct
	(
		detail::tvec4<T> const & c, 
		detail::tvec4<T> const & r
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat4x4<T> m(detail::tmat4x4<T>::null);
		for(typename detail::tmat4x4<T>::size_type i(0); i < m.length(); ++i)
			m[i] = c * r[i];
		return m;
	}

	template <typename T>
	 inline detail::tmat2x3<T> outerProduct
	(
		detail::tvec3<T> const & c, 
		detail::tvec2<T> const & r
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat2x3<T> m(detail::tmat2x3<T>::null);
		m[0][0] = c.x * r.x;
		m[0][1] = c.y * r.x;
		m[0][2] = c.z * r.x;
		m[1][0] = c.x * r.y;
		m[1][1] = c.y * r.y;
		m[1][2] = c.z * r.y;
		return m;
	}

	template <typename T>
	 inline detail::tmat3x2<T> outerProduct
	(
		detail::tvec2<T> const & c, 
		detail::tvec3<T> const & r
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat3x2<T> m(detail::tmat3x2<T>::null);
		m[0][0] = c.x * r.x;
		m[0][1] = c.y * r.x;
		m[1][0] = c.x * r.y;
		m[1][1] = c.y * r.y;
		m[2][0] = c.x * r.z;
		m[2][1] = c.y * r.z;
		return m;
	}

	template <typename T>
	 inline detail::tmat2x4<T> outerProduct
	(
		detail::tvec4<T> const & c, 
		detail::tvec2<T> const & r
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat2x4<T> m(detail::tmat2x4<T>::null);
		m[0][0] = c.x * r.x;
		m[0][1] = c.y * r.x;
		m[0][2] = c.z * r.x;
		m[0][3] = c.w * r.x;
		m[1][0] = c.x * r.y;
		m[1][1] = c.y * r.y;
		m[1][2] = c.z * r.y;
		m[1][3] = c.w * r.y;
		return m;
	}

	template <typename T>
	 inline detail::tmat4x2<T> outerProduct
	(
		detail::tvec2<T> const & c, 
		detail::tvec4<T> const & r
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat4x2<T> m(detail::tmat4x2<T>::null);
		m[0][0] = c.x * r.x;
		m[0][1] = c.y * r.x;
		m[1][0] = c.x * r.y;
		m[1][1] = c.y * r.y;
		m[2][0] = c.x * r.z;
		m[2][1] = c.y * r.z;
		m[3][0] = c.x * r.w;
		m[3][1] = c.y * r.w;
		return m;
	}

	template <typename T>
	 inline detail::tmat3x4<T> outerProduct
	(
		detail::tvec4<T> const & c, 
		detail::tvec3<T> const & r
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat3x4<T> m(detail::tmat3x4<T>::null);
		m[0][0] = c.x * r.x;
		m[0][1] = c.y * r.x;
		m[0][2] = c.z * r.x;
		m[0][3] = c.w * r.x;
		m[1][0] = c.x * r.y;
		m[1][1] = c.y * r.y;
		m[1][2] = c.z * r.y;
		m[1][3] = c.w * r.y;
		m[2][0] = c.x * r.z;
		m[2][1] = c.y * r.z;
		m[2][2] = c.z * r.z;
		m[2][3] = c.w * r.z;
		return m;
	}

	template <typename T>
	 inline detail::tmat4x3<T> outerProduct
	(
		detail::tvec3<T> const & c, 
		detail::tvec4<T> const & r
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat4x3<T> m(detail::tmat4x3<T>::null);
		m[0][0] = c.x * r.x;
		m[0][1] = c.y * r.x;
		m[0][2] = c.z * r.x;
		m[1][0] = c.x * r.y;
		m[1][1] = c.y * r.y;
		m[1][2] = c.z * r.y;
		m[2][0] = c.x * r.z;
		m[2][1] = c.y * r.z;
		m[2][2] = c.z * r.z;
		m[3][0] = c.x * r.w;
		m[3][1] = c.y * r.w;
		m[3][2] = c.z * r.w;
		return m;
	}

	template <typename T>
	 inline detail::tmat2x2<T> transpose
	(
		detail::tmat2x2<T> const & m
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat2x2<T> result(detail::tmat2x2<T>::null);
		result[0][0] = m[0][0];
		result[0][1] = m[1][0];
		result[1][0] = m[0][1];
		result[1][1] = m[1][1];
		return result;
	}

	template <typename T>
	 inline detail::tmat3x3<T> transpose
	(
		detail::tmat3x3<T> const & m
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat3x3<T> result(detail::tmat3x3<T>::null);
		result[0][0] = m[0][0];
		result[0][1] = m[1][0];
		result[0][2] = m[2][0];

		result[1][0] = m[0][1];
		result[1][1] = m[1][1];
		result[1][2] = m[2][1];

		result[2][0] = m[0][2];
		result[2][1] = m[1][2];
		result[2][2] = m[2][2];
		return result;
	}

	template <typename T>
	 inline detail::tmat4x4<T> transpose
	(
		detail::tmat4x4<T> const & m
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat4x4<T> result(detail::tmat4x4<T>::null);
		result[0][0] = m[0][0];
		result[0][1] = m[1][0];
		result[0][2] = m[2][0];
		result[0][3] = m[3][0];

		result[1][0] = m[0][1];
		result[1][1] = m[1][1];
		result[1][2] = m[2][1];
		result[1][3] = m[3][1];

		result[2][0] = m[0][2];
		result[2][1] = m[1][2];
		result[2][2] = m[2][2];
		result[2][3] = m[3][2];

		result[3][0] = m[0][3];
		result[3][1] = m[1][3];
		result[3][2] = m[2][3];
		result[3][3] = m[3][3];
		return result;
	}

	template <typename T>
	 inline detail::tmat2x3<T> transpose
	(
		detail::tmat3x2<T> const & m
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat2x3<T> result(detail::tmat2x3<T>::null);
		result[0][0] = m[0][0];
		result[0][1] = m[1][0];
		result[0][2] = m[2][0];
		result[1][0] = m[0][1];
		result[1][1] = m[1][1];
		result[1][2] = m[2][1];
		return result;
	}

	template <typename T>
	 inline detail::tmat3x2<T> transpose
	(
		detail::tmat2x3<T> const & m
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat3x2<T> result(detail::tmat3x2<T>::null);
		result[0][0] = m[0][0];
		result[0][1] = m[1][0];
		result[1][0] = m[0][1];
		result[1][1] = m[1][1];
		result[2][0] = m[0][2];
		result[2][1] = m[1][2];
		return result;
	}

	template <typename T>
	 inline detail::tmat2x4<T> transpose
	(
		detail::tmat4x2<T> const & m
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat2x4<T> result(detail::tmat2x4<T>::null);
		result[0][0] = m[0][0];
		result[0][1] = m[1][0];
		result[0][2] = m[2][0];
		result[0][3] = m[3][0];
		result[1][0] = m[0][1];
		result[1][1] = m[1][1];
		result[1][2] = m[2][1];
		result[1][3] = m[3][1];
		return result;
	}

	template <typename T>
	 inline detail::tmat4x2<T> transpose
	(
		detail::tmat2x4<T> const & m
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat4x2<T> result(detail::tmat4x2<T>::null);
		result[0][0] = m[0][0];
		result[0][1] = m[1][0];
		result[1][0] = m[0][1];
		result[1][1] = m[1][1];
		result[2][0] = m[0][2];
		result[2][1] = m[1][2];
		result[3][0] = m[0][3];
		result[3][1] = m[1][3];
		return result;
	}

	template <typename T>
	 inline detail::tmat3x4<T> transpose
	(
		detail::tmat4x3<T> const & m
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat3x4<T> result(detail::tmat3x4<T>::null);
		result[0][0] = m[0][0];
		result[0][1] = m[1][0];
		result[0][2] = m[2][0];
		result[0][3] = m[3][0];
		result[1][0] = m[0][1];
		result[1][1] = m[1][1];
		result[1][2] = m[2][1];
		result[1][3] = m[3][1];
		result[2][0] = m[0][2];
		result[2][1] = m[1][2];
		result[2][2] = m[2][2];
		result[2][3] = m[3][2];
		return result;
	}

	template <typename T>
	 inline detail::tmat4x3<T> transpose
	(
		detail::tmat3x4<T> const & m
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		detail::tmat4x3<T> result(detail::tmat4x3<T>::null);
		result[0][0] = m[0][0];
		result[0][1] = m[1][0];
		result[0][2] = m[2][0];
		result[1][0] = m[0][1];
		result[1][1] = m[1][1];
		result[1][2] = m[2][1];
		result[2][0] = m[0][2];
		result[2][1] = m[1][2];
		result[2][2] = m[2][2];
		result[3][0] = m[0][3];
		result[3][1] = m[1][3];
		result[3][2] = m[2][3];
		return result;
	}

	template <typename T>
	 inline typename detail::tmat2x2<T>::value_type determinant
	(
		detail::tmat2x2<T> const & m
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		return m[0][0] * m[1][1] - m[1][0] * m[0][1];
	}

	template <typename T>
	 inline typename detail::tmat3x3<T>::value_type determinant
	(
		detail::tmat3x3<T> const & m
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		return 
			+ m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
			- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
			+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
	}

	template <typename T>
	 inline typename detail::tmat4x4<T>::value_type determinant
	(
		detail::tmat4x4<T> const & m
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
		T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
		T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
		T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
		T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
		T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

		detail::tvec4<T> DetCof(
			+ (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
			- (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
			+ (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
			- (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

		return m[0][0] * DetCof[0]
				+ m[0][1] * DetCof[1]
				+ m[0][2] * DetCof[2]
				+ m[0][3] * DetCof[3];
	}

	template <typename T> 
	 inline detail::tmat2x2<T> inverse
	(
		detail::tmat2x2<T> const & m
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];
			
		
		T Determinant = determinant(m);

		detail::tmat2x2<T> Inverse(
			+ m[1][1] / Determinant,
			- m[0][1] / Determinant, 
			- m[1][0] / Determinant,
			+ m[0][0] / Determinant);

		return Inverse;
	}

	template <typename T> 
	 inline detail::tmat3x3<T> inverse
	(
		detail::tmat3x3<T> const & m
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		
		
		

		T Determinant = determinant(m);

		detail::tmat3x3<T> Inverse(detail::tmat3x3<T>::null);
		Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]);
		Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]);
		Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
		Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]);
		Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]);
		Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]);
		Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
		Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]);
		Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]);
		Inverse /= Determinant;

		return Inverse;
	}

	template <typename T> 
	 inline detail::tmat4x4<T> inverse
	(
		detail::tmat4x4<T> const & m
	)
	{
		typedef char __CASSERT____LINE__[(detail::type<T>::is_float) ? 1 : -1];

		T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
		T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
		T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

		T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
		T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
		T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

		T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
		T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
		T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

		T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
		T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
		T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

		T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
		T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
		T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

		T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
		T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
		T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

		detail::tvec4<T> const SignA(+1, -1, +1, -1);
		detail::tvec4<T> const SignB(-1, +1, -1, +1);

		detail::tvec4<T> Fac0(Coef00, Coef00, Coef02, Coef03);
		detail::tvec4<T> Fac1(Coef04, Coef04, Coef06, Coef07);
		detail::tvec4<T> Fac2(Coef08, Coef08, Coef10, Coef11);
		detail::tvec4<T> Fac3(Coef12, Coef12, Coef14, Coef15);
		detail::tvec4<T> Fac4(Coef16, Coef16, Coef18, Coef19);
		detail::tvec4<T> Fac5(Coef20, Coef20, Coef22, Coef23);

		detail::tvec4<T> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
		detail::tvec4<T> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
		detail::tvec4<T> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
		detail::tvec4<T> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

		detail::tvec4<T> Inv0 = SignA * (Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
		detail::tvec4<T> Inv1 = SignB * (Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
		detail::tvec4<T> Inv2 = SignA * (Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
		detail::tvec4<T> Inv3 = SignB * (Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

		detail::tmat4x4<T> Inverse(Inv0, Inv1, Inv2, Inv3);

		detail::tvec4<T> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

		T Determinant = glm::dot(m[0], Row0);

		Inverse /= Determinant;

		return Inverse;
	}
}
#line 149 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_matrix.hpp"

#line 151 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_matrix.hpp"
#line 106 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.hpp"













































namespace glm
{
	
	

	
	
	
	
	
	
	template <typename vecType> 
	 typename vecType::bool_type lessThan(vecType const & x, vecType const & y);

	
	
	
	
	
	
	template <typename vecType> 
	 typename vecType::bool_type lessThanEqual(vecType const & x, vecType const & y);

	
	
	
	
	
	
	template <typename vecType> 
	 typename vecType::bool_type greaterThan(vecType const & x, vecType const & y);

	
	
	
	
	
	
	template <typename vecType> 
	 typename vecType::bool_type greaterThanEqual(vecType const & x, vecType const & y);

	
	
	
	
	
	
	template <typename vecType> 
	 typename vecType::bool_type equal(vecType const & x, vecType const & y);

	
	
	
	
	
	
	template <typename vecType> 
	 typename vecType::bool_type notEqual(vecType const & x, vecType const & y);

	
	
	
	
	
	
	template <template <typename> class vecType> 
	 bool any(vecType<bool> const & v);

	
	
	
	
	
	
	template <template <typename> class vecType> 
	 bool all(vecType<bool> const & v);

	
	
	
	
	
	
	
	template <template <typename> class vecType> 
	 vecType<bool> not_(vecType<bool> const & v);

	
}

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl"




























namespace glm
{
	template <typename T, template <typename> class vecType> 
	 inline typename vecType<T>::bool_type lessThan
	(
		vecType<T> const & x, 
		vecType<T> const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::is_vector<vecType<T> >::_YES) ? 1 : -1];
#line 40 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl"
		typedef char __CASSERT____LINE__[(detail::is_bool<T>::_NO) ? 1 : -1];
#line 42 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl"
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl", 42), 0) );

		typename vecType<bool>::bool_type Result(vecType<bool>::null);
		for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
			Result[i] = x[i] < y[i];

		return Result;
	}

	template <typename T, template <typename> class vecType> 
	 inline typename vecType<T>::bool_type lessThanEqual
	(
		vecType<T> const & x, 
		vecType<T> const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::is_vector<vecType<T> >::_YES) ? 1 : -1];
#line 60 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl"
		typedef char __CASSERT____LINE__[(detail::is_bool<T>::_NO) ? 1 : -1];
#line 62 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl"
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl", 62), 0) );

		typename vecType<bool>::bool_type Result(vecType<bool>::null);
		for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
			Result[i] = x[i] <= y[i];
		return Result;
	}

	template <typename T, template <typename> class vecType> 
	 inline typename vecType<T>::bool_type greaterThan
	(
		vecType<T> const & x, 
		vecType<T> const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::is_vector<vecType<T> >::_YES) ? 1 : -1];
#line 79 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl"
		typedef char __CASSERT____LINE__[(detail::is_bool<T>::_NO) ? 1 : -1];
#line 81 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl"
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl", 81), 0) );

		typename vecType<bool>::bool_type Result(vecType<bool>::null);
		for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
			Result[i] = x[i] > y[i];
		return Result;
	}

	template <typename T, template <typename> class vecType> 
	 inline typename vecType<T>::bool_type greaterThanEqual
	(
		vecType<T> const & x, 
		vecType<T> const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::is_vector<vecType<T> >::_YES) ? 1 : -1];
#line 98 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl"
		typedef char __CASSERT____LINE__[(detail::is_bool<T>::_NO) ? 1 : -1];
#line 100 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl"
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl", 100), 0) );

		typename vecType<bool>::bool_type Result(vecType<bool>::null);
		for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
			Result[i] = x[i] >= y[i];
		return Result;
	}

	template <typename T, template <typename> class vecType> 
	 inline typename vecType<T>::bool_type equal
	(
		vecType<T> const & x, 
		vecType<T> const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::is_vector<vecType<T> >::_YES) ? 1 : -1];
#line 117 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl"
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl", 117), 0) );

		typename vecType<bool>::bool_type Result(vecType<bool>::null);
		for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
			Result[i] = x[i] == y[i];
		return Result;
	}

	template <typename T, template <typename> class vecType> 
	 inline typename vecType<T>::bool_type notEqual
	(
		vecType<T> const & x, 
		vecType<T> const & y
	)
	{
		typedef char __CASSERT____LINE__[(detail::is_vector<vecType<T> >::_YES) ? 1 : -1];
#line 134 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl"
		(void)( (!!(x.length() == y.length())) || (_wassert(L"x.length() == y.length()", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl", 134), 0) );

		typename vecType<bool>::bool_type Result(vecType<bool>::null);
		for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
			Result[i] = x[i] != y[i];
		return Result;
	}

	template <template <typename> class vecType> 
	 inline bool any(vecType<bool> const & v)
	{
		typedef char __CASSERT____LINE__[(detail::is_vector<vecType<bool> >::_YES) ? 1 : -1];
#line 147 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl"

		bool Result = false;
		for(typename vecType<bool>::size_type i = 0; i < v.length(); ++i)
			Result = Result || v[i];
		return Result;
	}

	template <template <typename> class vecType> 
	 inline bool all(vecType<bool> const & v)
	{
		typedef char __CASSERT____LINE__[(detail::is_vector<vecType<bool> >::_YES) ? 1 : -1];
#line 159 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl"

		bool Result = true;
		for(typename vecType<bool>::size_type i = 0; i < v.length(); ++i)
			Result = Result && v[i];
		return Result;
	}

	template <template <typename> class vecType> 
	 inline vecType<bool> not_(vecType<bool> const & v)
	{
		typedef char __CASSERT____LINE__[(detail::is_vector<vecType<bool> >::_YES) ? 1 : -1];
#line 171 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.inl"

		typename vecType<bool>::bool_type Result(vecType<bool>::null);
		for(typename vecType<bool>::size_type i = 0; i < v.length(); ++i)
			Result[i] = !v[i];
		return Result;
	}
}

#line 137 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.hpp"

#line 139 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_vector_relational.hpp"
#line 107 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_integer.hpp"








































namespace glm
{
	
	

	
	
	
	
	
	
	
	
	template <typename genUType>
	 genUType uaddCarry(
		genUType const & x, 
		genUType const & y, 
		genUType & carry);

	
	
	
	
	
	
	
	
	template <typename genUType>
	 genUType usubBorrow(
		genUType const & x, 
		genUType const & y, 
		genUType & borrow);
		
	
	
	
	
	
	
	
	
	template <typename genUType>
	 void umulExtended(
		genUType const & x, 
		genUType const & y, 
		genUType & msb, 
		genUType & lsb);
		
	
	
	
	
	
	
	
	
	template <typename genIType>
	 void imulExtended(
		genIType const & x, 
		genIType const & y, 
		genIType & msb, 
		genIType & lsb);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename genIUType>
	 genIUType bitfieldExtract(
		genIUType const & Value, 
		int const & Offset, 
		int const & Bits);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename genIUType>
	 genIUType bitfieldInsert(
		genIUType const & Base, 
		genIUType const & Insert, 
		int const & Offset, 
		int const & Bits);

	
	
	
	
	
	
	
	
	template <typename genIUType>
	 genIUType bitfieldReverse(genIUType const & Value);
		
	
	
	
	
	
	
	
	
	template <typename T, template <typename> class genIUType>
	 typename genIUType<T>::signed_type bitCount(genIUType<T> const & Value);

	
	
	
	
	
	
	
	
	
	
	template <typename T, template <typename> class genIUType>
	 typename genIUType<T>::signed_type findLSB(genIUType<T> const & Value);

	
	
	
	
	
	
	
	
	
	
	
	template <typename T, template <typename> class genIUType>
	 typename genIUType<T>::signed_type findMSB(genIUType<T> const & Value);

	
}

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_integer.inl"

































#line 35 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_integer.inl"

namespace glm
{
	
	template <typename genUType>
	 inline genUType uaddCarry
	(
		genUType const & x, 
		genUType const & y, 
		genUType & Carry
	)
	{
		detail::highp_uint_t Value64 = detail::highp_uint_t(x) + detail::highp_uint_t(y);
		genUType Result = genUType(Value64 % (detail::highp_uint_t(1) << detail::highp_uint_t(32)));
		Carry = (Value64 % (detail::highp_uint_t(1) << detail::highp_uint_t(32))) > 1 ? 1 : 0;
		return Result;
	}

	template <typename T>
	 inline detail::tvec2<T> uaddCarry
	(
		detail::tvec2<T> const & x, 
		detail::tvec2<T> const & y, 
		detail::tvec2<T> & Carry
	)
	{
		return detail::tvec2<T>(
			uaddCarry(x[0], y[0], Carry[0]),
			uaddCarry(x[1], y[1], Carry[1]));
	}

	template <typename T>
	 inline detail::tvec3<T> uaddCarry
	(
		detail::tvec3<T> const & x, 
		detail::tvec3<T> const & y, 
		detail::tvec3<T> & Carry
	)
	{
		return detail::tvec3<T>(
			uaddCarry(x[0], y[0], Carry[0]),
			uaddCarry(x[1], y[1], Carry[1]),
			uaddCarry(x[2], y[2], Carry[2]));
	}

	template <typename T>
	 inline detail::tvec4<T> uaddCarry
	(
		detail::tvec4<T> const & x, 
		detail::tvec4<T> const & y, 
		detail::tvec4<T> & Carry
	)
	{
		return detail::tvec4<T>(
			uaddCarry(x[0], y[0], Carry[0]),
			uaddCarry(x[1], y[1], Carry[1]),
			uaddCarry(x[2], y[2], Carry[2]),
			uaddCarry(x[3], y[3], Carry[3]));
	}

	
	template <typename genUType>
	 inline genUType usubBorrow
	(
		genUType const & x, 
		genUType const & y, 
		genUType & Borrow
	)
	{
		Borrow = x >= y ? 0 : 1;
		if(x > y)
			return genUType(detail::highp_int_t(x) - detail::highp_int_t(y));
		else
			return genUType((detail::highp_int_t(1) << detail::highp_int_t(32)) + detail::highp_int_t(x) - detail::highp_int_t(y));
	}

	template <typename T>
	 inline detail::tvec2<T> usubBorrow
	(
		detail::tvec2<T> const & x, 
		detail::tvec2<T> const & y, 
		detail::tvec2<T> & Borrow
	)
	{
		return detail::tvec2<T>(
			usubBorrow(x[0], y[0], Borrow[0]),
			usubBorrow(x[1], y[1], Borrow[1]));
	}

	template <typename T>
	 inline detail::tvec3<T> usubBorrow
	(
		detail::tvec3<T> const & x, 
		detail::tvec3<T> const & y, 
		detail::tvec3<T> & Borrow
	)
	{
		return detail::tvec3<T>(
			usubBorrow(x[0], y[0], Borrow[0]),
			usubBorrow(x[1], y[1], Borrow[1]),
			usubBorrow(x[2], y[2], Borrow[2]));
	}

	template <typename T>
	 inline detail::tvec4<T> usubBorrow
	(
		detail::tvec4<T> const & x, 
		detail::tvec4<T> const & y, 
		detail::tvec4<T> & Borrow
	)
	{
		return detail::tvec4<T>(
			usubBorrow(x[0], y[0], Borrow[0]),
			usubBorrow(x[1], y[1], Borrow[1]),
			usubBorrow(x[2], y[2], Borrow[2]),
			usubBorrow(x[3], y[3], Borrow[3]));
	}

	
	template <typename genUType>
	 inline void umulExtended
	(
		genUType const & x, 
		genUType const & y, 
		genUType & msb, 
		genUType & lsb
	)
	{
		detail::highp_uint_t ValueX64 = x;
		detail::highp_uint_t ValueY64 = y;
		detail::highp_uint_t Value64 = ValueX64 * ValueY64;
		msb = *(genUType*)&genUType(Value64 & ((detail::highp_uint_t(1) << detail::highp_uint_t(32)) - detail::highp_uint_t(1)));
		lsb = *(genUType*)&genUType(Value64 >> detail::highp_uint_t(32));
	}

	template <typename T>
	 inline detail::tvec2<T> umulExtended
	(
		detail::tvec2<T> const & x, 
		detail::tvec2<T> const & y, 
		detail::tvec2<T> & msb, 
		detail::tvec2<T> & lsb
	)
	{
		return detail::tvec2<T>(
			umulExtended(x[0], y[0], msb, lsb),
			umulExtended(x[1], y[1], msb, lsb));
	}

	template <typename T>
	 inline detail::tvec3<T> umulExtended
	(
		detail::tvec3<T> const & x, 
		detail::tvec3<T> const & y, 
		detail::tvec3<T> & msb, 
		detail::tvec3<T> & lsb
	)
	{
		return detail::tvec3<T>(
			umulExtended(x[0], y[0], msb, lsb),
			umulExtended(x[1], y[1], msb, lsb),
			umulExtended(x[2], y[2], msb, lsb));
	}

	template <typename T>
	 inline detail::tvec4<T> umulExtended
	(
		detail::tvec4<T> const & x, 
		detail::tvec4<T> const & y, 
		detail::tvec4<T> & msb, 
		detail::tvec4<T> & lsb
	)
	{
		return detail::tvec4<T>(
			umulExtended(x[0], y[0], msb, lsb),
			umulExtended(x[1], y[1], msb, lsb),
			umulExtended(x[2], y[2], msb, lsb),
			umulExtended(x[3], y[3], msb, lsb));
	}

	
	template <typename genIType>
	 inline void imulExtended
	(
		genIType const & x, 
		genIType const & y, 
		genIType & msb, 
		genIType & lsb
	)
	{
		detail::highp_int_t ValueX64 = x;
		detail::highp_int_t ValueY64 = y;
		detail::highp_int_t Value64 = ValueX64 * ValueY64;
		msb = *(genIType*)&genIType(Value64 & ((detail::highp_uint_t(1) << detail::highp_uint_t(32)) - detail::highp_uint_t(1)));
		lsb = *(genIType*)&genIType(Value64 >> detail::highp_uint_t(32));
	}

	template <typename T>
	 inline detail::tvec2<T> imulExtended
	(
		detail::tvec2<T> const & x, 
		detail::tvec2<T> const & y, 
		detail::tvec2<T> & msb, 
		detail::tvec2<T> & lsb
	)
	{
		return detail::tvec2<T>(
			imulExtended(x[0], y[0], msb, lsb),
			imulExtended(x[1], y[1], msb, lsb));
	}

	template <typename T>
	 inline detail::tvec3<T> imulExtended
	(
		detail::tvec3<T> const & x, 
		detail::tvec3<T> const & y, 
		detail::tvec3<T> & msb, 
		detail::tvec3<T> & lsb
	)
	{
		return detail::tvec3<T>(
			imulExtended(x[0], y[0], msb, lsb),
			imulExtended(x[1], y[1], msb, lsb),
			imulExtended(x[2], y[2], msb, lsb));
	}

	template <typename T>
	 inline detail::tvec4<T> imulExtended
	(
		detail::tvec4<T> const & x, 
		detail::tvec4<T> const & y, 
		detail::tvec4<T> & msb, 
		detail::tvec4<T> & lsb
	)
	{
		return detail::tvec4<T>(
			imulExtended(x[0], y[0], msb, lsb),
			imulExtended(x[1], y[1], msb, lsb),
			imulExtended(x[2], y[2], msb, lsb),
			imulExtended(x[3], y[3], msb, lsb));
	}

	
	template <typename genIUType>
	 inline genIUType bitfieldExtract
	(
		genIUType const & Value, 
		int const & Offset, 
		int const & Bits
	)
	{
		int GenSize = int(sizeof(genIUType)) << int(3);

		(void)( (!!(Offset + Bits <= GenSize)) || (_wassert(L"Offset + Bits <= GenSize", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_integer.inl", 288), 0) );

		genIUType ShiftLeft = Bits ? Value << (GenSize - (Bits + Offset)) : genIUType(0);
		genIUType ShiftBack = ShiftLeft >> genIUType(GenSize - Bits);

		return ShiftBack;
	}

	template <typename T>
	 inline detail::tvec2<T> bitfieldExtract
	(
		detail::tvec2<T> const & Value, 
		int const & Offset, 
		int const & Bits
	)
	{
		return detail::tvec2<T>(
			bitfieldExtract(Value[0], Offset, Bits),
			bitfieldExtract(Value[1], Offset, Bits));
	}

	template <typename T>
	 inline detail::tvec3<T> bitfieldExtract
	(
		detail::tvec3<T> const & Value, 
		int const & Offset, 
		int const & Bits
	)
	{
		return detail::tvec3<T>(
			bitfieldExtract(Value[0], Offset, Bits),
			bitfieldExtract(Value[1], Offset, Bits),
			bitfieldExtract(Value[2], Offset, Bits));
	}

	template <typename T>
	 inline detail::tvec4<T> bitfieldExtract
	(
		detail::tvec4<T> const & Value, 
		int const & Offset, 
		int const & Bits
	)
	{
		return detail::tvec4<T>(
			bitfieldExtract(Value[0], Offset, Bits),
			bitfieldExtract(Value[1], Offset, Bits),
			bitfieldExtract(Value[2], Offset, Bits),
			bitfieldExtract(Value[3], Offset, Bits));
	}

	
	template <typename genIUType>
	 inline genIUType bitfieldInsert
	(
		genIUType const & Base, 
		genIUType const & Insert, 
		int const & Offset, 
		int const & Bits
	)
	{
		typedef char __CASSERT____LINE__[(std::numeric_limits<genIUType>::is_integer) ? 1 : -1];
		(void)( (!!(Offset + Bits <= sizeof(genIUType))) || (_wassert(L"Offset + Bits <= sizeof(genIUType)", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_integer.inl", 349), 0) );

		if(Bits == 0)
			return Base;

		genIUType Mask = 0;
		for(int Bit = Offset; Bit < Offset + Bits; ++Bit)
			Mask |= (1 << Bit);

		return (Base & ~Mask) | (Insert & Mask);
	}

	template <typename T>
	 inline detail::tvec2<T> bitfieldInsert
	(
		detail::tvec2<T> const & Base, 
		detail::tvec2<T> const & Insert, 
		int const & Offset, 
		int const & Bits
	)
	{
		return detail::tvec2<T>(
			bitfieldInsert(Base[0], Insert[0], Offset, Bits),
			bitfieldInsert(Base[1], Insert[1], Offset, Bits));
	}

	template <typename T>
	 inline detail::tvec3<T> bitfieldInsert
	(
		detail::tvec3<T> const & Base, 
		detail::tvec3<T> const & Insert, 
		int const & Offset, 
		int const & Bits
	)
	{
		return detail::tvec3<T>(
			bitfieldInsert(Base[0], Insert[0], Offset, Bits),
			bitfieldInsert(Base[1], Insert[1], Offset, Bits),
			bitfieldInsert(Base[2], Insert[2], Offset, Bits));
	}

	template <typename T>
	 inline detail::tvec4<T> bitfieldInsert
	(
		detail::tvec4<T> const & Base, 
		detail::tvec4<T> const & Insert, 
		int const & Offset, 
		int const & Bits
	)
	{
		return detail::tvec4<T>(
			bitfieldInsert(Base[0], Insert[0], Offset, Bits),
			bitfieldInsert(Base[1], Insert[1], Offset, Bits),
			bitfieldInsert(Base[2], Insert[2], Offset, Bits),
			bitfieldInsert(Base[3], Insert[3], Offset, Bits));
	}

	
	template <typename genIUType>
	 inline genIUType bitfieldReverse(genIUType const & Value)
	{
		typedef char __CASSERT____LINE__[(std::numeric_limits<genIUType>::is_integer) ? 1 : -1];

		genIUType Out = 0;
		std::size_t BitSize = sizeof(genIUType) * 8;
		for(std::size_t i = 0; i < BitSize; ++i)
			if(Value & (genIUType(1) << i))
				Out |= genIUType(1) << (BitSize - 1 - i);
		return Out;
	}	

	template <typename T>  inline detail::tvec2<T> bitfieldReverse( detail::tvec2<T> const & v) { return detail::tvec2<T>( bitfieldReverse(v.x), bitfieldReverse(v.y)); } template <typename T>  inline detail::tvec3<T> bitfieldReverse( detail::tvec3<T> const & v) { return detail::tvec3<T>( bitfieldReverse(v.x), bitfieldReverse(v.y), bitfieldReverse(v.z)); } template <typename T>  inline detail::tvec4<T> bitfieldReverse( detail::tvec4<T> const & v) { return detail::tvec4<T>( bitfieldReverse(v.x), bitfieldReverse(v.y), bitfieldReverse(v.z), bitfieldReverse(v.w)); }

	
	template <typename genIUType>
	 inline int bitCount(genIUType const & Value)
	{
		typedef char __CASSERT____LINE__[(std::numeric_limits<genIUType>::is_integer) ? 1 : -1];

		int Count = 0;
		for(std::size_t i = 0; i < sizeof(genIUType) * std::size_t(8); ++i)
		{
			if(Value & (1 << i))
				++Count;
		}
		return Count;
	}

	template <typename T>
	 inline detail::tvec2<int> bitCount
	(
		detail::tvec2<T> const & value
	)
	{
		return detail::tvec2<int>(
			bitCount(value[0]),
			bitCount(value[1]));
	}

	template <typename T>
	 inline detail::tvec3<int> bitCount
	(
		detail::tvec3<T> const & value
	)
	{
		return detail::tvec3<int>(
			bitCount(value[0]),
			bitCount(value[1]),
			bitCount(value[2]));
	}

	template <typename T>
	 inline detail::tvec4<int> bitCount
	(
		detail::tvec4<T> const & value
	)
	{
		return detail::tvec4<int>(
			bitCount(value[0]),
			bitCount(value[1]),
			bitCount(value[2]),
			bitCount(value[3]));
	}

	
	template <typename genIUType>
	 inline int findLSB
	(
		genIUType const & Value
	)
	{
		typedef char __CASSERT____LINE__[(std::numeric_limits<genIUType>::is_integer) ? 1 : -1];
		if(Value == 0)
			return -1;

		genIUType Bit;
		for(Bit = genIUType(0); !(Value & (1 << Bit)); ++Bit){}
		return Bit;
	}

	template <typename T>
	 inline detail::tvec2<int> findLSB
	(
		detail::tvec2<T> const & value
	)
	{
		return detail::tvec2<int>(
			findLSB(value[0]),
			findLSB(value[1]));
	}

	template <typename T>
	 inline detail::tvec3<int> findLSB
	(
		detail::tvec3<T> const & value
	)
	{
		return detail::tvec3<int>(
			findLSB(value[0]),
			findLSB(value[1]),
			findLSB(value[2]));
	}

	template <typename T>
	 inline detail::tvec4<int> findLSB
	(
		detail::tvec4<T> const & value
	)
	{
		return detail::tvec4<int>(
			findLSB(value[0]),
			findLSB(value[1]),
			findLSB(value[2]),
			findLSB(value[3]));
	}

	







































#line 566 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_integer.inl"



















	template <typename genIUType>
	 inline int findMSB
	(
		genIUType const & Value
	)
	{
		typedef char __CASSERT____LINE__[(std::numeric_limits<genIUType>::is_integer) ? 1 : -1];
		
		if(Value == genIUType(0) || Value == genIUType(-1))
			return -1;
		else if(Value > 0)
		{
			genIUType Bit = genIUType(-1);
			for(genIUType tmp = Value; tmp > 0; tmp >>= 1, ++Bit){}
			return Bit;
		}
		else 
		{
			int const BitCount(sizeof(genIUType) * 8);
			int MostSignificantBit(-1);
			for(int BitIndex(0); BitIndex < BitCount; ++BitIndex)
				MostSignificantBit = (Value & (1 << BitIndex)) ? MostSignificantBit : BitIndex;
			(void)( (!!(MostSignificantBit >= 0)) || (_wassert(L"MostSignificantBit >= 0", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_integer.inl", 607), 0) );
			return MostSignificantBit;
		}
	}
#line 612 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_integer.inl"

	template <typename T>
	 inline detail::tvec2<int> findMSB
	(
		detail::tvec2<T> const & value
	)
	{
		return detail::tvec2<int>(
			findMSB(value[0]),
			findMSB(value[1]));
	}

	template <typename T>
	 inline detail::tvec3<int> findMSB
	(
		detail::tvec3<T> const & value
	)
	{
		return detail::tvec3<int>(
			findMSB(value[0]),
			findMSB(value[1]),
			findMSB(value[2]));
	}

	template <typename T>
	 inline detail::tvec4<int> findMSB
	(
		detail::tvec4<T> const & value
	)
	{
		return detail::tvec4<int>(
			findMSB(value[0]),
			findMSB(value[1]),
			findMSB(value[2]),
			findMSB(value[3]));
	}
}
#line 199 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_integer.hpp"

#line 201 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_integer.hpp"

#line 108 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_noise.hpp"








































namespace glm
{
	
	

	
	
	
	
	
	
	template <typename genType>
	 typename genType::value_type noise1(genType const & x);

	
	
	
	
	
	
	template <typename genType>
	 detail::tvec2<typename genType::value_type> noise2(genType const & x);

	
	
	
	
	
	
	template <typename genType>
	 detail::tvec3<typename genType::value_type> noise3(genType const & x);

	
	
	
	
	
	
	template <typename genType>
	 detail::tvec4<typename genType::value_type> noise4(genType const & x);

	
}

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_noise.inl"




























namespace glm
{
	template <typename T>
	 inline T noise1(T const & x)
	{
		return noise1(glm::detail::tvec2<T>(x, T(0)));
	}

	template <typename T>
	 inline glm::detail::tvec2<T> noise2(T const & x)
	{
		return glm::detail::tvec2<T>(
			noise1(x + T(0.0)),
			noise1(x + T(1.0)));
	}

	template <typename T>
	 inline glm::detail::tvec3<T> noise3(T const & x)
	{
		return glm::detail::tvec3<T>(
			noise1(x - T(1.0)),
			noise1(x + T(0.0)),
			noise1(x + T(1.0)));
	}

	template <typename T>
	 inline glm::detail::tvec4<T> noise4(T const & x)
	{
		return glm::detail::tvec4<T>(
			noise1(x - T(1.0)),
			noise1(x + T(0.0)),
			noise1(x + T(1.0)),
			noise1(x + T(2.0)));
	}
	
	template <typename T>
	 inline T noise1(glm::detail::tvec2<T> const & v)
	{
		detail::tvec4<T> const C = detail::tvec4<T>(
													T( 0.211324865405187),  
													T( 0.366025403784439),  
													T(-0.577350269189626),	
													T( 0.024390243902439)); 
		
		
		detail::tvec2<T> i  = floor(v + dot(v, detail::tvec2<T>(C[1])));
		detail::tvec2<T> x0 = v -   i + dot(i, detail::tvec2<T>(C[0]));
		
		
		
		
		detail::tvec2<T> i1 = (x0.x > x0.y) ? detail::tvec2<T>(1, 0) : detail::tvec2<T>(0, 1);
		
		
		
		detail::tvec4<T> x12 = detail::tvec4<T>(x0.x, x0.y, x0.x, x0.y) + detail::tvec4<T>(C.x, C.x, C.z, C.z);
		x12 = detail::tvec4<T>(detail::tvec2<T>(x12) - i1, x12.z, x12.w);
		
		
		i = mod(i, T(289)); 
		detail::tvec3<T> p = permute(
									 permute(i.y + detail::tvec3<T>(T(0), i1.y, T(1)))
									 + i.x + detail::tvec3<T>(T(0), i1.x, T(1)));
		
		detail::tvec3<T> m = max(T(0.5) - detail::tvec3<T>(
														   dot(x0, x0), 
														   dot(detail::tvec2<T>(x12.x, x12.y), detail::tvec2<T>(x12.x, x12.y)), 
														   dot(detail::tvec2<T>(x12.z, x12.w), detail::tvec2<T>(x12.z, x12.w))), T(0));
		m = m * m ;
		m = m * m ;
		
		
		
		
		detail::tvec3<T> x = T(2) * fract(p * C.w) - T(1);
		detail::tvec3<T> h = abs(x) - T(0.5);
		detail::tvec3<T> ox = floor(x + T(0.5));
		detail::tvec3<T> a0 = x - ox;
		
		
		
		m *= T(1.79284291400159) - T(0.85373472095314) * (a0 * a0 + h * h);
		
		
		detail::tvec3<T> g;
		g.x  = a0.x  * x0.x  + h.x  * x0.y;
		
		g.y = a0.y * x12.x + h.y * x12.y;
		g.z = a0.z * x12.z + h.z * x12.w;
		return T(130) * dot(m, g);
	}
	
	template <typename T>
	 inline T noise1(detail::tvec3<T> const & v)
	{ 
		detail::tvec2<T> const C(1.0 / 6.0, 1.0 / 3.0);
		detail::tvec4<T> const D(0.0, 0.5, 1.0, 2.0);
		
		
		detail::tvec3<T> i(floor(v + dot(v, detail::tvec3<T>(C.y))));
		detail::tvec3<T> x0(v - i + dot(i, detail::tvec3<T>(C.x)));
		
		
		detail::tvec3<T> g(step(detail::tvec3<T>(x0.y, x0.z, x0.x), x0));
		detail::tvec3<T> l(T(1) - g);
		detail::tvec3<T> i1(min(g, detail::tvec3<T>(l.z, l.x, l.y)));
		detail::tvec3<T> i2(max(g, detail::tvec3<T>(l.z, l.x, l.y)));
		
		
		
		
		
		detail::tvec3<T> x1(x0 - i1 + C.x);
		detail::tvec3<T> x2(x0 - i2 + C.y); 
		detail::tvec3<T> x3(x0 - D.y);      
		
		
		i = mod289(i); 
		detail::tvec4<T> p(permute(permute(permute( 
												   i.z + detail::tvec4<T>(T(0), i1.z, i2.z, T(1))) + 
										   i.y + detail::tvec4<T>(T(0), i1.y, i2.y, T(1))) + 
								   i.x + detail::tvec4<T>(T(0), i1.x, i2.x, T(1))));
		
		
		
		T n_ = T(0.142857142857); 
		detail::tvec3<T> ns(n_ * detail::tvec3<T>(D.w, D.y, D.z) - detail::tvec3<T>(D.x, D.z, D.x));
		
		detail::tvec4<T> j(p - T(49) * floor(p * ns.z * ns.z));  
		
		detail::tvec4<T> x_(floor(j * ns.z));
		detail::tvec4<T> y_(floor(j - T(7) * x_));    
		
		detail::tvec4<T> x(x_ * ns.x + ns.y);
		detail::tvec4<T> y(y_ * ns.x + ns.y);
		detail::tvec4<T> h(T(1) - abs(x) - abs(y));
		
		detail::tvec4<T> b0(x.x, x.y, y.x, y.y);
		detail::tvec4<T> b1(x.z, x.w, y.z, y.w);
		
		
		
		detail::tvec4<T> s0(floor(b0) * T(2) + T(1));
		detail::tvec4<T> s1(floor(b1) * T(2) + T(1));
		detail::tvec4<T> sh(-step(h, detail::tvec4<T>(0.0)));
		
		detail::tvec4<T> a0 = detail::tvec4<T>(b0.x, b0.z, b0.y, b0.w) + detail::tvec4<T>(s0.x, s0.z, s0.y, s0.w) * detail::tvec4<T>(sh.x, sh.x, sh.y, sh.y);
		detail::tvec4<T> a1 = detail::tvec4<T>(b1.x, b1.z, b1.y, b1.w) + detail::tvec4<T>(s1.x, s1.z, s1.y, s1.w) * detail::tvec4<T>(sh.z, sh.z, sh.w, sh.w);
		
		detail::tvec3<T> p0(a0.x, a0.y, h.x);
		detail::tvec3<T> p1(a0.z, a0.w, h.y);
		detail::tvec3<T> p2(a1.x, a1.y, h.z);
		detail::tvec3<T> p3(a1.z, a1.w, h.w);
		
		
		detail::tvec4<T> norm = taylorInvSqrt(detail::tvec4<T>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
		p0 *= norm.x;
		p1 *= norm.y;
		p2 *= norm.z;
		p3 *= norm.w;
		
		
		detail::tvec4<T> m = max(T(0.6) - detail::tvec4<T>(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), T(0));
		m = m * m;
		return T(42) * dot(m * m, detail::tvec4<T>(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
	}
	
	template <typename T>
	 inline T noise1(detail::tvec4<T> const & v)
	{
		detail::tvec4<T> const C(
								 0.138196601125011,  
								 0.276393202250021,  
								 0.414589803375032,  
								 -0.447213595499958); 
		
		
		T const F4 = T(0.309016994374947451);
		
		
		detail::tvec4<T> i  = floor(v + dot(v, vec4(F4)));
		detail::tvec4<T> x0 = v -   i + dot(i, vec4(C.x));
		
		
		
		
		detail::tvec4<T> i0;
		detail::tvec3<T> isX = step(detail::tvec3<T>(x0.y, x0.z, x0.w), detail::tvec3<T>(x0.x));
		detail::tvec3<T> isYZ = step(detail::tvec3<T>(x0.z, x0.w, x0.w), detail::tvec3<T>(x0.y, x0.y, x0.z));
		
		
		
		i0 = detail::tvec4<T>(isX.x + isX.y + isX.z, T(1) - isX);
		
		i0.y += isYZ.x + isYZ.y;
		
		i0.z += T(1) - isYZ.x;
		i0.w += T(1) - isYZ.y;
		i0.z += isYZ.z;
		i0.w += T(1) - isYZ.z;
		
		
		detail::tvec4<T> i3 = clamp(i0, 0.0, 1.0);
		detail::tvec4<T> i2 = clamp(i0 - 1.0, 0.0, 1.0);
		detail::tvec4<T> i1 = clamp(i0 - 2.0, 0.0, 1.0);
		
		
		
		
		
		
		detail::tvec4<T> x1 = x0 - i1 + C.x;
		detail::tvec4<T> x2 = x0 - i2 + C.y;
		detail::tvec4<T> x3 = x0 - i3 + C.z;
		detail::tvec4<T> x4 = x0 + C.w;
		
		
		i = mod(i, T(289)); 
		T j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);
		detail::tvec4<T> j1 = permute(permute(permute(permute(
															  i.w + detail::tvec4<T>(i1.w, i2.w, i3.w, T(1)))
													  + i.z + detail::tvec4<T>(i1.z, i2.z, i3.z, T(1)))
											  + i.y + detail::tvec4<T>(i1.y, i2.y, i3.y, T(1)))
									  + i.x + detail::tvec4<T>(i1.x, i2.x, i3.x, T(1)));
		
		
		
		detail::tvec4<T> ip = detail::tvec4<T>(T(1) / T(294), T(1) / T(49), T(1) / T(7), T(0));
		
		detail::tvec4<T> p0 = grad4(j0,   ip);
		detail::tvec4<T> p1 = grad4(j1.x, ip);
		detail::tvec4<T> p2 = grad4(j1.y, ip);
		detail::tvec4<T> p3 = grad4(j1.z, ip);
		detail::tvec4<T> p4 = grad4(j1.w, ip);
		
		
		detail::tvec4<T> norm = taylorInvSqrt(detail::tvec4<T>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
		p0 *= norm.x;
		p1 *= norm.y;
		p2 *= norm.z;
		p3 *= norm.w;
		p4 *= taylorInvSqrt(dot(p4, p4));
		
		
		detail::tvec3<T> m0 = max(T(0.6) - detail::tvec3<T>(dot(x0, x0), dot(x1, x1), dot(x2, x2)), T(0));
		detail::tvec2<T> m1 = max(T(0.6) - detail::tvec2<T>(dot(x3, x3), dot(x4, x4)             ), T(0));
		m0 = m0 * m0;
		m1 = m1 * m1;
		return T(49) * 
		(dot(m0 * m0, detail::tvec3<T>(dot(p0, x0), dot(p1, x1), dot(p2, x2))) + 
		 dot(m1 * m1, detail::tvec2<T>(dot(p3, x3), dot(p4, x4))));
	}
	
	template <typename T>
	 inline glm::detail::tvec2<T> noise2(glm::detail::tvec2<T> const & x)
	{
		return glm::detail::tvec2<T>(
			noise1(x + glm::detail::tvec2<T>(0.0)),
			noise1(glm::detail::tvec2<T>(0.0) - x));
	}
	
	template <typename T>
	 inline glm::detail::tvec2<T> noise2(glm::detail::tvec3<T> const & x)
	{
		return glm::detail::tvec2<T>(
			noise1(x + glm::detail::tvec3<T>(0.0)),
			noise1(glm::detail::tvec3<T>(0.0) - x));
	}
	
	template <typename T>
	 inline glm::detail::tvec2<T> noise2(glm::detail::tvec4<T> const & x)
	{
		return glm::detail::tvec2<T>(
			noise1(x + glm::detail::tvec4<T>(0.0)),
			noise1(glm::detail::tvec4<T>(0.0) - x));
	}
	
	template <typename T>
	 inline glm::detail::tvec3<T> noise3(glm::detail::tvec2<T> const & x)
	{
		return glm::detail::tvec3<T>(
			noise1(x - glm::detail::tvec2<T>(1.0)),
			noise1(x + glm::detail::tvec2<T>(0.0)),
			noise1(x + glm::detail::tvec2<T>(1.0)));
	}
	
	template <typename T>
	 inline glm::detail::tvec3<T> noise3(glm::detail::tvec3<T> const & x)
	{
		return glm::detail::tvec3<T>(
			noise1(x - glm::detail::tvec3<T>(1.0)),
			noise1(x + glm::detail::tvec3<T>(0.0)),
			noise1(x + glm::detail::tvec3<T>(1.0)));
	}
	
	template <typename T>
	 inline glm::detail::tvec3<T> noise3(glm::detail::tvec4<T> const & x)
	{
		return glm::detail::tvec3<T>(
			noise1(x - glm::detail::tvec4<T>(1.0)),
			noise1(x + glm::detail::tvec4<T>(0.0)),
			noise1(x + glm::detail::tvec4<T>(1.0)));
	}
	
	template <typename T>
	 inline glm::detail::tvec4<T> noise4(glm::detail::tvec2<T> const & x)
	{
		return glm::detail::tvec4<T>(
			noise1(x - glm::detail::tvec2<T>(1.0)),
			noise1(x + glm::detail::tvec2<T>(0.0)),
			noise1(x + glm::detail::tvec2<T>(1.0)),
			noise1(x + glm::detail::tvec2<T>(2.0)));
	}

	
	template <typename T>
	 inline glm::detail::tvec4<T> noise4(glm::detail::tvec3<T> const & x)
	{
		return glm::detail::tvec4<T>(
			noise1(x - glm::detail::tvec3<T>(1.0)),
			noise1(x + glm::detail::tvec3<T>(0.0)),
			noise1(x + glm::detail::tvec3<T>(1.0)),
			noise1(x + glm::detail::tvec3<T>(2.0)));
	}
	
	template <typename T>
	 inline glm::detail::tvec4<T> noise4(glm::detail::tvec4<T> const & x)
	{
		return glm::detail::tvec4<T>(
			noise1(x - glm::detail::tvec4<T>(1.0)),
			noise1(x + glm::detail::tvec4<T>(0.0)),
			noise1(x + glm::detail::tvec4<T>(1.0)),
			noise1(x + glm::detail::tvec4<T>(2.0)));
	}
	
}
#line 86 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_noise.hpp"

#line 88 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\func_noise.hpp"
#line 109 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"





	typedef char __CASSERT____LINE__[(sizeof(glm::detail::int8) == 1) ? 1 : -1];
	typedef char __CASSERT____LINE__[(sizeof(glm::detail::int16) == 2) ? 1 : -1];
	typedef char __CASSERT____LINE__[(sizeof(glm::detail::int32) == 4) ? 1 : -1];
	typedef char __CASSERT____LINE__[(sizeof(glm::detail::int64) == 8) ? 1 : -1];

	typedef char __CASSERT____LINE__[(sizeof(glm::detail::uint8) == 1) ? 1 : -1];
	typedef char __CASSERT____LINE__[(sizeof(glm::detail::uint16) == 2) ? 1 : -1];
	typedef char __CASSERT____LINE__[(sizeof(glm::detail::uint32) == 4) ? 1 : -1];
	typedef char __CASSERT____LINE__[(sizeof(glm::detail::uint64) == 8) ? 1 : -1];

	typedef char __CASSERT____LINE__[(sizeof(glm::detail::float16) == 2) ? 1 : -1];
	typedef char __CASSERT____LINE__[(sizeof(glm::detail::float32) == 4) ? 1 : -1];
	typedef char __CASSERT____LINE__[(sizeof(glm::detail::float64) == 8) ? 1 : -1];
#line 128 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"

#line 130 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"
#line 19 "d:\\my documents\\programs\\jotunengine2\\stdafx.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\gtc\\matrix_transform.hpp"

















































#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"













































































#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\core\\_fixes.hpp"























































#line 79 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\glm.hpp"



















































#line 51 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\gtc\\matrix_transform.hpp"



#line 55 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\gtc\\matrix_transform.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename T> 
	detail::tmat4x4<T> translate(
		detail::tmat4x4<T> const & m,
		detail::tvec3<T> const & v);
		
	
	
	
	
	
	
	
	
	
	
	
	template <typename T> 
	detail::tmat4x4<T> rotate(
		detail::tmat4x4<T> const & m,
		T const & angle, 
		detail::tvec3<T> const & axis);

	
	
	
	
	
	
	
	
	
	
	template <typename T> 
	detail::tmat4x4<T> scale(
		detail::tmat4x4<T> const & m,
		detail::tvec3<T> const & v);

	
	
	
	
	
	
	
	
	
	
	
	template <typename T> 
	detail::tmat4x4<T> ortho(
		T const & left, 
		T const & right, 
		T const & bottom, 
		T const & top, 
		T const & zNear, 
		T const & zFar);

	
	
	
	
	
	
	
	
    
	template <typename T> 
	detail::tmat4x4<T> ortho(
		T const & left, 
		T const & right, 
		T const & bottom, 
		T const & top);

	
	
	
	
	
	
	
	
	
	
	template <typename T> 
	detail::tmat4x4<T> frustum(
		T const & left, 
		T const & right, 
		T const & bottom, 
		T const & top, 
		T const & near, 
		T const & far);

	
	
	
	
	
	
	
	
	template <typename T> 
	detail::tmat4x4<T> perspective(
		T const & fovy, 
		T const & aspect, 
		T const & near, 
		T const & far);

	
	
	
	
	
	
	
	
	
	template <typename valType> 
	detail::tmat4x4<valType> perspectiveFov(
		valType const & fov, 
		valType const & width, 
		valType const & height, 
		valType const & near, 
		valType const & far);

	
	
	
	
	
	
	
    template <typename T> 
	detail::tmat4x4<T> infinitePerspective(
		T fovy, T aspect, T near);

	
	
	
	
	
	
	
    template <typename T> 
	detail::tmat4x4<T> tweakedInfinitePerspective(
		T fovy, T aspect, T near);

	
	
	
	
	
	
	
	
	
	template <typename T, typename U> 
	detail::tvec3<T> project(
		detail::tvec3<T> const & obj, 
		detail::tmat4x4<T> const & model, 
		detail::tmat4x4<T> const & proj, 
		detail::tvec4<U> const & viewport);

	
	
	
	
	
	
	
	
	
	template <typename T, typename U> 
	detail::tvec3<T> unProject(
		detail::tvec3<T> const & win, 
		detail::tmat4x4<T> const & model, 
		detail::tmat4x4<T> const & proj, 
		detail::tvec4<U> const & viewport);

	
	
	
	
	
	
	
	
	template <typename T, typename U> 
	detail::tmat4x4<T> pickMatrix(
		detail::tvec2<T> const & center, 
		detail::tvec2<T> const & delta, 
		detail::tvec4<U> const & viewport);

	
	
	
	
	
	
	
	template <typename T> 
	detail::tmat4x4<T> lookAt(
		detail::tvec3<T> const & eye, 
		detail::tvec3<T> const & center, 
		detail::tvec3<T> const & up);

	
}

#line 1 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\gtc\\matrix_transform.inl"




























namespace glm
{
	template <typename T> 
	 inline detail::tmat4x4<T> translate
	(
		detail::tmat4x4<T> const & m,
		detail::tvec3<T> const & v
	)
	{
		detail::tmat4x4<T> Result(m);
		Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
		return Result;
	}
		
	template <typename T> 
	 inline detail::tmat4x4<T> rotate
	(
		detail::tmat4x4<T> const & m,
		T const & angle, 
		detail::tvec3<T> const & v
	)
	{



		T a = radians(angle);		
#line 56 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\gtc\\matrix_transform.inl"
		T c = cos(a);
		T s = sin(a);

		detail::tvec3<T> axis = normalize(v);

		detail::tvec3<T> temp = (T(1) - c) * axis;

		detail::tmat4x4<T> Rotate(detail::tmat4x4<T>::null);
		Rotate[0][0] = c + temp[0] * axis[0];
		Rotate[0][1] = 0 + temp[0] * axis[1] + s * axis[2];
		Rotate[0][2] = 0 + temp[0] * axis[2] - s * axis[1];

		Rotate[1][0] = 0 + temp[1] * axis[0] - s * axis[2];
		Rotate[1][1] = c + temp[1] * axis[1];
		Rotate[1][2] = 0 + temp[1] * axis[2] + s * axis[0];

		Rotate[2][0] = 0 + temp[2] * axis[0] + s * axis[1];
		Rotate[2][1] = 0 + temp[2] * axis[1] - s * axis[0];
		Rotate[2][2] = c + temp[2] * axis[2];

		detail::tmat4x4<T> Result(detail::tmat4x4<T>::null);
		Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
		Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
		Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
		Result[3] = m[3];
		return Result;
	}

	template <typename T> 
	 inline detail::tmat4x4<T> scale
	(
		detail::tmat4x4<T> const & m,
		detail::tvec3<T> const & v
	)
	{
		detail::tmat4x4<T> Result(detail::tmat4x4<T>::null);
		Result[0] = m[0] * v[0];
		Result[1] = m[1] * v[1];
		Result[2] = m[2] * v[2];
		Result[3] = m[3];
		return Result;
	}

	template <typename T> 
	 inline detail::tmat4x4<T> translate_slow
	(
		detail::tmat4x4<T> const & m,
		detail::tvec3<T> const & v
	)
	{
		detail::tmat4x4<T> Result(T(1));
		Result[3] = detail::tvec4<T>(v, T(1));
		return m * Result;

		
		Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
		
		
		
		
		
	}
		
	template <typename T> 
	 inline detail::tmat4x4<T> rotate_slow
	(
		detail::tmat4x4<T> const & m,
		T const & angle, 
		detail::tvec3<T> const & v
	)
	{



		T const a = radians(angle);
#line 132 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\gtc\\matrix_transform.inl"
		T c = cos(a);
		T s = sin(a);
		detail::tmat4x4<T> Result;

		detail::tvec3<T> axis = normalize(v);

		Result[0][0] = c + (1 - c)      * axis.x     * axis.x;
		Result[0][1] = (1 - c) * axis.x * axis.y + s * axis.z;
		Result[0][2] = (1 - c) * axis.x * axis.z - s * axis.y;
		Result[0][3] = 0;

		Result[1][0] = (1 - c) * axis.y * axis.x - s * axis.z;
		Result[1][1] = c + (1 - c) * axis.y * axis.y;
		Result[1][2] = (1 - c) * axis.y * axis.z + s * axis.x;
		Result[1][3] = 0;

		Result[2][0] = (1 - c) * axis.z * axis.x + s * axis.y;
		Result[2][1] = (1 - c) * axis.z * axis.y - s * axis.x;
		Result[2][2] = c + (1 - c) * axis.z * axis.z;
		Result[2][3] = 0;

		Result[3] = detail::tvec4<T>(0, 0, 0, 1);
		return m * Result;
	}

	template <typename T> 
	 inline detail::tmat4x4<T> scale_slow
	(
		detail::tmat4x4<T> const & m,
		detail::tvec3<T> const & v
	)
	{
		detail::tmat4x4<T> Result(T(1));
		Result[0][0] = v.x;
		Result[1][1] = v.y;
		Result[2][2] = v.z;
		return m * Result;
	}

	template <typename valType> 
	 inline detail::tmat4x4<valType> ortho
	(
		valType const & left, 
		valType const & right, 
		valType const & bottom, 
		valType const & top, 
		valType const & zNear, 
		valType const & zFar
	)
	{
		detail::tmat4x4<valType> Result(1);
		Result[0][0] = valType(2) / (right - left);
		Result[1][1] = valType(2) / (top - bottom);
		Result[2][2] = - valType(2) / (zFar - zNear);
		Result[3][0] = - (right + left) / (right - left);
		Result[3][1] = - (top + bottom) / (top - bottom);
		Result[3][2] = - (zFar + zNear) / (zFar - zNear);
		return Result;
	}

	template <typename valType> 
	 inline detail::tmat4x4<valType> ortho(
		valType const & left, 
		valType const & right, 
		valType const & bottom, 
		valType const & top)
	{
		detail::tmat4x4<valType> Result(1);
		Result[0][0] = valType(2) / (right - left);
		Result[1][1] = valType(2) / (top - bottom);
		Result[2][2] = - valType(1);
		Result[3][0] = - (right + left) / (right - left);
		Result[3][1] = - (top + bottom) / (top - bottom);
		return Result;
	}

	template <typename valType> 
	 inline detail::tmat4x4<valType> frustum
	(
		valType const & left, 
		valType const & right, 
		valType const & bottom, 
		valType const & top, 
		valType const & nearVal, 
		valType const & farVal
	)
	{
		detail::tmat4x4<valType> Result(0);
		Result[0][0] = (valType(2) * nearVal) / (right - left);
		Result[1][1] = (valType(2) * nearVal) / (top - bottom);
		Result[2][0] = (right + left) / (right - left);
		Result[2][1] = (top + bottom) / (top - bottom);
		Result[2][2] = -(farVal + nearVal) / (farVal - nearVal);
		Result[2][3] = valType(-1);
		Result[3][2] = -(valType(2) * farVal * nearVal) / (farVal - nearVal);
		return Result;
	}

	template <typename valType> 
	 inline detail::tmat4x4<valType> perspective
	(
		valType const & fovy, 
		valType const & aspect, 
		valType const & zNear, 
		valType const & zFar
	)
	{
		(void)( (!!(aspect != valType(0))) || (_wassert(L"aspect != valType(0)", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\gtc\\matrix_transform.inl", 239), 0) );
		(void)( (!!(zFar != zNear)) || (_wassert(L"zFar != zNear", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\gtc\\matrix_transform.inl", 240), 0) );




		valType const rad = glm::radians(fovy);
#line 247 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\gtc\\matrix_transform.inl"

		valType tanHalfFovy = tan(rad / valType(2));
		detail::tmat4x4<valType> Result(valType(0));
		Result[0][0] = valType(1) / (aspect * tanHalfFovy);
		Result[1][1] = valType(1) / (tanHalfFovy);
		Result[2][2] = - (zFar + zNear) / (zFar - zNear);
		Result[2][3] = - valType(1);
		Result[3][2] = - (valType(2) * zFar * zNear) / (zFar - zNear);
		return Result;
	}
	
	template <typename valType>
	 inline detail::tmat4x4<valType> perspectiveFov
	(
		valType const & fov, 
		valType const & width, 
		valType const & height, 
		valType const & zNear, 
		valType const & zFar
	)
	{



		valType rad = glm::radians(fov);
#line 273 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\gtc\\matrix_transform.inl"
		valType h = glm::cos(valType(0.5) * rad) / glm::sin(valType(0.5) * rad);
		valType w = h * height / width; 

		detail::tmat4x4<valType> Result(valType(0));
		Result[0][0] = w;
		Result[1][1] = h;
		Result[2][2] = - (zFar + zNear) / (zFar - zNear);
		Result[2][3] = - valType(1);
		Result[3][2] = - (valType(2) * zFar * zNear) / (zFar - zNear);
		return Result;
	}

	template <typename T> 
	 inline detail::tmat4x4<T> infinitePerspective
	(
		T fovy, 
		T aspect, 
		T zNear
	)
	{



		T const range = tan(radians(fovy / T(2))) * zNear;	
#line 298 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\gtc\\matrix_transform.inl"
		T left = -range * aspect;
		T right = range * aspect;
		T bottom = -range;
		T top = range;

		detail::tmat4x4<T> Result(T(0));
		Result[0][0] = (T(2) * zNear) / (right - left);
		Result[1][1] = (T(2) * zNear) / (top - bottom);
		Result[2][2] = - T(1);
		Result[2][3] = - T(1);
		Result[3][2] = - T(2) * zNear;
		return Result;
	}

	template <typename T> 
	 inline detail::tmat4x4<T> tweakedInfinitePerspective
	(
		T fovy, 
		T aspect, 
		T zNear
	)
	{



		T range = tan(radians(fovy / T(2))) * zNear;	
#line 325 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\gtc\\matrix_transform.inl"
		T left = -range * aspect;
		T right = range * aspect;
		T bottom = -range;
		T top = range;

		detail::tmat4x4<T> Result(T(0));
		Result[0][0] = (T(2) * zNear) / (right - left);
		Result[1][1] = (T(2) * zNear) / (top - bottom);
		Result[2][2] = T(0.0001) - T(1);
		Result[2][3] = T(-1);
		Result[3][2] = - (T(0.0001) - T(2)) * zNear;
		return Result;
	}

	template <typename T, typename U>
	 inline detail::tvec3<T> project
	(
		detail::tvec3<T> const & obj, 
		detail::tmat4x4<T> const & model, 
		detail::tmat4x4<T> const & proj, 
		detail::tvec4<U> const & viewport
	)
	{
		detail::tvec4<T> tmp = detail::tvec4<T>(obj, T(1));
		tmp = model * tmp;
		tmp = proj * tmp;

		tmp /= tmp.w;
		tmp = tmp * T(0.5) + T(0.5);
		tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
		tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

		return detail::tvec3<T>(tmp);
	}

	template <typename T, typename U>
	 inline detail::tvec3<T> unProject
	(
		detail::tvec3<T> const & win, 
		detail::tmat4x4<T> const & model, 
		detail::tmat4x4<T> const & proj, 
		detail::tvec4<U> const & viewport
	)
	{
		detail::tmat4x4<T> inverse = glm::inverse(proj * model);

		detail::tvec4<T> tmp = detail::tvec4<T>(win, T(1));
		tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
		tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);
		tmp = tmp * T(2) - T(1);

		detail::tvec4<T> obj = inverse * tmp;
		obj /= obj.w;

		return detail::tvec3<T>(obj);
	}

	template <typename T, typename U> 
	detail::tmat4x4<T> pickMatrix
	(
		detail::tvec2<T> const & center, 
		detail::tvec2<T> const & delta, 
		detail::tvec4<U> const & viewport
	)
	{
		(void)( (!!(delta.x > T(0) && delta.y > T(0))) || (_wassert(L"delta.x > T(0) && delta.y > T(0)", L"c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\gtc\\matrix_transform.inl", 390), 0) );
		detail::tmat4x4<T> Result(1.0f);

		if(!(delta.x > T(0) && delta.y > T(0))) 
			return Result; 

		detail::tvec3<T> Temp(
			(T(viewport[2]) - T(2) * (center.x - T(viewport[0]))) / delta.x,
			(T(viewport[3]) - T(2) * (center.y - T(viewport[1]))) / delta.y,
			T(0));

		
		Result = translate(Result, Temp);
		return scale(Result, detail::tvec3<T>(T(viewport[2]) / delta.x, T(viewport[3]) / delta.y, T(1)));
	}

	template <typename T> 
	 inline detail::tmat4x4<T> lookAt
	(
		detail::tvec3<T> const & eye,
		detail::tvec3<T> const & center,
		detail::tvec3<T> const & up
	)
	{
		detail::tvec3<T> f = normalize(center - eye);
		detail::tvec3<T> u = normalize(up);
		detail::tvec3<T> s = normalize(cross(f, u));
		u = cross(s, f);

		detail::tmat4x4<T> Result(1);
		Result[0][0] = s.x;
		Result[1][0] = s.y;
		Result[2][0] = s.z;
		Result[0][1] = u.x;
		Result[1][1] = u.y;
		Result[2][1] = u.z;
		Result[0][2] =-f.x;
		Result[1][2] =-f.y;
		Result[2][2] =-f.z;
		Result[3][0] =-dot(s, eye);
		Result[3][1] =-dot(u, eye);
		Result[3][2] = dot(f, eye);
		return Result;
	}
}
#line 290 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\gtc\\matrix_transform.hpp"

#line 292 "c:\\program files (x86)\\microsoft visual studio 12.0\\vc\\include\\gl\\glm\\gtc\\matrix_transform.hpp"
#line 20 "d:\\my documents\\programs\\jotunengine2\\stdafx.h"
using namespace glm;

#line 1 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"





























































































#line 95 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"



enum
{
   STBI_default = 0, 

   STBI_grey       = 1,
   STBI_grey_alpha = 2,
   STBI_rgb        = 3,
   STBI_rgb_alpha  = 4,
};

typedef unsigned char stbi_uc;


extern "C" {
#line 113 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"







extern int      stbi_write_bmp       (char const *filename,     int x, int y, int comp, void *data);
extern int      stbi_write_tga       (char const *filename,     int x, int y, int comp, void *data);
#line 123 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"





extern stbi_uc *stbi_load            (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi_load_from_file  (FILE *f,                  int *x, int *y, int *comp, int req_comp);
extern int      stbi_info_from_file  (FILE *f,                  int *x, int *y, int *comp);
#line 132 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"
extern stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);




extern float *stbi_loadf            (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern float *stbi_loadf_from_file  (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#line 140 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"
extern float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);

extern void   stbi_hdr_to_ldr_gamma(float gamma);
extern void   stbi_hdr_to_ldr_scale(float scale);

extern void   stbi_ldr_to_hdr_gamma(float gamma);
extern void   stbi_ldr_to_hdr_scale(float scale);

#line 149 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"



extern char    *stbi_failure_reason  (void); 


extern void     stbi_image_free      (void *retval_from_stbi_load);


extern int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
extern int      stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);

extern int      stbi_info            (char const *filename,     int *x, int *y, int *comp);
extern int      stbi_is_hdr          (char const *filename);
extern int      stbi_is_hdr_from_file(FILE *f);
#line 165 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"



extern char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
extern char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
extern int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

extern char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
extern int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);




extern int      stbi_jpeg_test_memory     (stbi_uc const *buffer, int len);
extern stbi_uc *stbi_jpeg_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
extern int      stbi_jpeg_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);


extern stbi_uc *stbi_jpeg_load            (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern int      stbi_jpeg_test_file       (FILE *f);
extern stbi_uc *stbi_jpeg_load_from_file  (FILE *f,                  int *x, int *y, int *comp, int req_comp);

extern int      stbi_jpeg_info            (char const *filename,     int *x, int *y, int *comp);
extern int      stbi_jpeg_info_from_file  (FILE *f,                  int *x, int *y, int *comp);
#line 190 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"


extern int      stbi_png_test_memory      (stbi_uc const *buffer, int len);
extern stbi_uc *stbi_png_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
extern int      stbi_png_info_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp);


extern stbi_uc *stbi_png_load             (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern int      stbi_png_info             (char const *filename,     int *x, int *y, int *comp);
extern int      stbi_png_test_file        (FILE *f);
extern stbi_uc *stbi_png_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
extern int      stbi_png_info_from_file   (FILE *f,                  int *x, int *y, int *comp);
#line 203 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"


extern int      stbi_bmp_test_memory      (stbi_uc const *buffer, int len);

extern stbi_uc *stbi_bmp_load             (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi_bmp_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);

extern int      stbi_bmp_test_file        (FILE *f);
extern stbi_uc *stbi_bmp_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#line 213 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"


extern int      stbi_tga_test_memory      (stbi_uc const *buffer, int len);

extern stbi_uc *stbi_tga_load             (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi_tga_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);

extern int      stbi_tga_test_file        (FILE *f);
extern stbi_uc *stbi_tga_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#line 223 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"


extern int      stbi_psd_test_memory      (stbi_uc const *buffer, int len);

extern stbi_uc *stbi_psd_load             (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi_psd_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);

extern int      stbi_psd_test_file        (FILE *f);
extern stbi_uc *stbi_psd_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#line 233 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"


extern int      stbi_hdr_test_memory      (stbi_uc const *buffer, int len);

extern float *  stbi_hdr_load             (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern float *  stbi_hdr_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);

extern int      stbi_hdr_test_file        (FILE *f);
extern float *  stbi_hdr_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#line 243 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"


typedef struct
{
   int       (*test_memory)(stbi_uc const *buffer, int len);
   stbi_uc * (*load_from_memory)(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
   
   int       (*test_file)(FILE *f);
   stbi_uc * (*load_from_file)(FILE *f, int *x, int *y, int *comp, int req_comp);
   #line 253 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"
} stbi_loader;




extern int stbi_register_loader(stbi_loader *loader);


















#line 278 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"


}
#line 282 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"




#line 287 "d:\\my documents\\programs\\jotunengine2\\stb_image.h"
#line 23 "d:\\my documents\\programs\\jotunengine2\\stdafx.h"


#line 1 "d:\\my documents\\programs\\jotunengine2\\inputhandler.h"
#pragma once
class InputHandler {
public:
	virtual void onKeyPress( int key ) = 0;
	virtual void onKeyRelease( int key ) = 0;
	virtual void onMouseMove( int deltaX, int deltaY ) = 0;
};

#line 26 "d:\\my documents\\programs\\jotunengine2\\stdafx.h"
#line 2 "d:\\my documents\\programs\\jotunengine2\\jotunengine2.h"

#line 1 "d:\\my documents\\programs\\jotunengine2\\camera.h"
#pragma once

#line 1 "d:\\my documents\\programs\\jotunengine2\\time.h"
#pragma once

class Time {
public:
	static void init();
	static void update();
	static float getTime();
	static float getDeltaTime();
private:
	static float lastTime, curTime, deltaTime;
};
#line 4 "d:\\my documents\\programs\\jotunengine2\\camera.h"
class Camera : public InputHandler {
public:
	Camera();
	Camera( glm::vec3 initPos );
	~Camera();
	
	void		lookAt( glm::vec3 pos );
	void		update();

	void		setFOV( float newFOV );
	void		setAspectRatio( float newAspectRatio );
	void		translate( glm::vec3 dir );
	void		rotate( float hRot, float vRot );

	virtual void onKeyPress( int key );
	virtual void onKeyRelease( int key );
	virtual void onMouseMove( int deltaX, int deltaY );

	float		getFOV();
	glm::vec3	getPosition();
	glm::vec3	getForward();
	glm::vec3   getUp();
	glm::vec3	getRight();
	glm::mat4	getViewMatrix();
	glm::mat4	getProjMatrix();
private:
	void init();

	
	float fov, aspectRatio, verticalAngle, horizontalAngle;
	float mouseSpeed;
	glm::vec3 position, up, right, forward;
	glm::mat4 viewMatrix, projMatrix;
};

#line 4 "d:\\my documents\\programs\\jotunengine2\\jotunengine2.h"
#line 1 "d:\\my documents\\programs\\jotunengine2\\mesh.h"
#pragma once

#line 1 "d:\\my documents\\programs\\jotunengine2\\vboindexer.h"





void indexVBO(
	std::vector<glm::vec3> & in_vertices,
	std::vector<glm::vec2> & in_uvs,
	std::vector<glm::vec3> & in_normals,

	std::vector<unsigned short> & out_indices,
	std::vector<glm::vec3> & out_vertices,
	std::vector<glm::vec2> & out_uvs,
	std::vector<glm::vec3> & out_normals
	);


void indexVBO_TBN(
	std::vector<glm::vec3> & in_vertices,
	std::vector<glm::vec2> & in_uvs,
	std::vector<glm::vec3> & in_normals,
	std::vector<glm::vec3> & in_tangents,
	std::vector<glm::vec3> & in_bitangents,

	std::vector<unsigned short> & out_indices,
	std::vector<glm::vec3> & out_vertices,
	std::vector<glm::vec2> & out_uvs,
	std::vector<glm::vec3> & out_normals,
	std::vector<glm::vec3> & out_tangents,
	std::vector<glm::vec3> & out_bitangents
	);

#line 34 "d:\\my documents\\programs\\jotunengine2\\vboindexer.h"
#line 4 "d:\\my documents\\programs\\jotunengine2\\mesh.h"










class Mesh {
public:
	Mesh( std::string name );
	~Mesh();
	void		drawShadowPass( GLuint verts );
	void		enable( GLuint verts, GLuint uvs, GLuint norms );
	void		bind();
	void		draw();
	void		disable(); 
private:
	void		loadMesh( std::vector<glm::vec3>&,
					std::vector<glm::vec2>&,
					std::vector<glm::vec3>& );
	void		makeGLMesh();
	std::string sName;
	std::vector<unsigned short> indices;
	std::vector<glm::vec3> indexed_vertices;
	std::vector<glm::vec2> indexed_uvs;
	std::vector<glm::vec3> indexed_normals;
	GLuint vertexbuffer, uvbuffer, normalbuffer, elementbuffer;
	GLuint verts, norms, uvs;
};

#line 5 "d:\\my documents\\programs\\jotunengine2\\jotunengine2.h"
#line 1 "d:\\my documents\\programs\\jotunengine2\\shader.h"
#pragma once


class Shader {
public:
	Shader( std::string vertName, std::string fragName );
	~Shader();
	void		genAttribMap( std::string varNames [], int numElems );
	void		genUniformMap( std::string varNames [], int numElems );
	void		setUniform1i( std::string name, int v1 );
	void		setUniform3f( std::string name, int v1, int v2, int v3 );
	void		setUniformMat4x4( std::string name, float* value );
	void		bind();
	GLuint		getAttribute( std::string attrib );
	GLuint		getGLName() { return glName; };
	std::string getSName() { return sName; };
private:
	void		loadShader( const char * vertFile, const char * fragFile );

	std::map<std::string, int> attribs;
	std::map<std::string, int> uniforms;
	std::string sName;
	GLuint		glName;
};
#line 6 "d:\\my documents\\programs\\jotunengine2\\jotunengine2.h"
#line 1 "d:\\my documents\\programs\\jotunengine2\\texture.h"
#pragma once

class Texture {
public:
	Texture( std::string name );
	~Texture();
	void		bind( int unit );
	GLuint		getGLName() { return glName; };
private:
	void		loadTexture();
	void		makeGLTex();
	int			width, height, comp;
	std::string sName;
	GLubyte		*data;
	GLuint		glName;
};

#line 7 "d:\\my documents\\programs\\jotunengine2\\jotunengine2.h"

#line 2 "d:\\my documents\\programs\\jotunengine2\\main.cpp"

int		init();
void	initOpenGL();
void	initData();
int		main();
void	draw();
void	destroy();
void	onGLFWError( int error, const char *description );
void	onGLFWKey( GLFWwindow *curWindow, int key, int scancode, int action, int mods );

std::vector<InputHandler*> inputHandlers;

GLFWwindow *window;

Camera *mainCamera, *lightCamera;

Shader *diffuse;
Shader *depth;
Shader *passthrough;

Mesh *mesh;

Texture *texture;

GLuint depthTexture;
GLuint FramebufferName = 0;

int init() {
	glfwSetErrorCallback( onGLFWError );
	
	if( !glfwInit() ) {
		fprintf( (&__iob_func()[2]), "Failed to initialize GLFW\n" );
		return -1;
	}

	glfwWindowHint( 0x0002100D, 4 );
	glfwWindowHint( 0x00022002, 2 );
	glfwWindowHint( 0x00022003, 1 );

	
	window = glfwCreateWindow( 1024, 786, "Jotun Engine 2", 0, 0 );
	if( !window ) {
		fprintf( (&__iob_func()[2]), "Failed to open GLFW window.\n" );
		glfwTerminate();
		return -1;
	}

	glfwMakeContextCurrent( window );
	glfwSetKeyCallback( window, onGLFWKey );
	
	if( glewInit() != 0 ) {
		fprintf( (&__iob_func()[2]), "Failed to initialize GLEW\n" );
		return -1;
	}

	glfwSetWindowTitle( window, "Tutorial 16" );

	
	glfwSetInputMode( window, 0x00033002, 1 );
	glfwSetCursorPos( window, 1024 / 2, 768 / 2 );
}

void initOpenGL() {
	
	glClearColor( 0.0f, 0.0f, 0.4f, 0.0f );

	
	glEnable( 0x0B71 );

	
	glDepthFunc( 0x0201 );

	
	glEnable( 0x0B44 );
}

void initData() {
	
	mesh = new Mesh( "room_thickwalls.obj" );

	mainCamera = new Camera();

	inputHandlers.push_back( mainCamera );

	lightCamera = new Camera( glm::vec3( 0.5f, 2, 2 ) );

	diffuse = new Shader( "Diffuse.vert", "Diffuse.frag" );
	depth = new Shader( "Depth.vert", "Depth.frag" );
	passthrough = new Shader( "Passthrough.vert", "Texture.frag" );
	Time::init();
}

void draw() {
	__glewBindFramebuffer( 0x8D40, FramebufferName );
	glViewport( 0, 0, 1024, 1024 ); 

	
	
	
	glEnable( 0x0B44 );
	glCullFace( 0x0405 ); 

	
	glClear( 0x00004000 | 0x00000100 );

	
	depth->bind();

	glm::vec3 lightInvDir = glm::vec3( 0.5f, 2, 2 );

	
	glm::mat4 depthProjectionMatrix = glm::ortho<float>( -10, 10, -10, 10, -10, 20 );
	glm::mat4 depthViewMatrix = glm::lookAt( lightInvDir, glm::vec3( 0, 0, 0 ), glm::vec3( 0, 1, 0 ) );
	
	
	
	

	glm::mat4 depthModelMatrix = glm::mat4( 1.0 );
	glm::mat4 depthMVP = depthProjectionMatrix * depthViewMatrix * depthModelMatrix;

	
	
	depth->setUniformMat4x4( "depthMVP", &depthMVP[0][0] );

	mesh->drawShadowPass( depth->getAttribute( "vertexPositino_modelspace" ) );

	
	__glewBindFramebuffer( 0x8D40, 0 );
	glViewport( 0, 0, 1024, 768 );

	glEnable( 0x0B44 );
	glCullFace( 0x0405 );

	glClear( 0x00004000 | 0x00000100 );

	
	diffuse->bind();

	mainCamera->update();
	glm::mat4 ProjectionMatrix = mainCamera->getProjMatrix();
	glm::mat4 ViewMatrix = mainCamera->getViewMatrix();
	glm::mat4 ModelMatrix = glm::mat4( 1.0 );
	glm::mat4 MVP = ProjectionMatrix * ViewMatrix * ModelMatrix;

	glm::mat4 biasMatrix(
		0.5, 0.0, 0.0, 0.0,
		0.0, 0.5, 0.0, 0.0,
		0.0, 0.0, 0.5, 0.0,
		0.5, 0.5, 0.5, 1.0
		);

	glm::mat4 depthBiasMVP = biasMatrix*depthMVP;

	
	
	diffuse->setUniformMat4x4( "MVP", &MVP[0][0] );
	diffuse->setUniformMat4x4( "M", &ModelMatrix[0][0] );
	diffuse->setUniformMat4x4( "V", &ViewMatrix[0][0] );
	diffuse->setUniformMat4x4( "DepthBiasMVP", &depthBiasMVP[0][0] );

	diffuse->setUniform3f( "LightInvDirection_modelspace",
		lightInvDir.x, lightInvDir.y, lightInvDir.z );

	
	texture->bind( 0 );
	
	diffuse->setUniform1i( "myTextureSampler", 0 );

	__glewActiveTexture( 0x84C1 );
	glBindTexture( 0x0DE1, depthTexture );
	diffuse->setUniform1i( "shadowMap", 1 );

	mesh->enable( diffuse->getAttribute( "vertexPosition_modelspace" ),
		diffuse->getAttribute( "vertexUV" ),
		diffuse->getAttribute( "vertexNormals_modelspace" ) );
	mesh->bind();
	mesh->draw();
	mesh->disable();

	
	glfwSwapBuffers( window );
}

int main( void ) {
	if( init() == -1 ) {
		return 1;
	}
	initOpenGL();
	initData();

	std::string *uniformNames = new std::string [] {"depthMVP"};
	std::string *attribNames = new std::string [] {"vertexPosition_modelspace"};

	depth->genUniformMap( uniformNames, 1 );
	depth->genAttribMap( attribNames, 1 );

	
	
	

	
	__glewGenFramebuffers( 1, &FramebufferName );
	__glewBindFramebuffer( 0x8D40, FramebufferName );

	
	glGenTextures( 1, &depthTexture );
	glBindTexture( 0x0DE1, depthTexture );
	glTexImage2D( 0x0DE1, 0, 0x81A5, 1024, 1024, 0, 0x1902, 0x1406, 0 );
	glTexParameteri( 0x0DE1, 0x2800, 0x2601 );
	glTexParameteri( 0x0DE1, 0x2801, 0x2601 );
	glTexParameteri( 0x0DE1, 0x2802, 0x812F );
	glTexParameteri( 0x0DE1, 0x2803, 0x812F );

	__glewFramebufferTexture2D( 0x8D40, 0x8D00, 0x0DE1, depthTexture, 0 );

	
	glDrawBuffer( 0 );
	glReadBuffer( 0 );

	
	GLuint error = __glewCheckFramebufferStatus( 0x8D40 );
	if( __glewCheckFramebufferStatus( 0x8D40 ) != 0x8CD5 ) {
		return false;
	}

	uniformNames = new std::string [] { "texture" };
	attribNames = new std::string [] {"vertexPosition_modelspace"};

	passthrough->genAttribMap( attribNames, 1 );
	passthrough->genUniformMap( uniformNames, 1 );

	uniformNames = new std::string [] { "texture", "myTextureSampler", "MVP", "V", "M",
		"DepthBiasMVP", "shadowMap", "LightInvDirection_modelspace" };
	attribNames = new std::string [] { "vertexPosition_modelspace", "vertexUV",
		"vertexNormal_modelspace" };

	diffuse->genAttribMap( attribNames, 3 );
	diffuse->genUniformMap( uniformNames, 8 );

	while( !glfwWindowShouldClose( window ) ) {
		Time::update();
		draw();
		glfwPollEvents();
	}
	destroy();
	return 0;
}

void destroy() {
	__glewDeleteFramebuffers( 1, &FramebufferName );
	glDeleteTextures( 1, &depthTexture );
	
	glfwTerminate(); 

	delete mainCamera;
	delete lightCamera;
	delete diffuse;
	delete depth;
	delete passthrough;
	delete mesh;
	delete texture;
}

static void onGLFWError( int error, const char *description ) {
	printf( "Error %d: %s\n", error, description );
}

static void onGLFWKey( GLFWwindow *curWindow, int key, int scancode, int action, int mods ) {
	if( key == 256 && action == 1 ) {
		glfwSetWindowShouldClose( window, 1 );
	}
	if( action == 1 ) {
		for( InputHandler *ih : inputHandlers ) {
			ih->onKeyPress( key );
		}
	} else if( action == 0 ) {
		for( InputHandler *ih : inputHandlers ) {
			ih->onKeyRelease( key );
		}
	}
}
